// Generated by dart2js, the Dart to JavaScript compiler.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// defaultPackagesBase:
//    Override the location where `package:` uris are resolved from. By default
//    they are resolved under "packages/" from the current window location.
(function() {
  // /* ::norenaming:: */
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function map(x) {
    x = Object.create(null);
    x.x = 0;
    delete x.x;
    return x;
  }
  // The global objects start as so-called "slow objects". For V8, this
  // means that it won't try to make map transitions as we add properties
  // to these objects. Later on, we attempt to turn these objects into
  // fast objects by calling "convertToFastObject" (see
  // [emitConvertToFastObjectFunction]).
  var A = map();
  var B = map();
  var C = map();
  var D = map();
  var E = map();
  var F = map();
  var G = map();
  var H = map();
  var J = map();
  var K = map();
  var L = map();
  var M = map();
  var N = map();
  var O = map();
  var P = map();
  var Q = map();
  var R = map();
  var S = map();
  var T = map();
  var U = map();
  var V = map();
  var W = map();
  var X = map();
  var Y = map();
  var Z = map();
  function Isolate() {
  }
  init();
  // Constructors are generated at runtime.
  function setupProgram(programData, typesOffset) {
    "use strict";
    function generateAccessor(fieldDescriptor, accessors, cls) {
      var fieldInformation = fieldDescriptor.split("-");
      var field = fieldInformation[0];
      var len = field.length;
      var code = field.charCodeAt(len - 1);
      var reflectable;
      if (fieldInformation.length > 1)
        reflectable = true;
      else
        reflectable = false;
      code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
      if (code) {
        var getterCode = code & 3;
        var setterCode = code >> 2;
        var accessorName = field = field.substring(0, len - 1);
        var divider = field.indexOf(":");
        if (divider > 0) {
          accessorName = field.substring(0, divider);
          field = field.substring(divider + 1);
        }
        if (getterCode) {
          var args = getterCode & 2 ? "receiver" : "";
          var receiver = getterCode & 1 ? "this" : "receiver";
          var body = "return " + receiver + "." + field;
          var property = cls + ".prototype.get$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
        if (setterCode) {
          var args = setterCode & 2 ? "receiver, value" : "value";
          var receiver = setterCode & 1 ? "this" : "receiver";
          var body = receiver + "." + field + " = value";
          var property = cls + ".prototype.set$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
      }
      return field;
    }
    function defineClass(name, fields) {
      var accessors = [];
      var str = "function " + name + "(";
      var body = "";
      var fieldNames = "";
      for (var i = 0; i < fields.length; i++) {
        if (i != 0)
          str += ", ";
        var field = generateAccessor(fields[i], accessors, name);
        fieldNames += "'" + field + "',";
        var parameter = "p_" + field;
        str += parameter;
        body += "this." + field + " = " + parameter + ";\n";
      }
      if (supportsDirectProtoAccess)
        body += "this." + "$deferredAction" + "();";
      str += ") {\n" + body + "}\n";
      str += name + ".builtin$cls=\"" + name + "\";\n";
      str += "$desc=$collectedClasses." + name + "[1];\n";
      str += name + ".prototype = $desc;\n";
      if (typeof defineClass.name != "string")
        str += name + ".name=\"" + name + "\";\n";
      str += name + "." + "$__fields__" + "=[" + fieldNames + "];\n";
      str += accessors.join("");
      return str;
    }
    init.createNewIsolate = function() {
      return new Isolate();
    };
    init.classIdExtractor = function(o) {
      return o.constructor.name;
    };
    init.classFieldsExtractor = function(o) {
      var fieldNames = o.constructor.$__fields__;
      if (!fieldNames)
        return [];
      var result = [];
      result.length = fieldNames.length;
      for (var i = 0; i < fieldNames.length; i++)
        result[i] = o[fieldNames[i]];
      return result;
    };
    init.instanceFromClassId = function(name) {
      return new init.allClasses[name]();
    };
    init.initializeEmptyInstance = function(name, o, fields) {
      init.allClasses[name].apply(o, fields);
      return o;
    };
    var inheritFrom = supportsDirectProtoAccess ? function(constructor, superConstructor) {
      var prototype = constructor.prototype;
      prototype.__proto__ = superConstructor.prototype;
      prototype.constructor = constructor;
      prototype["$is" + constructor.name] = constructor;
      return convertToFastObject(prototype);
    } : function() {
      function tmp() {
      }
      return function(constructor, superConstructor) {
        tmp.prototype = superConstructor.prototype;
        var object = new tmp();
        convertToSlowObject(object);
        var properties = constructor.prototype;
        var members = Object.keys(properties);
        for (var i = 0; i < members.length; i++) {
          var member = members[i];
          object[member] = properties[member];
        }
        object["$is" + constructor.name] = constructor;
        object.constructor = constructor;
        constructor.prototype = object;
        return object;
      };
    }();
    function finishClasses(processedClasses) {
      var allClasses = init.allClasses;
      processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
      processedClasses.combinedConstructorFunction = null;
      for (var i = 0; i < constructors.length; i++) {
        var constructor = constructors[i];
        var cls = constructor.name;
        var desc = processedClasses.collected[cls];
        var globalObject = desc[0];
        desc = desc[1];
        allClasses[cls] = constructor;
        globalObject[cls] = constructor;
      }
      constructors = null;
      var finishedClasses = init.finishedClasses;
      function finishClass(cls) {
        if (finishedClasses[cls])
          return;
        finishedClasses[cls] = true;
        var superclass = processedClasses.pending[cls];
        if (superclass && superclass.indexOf("+") > 0) {
          var s = superclass.split("+");
          superclass = s[0];
          var mixinClass = s[1];
          finishClass(mixinClass);
          var mixin = allClasses[mixinClass];
          var mixinPrototype = mixin.prototype;
          var clsPrototype = allClasses[cls].prototype;
          var properties = Object.keys(mixinPrototype);
          for (var i = 0; i < properties.length; i++) {
            var d = properties[i];
            if (!hasOwnProperty.call(clsPrototype, d))
              clsPrototype[d] = mixinPrototype[d];
          }
        }
        if (!superclass || typeof superclass != "string") {
          var constructor = allClasses[cls];
          var prototype = constructor.prototype;
          prototype.constructor = constructor;
          prototype.$isObject = constructor;
          prototype.$deferredAction = function() {
          };
          return;
        }
        finishClass(superclass);
        var superConstructor = allClasses[superclass];
        if (!superConstructor)
          superConstructor = existingIsolateProperties[superclass];
        var constructor = allClasses[cls];
        var prototype = inheritFrom(constructor, superConstructor);
        if (mixinPrototype)
          prototype.$deferredAction = mixinDeferredActionHelper(mixinPrototype, prototype);
        if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
          var nativeSpec = prototype["%"].split(";");
          if (nativeSpec[0]) {
            var tags = nativeSpec[0].split("|");
            for (var i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = true;
            }
          }
          if (nativeSpec[1]) {
            tags = nativeSpec[1].split("|");
            if (nativeSpec[2]) {
              var subclasses = nativeSpec[2].split("|");
              for (var i = 0; i < subclasses.length; i++) {
                var subclass = allClasses[subclasses[i]];
                subclass.$nativeSuperclassTag = tags[0];
              }
            }
            for (i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = false;
            }
          }
          prototype.$deferredAction();
        }
        if (prototype.$isInterceptor)
          prototype.$deferredAction();
      }
      var properties = Object.keys(processedClasses.pending);
      for (var i = 0; i < properties.length; i++)
        finishClass(properties[i]);
    }
    function finishAddStubsHelper() {
      var prototype = this;
      while (!prototype.hasOwnProperty("$deferredAction"))
        prototype = prototype.__proto__;
      delete prototype.$deferredAction;
      var properties = Object.keys(prototype);
      for (var index = 0; index < properties.length; index++) {
        var property = properties[index];
        var firstChar = property.charCodeAt(0);
        var elem;
        if (property !== "^" && property !== "$reflectable" && firstChar !== 43 && firstChar !== 42 && (elem = prototype[property]) != null && elem.constructor === Array && property !== "<>")
          addStubs(prototype, elem, property, false, []);
      }
      convertToFastObject(prototype);
      prototype = prototype.__proto__;
      prototype.$deferredAction();
    }
    function mixinDeferredActionHelper(mixinPrototype, targetPrototype) {
      var chain;
      if (targetPrototype.hasOwnProperty("$deferredAction"))
        chain = targetPrototype.$deferredAction;
      return function foo() {
        if (!supportsDirectProtoAccess)
          return;
        var prototype = this;
        while (!prototype.hasOwnProperty("$deferredAction"))
          prototype = prototype.__proto__;
        if (chain)
          prototype.$deferredAction = chain;
        else {
          delete prototype.$deferredAction;
          convertToFastObject(prototype);
        }
        mixinPrototype.$deferredAction();
        prototype.$deferredAction();
      };
    }
    function processClassData(cls, descriptor, processedClasses) {
      descriptor = convertToSlowObject(descriptor);
      var previousProperty;
      var properties = Object.keys(descriptor);
      var hasDeferredWork = false;
      var shouldDeferWork = supportsDirectProtoAccess && cls != "Object";
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        var firstChar = property.charCodeAt(0);
        if (property === "static") {
          processStatics(init.statics[cls] = descriptor.static, processedClasses);
          delete descriptor.static;
        } else if (firstChar === 43) {
          mangledNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
        } else if (firstChar === 42) {
          descriptor[previousProperty].$defaultValues = descriptor[property];
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else {
          var elem = descriptor[property];
          if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
            if (shouldDeferWork)
              hasDeferredWork = true;
            else
              addStubs(descriptor, elem, property, false, []);
          else
            previousProperty = property;
        }
      }
      if (hasDeferredWork)
        descriptor.$deferredAction = finishAddStubsHelper;
      var classData = descriptor["^"], split, supr, fields = classData;
      var s = fields.split(";");
      fields = s[1] ? s[1].split(",") : [];
      supr = s[0];
      split = supr.split(":");
      if (split.length == 2) {
        supr = split[0];
        var functionSignature = split[1];
        if (functionSignature)
          descriptor.$signature = function(s) {
            return function() {
              return init.types[s];
            };
          }(functionSignature);
      }
      if (supr)
        processedClasses.pending[cls] = supr;
      processedClasses.combinedConstructorFunction += defineClass(cls, fields);
      processedClasses.constructorsList.push(cls);
      processedClasses.collected[cls] = [globalObject, descriptor];
      classes.push(cls);
    }
    function processStatics(descriptor, processedClasses) {
      var properties = Object.keys(descriptor);
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (property === "^")
          continue;
        var element = descriptor[property];
        var firstChar = property.charCodeAt(0);
        var previousProperty;
        if (firstChar === 43) {
          mangledGlobalNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
          if (element && element.length)
            init.typeInformation[previousProperty] = element;
        } else if (firstChar === 42) {
          globalObject[previousProperty].$defaultValues = element;
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else if (typeof element === "function") {
          globalObject[previousProperty = property] = element;
          functions.push(property);
          init.globalFunctions[property] = element;
        } else if (element.constructor === Array)
          addStubs(globalObject, element, property, true, functions);
        else {
          previousProperty = property;
          processClassData(property, element, processedClasses);
        }
      }
    }
    function addStubs(prototype, array, name, isStatic, functions) {
      var index = 0, alias = array[index], f;
      if (typeof alias == "string")
        f = array[++index];
      else {
        f = alias;
        alias = name;
      }
      var funcs = [prototype[name] = prototype[alias] = f];
      f.$stubName = name;
      functions.push(name);
      for (index++; index < array.length; index++) {
        f = array[index];
        if (typeof f != "function")
          break;
        if (!isStatic)
          f.$stubName = array[++index];
        funcs.push(f);
        if (f.$stubName) {
          prototype[f.$stubName] = f;
          functions.push(f.$stubName);
        }
      }
      for (var i = 0; i < funcs.length; index++, i++)
        funcs[i].$callName = array[index];
      var getterStubName = array[index];
      array = array.slice(++index);
      var requiredParameterInfo = array[0];
      var requiredParameterCount = requiredParameterInfo >> 1;
      var isAccessor = (requiredParameterInfo & 1) === 1;
      var isSetter = requiredParameterInfo === 3;
      var isGetter = requiredParameterInfo === 1;
      var optionalParameterInfo = array[1];
      var optionalParameterCount = optionalParameterInfo >> 1;
      var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
      var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
      var functionTypeIndex = array[2];
      if (typeof functionTypeIndex == "number")
        array[2] = functionTypeIndex + typesOffset;
      var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
      if (getterStubName) {
        f = tearOff(funcs, array, isStatic, name, isIntercepted);
        prototype[name].$getter = f;
        f.$getterStub = true;
        if (isStatic) {
          init.globalFunctions[name] = f;
          functions.push(getterStubName);
        }
        prototype[getterStubName] = f;
        funcs.push(f);
        f.$stubName = getterStubName;
        f.$callName = null;
      }
      var isReflectable = array.length > unmangledNameIndex;
      if (isReflectable) {
        funcs[0].$reflectable = 1;
        funcs[0].$reflectionInfo = array;
        for (var i = 1; i < funcs.length; i++) {
          funcs[i].$reflectable = 2;
          funcs[i].$reflectionInfo = array;
        }
        var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
        var unmangledName = array[unmangledNameIndex];
        var reflectionName = unmangledName;
        if (getterStubName)
          mangledNames[getterStubName] = reflectionName;
        if (isSetter)
          reflectionName += "=";
        else if (!isGetter)
          reflectionName += ":" + (requiredParameterCount + optionalParameterCount);
        mangledNames[name] = reflectionName;
        funcs[0].$reflectionName = reflectionName;
        funcs[0].$metadataIndex = unmangledNameIndex + 1;
        if (optionalParameterCount)
          prototype[unmangledName + "*"] = funcs[0];
      }
    }
    function tearOffGetter(funcs, reflectionInfo, name, isIntercepted) {
      return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
    }
    function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
      var cache;
      return isStatic ? function() {
        if (cache === void 0)
          cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
        return cache;
      } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
    }
    var functionCounter = 0;
    if (!init.libraries)
      init.libraries = [];
    if (!init.mangledNames)
      init.mangledNames = map();
    if (!init.mangledGlobalNames)
      init.mangledGlobalNames = map();
    if (!init.statics)
      init.statics = map();
    if (!init.typeInformation)
      init.typeInformation = map();
    if (!init.globalFunctions)
      init.globalFunctions = map();
    var libraries = init.libraries;
    var mangledNames = init.mangledNames;
    var mangledGlobalNames = init.mangledGlobalNames;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var length = programData.length;
    var processedClasses = map();
    processedClasses.collected = map();
    processedClasses.pending = map();
    processedClasses.constructorsList = [];
    processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
    for (var i = 0; i < length; i++) {
      var data = programData[i];
      var name = data[0];
      var uri = data[1];
      var metadata = data[2];
      var globalObject = data[3];
      var descriptor = data[4];
      var isRoot = !!data[5];
      var fields = descriptor && descriptor["^"];
      if (fields instanceof Array)
        fields = fields[0];
      var classes = [];
      var functions = [];
      processStatics(descriptor, processedClasses);
      libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
    }
    finishClasses(processedClasses);
  }
  Isolate.functionThatReturnsNull = function() {
  };
  var dart = [["_foreign_helper", "dart:_foreign_helper",, H, {
    "^": "",
    JS_CONST: {
      "^": "Object;code"
    }
  }], ["_interceptors", "dart:_interceptors",, J, {
    "^": "",
    getInterceptor: function(object) {
      return void 0;
    },
    makeDispatchRecord: function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor: function(object) {
      var record, proto, objectProto, $constructor, interceptor;
      record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw H.wrapException(new P.UnimplementedError("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: C.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    },
    Interceptor: {
      "^": "Object;",
      $eq: function(receiver, other) {
        return receiver === other;
      },
      get$hashCode: function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      },
      toString$0: ["super$Interceptor$toString", function(receiver) {
        return H.Primitives_objectToHumanReadableString(receiver);
      }],
      noSuchMethod$1: ["super$Interceptor$noSuchMethod", function(receiver, invocation) {
        throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      }, null, "get$noSuchMethod", 2, 0, null, 14],
      "%": "ANGLEInstancedArrays|ANGLE_instanced_arrays|AnimationEffectReadOnly|AnimationTimeline|AppBannerPromptResult|AudioListener|Bluetooth|BluetoothAdvertisingData|BluetoothCharacteristicProperties|BluetoothRemoteGATTServer|BluetoothRemoteGATTService|BluetoothUUID|CHROMIUMSubscribeUniform|CHROMIUMValuebuffer|CSS|Cache|CanvasGradient|CanvasPattern|Clients|CompositorProxy|ConsoleBase|Coordinates|CredentialsContainer|Crypto|DOMFileSystemSync|DOMImplementation|DOMMatrix|DOMMatrixReadOnly|DOMStringMap|DataTransfer|Database|DeprecatedStorageInfo|DeprecatedStorageQuota|DirectoryEntrySync|DirectoryReader|DirectoryReaderSync|EXTBlendMinMax|EXTColorBufferFloat|EXTDisjointTimerQuery|EXTFragDepth|EXTShaderTextureLOD|EXTTextureFilterAnisotropic|EXT_blend_minmax|EXT_frag_depth|EXT_sRGB|EXT_shader_texture_lod|EXT_texture_filter_anisotropic|EXTsRGB|EffectModel|EntrySync|FileEntrySync|FileReaderSync|FileWriterSync|FormData|Geofencing|Geolocation|Geoposition|HMDVRDevice|HTMLAllCollection|Headers|IDBFactory|IdleDeadline|ImageBitmapRenderingContext|InjectedScriptHost|InputDeviceCapabilities|IntersectionObserver|KeyframeEffect|MIDIInputMap|MIDIOutputMap|MediaDeviceInfo|MediaDevices|MediaError|MediaKeyStatusMap|MediaKeySystemAccess|MediaKeys|MediaMetadata|MediaSession|MemoryInfo|MessageChannel|Metadata|MutationObserver|NFC|NavigatorStorageUtils|NodeFilter|NodeIterator|NonDocumentTypeChildNode|NonElementParentNode|OESElementIndexUint|OESStandardDerivatives|OESTextureFloat|OESTextureFloatLinear|OESTextureHalfFloat|OESTextureHalfFloatLinear|OESVertexArrayObject|OES_element_index_uint|OES_standard_derivatives|OES_texture_float|OES_texture_float_linear|OES_texture_half_float|OES_texture_half_float_linear|OES_vertex_array_object|PagePopupController|PerformanceObserver|PerformanceObserverEntryList|PerformanceTiming|PeriodicWave|Permissions|PositionError|PositionSensorVRDevice|Presentation|PushManager|PushSubscription|RTCCertificate|RTCIceCandidate|Range|ReadableByteStream|SQLError|SQLResultSet|SQLTransaction|SVGAnimatedAngle|SVGAnimatedBoolean|SVGAnimatedEnumeration|SVGAnimatedInteger|SVGAnimatedLength|SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedPreserveAspectRatio|SVGAnimatedRect|SVGAnimatedString|SVGAnimatedTransformList|SVGMatrix|SVGPreserveAspectRatio|SVGUnitTypes|SharedArrayBuffer|SpeechRecognitionAlternative|StorageInfo|StorageManager|StorageQuota|StylePropertyMap|SubtleCrypto|SyncManager|TreeWalker|URLSearchParams|USBAlternateInterface|USBConfiguration|USBDevice|USBEndpoint|USBInTransferResult|USBInterface|USBIsochronousInTransferPacket|USBIsochronousInTransferResult|USBIsochronousOutTransferPacket|USBIsochronousOutTransferResult|USBOutTransferResult|VRDevice|VREyeParameters|VRFieldOfView|VRPositionState|ValidityState|VideoPlaybackQuality|WEBGL_compressed_texture_atc|WEBGL_compressed_texture_etc1|WEBGL_compressed_texture_pvrtc|WEBGL_compressed_texture_s3tc|WEBGL_debug_renderer_info|WEBGL_debug_shaders|WEBGL_depth_texture|WEBGL_draw_buffers|WEBGL_lose_context|WebGLBuffer|WebGLCompressedTextureASTC|WebGLCompressedTextureATC|WebGLCompressedTextureETC1|WebGLCompressedTexturePVRTC|WebGLCompressedTextureS3TC|WebGLDebugRendererInfo|WebGLDebugShaders|WebGLDepthTexture|WebGLDrawBuffers|WebGLExtensionLoseContext|WebGLFramebuffer|WebGLLoseContext|WebGLProgram|WebGLQuery|WebGLRenderbuffer|WebGLSampler|WebGLShader|WebGLShaderPrecisionFormat|WebGLSync|WebGLTexture|WebGLTimerQueryEXT|WebGLTransformFeedback|WebGLVertexArrayObject|WebGLVertexArrayObjectOES|WebKitCSSMatrix|WebKitMutationObserver|WorkerConsole|Worklet|WorkletGlobalScope|XMLSerializer|XPathEvaluator|XPathExpression|XPathNSResolver|XPathResult|XSLTProcessor|mozRTCIceCandidate"
    },
    JSBool: {
      "^": "Interceptor;",
      toString$0: function(receiver) {
        return String(receiver);
      },
      get$hashCode: function(receiver) {
        return receiver ? 519018 : 218159;
      },
      $isbool: 1
    },
    JSNull: {
      "^": "Interceptor;",
      $eq: function(receiver, other) {
        return null == other;
      },
      toString$0: function(receiver) {
        return "null";
      },
      get$hashCode: function(receiver) {
        return 0;
      },
      noSuchMethod$1: [function(receiver, invocation) {
        return this.super$Interceptor$noSuchMethod(receiver, invocation);
      }, null, "get$noSuchMethod", 2, 0, null, 14],
      $isNull: 1
    },
    JavaScriptObject: {
      "^": "Interceptor;",
      get$hashCode: function(receiver) {
        return 0;
      },
      toString$0: ["super$JavaScriptObject$toString", function(receiver) {
        return String(receiver);
      }],
      $isJSObject: 1
    },
    PlainJavaScriptObject: {
      "^": "JavaScriptObject;"
    },
    UnknownJavaScriptObject: {
      "^": "JavaScriptObject;"
    },
    JavaScriptFunction: {
      "^": "JavaScriptObject;",
      toString$0: function(receiver) {
        var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
        return dartClosure == null ? this.super$JavaScriptObject$toString(receiver) : J.toString$0$(dartClosure);
      },
      $isFunction: 1,
      $signature: function() {
        return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
      }
    },
    JSArray: {
      "^": "Interceptor;$ti",
      checkMutable$1: function(receiver, reason) {
        if (!!receiver.immutable$list)
          throw H.wrapException(new P.UnsupportedError(reason));
      },
      checkGrowable$1: function(receiver, reason) {
        if (!!receiver.fixed$length)
          throw H.wrapException(new P.UnsupportedError(reason));
      },
      add$1: function(receiver, value) {
        this.checkGrowable$1(receiver, "add");
        receiver.push(value);
      },
      removeAt$1: function(receiver, index) {
        this.checkGrowable$1(receiver, "removeAt");
        if (index < 0 || index >= receiver.length)
          throw H.wrapException(P.RangeError$value(index, null, null));
        return receiver.splice(index, 1)[0];
      },
      insert$2: function(receiver, index, value) {
        var t1;
        this.checkGrowable$1(receiver, "insert");
        t1 = receiver.length;
        if (index > t1)
          throw H.wrapException(P.RangeError$value(index, null, null));
        receiver.splice(index, 0, value);
      },
      remove$1: function(receiver, element) {
        var i;
        this.checkGrowable$1(receiver, "remove");
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], element)) {
            receiver.splice(i, 1);
            return true;
          }
        return false;
      },
      _removeWhere$2: function(receiver, test, removeMatching) {
        var retained, end, i, element, t1;
        retained = [];
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          element = receiver[i];
          if (test.call$1(element) !== true)
            retained.push(element);
          if (receiver.length !== end)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        t1 = retained.length;
        if (t1 === end)
          return;
        this.set$length(receiver, t1);
        for (i = 0; i < retained.length; ++i)
          receiver[i] = retained[i];
      },
      addAll$1: function(receiver, collection) {
        var t1;
        this.checkGrowable$1(receiver, "addAll");
        for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
          receiver.push(t1.get$current());
      },
      forEach$1: function(receiver, f) {
        var end, i;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          f.call$1(receiver[i]);
          if (receiver.length !== end)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
      },
      map$1: function(receiver, f) {
        return new H.MappedListIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0), null]);
      },
      join$1: function(receiver, separator) {
        var t1, list, i, t2;
        t1 = receiver.length;
        list = new Array(t1);
        list.fixed$length = Array;
        for (i = 0; i < receiver.length; ++i) {
          t2 = H.S(receiver[i]);
          if (i >= t1)
            return H.ioore(list, i);
          list[i] = t2;
        }
        return list.join(separator);
      },
      skip$1: function(receiver, n) {
        return H.SubListIterable$(receiver, n, null, H.getTypeArgumentByIndex(receiver, 0));
      },
      fold$2: function(receiver, initialValue, combine) {
        var $length, value, i;
        $length = receiver.length;
        for (value = initialValue, i = 0; i < $length; ++i) {
          value = combine.call$2(value, receiver[i]);
          if (receiver.length !== $length)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return value;
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        if (start == null)
          H.throwExpression(H.argumentErrorValue(start));
        if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
        if (end == null)
          end = receiver.length;
        else {
          if (typeof end !== "number" || Math.floor(end) !== end)
            throw H.wrapException(H.argumentErrorValue(end));
          if (end < start || end > receiver.length)
            throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
        }
        if (start === end)
          return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
        return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
      },
      sublist$1: function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      },
      get$first: function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(H.IterableElementError_noElement());
      },
      get$last: function(receiver) {
        var t1 = receiver.length;
        if (t1 > 0)
          return receiver[t1 - 1];
        throw H.wrapException(H.IterableElementError_noElement());
      },
      removeRange$2: function(receiver, start, end) {
        this.checkGrowable$1(receiver, "removeRange");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        receiver.splice(start, end - start);
      },
      setRange$4: function(receiver, start, end, iterable, skipCount) {
        var $length, t1, i, t2;
        this.checkMutable$1(receiver, "setRange");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length === 0)
          return;
        t1 = J.getInterceptor$n(skipCount);
        if (t1.$lt(skipCount, 0))
          H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
        if (t1.$add(skipCount, $length) > iterable.length)
          throw H.wrapException(H.IterableElementError_tooFew());
        if (t1.$lt(skipCount, start))
          for (i = $length - 1; i >= 0; --i) {
            t2 = t1.$add(skipCount, i);
            if (t2 >>> 0 !== t2 || t2 >= iterable.length)
              return H.ioore(iterable, t2);
            receiver[start + i] = iterable[t2];
          }
        else
          for (i = 0; i < $length; ++i) {
            t2 = t1.$add(skipCount, i);
            if (t2 >>> 0 !== t2 || t2 >= iterable.length)
              return H.ioore(iterable, t2);
            receiver[start + i] = iterable[t2];
          }
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      fillRange$3: function(receiver, start, end, fillValue) {
        var i;
        this.checkMutable$1(receiver, "fill range");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        for (i = start; i < end; ++i)
          receiver[i] = fillValue;
      },
      replaceRange$3: function(receiver, start, end, replacement) {
        var removeLength, insertLength, t1, delta, insertEnd, newLength;
        this.checkGrowable$1(receiver, "replaceRange");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        replacement = C.JSString_methods.toList$0(replacement);
        removeLength = J.$sub$n(end, start);
        insertLength = replacement.length;
        t1 = J.getInterceptor$ns(start);
        if (removeLength >= insertLength) {
          delta = removeLength - insertLength;
          insertEnd = t1.$add(start, insertLength);
          newLength = receiver.length - delta;
          this.setRange$3(receiver, start, insertEnd, replacement);
          if (delta !== 0) {
            this.setRange$4(receiver, insertEnd, newLength, receiver, end);
            this.set$length(receiver, newLength);
          }
        } else {
          newLength = receiver.length + (insertLength - removeLength);
          insertEnd = t1.$add(start, insertLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, replacement);
        }
      },
      sort$1: function(receiver, compare) {
        var t1;
        this.checkMutable$1(receiver, "sort");
        t1 = compare == null ? P.core_Comparable_compare$closure() : compare;
        H.Sort__doSort(receiver, 0, receiver.length - 1, t1);
      },
      indexOf$2: function(receiver, element, start) {
        var i;
        if (start >= receiver.length)
          return -1;
        if (start < 0)
          start = 0;
        for (i = start; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], element))
            return i;
        return -1;
      },
      indexOf$1: function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      },
      contains$1: function(receiver, other) {
        var i;
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], other))
            return true;
        return false;
      },
      get$isEmpty: function(receiver) {
        return receiver.length === 0;
      },
      toString$0: function(receiver) {
        return P.IterableBase_iterableToFullString(receiver, "[", "]");
      },
      toList$1$growable: function(receiver, growable) {
        var t1 = [H.getTypeArgumentByIndex(receiver, 0)];
        if (growable)
          t1 = H.setRuntimeTypeInfo(receiver.slice(0), t1);
        else {
          t1 = H.setRuntimeTypeInfo(receiver.slice(0), t1);
          t1.fixed$length = Array;
          t1 = t1;
        }
        return t1;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      get$iterator: function(receiver) {
        return new J.ArrayIterator(receiver, receiver.length, 0, null);
      },
      get$hashCode: function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      },
      get$length: function(receiver) {
        return receiver.length;
      },
      set$length: function(receiver, newLength) {
        this.checkGrowable$1(receiver, "set length");
        if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
          throw H.wrapException(P.ArgumentError$value(newLength, "newLength", null));
        if (newLength < 0)
          throw H.wrapException(P.RangeError$range(newLength, 0, null, "newLength", null));
        receiver.length = newLength;
      },
      $index: function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        if (!!receiver.immutable$list)
          H.throwExpression(new P.UnsupportedError("indexed set"));
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      },
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null
    },
    JSUnmodifiableArray: {
      "^": "JSArray;$ti"
    },
    ArrayIterator: {
      "^": "Object;__interceptors$_iterable,__interceptors$_length,_index,__interceptors$_current",
      get$current: function() {
        return this.__interceptors$_current;
      },
      moveNext$0: function() {
        var t1, $length, t2;
        t1 = this.__interceptors$_iterable;
        $length = t1.length;
        if (this.__interceptors$_length !== $length)
          throw H.wrapException(H.throwConcurrentModificationError(t1));
        t2 = this._index;
        if (t2 >= $length) {
          this.__interceptors$_current = null;
          return false;
        }
        this.__interceptors$_current = t1[t2];
        this._index = t2 + 1;
        return true;
      }
    },
    JSNumber: {
      "^": "Interceptor;",
      compareTo$1: function(receiver, b) {
        var bIsNegative;
        if (typeof b !== "number")
          throw H.wrapException(H.argumentErrorValue(b));
        if (receiver < b)
          return -1;
        else if (receiver > b)
          return 1;
        else if (receiver === b) {
          if (receiver === 0) {
            bIsNegative = this.get$isNegative(b);
            if (this.get$isNegative(receiver) === bIsNegative)
              return 0;
            if (this.get$isNegative(receiver))
              return -1;
            return 1;
          }
          return 0;
        } else if (isNaN(receiver)) {
          if (isNaN(b))
            return 0;
          return 1;
        } else
          return -1;
      },
      get$isNegative: function(receiver) {
        return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
      },
      remainder$1: function(receiver, b) {
        return receiver % b;
      },
      abs$0: function(receiver) {
        return Math.abs(receiver);
      },
      toInt$0: function(receiver) {
        var t1;
        if (receiver >= -2147483648 && receiver <= 2147483647)
          return receiver | 0;
        if (isFinite(receiver)) {
          t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
          return t1 + 0;
        }
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".toInt()"));
      },
      ceil$0: function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647) {
            truncated = receiver | 0;
            return receiver === truncated ? truncated : truncated + 1;
          }
        } else if (receiver >= -2147483648)
          return receiver | 0;
        d = Math.ceil(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".ceil()"));
      },
      floor$0: function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647)
            return receiver | 0;
        } else if (receiver >= -2147483648) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated - 1;
        }
        d = Math.floor(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".floor()"));
      },
      round$0: function(receiver) {
        if (receiver > 0) {
          if (receiver !== 1 / 0)
            return Math.round(receiver);
        } else if (receiver > -1 / 0)
          return 0 - Math.round(0 - receiver);
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".round()"));
      },
      toDouble$0: function(receiver) {
        return receiver;
      },
      toStringAsFixed$1: function(receiver, fractionDigits) {
        var result;
        if (fractionDigits > 20)
          throw H.wrapException(P.RangeError$range(fractionDigits, 0, 20, "fractionDigits", null));
        result = receiver.toFixed(fractionDigits);
        if (receiver === 0 && this.get$isNegative(receiver))
          return "-" + result;
        return result;
      },
      toRadixString$1: function(receiver, radix) {
        var result, match, t1, exponent;
        if (radix < 2 || radix > 36)
          throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
        result = receiver.toString(radix);
        if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
          return result;
        match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
        if (match == null)
          H.throwExpression(new P.UnsupportedError("Unexpected toString result: " + result));
        t1 = J.getInterceptor$asx(match);
        result = t1.$index(match, 1);
        exponent = +t1.$index(match, 3);
        if (t1.$index(match, 2) != null) {
          result += t1.$index(match, 2);
          exponent -= t1.$index(match, 2).length;
        }
        return result + C.JSString_methods.$mul("0", exponent);
      },
      toString$0: function(receiver) {
        if (receiver === 0 && 1 / receiver < 0)
          return "-0.0";
        else
          return "" + receiver;
      },
      get$hashCode: function(receiver) {
        return receiver & 0x1FFFFFFF;
      },
      $negate: function(receiver) {
        return -receiver;
      },
      $add: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver + other;
      },
      $sub: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver - other;
      },
      $div: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver / other;
      },
      $mul: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver * other;
      },
      $mod: function(receiver, other) {
        var result;
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        result = receiver % other;
        if (result === 0)
          return 0;
        if (result > 0)
          return result;
        if (other < 0)
          return result - other;
        else
          return result + other;
      },
      $tdiv: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        if ((receiver | 0) === receiver)
          if (other >= 1 || other < -1)
            return receiver / other | 0;
        return this._tdivSlow$1(receiver, other);
      },
      _tdivFast$1: function(receiver, other) {
        return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
      },
      _tdivSlow$1: function(receiver, other) {
        var quotient = receiver / other;
        if (quotient >= -2147483648 && quotient <= 2147483647)
          return quotient | 0;
        if (quotient > 0) {
          if (quotient !== 1 / 0)
            return Math.floor(quotient);
        } else if (quotient > -1 / 0)
          return Math.ceil(quotient);
        throw H.wrapException(new P.UnsupportedError("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + H.S(other)));
      },
      $shl: function(receiver, other) {
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        return other > 31 ? 0 : receiver << other >>> 0;
      },
      _shlPositive$1: function(receiver, other) {
        return other > 31 ? 0 : receiver << other >>> 0;
      },
      $shr: function(receiver, other) {
        var t1;
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        if (receiver > 0)
          t1 = other > 31 ? 0 : receiver >>> other;
        else {
          t1 = other > 31 ? 31 : other;
          t1 = receiver >> t1 >>> 0;
        }
        return t1;
      },
      _shrOtherPositive$1: function(receiver, other) {
        var t1;
        if (receiver > 0)
          t1 = other > 31 ? 0 : receiver >>> other;
        else {
          t1 = other > 31 ? 31 : other;
          t1 = receiver >> t1 >>> 0;
        }
        return t1;
      },
      _shrReceiverPositive$1: function(receiver, other) {
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        return other > 31 ? 0 : receiver >>> other;
      },
      _shrBothPositive$1: function(receiver, other) {
        return other > 31 ? 0 : receiver >>> other;
      },
      $and: function(receiver, other) {
        return (receiver & other) >>> 0;
      },
      $xor: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver ^ other) >>> 0;
      },
      $lt: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver < other;
      },
      $gt: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver > other;
      },
      $le: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver <= other;
      },
      $ge: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver >= other;
      },
      $isnum: 1
    },
    JSInt: {
      "^": "JSNumber;",
      $isdouble: 1,
      $isnum: 1,
      $isint: 1
    },
    JSDouble: {
      "^": "JSNumber;",
      $isdouble: 1,
      $isnum: 1
    },
    JSString: {
      "^": "Interceptor;",
      codeUnitAt$1: function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver.charCodeAt(index);
      },
      _codeUnitAt$1: function(receiver, index) {
        if (index >= receiver.length)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver.charCodeAt(index);
      },
      allMatches$2: function(receiver, string, start) {
        if (start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return new H._StringAllMatchesIterable(string, receiver, start);
      },
      allMatches$1: function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      },
      matchAsPrefix$2: function(receiver, string, start) {
        var t1, i;
        if (typeof start !== "number")
          return start.$lt();
        if (start < 0 || start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        t1 = receiver.length;
        if (start + t1 > string.length)
          return;
        for (i = 0; i < t1; ++i)
          if (this.codeUnitAt$1(string, start + i) !== this._codeUnitAt$1(receiver, i))
            return;
        return new H.StringMatch(start, string, receiver);
      },
      $add: function(receiver, other) {
        if (typeof other !== "string")
          throw H.wrapException(P.ArgumentError$value(other, null, null));
        return receiver + other;
      },
      endsWith$1: function(receiver, other) {
        var otherLength, t1;
        otherLength = other.length;
        t1 = receiver.length;
        if (otherLength > t1)
          return false;
        return other === this.substring$1(receiver, t1 - otherLength);
      },
      replaceAll$2: function(receiver, from, to) {
        return H.stringReplaceAllUnchecked(receiver, from, to);
      },
      split$1: function(receiver, pattern) {
        if (typeof pattern === "string")
          return receiver.split(pattern);
        else if (pattern instanceof H.JSSyntaxRegExp && pattern.get$_nativeAnchoredVersion().exec("").length - 2 === 0)
          return receiver.split(pattern.get$_nativeRegExp());
        else
          return this._defaultSplit$1(receiver, pattern);
      },
      replaceRange$3: function(receiver, start, end, replacement) {
        var prefix, suffix;
        H.checkInt(start);
        end = P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        H.checkInt(end);
        prefix = receiver.substring(0, start);
        suffix = receiver.substring(end);
        return prefix + replacement + suffix;
      },
      _defaultSplit$1: function(receiver, pattern) {
        var result, t1, start, $length, match, matchStart, matchEnd;
        result = H.setRuntimeTypeInfo([], [P.String]);
        for (t1 = J.allMatches$1$s(pattern, receiver), t1 = t1.get$iterator(t1), start = 0, $length = 1; t1.moveNext$0();) {
          match = t1.get$current();
          matchStart = match.get$start(match);
          matchEnd = match.get$end(match);
          if (typeof matchStart !== "number")
            return H.iae(matchStart);
          $length = matchEnd - matchStart;
          if ($length === 0 && start === matchStart)
            continue;
          result.push(this.substring$2(receiver, start, matchStart));
          start = matchEnd;
        }
        if (start < receiver.length || $length > 0)
          result.push(this.substring$1(receiver, start));
        return result;
      },
      startsWith$2: function(receiver, pattern, index) {
        var endIndex;
        H.checkInt(index);
        if (typeof index !== "number")
          return index.$lt();
        if (index < 0 || index > receiver.length)
          throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
        if (typeof pattern === "string") {
          endIndex = index + pattern.length;
          if (endIndex > receiver.length)
            return false;
          return pattern === receiver.substring(index, endIndex);
        }
        return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
      },
      startsWith$1: function($receiver, pattern) {
        return this.startsWith$2($receiver, pattern, 0);
      },
      substring$2: function(receiver, startIndex, endIndex) {
        var t1;
        if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
          H.throwExpression(H.argumentErrorValue(startIndex));
        if (endIndex == null)
          endIndex = receiver.length;
        if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
          H.throwExpression(H.argumentErrorValue(endIndex));
        t1 = J.getInterceptor$n(startIndex);
        if (t1.$lt(startIndex, 0))
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (t1.$gt(startIndex, endIndex))
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (J.$gt$n(endIndex, receiver.length))
          throw H.wrapException(P.RangeError$value(endIndex, null, null));
        return receiver.substring(startIndex, endIndex);
      },
      substring$1: function($receiver, startIndex) {
        return this.substring$2($receiver, startIndex, null);
      },
      toLowerCase$0: function(receiver) {
        return receiver.toLowerCase();
      },
      trim$0: function(receiver) {
        var result, endIndex, startIndex, t1, endIndex0;
        result = receiver.trim();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        if (this._codeUnitAt$1(result, 0) === 133) {
          startIndex = J.JSString__skipLeadingWhitespace(result, 1);
          if (startIndex === endIndex)
            return "";
        } else
          startIndex = 0;
        t1 = endIndex - 1;
        endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
        if (startIndex === 0 && endIndex0 === endIndex)
          return result;
        return result.substring(startIndex, endIndex0);
      },
      $mul: function(receiver, times) {
        var s, result;
        if (typeof times !== "number")
          return H.iae(times);
        if (0 >= times)
          return "";
        if (times === 1 || receiver.length === 0)
          return receiver;
        if (times !== times >>> 0)
          throw H.wrapException(C.C_OutOfMemoryError);
        for (s = receiver, result = ""; true;) {
          if ((times & 1) === 1)
            result = s + result;
          times = times >>> 1;
          if (times === 0)
            break;
          s += s;
        }
        return result;
      },
      padLeft$2: function(receiver, width, padding) {
        var delta = width - receiver.length;
        if (delta <= 0)
          return receiver;
        return this.$mul(padding, delta) + receiver;
      },
      padLeft$1: function($receiver, width) {
        return this.padLeft$2($receiver, width, " ");
      },
      indexOf$2: function(receiver, pattern, start) {
        var t1;
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
        t1 = receiver.indexOf(pattern, start);
        return t1;
      },
      indexOf$1: function($receiver, pattern) {
        return this.indexOf$2($receiver, pattern, 0);
      },
      lastIndexOf$2: function(receiver, pattern, start) {
        var t1;
        start = receiver.length;
        t1 = pattern.length;
        if (start + t1 > start)
          start -= t1;
        return receiver.lastIndexOf(pattern, start);
      },
      lastIndexOf$1: function($receiver, pattern) {
        return this.lastIndexOf$2($receiver, pattern, null);
      },
      contains$2: function(receiver, other, startIndex) {
        if (startIndex > receiver.length)
          throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
        return H.stringContainsUnchecked(receiver, other, startIndex);
      },
      get$isEmpty: function(receiver) {
        return receiver.length === 0;
      },
      compareTo$1: function(receiver, other) {
        var t1;
        if (typeof other !== "string")
          throw H.wrapException(H.argumentErrorValue(other));
        if (receiver === other)
          t1 = 0;
        else
          t1 = receiver < other ? -1 : 1;
        return t1;
      },
      toString$0: function(receiver) {
        return receiver;
      },
      get$hashCode: function(receiver) {
        var t1, hash, i;
        for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
          hash = 536870911 & hash + receiver.charCodeAt(i);
          hash = 536870911 & hash + ((524287 & hash) << 10);
          hash ^= hash >> 6;
        }
        hash = 536870911 & hash + ((67108863 & hash) << 3);
        hash ^= hash >> 11;
        return 536870911 & hash + ((16383 & hash) << 15);
      },
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $isString: 1,
      static: {
        JSString__isWhitespace: function(codeUnit) {
          if (codeUnit < 256)
            switch (codeUnit) {
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 32:
              case 133:
              case 160:
                return true;
              default:
                return false;
            }
          switch (codeUnit) {
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8232:
            case 8233:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        },
        JSString__skipLeadingWhitespace: function(string, index) {
          var t1, codeUnit;
          for (t1 = string.length; index < t1;) {
            codeUnit = C.JSString_methods._codeUnitAt$1(string, index);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
            ++index;
          }
          return index;
        },
        JSString__skipTrailingWhitespace: function(string, index) {
          var index0, codeUnit;
          for (; index > 0; index = index0) {
            index0 = index - 1;
            codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
          }
          return index;
        }
      }
    }
  }], ["dart._internal", "dart:_internal",, H, {
    "^": "",
    hexDigitValue: function(char) {
      var digit, letter;
      digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    IterableElementError_noElement: function() {
      return new P.StateError("No element");
    },
    IterableElementError_tooFew: function() {
      return new P.StateError("Too few elements");
    },
    Sort__doSort: function(a, left, right, compare) {
      if (right - left <= 32)
        H.Sort__insertionSort(a, left, right, compare);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare);
    },
    Sort__insertionSort: function(a, left, right, compare) {
      var i, t1, el, j, j0;
      for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
            break;
          j0 = j - 1;
          t1.$indexSet(a, j, t1.$index(a, j0));
          j = j0;
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort: function(a, left, right, compare) {
      var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t2, great0, less0, pivots_are_equal;
      sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
      index1 = left + sixth;
      index5 = right - sixth;
      index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
      index2 = index3 - sixth;
      index4 = index3 + sixth;
      t1 = J.getInterceptor$asx(a);
      el1 = t1.$index(a, index1);
      el2 = t1.$index(a, index2);
      el3 = t1.$index(a, index3);
      el4 = t1.$index(a, index4);
      el5 = t1.$index(a, index5);
      if (J.$gt$n(compare.call$2(el1, el2), 0)) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el3), 0)) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el4), 0)) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el3, el4), 0)) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el5), 0)) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t1.$indexSet(a, index1, el1);
      t1.$indexSet(a, index3, el3);
      t1.$indexSet(a, index5, el5);
      t1.$indexSet(a, index2, t1.$index(a, left));
      t1.$indexSet(a, index4, t1.$index(a, right));
      less = left + 1;
      great = right - 1;
      if (J.$eq$(compare.call$2(el2, el4), 0)) {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp = compare.call$2(ak, el2);
          t2 = J.getInterceptor(comp);
          if (t2.$eq(comp, 0))
            continue;
          if (t2.$lt(comp, 0)) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else
            for (; true;) {
              comp = compare.call$2(t1.$index(a, great), el2);
              t2 = J.getInterceptor$n(comp);
              if (t2.$gt(comp, 0)) {
                --great;
                continue;
              } else {
                great0 = great - 1;
                if (t2.$lt(comp, 0)) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
        pivots_are_equal = true;
      } else {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (J.$lt$n(compare.call$2(ak, el2), 0)) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (J.$gt$n(compare.call$2(ak, el4), 0))
            for (; true;)
              if (J.$gt$n(compare.call$2(t1.$index(a, great), el4), 0)) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                great0 = great - 1;
                if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        pivots_are_equal = false;
      }
      t2 = less - 1;
      t1.$indexSet(a, left, t1.$index(a, t2));
      t1.$indexSet(a, t2, el2);
      t2 = great + 1;
      t1.$indexSet(a, right, t1.$index(a, t2));
      t1.$indexSet(a, t2, el4);
      H.Sort__doSort(a, left, less - 2, compare);
      H.Sort__doSort(a, great + 2, right, compare);
      if (pivots_are_equal)
        return;
      if (less < index1 && great > index5) {
        for (; J.$eq$(compare.call$2(t1.$index(a, less), el2), 0);)
          ++less;
        for (; J.$eq$(compare.call$2(t1.$index(a, great), el4), 0);)
          --great;
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (J.$eq$(compare.call$2(ak, el2), 0)) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (J.$eq$(compare.call$2(ak, el4), 0))
            for (; true;)
              if (J.$eq$(compare.call$2(t1.$index(a, great), el4), 0)) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                great0 = great - 1;
                if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare);
      } else
        H.Sort__doSort(a, less, great, compare);
    },
    CodeUnits: {
      "^": "UnmodifiableListBase;__internal$_string",
      get$length: function(_) {
        return this.__internal$_string.length;
      },
      $index: function(_, i) {
        return C.JSString_methods.codeUnitAt$1(this.__internal$_string, i);
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      }
    },
    EfficientLengthIterable: {
      "^": "Iterable;$ti",
      $asEfficientLengthIterable: null
    },
    ListIterable: {
      "^": "EfficientLengthIterable;$ti",
      get$iterator: function(_) {
        return new H.ListIterator(this, this.get$length(this), 0, null);
      },
      forEach$1: function(_, action) {
        var $length, i;
        $length = this.get$length(this);
        for (i = 0; i < $length; ++i) {
          action.call$1(this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
      },
      get$isEmpty: function(_) {
        return this.get$length(this) === 0;
      },
      get$first: function(_) {
        if (this.get$length(this) === 0)
          throw H.wrapException(H.IterableElementError_noElement());
        return this.elementAt$1(0, 0);
      },
      every$1: function(_, test) {
        var $length, i;
        $length = this.get$length(this);
        for (i = 0; i < $length; ++i) {
          if (test.call$1(this.elementAt$1(0, i)) !== true)
            return false;
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return true;
      },
      map$1: function(_, f) {
        return new H.MappedListIterable(this, f, [H.getRuntimeTypeArgument(this, "ListIterable", 0), null]);
      },
      toList$1$growable: function(_, growable) {
        var result, i, t1;
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
        for (i = 0; i < this.get$length(this); ++i) {
          t1 = this.elementAt$1(0, i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t1;
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      }
    },
    SubListIterable: {
      "^": "ListIterable;_iterable,__internal$_start,_endOrLength,$ti",
      get$_endIndex: function() {
        var $length, t1;
        $length = J.get$length$asx(this._iterable);
        t1 = this._endOrLength;
        if (t1 == null || t1 > $length)
          return $length;
        return t1;
      },
      get$_startIndex: function() {
        var $length, t1;
        $length = J.get$length$asx(this._iterable);
        t1 = this.__internal$_start;
        if (J.$gt$n(t1, $length))
          return $length;
        return t1;
      },
      get$length: function(_) {
        var $length, t1, t2;
        $length = J.get$length$asx(this._iterable);
        t1 = this.__internal$_start;
        if (J.$ge$n(t1, $length))
          return 0;
        t2 = this._endOrLength;
        if (t2 == null || t2 >= $length) {
          if (typeof t1 !== "number")
            return H.iae(t1);
          return $length - t1;
        }
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        return t2 - t1;
      },
      elementAt$1: function(_, index) {
        var realIndex, t1;
        realIndex = J.$add$ns(this.get$_startIndex(), index);
        if (!(index < 0)) {
          t1 = this.get$_endIndex();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = realIndex >= t1;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.IndexError$(index, this, "index", null, null));
        return J.elementAt$1$ax(this._iterable, realIndex);
      },
      take$1: function(_, count) {
        var t1, t2, newEnd;
        if (count < 0)
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        t1 = this._endOrLength;
        t2 = this.__internal$_start;
        if (t1 == null)
          return H.SubListIterable$(this._iterable, t2, J.$add$ns(t2, count), H.getTypeArgumentByIndex(this, 0));
        else {
          newEnd = J.$add$ns(t2, count);
          if (t1 < newEnd)
            return this;
          return H.SubListIterable$(this._iterable, t2, newEnd, H.getTypeArgumentByIndex(this, 0));
        }
      },
      toList$1$growable: function(_, growable) {
        var start, t1, t2, end, end0, $length, t3, result, i;
        start = this.__internal$_start;
        t1 = this._iterable;
        t2 = J.getInterceptor$asx(t1);
        end = t2.get$length(t1);
        end0 = this._endOrLength;
        if (end0 != null && end0 < end)
          end = end0;
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length < 0)
          $length = 0;
        t3 = this.$ti;
        if (growable) {
          result = H.setRuntimeTypeInfo([], t3);
          C.JSArray_methods.set$length(result, $length);
        } else
          result = H.setRuntimeTypeInfo(new Array($length), t3);
        for (i = 0; i < $length; ++i) {
          t3 = t2.elementAt$1(t1, start + i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t3;
          if (t2.get$length(t1) < end)
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
        var t1, t2, t3;
        t1 = this.__internal$_start;
        t2 = J.getInterceptor$n(t1);
        if (t2.$lt(t1, 0))
          H.throwExpression(P.RangeError$range(t1, 0, null, "start", null));
        t3 = this._endOrLength;
        if (t3 != null) {
          if (t3 < 0)
            H.throwExpression(P.RangeError$range(t3, 0, null, "end", null));
          if (t2.$gt(t1, t3))
            throw H.wrapException(P.RangeError$range(t1, 0, t3, "start", null));
        }
      },
      static: {
        SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
          var t1 = new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
          t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
          return t1;
        }
      }
    },
    ListIterator: {
      "^": "Object;_iterable,__internal$_length,__internal$_index,__internal$_current",
      get$current: function() {
        return this.__internal$_current;
      },
      moveNext$0: function() {
        var t1, t2, $length, t3;
        t1 = this._iterable;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (this.__internal$_length !== $length)
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        t3 = this.__internal$_index;
        if (t3 >= $length) {
          this.__internal$_current = null;
          return false;
        }
        this.__internal$_current = t2.elementAt$1(t1, t3);
        ++this.__internal$_index;
        return true;
      }
    },
    MappedIterable: {
      "^": "Iterable;_iterable,_f,$ti",
      get$iterator: function(_) {
        return new H.MappedIterator(null, J.get$iterator$ax(this._iterable), this._f, this.$ti);
      },
      get$length: function(_) {
        return J.get$length$asx(this._iterable);
      },
      get$isEmpty: function(_) {
        return J.get$isEmpty$asx(this._iterable);
      },
      $asIterable: function($S, $T) {
        return [$T];
      },
      static: {
        MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
          if (!!J.getInterceptor(iterable).$isEfficientLengthIterable)
            return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
          return new H.MappedIterable(iterable, $function, [$S, $T]);
        }
      }
    },
    EfficientLengthMappedIterable: {
      "^": "MappedIterable;_iterable,_f,$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      }
    },
    MappedIterator: {
      "^": "Iterator;__internal$_current,_iterator,_f,$ti",
      moveNext$0: function() {
        var t1 = this._iterator;
        if (t1.moveNext$0()) {
          this.__internal$_current = this._f.call$1(t1.get$current());
          return true;
        }
        this.__internal$_current = null;
        return false;
      },
      get$current: function() {
        return this.__internal$_current;
      }
    },
    MappedListIterable: {
      "^": "ListIterable;_source,_f,$ti",
      get$length: function(_) {
        return J.get$length$asx(this._source);
      },
      elementAt$1: function(_, index) {
        return this._f.call$1(J.elementAt$1$ax(this._source, index));
      },
      $asListIterable: function($S, $T) {
        return [$T];
      },
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    WhereIterable: {
      "^": "Iterable;_iterable,_f,$ti",
      get$iterator: function(_) {
        return new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f, this.$ti);
      },
      map$1: function(_, f) {
        return new H.MappedIterable(this, f, [H.getTypeArgumentByIndex(this, 0), null]);
      }
    },
    WhereIterator: {
      "^": "Iterator;_iterator,_f,$ti",
      moveNext$0: function() {
        var t1, t2;
        for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
          if (t2.call$1(t1.get$current()) === true)
            return true;
        return false;
      },
      get$current: function() {
        return this._iterator.get$current();
      }
    },
    FixedLengthListMixin: {
      "^": "Object;$ti",
      set$length: function(receiver, newLength) {
        throw H.wrapException(new P.UnsupportedError("Cannot change the length of a fixed-length list"));
      },
      replaceRange$3: function(receiver, start, end, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }
    },
    UnmodifiableListMixin: {
      "^": "Object;$ti",
      $indexSet: function(_, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      },
      set$length: function(_, newLength) {
        throw H.wrapException(new P.UnsupportedError("Cannot change the length of an unmodifiable list"));
      },
      setRange$4: function(_, start, end, iterable, skipCount) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      replaceRange$3: function(_, start, end, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      },
      fillRange$3: function(_, start, end, fillValue) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      },
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null
    },
    UnmodifiableListBase: {
      "^": "ListBase+UnmodifiableListMixin;$ti",
      $asList: null,
      $asEfficientLengthIterable: null,
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Symbol: {
      "^": "Object;__internal$_name<",
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.Symbol && J.$eq$(this.__internal$_name, other.__internal$_name);
      },
      get$hashCode: function(_) {
        var hash, t1;
        hash = this._hashCode;
        if (hash != null)
          return hash;
        t1 = J.get$hashCode$(this.__internal$_name);
        if (typeof t1 !== "number")
          return H.iae(t1);
        hash = 536870911 & 664597 * t1;
        this._hashCode = hash;
        return hash;
      },
      toString$0: function(_) {
        return 'Symbol("' + H.S(this.__internal$_name) + '")';
      },
      $isSymbol0: 1
    }
  }], ["_isolate_helper", "dart:_isolate_helper",, H, {
    "^": "",
    _callInIsolate: function(isolate, $function) {
      var result = isolate.eval$1($function);
      if (!init.globalState.currentContext._isExecutingEvent)
        init.globalState.topEventLoop.run$0();
      return result;
    },
    startRootIsolate: function(entry, args) {
      var t1, t2, t3, t4, t5, rootContext;
      t1 = {};
      t1.args = args;
      if (args == null) {
        args = [];
        t1.args = args;
        t2 = args;
      } else
        t2 = args;
      if (!J.getInterceptor(t2).$isList)
        throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
      init.globalState = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
      t2 = init.globalState;
      t3 = self.window == null;
      t4 = self.Worker;
      t5 = t3 && !!self.postMessage;
      t2.isWorker = t5;
      t5 = !t5;
      if (t5)
        t4 = t4 != null && $.$get$IsolateNatives_thisScript() != null;
      else
        t4 = true;
      t2.supportsWorkers = t4;
      t2.fromCommandLine = t3 && t5;
      t2.topEventLoop = new H._EventLoop(P.ListQueue$(null, H._IsolateEvent), 0);
      t3 = P.int;
      t2.isolates = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, H._IsolateContext]);
      t2.managers = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, null]);
      if (t2.isWorker === true) {
        t4 = new H._MainManagerStub();
        t2.mainManager = t4;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t4);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log)
              self.console.log(object);
            else
              self.postMessage(serialize(object));
          };
        }(H._Manager__serializePrintMessage);
      }
      if (init.globalState.isWorker === true)
        return;
      t2 = init.globalState.nextIsolateId++;
      t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, t3);
      t5 = new H.RawReceivePortImpl(0, null, false);
      rootContext = new H._IsolateContext(t2, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, H.RawReceivePortImpl]), t4, init.createNewIsolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
      t4.add$1(0, 0);
      rootContext._addRegistration$2(0, t5);
      init.globalState.rootContext = rootContext;
      init.globalState.currentContext = rootContext;
      if (H.functionTypeTest(entry, {func: 1, args: [,]}))
        rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
      else if (H.functionTypeTest(entry, {func: 1, args: [,,]}))
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
      init.globalState.topEventLoop.run$0();
    },
    IsolateNatives_computeThisScript: function() {
      var currentScript = init.currentScript;
      if (currentScript != null)
        return String(currentScript.src);
      if (init.globalState.isWorker === true)
        return H.IsolateNatives_computeThisScriptFromTrace();
      return;
    },
    IsolateNatives_computeThisScriptFromTrace: function() {
      var stack, matches;
      stack = new Error().stack;
      if (stack == null) {
        stack = function() {
          try {
            throw new Error();
          } catch (e) {
            return e.stack;
          }
        }();
        if (stack == null)
          throw H.wrapException(new P.UnsupportedError("No stack trace"));
      }
      matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
      if (matches != null)
        return matches[1];
      matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
      if (matches != null)
        return matches[1];
      throw H.wrapException(new P.UnsupportedError('Cannot extract URI from "' + stack + '"'));
    },
    IsolateNatives__processWorkerMessage: [function(sender, e) {
      var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
      msg = new H._Deserializer(true, []).deserialize$1(e.data);
      t1 = J.getInterceptor$asx(msg);
      switch (t1.$index(msg, "command")) {
        case "start":
          init.globalState.currentManagerId = t1.$index(msg, "id");
          functionName = t1.$index(msg, "functionName");
          entryPoint = functionName == null ? init.globalState.entry : init.globalFunctions[functionName]();
          args = t1.$index(msg, "args");
          message = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "msg"));
          isSpawnUri = t1.$index(msg, "isSpawnUri");
          startPaused = t1.$index(msg, "startPaused");
          replyTo = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "replyTo"));
          t1 = init.globalState.nextIsolateId++;
          t2 = P.int;
          t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, t2);
          t4 = new H.RawReceivePortImpl(0, null, false);
          context = new H._IsolateContext(t1, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t2, H.RawReceivePortImpl]), t3, init.createNewIsolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
          t3.add$1(0, 0);
          context._addRegistration$2(0, t4);
          init.globalState.topEventLoop.events._add$1(0, new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
          init.globalState.currentContext = context;
          init.globalState.topEventLoop.run$0();
          break;
        case "spawn-worker":
          break;
        case "message":
          if (t1.$index(msg, "port") != null)
            J.send$1$x(t1.$index(msg, "port"), t1.$index(msg, "msg"));
          init.globalState.topEventLoop.run$0();
          break;
        case "close":
          init.globalState.managers.remove$1(0, $.$get$IsolateNatives_workerIds().$index(0, sender));
          sender.terminate();
          init.globalState.topEventLoop.run$0();
          break;
        case "log":
          H.IsolateNatives__log(t1.$index(msg, "msg"));
          break;
        case "print":
          if (init.globalState.isWorker === true) {
            t1 = init.globalState.mainManager;
            t2 = P.LinkedHashMap__makeLiteral(["command", "print", "msg", msg]);
            t2 = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t2);
            t1.toString;
            self.postMessage(t2);
          } else
            P.print(t1.$index(msg, "msg"));
          break;
        case "error":
          throw H.wrapException(t1.$index(msg, "msg"));
      }
    }, null, null, 4, 0, null, 22, 0],
    IsolateNatives__log: function(msg) {
      var trace, t1, t2, exception;
      if (init.globalState.isWorker === true) {
        t1 = init.globalState.mainManager;
        t2 = P.LinkedHashMap__makeLiteral(["command", "log", "msg", msg]);
        t2 = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t2);
        t1.toString;
        self.postMessage(t2);
      } else
        try {
          self.console.log(msg);
        } catch (exception) {
          H.unwrapException(exception);
          trace = H.getTraceFromException(exception);
          t1 = P.Exception_Exception(trace);
          throw H.wrapException(t1);
        }
    },
    IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
      var context, t1, t2, t3;
      context = init.globalState.currentContext;
      t1 = context.id;
      $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
      $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
      t1 = context.controlPort;
      t2 = init.globalState.currentContext.id;
      t3 = context.pauseCapability;
      J.send$1$x(replyTo, ["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
      t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
      if (startPaused === true) {
        context.addPause$2(t3, t3);
        init.globalState.topEventLoop.events._add$1(0, new H._IsolateEvent(context, t2, "start isolate"));
      } else
        t2.call$0();
    },
    _clone: function(message) {
      return new H._Deserializer(true, []).deserialize$1(new H._Serializer(false, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(message));
    },
    startRootIsolate_closure: {
      "^": "Closure:1;_box_0,entry",
      call$0: function() {
        this.entry.call$1(this._box_0.args);
      }
    },
    startRootIsolate_closure0: {
      "^": "Closure:1;_box_0,entry",
      call$0: function() {
        this.entry.call$2(this._box_0.args, null);
      }
    },
    _Manager: {
      "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
      static: {
        _Manager__serializePrintMessage: [function(object) {
          var t1 = P.LinkedHashMap__makeLiteral(["command", "print", "msg", object]);
          return new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t1);
        }, null, null, 2, 0, null, 41]
      }
    },
    _IsolateContext: {
      "^": "Object;id>,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized?,isPaused<,delayedEvents<,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
      addPause$2: function(authentification, resume) {
        if (!this.pauseCapability.$eq(0, authentification))
          return;
        if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
          this.isPaused = true;
        this._updateGlobalState$0();
      },
      removePause$1: function(resume) {
        var t1, t2, $event, t3, t4, t5;
        if (!this.isPaused)
          return;
        t1 = this.pauseTokens;
        t1.remove$1(0, resume);
        if (t1._collection$_length === 0) {
          for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
            if (0 >= t2)
              return H.ioore(t1, -1);
            $event = t1.pop();
            t2 = init.globalState.topEventLoop.events;
            t3 = t2._head;
            t4 = t2._table;
            t5 = t4.length;
            t3 = (t3 - 1 & t5 - 1) >>> 0;
            t2._head = t3;
            if (t3 < 0 || t3 >= t5)
              return H.ioore(t4, t3);
            t4[t3] = $event;
            if (t3 === t2._tail)
              t2._grow$0();
            ++t2._modificationCount;
          }
          this.isPaused = false;
        }
        this._updateGlobalState$0();
      },
      addDoneListener$2: function(responsePort, response) {
        var t1, i, t2;
        if (this.doneHandlers == null)
          this.doneHandlers = [];
        for (t1 = J.getInterceptor(responsePort), i = 0; t2 = this.doneHandlers, i < t2.length; i += 2)
          if (t1.$eq(responsePort, t2[i])) {
            t1 = this.doneHandlers;
            t2 = i + 1;
            if (t2 >= t1.length)
              return H.ioore(t1, t2);
            t1[t2] = response;
            return;
          }
        t2.push(responsePort);
        this.doneHandlers.push(response);
      },
      removeDoneListener$1: function(responsePort) {
        var t1, i, t2;
        if (this.doneHandlers == null)
          return;
        for (t1 = J.getInterceptor(responsePort), i = 0; t2 = this.doneHandlers, i < t2.length; i += 2)
          if (t1.$eq(responsePort, t2[i])) {
            t1 = this.doneHandlers;
            t2 = i + 2;
            t1.toString;
            if (typeof t1 !== "object" || t1 === null || !!t1.fixed$length)
              H.throwExpression(new P.UnsupportedError("removeRange"));
            P.RangeError_checkValidRange(i, t2, t1.length, null, null, null);
            t1.splice(i, t2 - i);
            return;
          }
      },
      setErrorsFatal$2: function(authentification, errorsAreFatal) {
        if (!this.terminateCapability.$eq(0, authentification))
          return;
        this.errorsAreFatal = errorsAreFatal;
      },
      handlePing$3: function(responsePort, pingType, response) {
        var t1 = J.getInterceptor(pingType);
        if (!t1.$eq(pingType, 0))
          t1 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
        else
          t1 = true;
        if (t1) {
          J.send$1$x(responsePort, response);
          return;
        }
        t1 = this._scheduledControlEvents;
        if (t1 == null) {
          t1 = P.ListQueue$(null, null);
          this._scheduledControlEvents = t1;
        }
        t1._add$1(0, new H._IsolateContext_handlePing_respond(responsePort, response));
      },
      handleKill$2: function(authentification, priority) {
        var t1;
        if (!this.terminateCapability.$eq(0, authentification))
          return;
        t1 = J.getInterceptor(priority);
        if (!t1.$eq(priority, 0))
          t1 = t1.$eq(priority, 1) && !this._isExecutingEvent;
        else
          t1 = true;
        if (t1) {
          this.kill$0();
          return;
        }
        t1 = this._scheduledControlEvents;
        if (t1 == null) {
          t1 = P.ListQueue$(null, null);
          this._scheduledControlEvents = t1;
        }
        t1._add$1(0, this.get$kill());
      },
      handleUncaughtError$2: function(error, stackTrace) {
        var t1, message, t2;
        t1 = this.errorPorts;
        if (t1._collection$_length === 0) {
          if (this.errorsAreFatal === true && this === init.globalState.rootContext)
            return;
          if (self.console && self.console.error)
            self.console.error(error, stackTrace);
          else {
            P.print(error);
            if (stackTrace != null)
              P.print(stackTrace);
          }
          return;
        }
        message = new Array(2);
        message.fixed$length = Array;
        message[0] = J.toString$0$(error);
        message[1] = stackTrace == null ? null : J.toString$0$(stackTrace);
        for (t2 = new P._LinkedHashSetIterator(t1, t1._collection$_modifications, null, null), t2._collection$_cell = t1._collection$_first; t2.moveNext$0();)
          J.send$1$x(t2._collection$_current, message);
      },
      eval$1: function(code) {
        var old, result, oldIsExecutingEvent, e, s, exception, t1;
        old = init.globalState.currentContext;
        init.globalState.currentContext = this;
        $ = this.isolateStatics;
        result = null;
        oldIsExecutingEvent = this._isExecutingEvent;
        this._isExecutingEvent = true;
        try {
          result = code.call$0();
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this.handleUncaughtError$2(e, s);
          if (this.errorsAreFatal === true) {
            this.kill$0();
            if (this === init.globalState.rootContext)
              throw exception;
          }
        } finally {
          this._isExecutingEvent = oldIsExecutingEvent;
          init.globalState.currentContext = old;
          if (old != null)
            $ = old.get$isolateStatics();
          if (this._scheduledControlEvents != null)
            for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
              this._scheduledControlEvents.removeFirst$0().call$0();
        }
        return result;
      },
      handleControlMessage$1: function(message) {
        var t1 = J.getInterceptor$asx(message);
        switch (t1.$index(message, 0)) {
          case "pause":
            this.addPause$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "resume":
            this.removePause$1(t1.$index(message, 1));
            break;
          case "add-ondone":
            this.addDoneListener$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "remove-ondone":
            this.removeDoneListener$1(t1.$index(message, 1));
            break;
          case "set-errors-fatal":
            this.setErrorsFatal$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "ping":
            this.handlePing$3(t1.$index(message, 1), t1.$index(message, 2), t1.$index(message, 3));
            break;
          case "kill":
            this.handleKill$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "getErrors":
            this.errorPorts.add$1(0, t1.$index(message, 1));
            break;
          case "stopErrors":
            this.errorPorts.remove$1(0, t1.$index(message, 1));
            break;
        }
      },
      lookup$1: function(portId) {
        return this.ports.$index(0, portId);
      },
      _addRegistration$2: function(portId, port) {
        var t1 = this.ports;
        if (t1.containsKey$1(0, portId))
          throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
        t1.$indexSet(0, portId, port);
      },
      _updateGlobalState$0: function() {
        var t1 = this.ports;
        if (t1.get$length(t1) - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
          init.globalState.isolates.$indexSet(0, this.id, this);
        else
          this.kill$0();
      },
      kill$0: [function() {
        var t1, t2, i, responsePort, t3;
        t1 = this._scheduledControlEvents;
        if (t1 != null)
          t1.clear$0(0);
        for (t1 = this.ports, t2 = t1.get$values(t1), t2 = t2.get$iterator(t2); t2.moveNext$0();)
          t2.get$current()._close$0();
        t1.clear$0(0);
        this.weakPorts.clear$0(0);
        init.globalState.isolates.remove$1(0, this.id);
        this.errorPorts.clear$0(0);
        if (this.doneHandlers != null) {
          for (i = 0; t1 = this.doneHandlers, t2 = t1.length, i < t2; i += 2) {
            responsePort = t1[i];
            t3 = i + 1;
            if (t3 >= t2)
              return H.ioore(t1, t3);
            J.send$1$x(responsePort, t1[t3]);
          }
          this.doneHandlers = null;
        }
      }, "call$0", "get$kill", 0, 0, 2]
    },
    _IsolateContext_handlePing_respond: {
      "^": "Closure:2;responsePort,response",
      call$0: [function() {
        J.send$1$x(this.responsePort, this.response);
      }, null, null, 0, 0, null, "call"]
    },
    _EventLoop: {
      "^": "Object;events,_activeJsAsyncCount",
      dequeue$0: function() {
        var t1 = this.events;
        if (t1._head === t1._tail)
          return;
        return t1.removeFirst$0();
      },
      runIteration$0: function() {
        var $event, t1, t2;
        $event = this.dequeue$0();
        if ($event == null) {
          if (init.globalState.rootContext != null)
            if (init.globalState.isolates.containsKey$1(0, init.globalState.rootContext.id))
              if (init.globalState.fromCommandLine === true) {
                t1 = init.globalState.rootContext.ports;
                t1 = t1.get$isEmpty(t1);
              } else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
          if (t1)
            H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
          t1 = init.globalState;
          if (t1.isWorker === true) {
            t2 = t1.isolates;
            t2 = t2.get$isEmpty(t2) && t1.topEventLoop._activeJsAsyncCount === 0;
          } else
            t2 = false;
          if (t2) {
            t1 = t1.mainManager;
            t2 = P.LinkedHashMap__makeLiteral(["command", "close"]);
            t2 = new H._Serializer(true, new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0, [null, P.int])).serialize$1(t2);
            t1.toString;
            self.postMessage(t2);
          }
          return false;
        }
        $event.process$0();
        return true;
      },
      _runHelper$0: function() {
        if (self.window != null)
          new H._EventLoop__runHelper_next(this).call$0();
        else
          for (; this.runIteration$0();)
            ;
      },
      run$0: function() {
        var e, trace, exception, t1, t2;
        if (init.globalState.isWorker !== true)
          this._runHelper$0();
        else
          try {
            this._runHelper$0();
          } catch (exception) {
            e = H.unwrapException(exception);
            trace = H.getTraceFromException(exception);
            t1 = init.globalState.mainManager;
            t2 = P.LinkedHashMap__makeLiteral(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)]);
            t2 = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t2);
            t1.toString;
            self.postMessage(t2);
          }
      }
    },
    _EventLoop__runHelper_next: {
      "^": "Closure:2;$this",
      call$0: function() {
        if (!this.$this.runIteration$0())
          return;
        P.Timer_Timer(C.Duration_0, this);
      }
    },
    _IsolateEvent: {
      "^": "Object;isolate,fn,message",
      process$0: function() {
        var t1 = this.isolate;
        if (t1.get$isPaused()) {
          t1.get$delayedEvents().push(this);
          return;
        }
        t1.eval$1(this.fn);
      }
    },
    _MainManagerStub: {
      "^": "Object;"
    },
    IsolateNatives__processWorkerMessage_closure: {
      "^": "Closure:1;entryPoint,args,message,isSpawnUri,startPaused,replyTo",
      call$0: function() {
        H.IsolateNatives__startIsolate(this.entryPoint, this.args, this.message, this.isSpawnUri, this.startPaused, this.replyTo);
      }
    },
    IsolateNatives__startIsolate_runStartFunction: {
      "^": "Closure:2;topLevel,args,message,isSpawnUri,context",
      call$0: function() {
        var t1, t2;
        t1 = this.context;
        t1.set$initialized(true);
        if (this.isSpawnUri !== true)
          this.topLevel.call$1(this.message);
        else {
          t2 = this.topLevel;
          if (H.functionTypeTest(t2, {func: 1, args: [,,]}))
            t2.call$2(this.args, this.message);
          else if (H.functionTypeTest(t2, {func: 1, args: [,]}))
            t2.call$1(this.args);
          else
            t2.call$0();
        }
        t1._updateGlobalState$0();
      }
    },
    _BaseSendPort: {
      "^": "Object;"
    },
    _NativeJsSendPort: {
      "^": "_BaseSendPort;_receivePort,_isolateId",
      send$1: function(_, message) {
        var isolate, t1, msg;
        isolate = init.globalState.isolates.$index(0, this._isolateId);
        if (isolate == null)
          return;
        t1 = this._receivePort;
        if (t1.get$_isClosed())
          return;
        msg = H._clone(message);
        if (isolate.get$controlPort() === t1) {
          isolate.handleControlMessage$1(msg);
          return;
        }
        init.globalState.topEventLoop.events._add$1(0, new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(this, msg), "receive"));
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof H._NativeJsSendPort && J.$eq$(this._receivePort, other._receivePort);
      },
      get$hashCode: function(_) {
        return this._receivePort.get$_id();
      }
    },
    _NativeJsSendPort_send_closure: {
      "^": "Closure:1;$this,msg",
      call$0: function() {
        var t1 = this.$this._receivePort;
        if (!t1.get$_isClosed())
          J.__isolate_helper$_add$1$x(t1, this.msg);
      }
    },
    _WorkerSendPort: {
      "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
      send$1: function(_, message) {
        var t1, workerMessage, manager;
        t1 = P.LinkedHashMap__makeLiteral(["command", "message", "port", this, "msg", message]);
        workerMessage = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t1);
        if (init.globalState.isWorker === true) {
          init.globalState.mainManager.toString;
          self.postMessage(workerMessage);
        } else {
          manager = init.globalState.managers.$index(0, this._workerId);
          if (manager != null)
            manager.postMessage(workerMessage);
        }
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof H._WorkerSendPort && J.$eq$(this._workerId, other._workerId) && J.$eq$(this._isolateId, other._isolateId) && J.$eq$(this._receivePortId, other._receivePortId);
      },
      get$hashCode: function(_) {
        var t1, t2, t3;
        t1 = J.$shl$n(this._workerId, 16);
        t2 = J.$shl$n(this._isolateId, 8);
        t3 = this._receivePortId;
        if (typeof t3 !== "number")
          return H.iae(t3);
        return (t1 ^ t2 ^ t3) >>> 0;
      }
    },
    RawReceivePortImpl: {
      "^": "Object;_id<,_handler,_isClosed<",
      _close$0: function() {
        this._isClosed = true;
        this._handler = null;
      },
      __isolate_helper$_add$1: function(_, dataEvent) {
        if (this._isClosed)
          return;
        this._handler.call$1(dataEvent);
      },
      $isRawReceivePort: 1
    },
    TimerImpl: {
      "^": "Object;_once,_inEventLoop,_handle",
      cancel$0: function(_) {
        var t1;
        if (self.setTimeout != null) {
          if (this._inEventLoop)
            throw H.wrapException(new P.UnsupportedError("Timer in event loop cannot be canceled."));
          t1 = this._handle;
          if (t1 == null)
            return;
          --init.globalState.topEventLoop._activeJsAsyncCount;
          if (this._once)
            self.clearTimeout(t1);
          else
            self.clearInterval(t1);
          this._handle = null;
        } else
          throw H.wrapException(new P.UnsupportedError("Canceling a timer."));
      },
      TimerImpl$periodic$2: function(milliseconds, callback) {
        if (self.setTimeout != null) {
          ++init.globalState.topEventLoop._activeJsAsyncCount;
          this._handle = self.setInterval(H.convertDartClosureToJS(new H.TimerImpl$periodic_closure(this, callback), 0), milliseconds);
        } else
          throw H.wrapException(new P.UnsupportedError("Periodic timer."));
      },
      TimerImpl$2: function(milliseconds, callback) {
        var t1, t2;
        if (milliseconds === 0)
          t1 = self.setTimeout == null || init.globalState.isWorker === true;
        else
          t1 = false;
        if (t1) {
          this._handle = 1;
          t1 = init.globalState.topEventLoop;
          t2 = init.globalState.currentContext;
          t1.events._add$1(0, new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
          this._inEventLoop = true;
        } else if (self.setTimeout != null) {
          ++init.globalState.topEventLoop._activeJsAsyncCount;
          this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
        } else
          throw H.wrapException(new P.UnsupportedError("Timer greater than 0."));
      },
      static: {
        TimerImpl$: function(milliseconds, callback) {
          var t1 = new H.TimerImpl(true, false, null);
          t1.TimerImpl$2(milliseconds, callback);
          return t1;
        },
        TimerImpl$periodic: function(milliseconds, callback) {
          var t1 = new H.TimerImpl(false, false, null);
          t1.TimerImpl$periodic$2(milliseconds, callback);
          return t1;
        }
      }
    },
    TimerImpl_internalCallback: {
      "^": "Closure:2;$this,callback",
      call$0: function() {
        this.$this._handle = null;
        this.callback.call$0();
      }
    },
    TimerImpl_internalCallback0: {
      "^": "Closure:2;$this,callback",
      call$0: [function() {
        this.$this._handle = null;
        --init.globalState.topEventLoop._activeJsAsyncCount;
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    TimerImpl$periodic_closure: {
      "^": "Closure:1;$this,callback",
      call$0: [function() {
        this.callback.call$1(this.$this);
      }, null, null, 0, 0, null, "call"]
    },
    CapabilityImpl: {
      "^": "Object;_id<",
      get$hashCode: function(_) {
        var hash, t1, t2;
        hash = this._id;
        t1 = J.getInterceptor$n(hash);
        t2 = t1.$shr(hash, 0);
        t1 = t1.$tdiv(hash, 4294967296);
        if (typeof t1 !== "number")
          return H.iae(t1);
        hash = t2 ^ t1;
        hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
        hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
        hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
        return (hash ^ hash >>> 16) >>> 0;
      },
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other === this)
          return true;
        if (other instanceof H.CapabilityImpl) {
          t1 = this._id;
          t2 = other._id;
          return t1 == null ? t2 == null : t1 === t2;
        }
        return false;
      }
    },
    _Serializer: {
      "^": "Object;_serializeSendPorts,serializedObjectIds",
      serialize$1: [function(x) {
        var t1, serializationId, serializeTearOff, t2, $name;
        if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
          return x;
        t1 = this.serializedObjectIds;
        serializationId = t1.$index(0, x);
        if (serializationId != null)
          return ["ref", serializationId];
        t1.$indexSet(0, x, t1.get$length(t1));
        t1 = J.getInterceptor(x);
        if (!!t1.$isNativeByteBuffer)
          return ["buffer", x];
        if (!!t1.$isNativeTypedData)
          return ["typed", x];
        if (!!t1.$isJSIndexable)
          return this.serializeJSIndexable$1(x);
        if (!!t1.$isInternalMap) {
          serializeTearOff = this.get$serialize();
          t2 = t1.get$keys(x);
          t2 = H.MappedIterable_MappedIterable(t2, serializeTearOff, H.getRuntimeTypeArgument(t2, "Iterable", 0), null);
          t2 = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0));
          t1 = t1.get$values(x);
          t1 = H.MappedIterable_MappedIterable(t1, serializeTearOff, H.getRuntimeTypeArgument(t1, "Iterable", 0), null);
          return ["map", t2, P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0))];
        }
        if (!!t1.$isJSObject)
          return this.serializeJSObject$1(x);
        if (!!t1.$isInterceptor)
          this.unsupported$1(x);
        if (!!t1.$isRawReceivePort)
          this.unsupported$2(x, "RawReceivePorts can't be transmitted:");
        if (!!t1.$is_NativeJsSendPort)
          return this.serializeJsSendPort$1(x);
        if (!!t1.$is_WorkerSendPort)
          return this.serializeWorkerSendPort$1(x);
        if (!!t1.$isClosure) {
          $name = x.$static_name;
          if ($name == null)
            this.unsupported$2(x, "Closures can't be transmitted:");
          return ["function", $name];
        }
        if (!!t1.$isCapabilityImpl)
          return ["capability", x._id];
        if (!(x instanceof P.Object))
          this.unsupported$1(x);
        return ["dart", init.classIdExtractor(x), this.serializeArrayInPlace$1(init.classFieldsExtractor(x))];
      }, "call$1", "get$serialize", 2, 0, 0, 13],
      unsupported$2: function(x, message) {
        throw H.wrapException(new P.UnsupportedError((message == null ? "Can't transmit:" : message) + " " + H.S(x)));
      },
      unsupported$1: function(x) {
        return this.unsupported$2(x, null);
      },
      serializeJSIndexable$1: function(indexable) {
        var serialized = this.serializeArray$1(indexable);
        if (!!indexable.fixed$length)
          return ["fixed", serialized];
        if (!indexable.fixed$length)
          return ["extendable", serialized];
        if (!indexable.immutable$list)
          return ["mutable", serialized];
        if (indexable.constructor === Array)
          return ["const", serialized];
        this.unsupported$2(indexable, "Can't serialize indexable: ");
      },
      serializeArray$1: function(x) {
        var serialized, i, t1;
        serialized = [];
        C.JSArray_methods.set$length(serialized, x.length);
        for (i = 0; i < x.length; ++i) {
          t1 = this.serialize$1(x[i]);
          if (i >= serialized.length)
            return H.ioore(serialized, i);
          serialized[i] = t1;
        }
        return serialized;
      },
      serializeArrayInPlace$1: function(x) {
        var i;
        for (i = 0; i < x.length; ++i)
          C.JSArray_methods.$indexSet(x, i, this.serialize$1(x[i]));
        return x;
      },
      serializeJSObject$1: function(x) {
        var keys, values, i, t1;
        if (!!x.constructor && x.constructor !== Object)
          this.unsupported$2(x, "Only plain JS Objects are supported:");
        keys = Object.keys(x);
        values = [];
        C.JSArray_methods.set$length(values, keys.length);
        for (i = 0; i < keys.length; ++i) {
          t1 = this.serialize$1(x[keys[i]]);
          if (i >= values.length)
            return H.ioore(values, i);
          values[i] = t1;
        }
        return ["js-object", keys, values];
      },
      serializeWorkerSendPort$1: function(x) {
        if (this._serializeSendPorts)
          return ["sendport", x._workerId, x._isolateId, x._receivePortId];
        return ["raw sendport", x];
      },
      serializeJsSendPort$1: function(x) {
        if (this._serializeSendPorts)
          return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort.get$_id()];
        return ["raw sendport", x];
      }
    },
    _Deserializer: {
      "^": "Object;_adjustSendPorts,deserializedObjects",
      deserialize$1: [function(x) {
        var serializationId, t1, result, classId, fields, emptyInstance;
        if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
          return x;
        if (typeof x !== "object" || x === null || x.constructor !== Array)
          throw H.wrapException(P.ArgumentError$("Bad serialized message: " + H.S(x)));
        switch (C.JSArray_methods.get$first(x)) {
          case "ref":
            if (1 >= x.length)
              return H.ioore(x, 1);
            serializationId = x[1];
            t1 = this.deserializedObjects;
            if (serializationId >>> 0 !== serializationId || serializationId >= t1.length)
              return H.ioore(t1, serializationId);
            return t1[serializationId];
          case "buffer":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return result;
          case "typed":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return result;
          case "fixed":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            t1 = H.setRuntimeTypeInfo(this.deserializeArrayInPlace$1(result), [null]);
            t1.fixed$length = Array;
            return t1;
          case "extendable":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return H.setRuntimeTypeInfo(this.deserializeArrayInPlace$1(result), [null]);
          case "mutable":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return this.deserializeArrayInPlace$1(result);
          case "const":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            t1 = H.setRuntimeTypeInfo(this.deserializeArrayInPlace$1(result), [null]);
            t1.fixed$length = Array;
            return t1;
          case "map":
            return this.deserializeMap$1(x);
          case "sendport":
            return this.deserializeSendPort$1(x);
          case "raw sendport":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return result;
          case "js-object":
            return this.deserializeJSObject$1(x);
          case "function":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = init.globalFunctions[x[1]]();
            this.deserializedObjects.push(result);
            return result;
          case "capability":
            if (1 >= x.length)
              return H.ioore(x, 1);
            return new H.CapabilityImpl(x[1]);
          case "dart":
            t1 = x.length;
            if (1 >= t1)
              return H.ioore(x, 1);
            classId = x[1];
            if (2 >= t1)
              return H.ioore(x, 2);
            fields = x[2];
            emptyInstance = init.instanceFromClassId(classId);
            this.deserializedObjects.push(emptyInstance);
            this.deserializeArrayInPlace$1(fields);
            return init.initializeEmptyInstance(classId, emptyInstance, fields);
          default:
            throw H.wrapException("couldn't deserialize: " + H.S(x));
        }
      }, "call$1", "get$deserialize", 2, 0, 0, 13],
      deserializeArrayInPlace$1: function(x) {
        var t1, i, t2;
        t1 = J.getInterceptor$asx(x);
        i = 0;
        while (true) {
          t2 = t1.get$length(x);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.$indexSet(x, i, this.deserialize$1(t1.$index(x, i)));
          ++i;
        }
        return x;
      },
      deserializeMap$1: function(x) {
        var t1, keys, values, result, t2, i;
        t1 = x.length;
        if (1 >= t1)
          return H.ioore(x, 1);
        keys = x[1];
        if (2 >= t1)
          return H.ioore(x, 2);
        values = x[2];
        result = P.LinkedHashMap__makeEmpty();
        this.deserializedObjects.push(result);
        keys = J.map$1$ax(keys, this.get$deserialize()).toList$0(0);
        for (t1 = J.getInterceptor$asx(keys), t2 = J.getInterceptor$asx(values), i = 0; i < t1.get$length(keys); ++i)
          result.$indexSet(0, t1.$index(keys, i), this.deserialize$1(t2.$index(values, i)));
        return result;
      },
      deserializeSendPort$1: function(x) {
        var t1, managerId, isolateId, receivePortId, isolate, receivePort, result;
        t1 = x.length;
        if (1 >= t1)
          return H.ioore(x, 1);
        managerId = x[1];
        if (2 >= t1)
          return H.ioore(x, 2);
        isolateId = x[2];
        if (3 >= t1)
          return H.ioore(x, 3);
        receivePortId = x[3];
        if (J.$eq$(managerId, init.globalState.currentManagerId)) {
          isolate = init.globalState.isolates.$index(0, isolateId);
          if (isolate == null)
            return;
          receivePort = isolate.lookup$1(receivePortId);
          if (receivePort == null)
            return;
          result = new H._NativeJsSendPort(receivePort, isolateId);
        } else
          result = new H._WorkerSendPort(managerId, receivePortId, isolateId);
        this.deserializedObjects.push(result);
        return result;
      },
      deserializeJSObject$1: function(x) {
        var t1, keys, values, o, t2, i, t3;
        t1 = x.length;
        if (1 >= t1)
          return H.ioore(x, 1);
        keys = x[1];
        if (2 >= t1)
          return H.ioore(x, 2);
        values = x[2];
        o = {};
        this.deserializedObjects.push(o);
        t1 = J.getInterceptor$asx(keys);
        t2 = J.getInterceptor$asx(values);
        i = 0;
        while (true) {
          t3 = t1.get$length(keys);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          o[t1.$index(keys, i)] = this.deserialize$1(t2.$index(values, i));
          ++i;
        }
        return o;
      }
    }
  }], ["_js_helper", "dart:_js_helper",, H, {
    "^": "",
    ConstantMap__throwUnmodifiable: function() {
      throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable Map"));
    },
    getType: function(index) {
      return init.types[index];
    },
    isJsIndexable: function(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
    },
    S: function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    },
    Primitives_objectHashCode: function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    },
    Primitives__parseIntError: function(source, handleError) {
      if (handleError == null)
        throw H.wrapException(new P.FormatException(source, null, null));
      return handleError.call$1(source);
    },
    Primitives_parseInt: function(source, radix, handleError) {
      var match, decimalMatch, maxCharCode, digitsPart, t1, i;
      H.checkString(source);
      match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return H.Primitives__parseIntError(source, handleError);
      if (3 >= match.length)
        return H.ioore(match, 3);
      decimalMatch = match[3];
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return H.Primitives__parseIntError(source, handleError);
      }
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((C.JSString_methods._codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
            return H.Primitives__parseIntError(source, handleError);
      }
      return parseInt(source, radix);
    },
    Primitives__parseDoubleError: function(source, handleError) {
      return handleError.call$1(source);
    },
    Primitives_parseDouble: function(source, handleError) {
      var result, trimmed;
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return H.Primitives__parseDoubleError(source, handleError);
      result = parseFloat(source);
      if (isNaN(result)) {
        trimmed = C.JSString_methods.trim$0(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return H.Primitives__parseDoubleError(source, handleError);
      }
      return result;
    },
    Primitives_objectTypeName: function(object) {
      var interceptor, interceptorConstructor, interceptorConstructorName, $name, dispatchName, objectConstructor, match, decompiledName;
      interceptor = J.getInterceptor(object);
      interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      if ($name == null || interceptor === C.Interceptor_methods || !!J.getInterceptor(object).$isUnknownJavaScriptObject) {
        dispatchName = C.JS_CONST_TSE(object);
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
          if ($name == null)
            $name = dispatchName;
        } else
          $name = dispatchName;
      }
      $name = $name;
      if ($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36)
        $name = C.JSString_methods.substring$1($name, 1);
      return function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null), init.mangledGlobalNames);
    },
    Primitives_objectToHumanReadableString: function(object) {
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    Primitives_dateNow: [function() {
      return Date.now();
    }, "call$0", "_js_helper_Primitives_dateNow$closure", 0, 0, 71],
    Primitives_initTicker: function() {
      var $window, performance;
      if ($.Primitives_timerFrequency != null)
        return;
      $.Primitives_timerFrequency = 1000;
      $.Primitives_timerTicks = H._js_helper_Primitives_dateNow$closure();
      if (typeof window == "undefined")
        return;
      $window = window;
      if ($window == null)
        return;
      performance = $window.performance;
      if (performance == null)
        return;
      if (typeof performance.now != "function")
        return;
      $.Primitives_timerFrequency = 1000000;
      $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
    },
    Primitives_currentUri: function() {
      if (!!self.location)
        return self.location.href;
      return;
    },
    Primitives__fromCharCodeApply: function(array) {
      var end, result, i, i0, chunkEnd;
      end = J.get$length$asx(array);
      if (J.$le$n(end, 500))
        return String.fromCharCode.apply(null, array);
      if (typeof end !== "number")
        return H.iae(end);
      result = "";
      i = 0;
      for (; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints: function(codePoints) {
      var a, t1, _i, i;
      a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = codePoints.length, _i = 0; _i < codePoints.length; codePoints.length === t1 || (0, H.throwConcurrentModificationError)(codePoints), ++_i) {
        i = codePoints[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          a.push(i);
        else if (i <= 1114111) {
          a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          a.push(56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes: function(charCodes) {
      var t1, _i, t2, i;
      for (t1 = charCodes.length, _i = 0; t2 = charCodes.length, _i < t2; t2 === t1 || (0, H.throwConcurrentModificationError)(charCodes), ++_i) {
        i = charCodes[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List: function(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (J.$le$n(end, 500) && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      result = "";
      for (; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode: function(charCode) {
      var bits;
      if (typeof charCode !== "number")
        return H.iae(charCode);
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_lazyAsJsDate: function(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._value);
      return receiver.date;
    },
    Primitives_getYear: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
    },
    Primitives_getMonth: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
    },
    Primitives_getDay: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
    },
    Primitives_getHours: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
    },
    Primitives_getMinutes: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
    },
    Primitives_getSeconds: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
    },
    Primitives_getMilliseconds: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
    },
    Primitives_getProperty: function(object, key) {
      if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
        throw H.wrapException(H.argumentErrorValue(object));
      return object[key];
    },
    Primitives_setProperty: function(object, key, value) {
      if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
        throw H.wrapException(H.argumentErrorValue(object));
      object[key] = value;
    },
    Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
      var t1, $arguments, namedArgumentList;
      t1 = {};
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      t1.argumentCount = positionalArguments.length;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
      t1.names = "";
      if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
        namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, $arguments, namedArgumentList));
      return J.noSuchMethod$1$($function, new H.JSInvocationMirror(C.Symbol_call, "call" + "$" + t1.argumentCount + t1.names, 0, $arguments, namedArgumentList, null));
    },
    Primitives_applyFunctionWithPositionalArguments: function($function, positionalArguments) {
      var $arguments, t1;
      $arguments = positionalArguments instanceof Array ? positionalArguments : P.List_List$from(positionalArguments, true, null);
      t1 = $arguments.length;
      if (t1 === 0) {
        if (!!$function.call$0)
          return $function.call$0();
      } else if (t1 === 1) {
        if (!!$function.call$1)
          return $function.call$1($arguments[0]);
      } else if (t1 === 2) {
        if (!!$function.call$2)
          return $function.call$2($arguments[0], $arguments[1]);
      } else if (t1 === 3) {
        if (!!$function.call$3)
          return $function.call$3($arguments[0], $arguments[1], $arguments[2]);
      } else if (t1 === 4) {
        if (!!$function.call$4)
          return $function.call$4($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
      } else if (t1 === 5)
        if (!!$function.call$5)
          return $function.call$5($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]);
      return H.Primitives__genericApplyFunctionWithPositionalArguments($function, $arguments);
    },
    Primitives__genericApplyFunctionWithPositionalArguments: function($function, $arguments) {
      var argumentCount, jsFunction, info, requiredArgumentCount, maxArgumentCount, pos;
      argumentCount = $arguments.length;
      jsFunction = $function["call" + "$" + argumentCount];
      if (jsFunction == null) {
        jsFunction = J.getInterceptor($function)["call*"];
        if (jsFunction == null)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        info = H.ReflectionInfo_ReflectionInfo(jsFunction);
        requiredArgumentCount = info.requiredParameterCount;
        maxArgumentCount = requiredArgumentCount + info.optionalParameterCount;
        if (info.areOptionalParametersNamed || requiredArgumentCount > argumentCount || maxArgumentCount < argumentCount)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        $arguments = P.List_List$from($arguments, true, null);
        for (pos = argumentCount; pos < maxArgumentCount; ++pos)
          C.JSArray_methods.add$1($arguments, init.metadata[info.defaultValue$1(0, pos)]);
      }
      return jsFunction.apply($function, $arguments);
    },
    iae: function(argument) {
      throw H.wrapException(H.argumentErrorValue(argument));
    },
    ioore: function(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, t1;
      if (typeof index !== "number" || Math.floor(index) !== index)
        return new P.ArgumentError(true, index, "index", null);
      $length = J.get$length$asx(indexable);
      if (!(index < 0)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = index >= $length;
      } else
        t1 = true;
      if (t1)
        return P.IndexError$(index, indexable, "index", null, $length);
      return P.RangeError$value(index, "index", null);
    },
    diagnoseRangeError: function(start, end, $length) {
      if (typeof start !== "number" || Math.floor(start) !== start)
        return new P.ArgumentError(true, start, "start", null);
      if (start < 0 || start > $length)
        return new P.RangeError(0, $length, true, start, "start", "Invalid value");
      if (end != null)
        if (end < start || end > $length)
          return new P.RangeError(start, $length, true, end, "end", "Invalid value");
      return new P.ArgumentError(true, end, "end", null);
    },
    argumentErrorValue: function(object) {
      return new P.ArgumentError(true, object, null, null);
    },
    checkNum: function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    checkInt: function(value) {
      if (typeof value !== "number" || Math.floor(value) !== value)
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    checkString: function(value) {
      if (typeof value !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    wrapException: function(ex) {
      var wrapper;
      if (ex == null)
        ex = new P.NullThrownError();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    },
    toStringWrapper: [function() {
      return J.toString$0$(this.dartException);
    }, null, null, 0, 0, null],
    throwExpression: function(ex) {
      throw H.wrapException(ex);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(new P.ConcurrentModificationError(collection));
    },
    unwrapException: function(ex) {
      var t1, message, number, ieErrorCode, t2, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match;
      t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
            case 445:
            case 5007:
              t2 = H.S(message) + " (Error " + ieErrorCode + ")";
              return t1.call$1(new H.NullError(t2, null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(message, match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(new H.NullError(message, match == null ? null : match.method));
          }
        }
        return t1.call$1(new H.UnknownJsTypeError(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && message.indexOf("call stack") !== -1)
          return new P.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return t1.call$1(new P.ArgumentError(false, null, null, typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return new P.StackOverflowError();
      return ex;
    },
    getTraceFromException: function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new H._StackTrace(exception, null);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = new H._StackTrace(exception, null);
    },
    objectHashCode: function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    },
    fillLiteralMap: function(keyValuePairs, result) {
      var $length, index, index0, index1;
      $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    invokeClosure: [function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
      switch (numberOfArguments) {
        case 0:
          return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
        case 1:
          return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
        case 2:
          return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
        case 3:
          return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
        case 4:
          return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
      }
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    }, null, null, 14, 0, null, 43, 26, 38, 49, 54, 46, 47],
    convertDartClosureToJS: function(closure, arity) {
      var $function;
      if (closure == null)
        return;
      $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, context, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, context, arity, a1, a2, a3, a4);
        };
      }(closure, arity, init.globalState.currentContext, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    },
    Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
      var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
      $function = functions[0];
      callName = $function.$callName;
      if (!!J.getInterceptor(reflectionInfo).$isList) {
        $function.$reflectionInfo = reflectionInfo;
        functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
      } else
        functionType = reflectionInfo;
      $prototype = isStatic ? Object.create(new H.StaticClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function() {
          this.$initialize();
        };
      else {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ns(t1, 1);
        $constructor = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        isIntercepted = jsArguments.length == 1 && true;
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
        isIntercepted = false;
      }
      if (typeof functionType == "number")
        signatureFunction = function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getType, functionType);
      else if (typeof functionType == "function")
        if (isStatic)
          signatureFunction = functionType;
        else {
          getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
          signatureFunction = function(f, r) {
            return function() {
              return f.apply({$receiver: r(this)}, arguments);
            };
          }(functionType, getReceiver);
        }
      else
        throw H.wrapException("Error in reflectionInfo.");
      $prototype.$signature = signatureFunction;
      $prototype[callName] = trampoline;
      for (t1 = functions.length, i = 1; i < t1; ++i) {
        stub = functions[i];
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = t2;
        }
      }
      $prototype["call*"] = trampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    },
    Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
      var getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    },
    Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, t2, selfName, $arguments;
      if (isIntercepted)
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t2 = !t1 || arity >= 27;
      if (t2)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ns(t1, 1);
        selfName = "self" + H.S(t1);
        t1 = "return function(){var " + selfName + " = this.";
        t2 = $.BoundClosure_selfFieldNameCache;
        if (t2 == null) {
          t2 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t2;
        }
        return new Function(t1 + H.S(t2) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      $arguments += H.S(t1);
      t1 = "return function(" + $arguments + "){return this.";
      t2 = $.BoundClosure_selfFieldNameCache;
      if (t2 == null) {
        t2 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t2;
      }
      return new Function(t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");}")();
    },
    Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
      var getSelf, getReceiver;
      getSelf = H.BoundClosure_selfOf;
      getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(new H.RuntimeError("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo: function(receiver, $function) {
      var selfField, t1, stubName, arity, lookedUpFunction, t2, t3, $arguments;
      selfField = H.BoundClosure_selfFieldName();
      t1 = $.BoundClosure_receiverFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("receiver");
        $.BoundClosure_receiverFieldNameCache = t1;
      }
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t3 = !t2 || arity >= 28;
      if (t3)
        return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
        t2 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ns(t2, 1);
        return new Function(t1 + H.S(t2) + "}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    },
    closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
      var t1;
      functions.fixed$length = Array;
      if (!!J.getInterceptor(reflectionInfo).$isList) {
        reflectionInfo.fixed$length = Array;
        t1 = reflectionInfo;
      } else
        t1 = reflectionInfo;
      return H.Closure_fromTearOff(receiver, functions, t1, !!isStatic, jsArguments, $name);
    },
    stringTypeCast: function(value) {
      if (typeof value === "string" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "String"));
    },
    boolTypeCast: function(value) {
      if (typeof value === "boolean" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "bool"));
    },
    propertyTypeCastError: function(value, property) {
      var t1 = J.getInterceptor$asx(property);
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
    },
    interceptedTypeCast: function(value, property) {
      var t1;
      if (value != null)
        t1 = (typeof value === "object" || typeof value === "function") && J.getInterceptor(value)[property];
      else
        t1 = true;
      if (t1)
        return value;
      H.propertyTypeCastError(value, property);
    },
    listTypeCast: function(value) {
      if (!!J.getInterceptor(value).$isList || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "List"));
    },
    extractFunctionTypeObjectFrom: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    functionTypeTest: function(value, functionTypeRti) {
      var functionTypeObject;
      if (value == null)
        return false;
      functionTypeObject = H.extractFunctionTypeObjectFrom(value);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, functionTypeRti);
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(new P.CyclicInitializationError(staticName));
    },
    random64: function() {
      return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
    },
    getIsolateAffinityTag: function($name) {
      return init.getIsolateTag($name);
    },
    setRuntimeTypeInfo: function(target, rti) {
      target.$ti = rti;
      return target;
    },
    getRuntimeTypeInfo: function(target) {
      if (target == null)
        return;
      return target.$ti;
    },
    getRuntimeTypeArguments: function(target, substitutionName) {
      return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
    },
    getRuntimeTypeArgument: function(target, substitutionName, index) {
      var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
      return $arguments == null ? null : $arguments[index];
    },
    getTypeArgumentByIndex: function(target, index) {
      var rti = H.getRuntimeTypeInfo(target);
      return rti == null ? null : rti[index];
    },
    runtimeTypeToString: function(rti, onTypeVariable) {
      var typedefInfo;
      if (rti == null)
        return "dynamic";
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return rti[0].builtin$cls + H.joinArguments(rti, 1, onTypeVariable);
      if (typeof rti == "function")
        return rti.builtin$cls;
      if (typeof rti === "number" && Math.floor(rti) === rti)
        return H.S(onTypeVariable == null ? rti : onTypeVariable.call$1(rti));
      if (typeof rti.func != "undefined") {
        typedefInfo = rti.typedef;
        if (typedefInfo != null)
          return H.runtimeTypeToString(typedefInfo, onTypeVariable);
        return H._functionRtiToString(rti, onTypeVariable);
      }
      return "unknown-reified-type";
    },
    _functionRtiToString: function(rti, onTypeVariable) {
      var returnTypeText, $arguments, t1, argumentsText, sep, _i, argument, optionalArguments, namedArguments, t2, $name;
      returnTypeText = !!rti.v ? "void" : H.runtimeTypeToString(rti.ret, onTypeVariable);
      if ("args" in rti) {
        $arguments = rti.args;
        for (t1 = $arguments.length, argumentsText = "", sep = "", _i = 0; _i < t1; ++_i, sep = ", ") {
          argument = $arguments[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToString(argument, onTypeVariable);
        }
      } else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText += sep + "[";
        for (t1 = optionalArguments.length, sep = "", _i = 0; _i < t1; ++_i, sep = ", ") {
          argument = optionalArguments[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToString(argument, onTypeVariable);
        }
        argumentsText += "]";
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText += sep + "{";
        for (t1 = H.extractKeys(namedArguments), t2 = t1.length, sep = "", _i = 0; _i < t2; ++_i, sep = ", ") {
          $name = t1[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToString(namedArguments[$name], onTypeVariable) + (" " + H.S($name));
        }
        argumentsText += "}";
      }
      return "(" + argumentsText + ") => " + returnTypeText;
    },
    joinArguments: function(types, startIndex, onTypeVariable) {
      var buffer, index, firstArgument, allDynamic, t1, argument;
      if (types == null)
        return "";
      buffer = new P.StringBuffer("");
      for (index = startIndex, firstArgument = true, allDynamic = true, t1 = ""; index < types.length; ++index) {
        if (firstArgument)
          firstArgument = false;
        else
          buffer._contents = t1 + ", ";
        argument = types[index];
        if (argument != null)
          allDynamic = false;
        t1 = buffer._contents += H.runtimeTypeToString(argument, onTypeVariable);
      }
      return allDynamic ? "" : "<" + buffer.toString$0(0) + ">";
    },
    substitute: function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      substitution = substitution.apply(null, $arguments);
      if (substitution == null)
        return;
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        return substitution;
      if (typeof substitution == "function")
        return substitution.apply(null, $arguments);
      return $arguments;
    },
    checkSubtype: function(object, isField, checks, asField) {
      var $arguments, interceptor;
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor(object);
      if (interceptor[isField] == null)
        return false;
      return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
    },
    subtypeCast: function(object, isField, checks, asField) {
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(isField.substring(3) + H.joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    areSubtypes: function(s, t) {
      var len, i;
      if (s == null || t == null)
        return true;
      len = s.length;
      for (i = 0; i < len; ++i)
        if (!H.isSubtype(s[i], t[i]))
          return false;
      return true;
    },
    computeSignature: function(signature, context, contextName) {
      return signature.apply(context, H.getRuntimeTypeArguments(context, contextName));
    },
    checkSubtypeOfRuntimeType: function(o, t) {
      var rti, type, targetSignatureFunction;
      if (o == null)
        return t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
      if (t == null)
        return true;
      rti = H.getRuntimeTypeInfo(o);
      o = J.getInterceptor(o);
      type = o.constructor;
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      if ('func' in t) {
        targetSignatureFunction = o.$signature;
        if (targetSignatureFunction == null)
          return false;
        return H.isFunctionSubtype(targetSignatureFunction.apply(o, null), t);
      }
      return H.isSubtype(type, t);
    },
    subtypeOfRuntimeTypeCast: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), H.runtimeTypeToString(type, null)));
      return object;
    },
    isSubtype: function(s, t) {
      var t1, typeOfS, t2, typeOfT, typeOfTString, substitution;
      if (s === t)
        return true;
      if (s == null || t == null)
        return true;
      if (s.builtin$cls === "Null")
        return true;
      if ('func' in t)
        return H.isFunctionSubtype(s, t);
      if ('func' in s)
        return t.builtin$cls === "Function" || t.builtin$cls === "Object";
      t1 = typeof s === "object" && s !== null && s.constructor === Array;
      typeOfS = t1 ? s[0] : s;
      t2 = typeof t === "object" && t !== null && t.constructor === Array;
      typeOfT = t2 ? t[0] : t;
      if (typeOfT !== typeOfS) {
        typeOfTString = H.runtimeTypeToString(typeOfT, null);
        if (!('$is' + typeOfTString in typeOfS.prototype))
          return false;
        substitution = typeOfS.prototype["$as" + typeOfTString];
      } else
        substitution = null;
      if (!t1 && substitution == null || !t2)
        return true;
      t1 = t1 ? s.slice(1) : null;
      t2 = t.slice(1);
      return H.areSubtypes(H.substitute(substitution, t1), t2);
    },
    areAssignable: function(s, t, allowShorter) {
      var t1, sLength, tLength, i, t2;
      t1 = t == null;
      if (t1 && s == null)
        return true;
      if (t1)
        return allowShorter;
      if (s == null)
        return false;
      sLength = s.length;
      tLength = t.length;
      if (allowShorter) {
        if (sLength < tLength)
          return false;
      } else if (sLength !== tLength)
        return false;
      for (i = 0; i < tLength; ++i) {
        t1 = s[i];
        t2 = t[i];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      return true;
    },
    areAssignableMaps: function(s, t) {
      var t1, names, i, $name, tType, sType;
      if (t == null)
        return true;
      if (s == null)
        return false;
      t1 = Object.getOwnPropertyNames(t);
      t1.fixed$length = Array;
      names = t1;
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        tType = t[$name];
        sType = s[$name];
        if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
          return false;
      }
      return true;
    },
    isFunctionSubtype: function(s, t) {
      var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
      if (!('func' in s))
        return false;
      if ("v" in s) {
        if (!("v" in t) && "ret" in t)
          return false;
      } else if (!("v" in t)) {
        sReturnType = s.ret;
        tReturnType = t.ret;
        if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
          return false;
      }
      sParameterTypes = s.args;
      tParameterTypes = t.args;
      sOptionalParameterTypes = s.opt;
      tOptionalParameterTypes = t.opt;
      sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
      tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
      sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
      tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
      if (sParametersLen > tParametersLen)
        return false;
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      if (sParametersLen === tParametersLen) {
        if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
          return false;
        if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
          return false;
      } else {
        for (pos = 0; pos < sParametersLen; ++pos) {
          t1 = sParameterTypes[pos];
          t2 = tParameterTypes[pos];
          if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
            return false;
        }
        for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
          t1 = sOptionalParameterTypes[sPos];
          t2 = tParameterTypes[tPos];
          if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
            return false;
        }
        for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
          t1 = sOptionalParameterTypes[sPos];
          t2 = tOptionalParameterTypes[tPos];
          if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
            return false;
        }
      }
      return H.areAssignableMaps(s.named, t.named);
    },
    toStringForNativeObject: function(obj) {
      var t1 = $.getTagFunction;
      return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
    },
    hashCodeForNativeObject: function(object) {
      return H.Primitives_objectHashCode(object);
    },
    defineProperty: function(obj, property, value) {
      Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor: function(obj) {
      var tag, record, interceptor, interceptorClass, mark, t1;
      tag = $.getTagFunction.call$1(obj);
      record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        tag = $.alternateTagFunction.call$2(obj, tag);
        if (tag != null) {
          record = $.dispatchRecordsForInstanceTags[tag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[tag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[tag];
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(new P.UnimplementedError(tag));
      if (init.leafTags[tag] === true) {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return H.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto: function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord: function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch: function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    },
    initNativeDispatchContinue: function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks: function() {
      var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
      hooks = C.JS_CONST_4IJ();
      hooks = H.applyHooksTransformer(C.JS_CONST_EKH, H.applyHooksTransformer(C.JS_CONST_EyN, H.applyHooksTransformer(C.JS_CONST_AgZ, H.applyHooksTransformer(C.JS_CONST_AgZ, H.applyHooksTransformer(C.JS_CONST_c0o, H.applyHooksTransformer(C.JS_CONST_LlX, H.applyHooksTransformer(C.JS_CONST_nuk(C.JS_CONST_TSE), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer: function(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    stringContainsUnchecked: function(receiver, other, startIndex) {
      var t1 = receiver.indexOf(other, startIndex);
      return t1 >= 0;
    },
    stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
      var nativeRegexp, t1;
      nativeRegexp = pattern.get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      t1 = receiver.replace(nativeRegexp, replacement.replace(/\$/g, "$$$$"));
      return t1;
    },
    ConstantMapView: {
      "^": "UnmodifiableMapView;_collection$_map,$ti",
      $asUnmodifiableMapView: Isolate.functionThatReturnsNull,
      $asMap: Isolate.functionThatReturnsNull,
      $isMap: 1
    },
    ConstantMap: {
      "^": "Object;",
      get$isEmpty: function(_) {
        return this.get$length(this) === 0;
      },
      toString$0: function(_) {
        return P.Maps_mapToString(this);
      },
      $indexSet: function(_, key, val) {
        return H.ConstantMap__throwUnmodifiable();
      },
      $isMap: 1,
      $asMap: null
    },
    ConstantStringMap: {
      "^": "ConstantMap;_length,_jsObject,_keys,$ti",
      get$length: function(_) {
        return this._length;
      },
      containsKey$1: function(_, key) {
        if (typeof key !== "string")
          return false;
        if ("__proto__" === key)
          return false;
        return this._jsObject.hasOwnProperty(key);
      },
      $index: function(_, key) {
        if (!this.containsKey$1(0, key))
          return;
        return this._fetch$1(key);
      },
      _fetch$1: function(key) {
        return this._jsObject[key];
      },
      forEach$1: function(_, f) {
        var keys, t1, i, key;
        keys = this._keys;
        for (t1 = keys.length, i = 0; i < t1; ++i) {
          key = keys[i];
          f.call$2(key, this._fetch$1(key));
        }
      },
      get$keys: function(_) {
        return new H._ConstantMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      }
    },
    _ConstantMapKeyIterable: {
      "^": "Iterable;_map,$ti",
      get$iterator: function(_) {
        var t1 = this._map._keys;
        return new J.ArrayIterator(t1, t1.length, 0, null);
      },
      get$length: function(_) {
        return this._map._keys.length;
      }
    },
    JSInvocationMirror: {
      "^": "Object;__js_helper$_memberName,_internalName,_kind,_arguments,_namedArgumentNames,_namedIndices",
      get$memberName: function() {
        var t1 = this.__js_helper$_memberName;
        return t1;
      },
      get$positionalArguments: function() {
        var t1, argumentCount, list, index;
        if (this._kind === 1)
          return C.List_empty;
        t1 = this._arguments;
        argumentCount = t1.length - this._namedArgumentNames.length;
        if (argumentCount === 0)
          return C.List_empty;
        list = [];
        for (index = 0; index < argumentCount; ++index) {
          if (index >= t1.length)
            return H.ioore(t1, index);
          list.push(t1[index]);
        }
        list.fixed$length = Array;
        list.immutable$list = Array;
        return list;
      },
      get$namedArguments: function() {
        var t1, namedArgumentCount, t2, namedArgumentsStartIndex, t3, map, i, t4, t5;
        if (this._kind !== 0)
          return C.Map_empty0;
        t1 = this._namedArgumentNames;
        namedArgumentCount = t1.length;
        t2 = this._arguments;
        namedArgumentsStartIndex = t2.length - namedArgumentCount;
        if (namedArgumentCount === 0)
          return C.Map_empty0;
        t3 = P.Symbol0;
        map = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, null]);
        for (i = 0; i < namedArgumentCount; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t4 = t1[i];
          t5 = namedArgumentsStartIndex + i;
          if (t5 < 0 || t5 >= t2.length)
            return H.ioore(t2, t5);
          map.$indexSet(0, new H.Symbol(t4), t2[t5]);
        }
        return new H.ConstantMapView(map, [t3, null]);
      }
    },
    ReflectionInfo: {
      "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
      defaultValue$1: function(_, parameter) {
        var t1 = this.requiredParameterCount;
        if (typeof parameter !== "number")
          return parameter.$lt();
        if (parameter < t1)
          return;
        return this.data[3 + parameter - t1];
      },
      static: {
        ReflectionInfo_ReflectionInfo: function(jsFunction) {
          var data, requiredParametersInfo, optionalParametersInfo;
          data = jsFunction.$reflectionInfo;
          if (data == null)
            return;
          data.fixed$length = Array;
          data = data;
          requiredParametersInfo = data[0];
          optionalParametersInfo = data[1];
          return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
        }
      }
    },
    Primitives_initTicker_closure: {
      "^": "Closure:1;performance",
      call$0: function() {
        return C.JSNumber_methods.floor$0(1000 * this.performance.now());
      }
    },
    Primitives_functionNoSuchMethod_closure: {
      "^": "Closure:16;_box_0,$arguments,namedArgumentList",
      call$2: function($name, argument) {
        var t1 = this._box_0;
        t1.names = t1.names + "$" + H.S($name);
        this.namedArgumentList.push($name);
        this.$arguments.push(argument);
        ++t1.argumentCount;
      }
    },
    TypeErrorDecoder: {
      "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
      matchTypeError$1: function(message) {
        var match, result, t1;
        match = new RegExp(this._pattern).exec(message);
        if (match == null)
          return;
        result = Object.create(null);
        t1 = this._arguments;
        if (t1 !== -1)
          result.arguments = match[t1 + 1];
        t1 = this._argumentsExpr;
        if (t1 !== -1)
          result.argumentsExpr = match[t1 + 1];
        t1 = this._expr;
        if (t1 !== -1)
          result.expr = match[t1 + 1];
        t1 = this._method;
        if (t1 !== -1)
          result.method = match[t1 + 1];
        t1 = this._receiver;
        if (t1 !== -1)
          result.receiver = match[t1 + 1];
        return result;
      },
      static: {
        TypeErrorDecoder_extractPattern: function(message) {
          var match, $arguments, argumentsExpr, expr, method, receiver;
          message = message.replace(String({}), '$receiver$').replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
          match = message.match(/\\\$[a-zA-Z]+\\\$/g);
          if (match == null)
            match = [];
          $arguments = match.indexOf("\\$arguments\\$");
          argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
          expr = match.indexOf("\\$expr\\$");
          method = match.indexOf("\\$method\\$");
          receiver = match.indexOf("\\$receiver\\$");
          return new H.TypeErrorDecoder(message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
        },
        TypeErrorDecoder_provokeCallErrorOn: function(expression) {
          return function($expr$) {
            var $argumentsExpr$ = '$arguments$';
            try {
              $expr$.$method$($argumentsExpr$);
            } catch (e) {
              return e.message;
            }
          }(expression);
        },
        TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
          return function($expr$) {
            try {
              $expr$.$method$;
            } catch (e) {
              return e.message;
            }
          }(expression);
        }
      }
    },
    NullError: {
      "^": "Error;_message,_method",
      toString$0: function(_) {
        var t1 = this._method;
        if (t1 == null)
          return "NullError: " + H.S(this._message);
        return "NullError: method not found: '" + H.S(t1) + "' on null";
      }
    },
    JsNoSuchMethodError: {
      "^": "Error;_message,_method,_receiver",
      toString$0: function(_) {
        var t1, t2;
        t1 = this._method;
        if (t1 == null)
          return "NoSuchMethodError: " + H.S(this._message);
        t2 = this._receiver;
        if (t2 == null)
          return "NoSuchMethodError: method not found: '" + t1 + "' (" + H.S(this._message) + ")";
        return "NoSuchMethodError: method not found: '" + t1 + "' on '" + t2 + "' (" + H.S(this._message) + ")";
      },
      static: {
        JsNoSuchMethodError$: function(_message, match) {
          var t1, t2;
          t1 = match == null;
          t2 = t1 ? null : match.method;
          return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
        }
      }
    },
    UnknownJsTypeError: {
      "^": "Error;_message",
      toString$0: function(_) {
        var t1 = this._message;
        return t1.length === 0 ? "Error" : "Error: " + t1;
      }
    },
    ExceptionAndStackTrace: {
      "^": "Object;dartException,stackTrace<"
    },
    unwrapException_saveStackTrace: {
      "^": "Closure:0;ex",
      call$1: function(error) {
        if (!!J.getInterceptor(error).$isError)
          if (error.$thrownJsError == null)
            error.$thrownJsError = this.ex;
        return error;
      }
    },
    _StackTrace: {
      "^": "Object;_exception,_trace",
      toString$0: function(_) {
        var t1, trace;
        t1 = this._trace;
        if (t1 != null)
          return t1;
        t1 = this._exception;
        trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
        t1 = trace == null ? "" : trace;
        this._trace = t1;
        return t1;
      }
    },
    invokeClosure_closure: {
      "^": "Closure:1;closure",
      call$0: function() {
        return this.closure.call$0();
      }
    },
    invokeClosure_closure0: {
      "^": "Closure:1;closure,arg1",
      call$0: function() {
        return this.closure.call$1(this.arg1);
      }
    },
    invokeClosure_closure1: {
      "^": "Closure:1;closure,arg1,arg2",
      call$0: function() {
        return this.closure.call$2(this.arg1, this.arg2);
      }
    },
    invokeClosure_closure2: {
      "^": "Closure:1;closure,arg1,arg2,arg3",
      call$0: function() {
        return this.closure.call$3(this.arg1, this.arg2, this.arg3);
      }
    },
    invokeClosure_closure3: {
      "^": "Closure:1;closure,arg1,arg2,arg3,arg4",
      call$0: function() {
        return this.closure.call$4(this.arg1, this.arg2, this.arg3, this.arg4);
      }
    },
    Closure: {
      "^": "Object;",
      toString$0: function(_) {
        return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
      },
      get$$call: function() {
        return this;
      },
      $isFunction: 1,
      get$$call: function() {
        return this;
      }
    },
    TearOffClosure: {
      "^": "Closure;"
    },
    StaticClosure: {
      "^": "TearOffClosure;",
      toString$0: function(_) {
        var $name = this.$static_name;
        if ($name == null)
          return "Closure of unknown static method";
        return "Closure '" + $name + "'";
      }
    },
    BoundClosure: {
      "^": "TearOffClosure;_self,_target,_receiver,_name",
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof H.BoundClosure))
          return false;
        return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
      },
      get$hashCode: function(_) {
        var t1, receiverHashCode;
        t1 = this._receiver;
        if (t1 == null)
          receiverHashCode = H.Primitives_objectHashCode(this._self);
        else
          receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
        return J.$xor$n(receiverHashCode, H.Primitives_objectHashCode(this._target));
      },
      toString$0: function(_) {
        var receiver = this._receiver;
        if (receiver == null)
          receiver = this._self;
        return "Closure '" + H.S(this._name) + "' of " + H.Primitives_objectToHumanReadableString(receiver);
      },
      static: {
        BoundClosure_selfOf: function(closure) {
          return closure._self;
        },
        BoundClosure_receiverOf: function(closure) {
          return closure._receiver;
        },
        BoundClosure_selfFieldName: function() {
          var t1 = $.BoundClosure_selfFieldNameCache;
          if (t1 == null) {
            t1 = H.BoundClosure_computeFieldNamed("self");
            $.BoundClosure_selfFieldNameCache = t1;
          }
          return t1;
        },
        BoundClosure_computeFieldNamed: function(fieldName) {
          var template, t1, names, i, $name;
          template = new H.BoundClosure("self", "target", "receiver", "name");
          t1 = Object.getOwnPropertyNames(template);
          t1.fixed$length = Array;
          names = t1;
          for (t1 = names.length, i = 0; i < t1; ++i) {
            $name = names[i];
            if (template[$name] === fieldName)
              return $name;
          }
        }
      }
    },
    CastErrorImplementation: {
      "^": "Error;message",
      toString$0: function(_) {
        return this.message;
      },
      static: {
        CastErrorImplementation$: function(actualType, expectedType) {
          return new H.CastErrorImplementation("CastError: Casting value of type '" + actualType + "' to incompatible type '" + expectedType + "'");
        }
      }
    },
    RuntimeError: {
      "^": "Error;message",
      toString$0: function(_) {
        return "RuntimeError: " + H.S(this.message);
      }
    },
    TypeImpl: {
      "^": "Object;_typeName,_unmangledName",
      toString$0: function(_) {
        var t1, unmangledName;
        t1 = this._unmangledName;
        if (t1 != null)
          return t1;
        unmangledName = function(str, names) {
          return str.replace(/[^<,> ]+/g, function(m) {
            return names[m] || m;
          });
        }(this._typeName, init.mangledGlobalNames);
        this._unmangledName = unmangledName;
        return unmangledName;
      },
      get$hashCode: function(_) {
        return J.get$hashCode$(this._typeName);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.TypeImpl && J.$eq$(this._typeName, other._typeName);
      }
    },
    JsLinkedHashMap: {
      "^": "Object;_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      get$length: function(_) {
        return this._length;
      },
      get$isEmpty: function(_) {
        return this._length === 0;
      },
      get$keys: function(_) {
        return new H.LinkedHashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      },
      get$values: function(_) {
        return H.MappedIterable_MappedIterable(this.get$keys(this), new H.JsLinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      },
      containsKey$1: function(_, key) {
        var strings, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null)
            return false;
          return this._containsTableEntry$2(strings, key);
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null)
            return false;
          return this._containsTableEntry$2(nums, key);
        } else
          return this.internalContainsKey$1(key);
      },
      internalContainsKey$1: function(key) {
        var rest = this._rest;
        if (rest == null)
          return false;
        return this.internalFindBucketIndex$2(this._getTableBucket$2(rest, this.internalComputeHashCode$1(key)), key) >= 0;
      },
      $index: function(_, key) {
        var strings, cell, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null)
            return;
          cell = this._getTableCell$2(strings, key);
          return cell == null ? null : cell.get$hashMapCellValue();
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null)
            return;
          cell = this._getTableCell$2(nums, key);
          return cell == null ? null : cell.get$hashMapCellValue();
        } else
          return this.internalGet$1(key);
      },
      internalGet$1: function(key) {
        var rest, bucket, index;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getTableBucket$2(rest, this.internalComputeHashCode$1(key));
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        return bucket[index].get$hashMapCellValue();
      },
      $indexSet: function(_, key, value) {
        var strings, nums, rest, hash, bucket, index;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null) {
            strings = this._newHashTable$0();
            this._strings = strings;
          }
          this._addHashTableEntry$3(strings, key, value);
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null) {
            nums = this._newHashTable$0();
            this._nums = nums;
          }
          this._addHashTableEntry$3(nums, key, value);
        } else {
          rest = this._rest;
          if (rest == null) {
            rest = this._newHashTable$0();
            this._rest = rest;
          }
          hash = this.internalComputeHashCode$1(key);
          bucket = this._getTableBucket$2(rest, hash);
          if (bucket == null)
            this._setTableEntry$3(rest, hash, [this._newLinkedCell$2(key, value)]);
          else {
            index = this.internalFindBucketIndex$2(bucket, key);
            if (index >= 0)
              bucket[index].set$hashMapCellValue(value);
            else
              bucket.push(this._newLinkedCell$2(key, value));
          }
        }
      },
      putIfAbsent$2: function(_, key, ifAbsent) {
        var value;
        if (this.containsKey$1(0, key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      },
      remove$1: function(_, key) {
        if (typeof key === "string")
          return this._removeHashTableEntry$2(this._strings, key);
        else if (typeof key === "number" && (key & 0x3ffffff) === key)
          return this._removeHashTableEntry$2(this._nums, key);
        else
          return this.internalRemove$1(key);
      },
      internalRemove$1: function(key) {
        var rest, bucket, index, cell;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getTableBucket$2(rest, this.internalComputeHashCode$1(key));
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        cell = bucket.splice(index, 1)[0];
        this._unlinkCell$1(cell);
        return cell.get$hashMapCellValue();
      },
      clear$0: function(_) {
        if (this._length > 0) {
          this._last = null;
          this._first = null;
          this._rest = null;
          this._nums = null;
          this._strings = null;
          this._length = 0;
          this._modifications = this._modifications + 1 & 67108863;
        }
      },
      forEach$1: function(_, action) {
        var cell, modifications;
        cell = this._first;
        modifications = this._modifications;
        for (; cell != null;) {
          action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
          if (modifications !== this._modifications)
            throw H.wrapException(new P.ConcurrentModificationError(this));
          cell = cell._next;
        }
      },
      _addHashTableEntry$3: function(table, key, value) {
        var cell = this._getTableCell$2(table, key);
        if (cell == null)
          this._setTableEntry$3(table, key, this._newLinkedCell$2(key, value));
        else
          cell.set$hashMapCellValue(value);
      },
      _removeHashTableEntry$2: function(table, key) {
        var cell;
        if (table == null)
          return;
        cell = this._getTableCell$2(table, key);
        if (cell == null)
          return;
        this._unlinkCell$1(cell);
        this._deleteTableEntry$2(table, key);
        return cell.get$hashMapCellValue();
      },
      _newLinkedCell$2: function(key, value) {
        var cell, last;
        cell = new H.LinkedHashMapCell(key, value, null, null);
        if (this._first == null) {
          this._last = cell;
          this._first = cell;
        } else {
          last = this._last;
          cell._previous = last;
          last._next = cell;
          this._last = cell;
        }
        ++this._length;
        this._modifications = this._modifications + 1 & 67108863;
        return cell;
      },
      _unlinkCell$1: function(cell) {
        var previous, next;
        previous = cell.get$_previous();
        next = cell.get$_next();
        if (previous == null)
          this._first = next;
        else
          previous._next = next;
        if (next == null)
          this._last = previous;
        else
          next._previous = previous;
        --this._length;
        this._modifications = this._modifications + 1 & 67108863;
      },
      internalComputeHashCode$1: function(key) {
        return J.get$hashCode$(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i].get$hashMapCellKey(), key))
            return i;
        return -1;
      },
      toString$0: function(_) {
        return P.Maps_mapToString(this);
      },
      _getTableCell$2: function(table, key) {
        return table[key];
      },
      _getTableBucket$2: function(table, key) {
        return table[key];
      },
      _setTableEntry$3: function(table, key, value) {
        table[key] = value;
      },
      _deleteTableEntry$2: function(table, key) {
        delete table[key];
      },
      _containsTableEntry$2: function(table, key) {
        return this._getTableCell$2(table, key) != null;
      },
      _newHashTable$0: function() {
        var table = Object.create(null);
        this._setTableEntry$3(table, "<non-identifier-key>", table);
        this._deleteTableEntry$2(table, "<non-identifier-key>");
        return table;
      },
      $isInternalMap: 1,
      $isMap: 1,
      $asMap: null,
      static: {
        JsLinkedHashMap_JsLinkedHashMap$es6: function($K, $V) {
          return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
        }
      }
    },
    JsLinkedHashMap_values_closure: {
      "^": "Closure:0;$this",
      call$1: [function(each) {
        return this.$this.$index(0, each);
      }, null, null, 2, 0, null, 25, "call"]
    },
    LinkedHashMapCell: {
      "^": "Object;hashMapCellKey<,hashMapCellValue@,_next<,_previous<"
    },
    LinkedHashMapKeyIterable: {
      "^": "EfficientLengthIterable;_map,$ti",
      get$length: function(_) {
        return this._map._length;
      },
      get$isEmpty: function(_) {
        return this._map._length === 0;
      },
      get$iterator: function(_) {
        var t1, t2;
        t1 = this._map;
        t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
        t2._cell = t1._first;
        return t2;
      },
      forEach$1: function(_, f) {
        var t1, cell, modifications;
        t1 = this._map;
        cell = t1._first;
        modifications = t1._modifications;
        for (; cell != null;) {
          f.call$1(cell.hashMapCellKey);
          if (modifications !== t1._modifications)
            throw H.wrapException(new P.ConcurrentModificationError(t1));
          cell = cell._next;
        }
      }
    },
    LinkedHashMapKeyIterator: {
      "^": "Object;_map,_modifications,_cell,_current",
      get$current: function() {
        return this._current;
      },
      moveNext$0: function() {
        var t1 = this._map;
        if (this._modifications !== t1._modifications)
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        else {
          t1 = this._cell;
          if (t1 == null) {
            this._current = null;
            return false;
          } else {
            this._current = t1.hashMapCellKey;
            this._cell = t1._next;
            return true;
          }
        }
      }
    },
    initHooks_closure: {
      "^": "Closure:0;getTag",
      call$1: function(o) {
        return this.getTag(o);
      }
    },
    initHooks_closure0: {
      "^": "Closure:36;getUnknownTag",
      call$2: function(o, tag) {
        return this.getUnknownTag(o, tag);
      }
    },
    initHooks_closure1: {
      "^": "Closure:17;prototypeForTag",
      call$1: function(tag) {
        return this.prototypeForTag(tag);
      }
    },
    JSSyntaxRegExp: {
      "^": "Object;pattern,_nativeRegExp<,_nativeGlobalRegExp,_nativeAnchoredRegExp",
      toString$0: function(_) {
        return "RegExp/" + this.pattern + "/";
      },
      get$_nativeGlobalVersion: function() {
        var t1 = this._nativeGlobalRegExp;
        if (t1 != null)
          return t1;
        t1 = this._nativeRegExp;
        t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
        this._nativeGlobalRegExp = t1;
        return t1;
      },
      get$_nativeAnchoredVersion: function() {
        var t1 = this._nativeAnchoredRegExp;
        if (t1 != null)
          return t1;
        t1 = this._nativeRegExp;
        t1 = H.JSSyntaxRegExp_makeNative(this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
        this._nativeAnchoredRegExp = t1;
        return t1;
      },
      firstMatch$1: function(string) {
        var m = this._nativeRegExp.exec(H.checkString(string));
        if (m == null)
          return;
        return new H._MatchImplementation(this, m);
      },
      allMatches$2: function(_, string, start) {
        if (start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return new H._AllMatchesIterable(this, string, start);
      },
      allMatches$1: function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      },
      _execGlobal$2: function(string, start) {
        var regexp, match;
        regexp = this.get$_nativeGlobalVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        return new H._MatchImplementation(this, match);
      },
      _execAnchored$2: function(string, start) {
        var regexp, match;
        regexp = this.get$_nativeAnchoredVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        if (0 >= match.length)
          return H.ioore(match, -1);
        if (match.pop() != null)
          return;
        return new H._MatchImplementation(this, match);
      },
      matchAsPrefix$2: function(_, string, start) {
        if (typeof start !== "number")
          return start.$lt();
        if (start < 0 || start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return this._execAnchored$2(string, start);
      },
      $isRegExp: 1,
      static: {
        JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
          var m, i, g, regexp;
          m = multiLine ? "m" : "";
          i = caseSensitive ? "" : "i";
          g = global ? "g" : "";
          regexp = function(source, modifiers) {
            try {
              return new RegExp(source, modifiers);
            } catch (e) {
              return e;
            }
          }(source, m + i + g);
          if (regexp instanceof RegExp)
            return regexp;
          throw H.wrapException(new P.FormatException("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
        }
      }
    },
    _MatchImplementation: {
      "^": "Object;pattern,_match",
      get$start: function(_) {
        return this._match.index;
      },
      get$end: function(_) {
        var t1 = this._match;
        return t1.index + t1[0].length;
      },
      $index: function(_, index) {
        var t1 = this._match;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return t1[index];
      },
      $isMatch: 1
    },
    _AllMatchesIterable: {
      "^": "IterableBase;_re,_string,_start",
      get$iterator: function(_) {
        return new H._AllMatchesIterator(this._re, this._string, this._start, null);
      },
      $asIterableBase: function() {
        return [P.Match];
      },
      $asIterable: function() {
        return [P.Match];
      }
    },
    _AllMatchesIterator: {
      "^": "Object;_regExp,_string,_nextIndex,_current",
      get$current: function() {
        return this._current;
      },
      moveNext$0: function() {
        var t1, t2, match, nextIndex;
        t1 = this._string;
        if (t1 == null)
          return false;
        t2 = this._nextIndex;
        if (t2 <= t1.length) {
          match = this._regExp._execGlobal$2(t1, t2);
          if (match != null) {
            this._current = match;
            t1 = match._match;
            t2 = t1.index;
            nextIndex = t2 + t1[0].length;
            this._nextIndex = t2 === nextIndex ? nextIndex + 1 : nextIndex;
            return true;
          }
        }
        this._current = null;
        this._string = null;
        return false;
      }
    },
    StringMatch: {
      "^": "Object;start>,input,pattern",
      get$end: function(_) {
        var t1 = this.start;
        if (typeof t1 !== "number")
          return t1.$add();
        return t1 + this.pattern.length;
      },
      $index: function(_, g) {
        if (!J.$eq$(g, 0))
          H.throwExpression(P.RangeError$value(g, null, null));
        return this.pattern;
      },
      $isMatch: 1
    },
    _StringAllMatchesIterable: {
      "^": "Iterable;_input,_pattern,__js_helper$_index",
      get$iterator: function(_) {
        return new H._StringAllMatchesIterator(this._input, this._pattern, this.__js_helper$_index, null);
      },
      $asIterable: function() {
        return [P.Match];
      }
    },
    _StringAllMatchesIterator: {
      "^": "Object;_input,_pattern,__js_helper$_index,_current",
      moveNext$0: function() {
        var t1, t2, t3, t4, t5, index, end;
        t1 = this.__js_helper$_index;
        t2 = this._pattern;
        t3 = t2.length;
        t4 = this._input;
        t5 = t4.length;
        if (t1 + t3 > t5) {
          this._current = null;
          return false;
        }
        index = t4.indexOf(t2, t1);
        if (index < 0) {
          this.__js_helper$_index = t5 + 1;
          this._current = null;
          return false;
        }
        end = index + t3;
        this._current = new H.StringMatch(index, t4, t2);
        this.__js_helper$_index = end === this.__js_helper$_index ? end + 1 : end;
        return true;
      },
      get$current: function() {
        return this._current;
      }
    }
  }], ["dart._js_names", "dart:_js_names",, H, {
    "^": "",
    extractKeys: function(victim) {
      var t1 = H.setRuntimeTypeInfo(victim ? Object.keys(victim) : [], [null]);
      t1.fixed$length = Array;
      return t1;
    }
  }], ["dart2js._js_primitives", "dart:_js_primitives",, H, {
    "^": "",
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }
  }], ["dart.typed_data.implementation", "dart:_native_typed_data",, H, {
    "^": "",
    _checkLength: function($length) {
      return $length;
    },
    _checkViewArguments: function(buffer, offsetInBytes, $length) {
      if (typeof offsetInBytes !== "number" || Math.floor(offsetInBytes) !== offsetInBytes)
        throw H.wrapException(P.ArgumentError$("Invalid view offsetInBytes " + H.S(offsetInBytes)));
    },
    _ensureNativeList: function(list) {
      return list;
    },
    NativeFloat32List_NativeFloat32List$view: function(buffer, offsetInBytes, $length) {
      var t1;
      H._checkViewArguments(buffer, offsetInBytes, $length);
      t1 = new Float32Array(buffer, offsetInBytes, $length);
      return t1;
    },
    NativeInt16List_NativeInt16List$view: function(buffer, offsetInBytes, $length) {
      var t1;
      H._checkViewArguments(buffer, offsetInBytes, $length);
      t1 = new Int16Array(buffer, offsetInBytes, $length);
      return t1;
    },
    NativeInt32List_NativeInt32List: function($length) {
      return new Int32Array(H._checkLength($length));
    },
    NativeInt8List_NativeInt8List$fromList: function(elements) {
      return new Int8Array(H._ensureNativeList(elements));
    },
    NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Uint8Array(buffer, offsetInBytes) : new Uint8Array(buffer, offsetInBytes, $length);
    },
    _checkValidRange: function(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        if (!(end >>> 0 !== end)) {
          if (typeof start !== "number")
            return start.$gt();
          t1 = start > end || end > $length;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      return end;
    },
    NativeByteBuffer: {
      "^": "Interceptor;",
      asUint8List$2: function(receiver, offsetInBytes, $length) {
        return H.NativeUint8List_NativeUint8List$view(receiver, offsetInBytes, $length);
      },
      asUint8List$0: function($receiver) {
        return this.asUint8List$2($receiver, 0, null);
      },
      $isNativeByteBuffer: 1,
      $isByteBuffer: 1,
      $isObject: 1,
      "%": "ArrayBuffer"
    },
    NativeTypedData: {
      "^": "Interceptor;",
      _invalidPosition$3: function(receiver, position, $length, $name) {
        if (typeof position !== "number" || Math.floor(position) !== position)
          throw H.wrapException(P.ArgumentError$value(position, $name, "Invalid list position"));
        else
          throw H.wrapException(P.RangeError$range(position, 0, $length, $name, null));
      },
      _checkPosition$3: function(receiver, position, $length, $name) {
        if (position >>> 0 !== position || position > $length)
          this._invalidPosition$3(receiver, position, $length, $name);
      },
      $isNativeTypedData: 1,
      $isTypedData: 1,
      $isObject: 1,
      "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt"
    },
    NativeByteData: {
      "^": "NativeTypedData;",
      $isTypedData: 1,
      $isObject: 1,
      "%": "DataView"
    },
    NativeTypedArray: {
      "^": "NativeTypedData;",
      get$length: function(receiver) {
        return receiver.length;
      },
      _setRangeFast$4: function(receiver, start, end, source, skipCount) {
        var targetLength, count, sourceLength;
        targetLength = receiver.length;
        this._checkPosition$3(receiver, start, targetLength, "start");
        this._checkPosition$3(receiver, end, targetLength, "end");
        if (J.$gt$n(start, end))
          throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
        if (typeof start !== "number")
          return H.iae(start);
        count = end - start;
        if (J.$lt$n(skipCount, 0))
          throw H.wrapException(P.ArgumentError$(skipCount));
        sourceLength = source.length;
        if (typeof skipCount !== "number")
          return H.iae(skipCount);
        if (sourceLength - skipCount < count)
          throw H.wrapException(new P.StateError("Not enough elements"));
        if (skipCount !== 0 || sourceLength !== count)
          source = source.subarray(skipCount, skipCount + count);
        receiver.set(source, start);
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull
    },
    NativeTypedArrayOfDouble: {
      "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      },
      setRange$4: function(receiver, start, end, iterable, skipCount) {
        if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfDouble) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }
    },
    NativeTypedArray_ListMixin: {
      "^": "NativeTypedArray+ListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.double];
      },
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    NativeTypedArray_ListMixin_FixedLengthListMixin: {
      "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.double];
      },
      $asEfficientLengthIterable: function() {
        return [P.double];
      }
    },
    NativeTypedArrayOfInt: {
      "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
      $indexSet: function(receiver, index, value) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      },
      setRange$4: function(receiver, start, end, iterable, skipCount) {
        if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      }
    },
    NativeTypedArray_ListMixin0: {
      "^": "NativeTypedArray+ListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.int];
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    NativeTypedArray_ListMixin_FixedLengthListMixin0: {
      "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.int];
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      }
    },
    NativeFloat32List: {
      "^": "NativeTypedArrayOfDouble;",
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      "%": "Float32Array"
    },
    NativeFloat64List: {
      "^": "NativeTypedArrayOfDouble;",
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      "%": "Float64Array"
    },
    NativeInt16List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      "%": "Int16Array"
    },
    NativeInt32List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      "%": "Int32Array"
    },
    NativeInt8List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      "%": "Int8Array"
    },
    NativeUint16List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      "%": "Uint16Array"
    },
    NativeUint32List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      "%": "Uint32Array"
    },
    NativeUint8ClampedList: {
      "^": "NativeTypedArrayOfInt;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      "%": "CanvasPixelArray|Uint8ClampedArray"
    },
    NativeUint8List: {
      "^": "NativeTypedArrayOfInt;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Uint8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      $isNativeUint8List: 1,
      $isUint8List: 1,
      $isTypedData: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      "%": ";Uint8Array"
    }
  }], ["dart.async", "dart:async",, P, {
    "^": "",
    _AsyncRun__initializeScheduleImmediate: function() {
      var t1, div, span;
      t1 = {};
      if (self.scheduleImmediate != null)
        return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
    }, "call$1", "async__AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 8],
    _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(callback), 0));
    }, "call$1", "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", 2, 0, 8],
    _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
      P.Timer__createTimer(C.Duration_0, callback);
    }, "call$1", "async__AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 8],
    _asyncStart: function(bodyFunction, completer) {
      P._awaitOnObject(null, bodyFunction);
      return completer.get$future();
    },
    _asyncAwait: function(object, bodyFunction) {
      P._awaitOnObject(object, bodyFunction);
    },
    _asyncReturn: function(object, completer) {
      J.complete$1$x(completer, object);
    },
    _asyncRethrow: function(object, completer) {
      completer.completeError$2(H.unwrapException(object), H.getTraceFromException(object));
    },
    _awaitOnObject: function(object, bodyFunction) {
      var thenCallback, errorCallback, t1, future;
      thenCallback = new P._awaitOnObject_closure(bodyFunction);
      errorCallback = new P._awaitOnObject_closure0(bodyFunction);
      t1 = J.getInterceptor(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$2(thenCallback, errorCallback);
      else if (!!t1.$isFuture)
        object.then$2$onError(thenCallback, errorCallback);
      else {
        future = new P._Future(0, $.Zone__current, null, [null]);
        future._state = 4;
        future._resultOrListeners = object;
        future._thenNoZoneRegistration$2(thenCallback, null);
      }
    },
    _wrapJsFunctionForAsync: function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      $.Zone__current.toString;
      return new P._wrapJsFunctionForAsync_closure($protected);
    },
    _invokeErrorHandler: function(errorHandler, error, stackTrace) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Null, P.Null]}))
        return errorHandler.call$2(error, stackTrace);
      else
        return errorHandler.call$1(error);
    },
    _registerErrorHandler: function(errorHandler, zone) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Null, P.Null]})) {
        zone.toString;
        return errorHandler;
      } else {
        zone.toString;
        return errorHandler;
      }
    },
    Future_Future$error: function(error, stackTrace, $T) {
      var t1;
      if (error == null)
        error = new P.NullThrownError();
      t1 = $.Zone__current;
      if (t1 !== C.C__RootZone)
        t1.toString;
      t1 = new P._Future(0, t1, null, [$T]);
      t1._asyncCompleteError$2(error, stackTrace);
      return t1;
    },
    Future_wait: function(futures, cleanUp, eagerError) {
      var _box_0, result, handleError, future, pos, e, st, t1, values, exception;
      _box_0 = {};
      result = new P._Future(0, $.Zone__current, null, [P.List]);
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.error = null;
      _box_0.stackTrace = null;
      handleError = new P.Future_wait_handleError(_box_0, false, cleanUp, result);
      try {
        for (t1 = new H.ListIterator(futures, futures.get$length(futures), 0, null); t1.moveNext$0();) {
          future = t1.__internal$_current;
          pos = _box_0.remaining;
          future.then$2$onError(new P.Future_wait_closure(_box_0, false, cleanUp, result, pos), handleError);
          ++_box_0.remaining;
        }
        t1 = _box_0.remaining;
        if (t1 === 0) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(C.List_empty);
          return t1;
        }
        values = new Array(t1);
        values.fixed$length = Array;
        _box_0.values = values;
      } catch (exception) {
        e = H.unwrapException(exception);
        st = H.getTraceFromException(exception);
        if (_box_0.remaining === 0 || false)
          return P.Future_Future$error(e, st, null);
        else {
          _box_0.error = e;
          _box_0.stackTrace = st;
        }
      }
      return result;
    },
    Completer_Completer$sync: function($T) {
      return new P._SyncCompleter(new P._Future(0, $.Zone__current, null, [$T]), [$T]);
    },
    _microtaskLoop: function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = J.get$next$x(t1);
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.get$callback().call$0();
      }
    },
    _startMicrotaskLoop: [function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      }
    }, "call$0", "async___startMicrotaskLoop$closure", 0, 0, 2],
    _scheduleAsyncCallback: function(callback) {
      var newEntry = new P._AsyncCallbackEntry(callback, null);
      if ($._nextCallback == null) {
        $._lastCallback = newEntry;
        $._nextCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      } else {
        $._lastCallback.next = newEntry;
        $._lastCallback = newEntry;
      }
    },
    _schedulePriorityAsyncCallback: function(callback) {
      var t1, entry, t2;
      t1 = $._nextCallback;
      if (t1 == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new P._AsyncCallbackEntry(callback, null);
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t2.next;
        t2.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask: function(callback) {
      var currentZone = $.Zone__current;
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
        return;
      }
      currentZone.toString;
      P._rootScheduleMicrotask(null, null, currentZone, currentZone.bindCallback$2$runGuarded(callback, true));
    },
    StreamIterator_StreamIterator: function(stream, $T) {
      return new P._StreamIterator(null, stream, false, [$T]);
    },
    StreamController_StreamController$broadcast: function(onCancel, onListen, sync, $T) {
      return sync ? new P._SyncBroadcastStreamController(onListen, onCancel, 0, null, null, null, null, [$T]) : new P._AsyncBroadcastStreamController(onListen, onCancel, 0, null, null, null, null, [$T]);
    },
    _runGuarded: function(notificationHandler) {
      var e, s, exception, t1;
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = $.Zone__current;
        t1.toString;
        P._rootHandleUncaughtError(null, null, t1, e, s);
      }
    },
    _nullDataHandler: [function(value) {
    }, "call$1", "async___nullDataHandler$closure", 2, 0, 73],
    _nullErrorHandler: [function(error, stackTrace) {
      var t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(null, null, t1, error, stackTrace);
    }, function(error) {
      return P._nullErrorHandler(error, null);
    }, "call$2", "call$1", "async___nullErrorHandler$closure", 2, 2, 9, 1, 2, 6],
    _nullDoneHandler: [function() {
    }, "call$0", "async___nullDoneHandler$closure", 0, 0, 2],
    _runUserCode: function(userCode, onSuccess, onError) {
      var e, s, replacement, error, stackTrace, exception, error0;
      try {
        onSuccess.call$1(userCode.call$0());
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        $.Zone__current.toString;
        replacement = null;
        if (replacement == null)
          onError.call$2(e, s);
        else {
          error0 = J.get$error$x(replacement);
          error = error0;
          stackTrace = replacement.get$stackTrace();
          onError.call$2(error, stackTrace);
        }
      }
    },
    _cancelAndError: function(subscription, future, error, stackTrace) {
      var cancelFuture = subscription.cancel$0(0);
      if (!!J.getInterceptor(cancelFuture).$isFuture && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
      else
        future._completeError$2(error, stackTrace);
    },
    _cancelAndErrorClosure: function(subscription, future) {
      return new P._cancelAndErrorClosure_closure(subscription, future);
    },
    _cancelAndValue: function(subscription, future, value) {
      var cancelFuture = subscription.cancel$0(0);
      if (!!J.getInterceptor(cancelFuture).$isFuture && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
      else
        future._complete$1(value);
    },
    _addErrorWithReplacement: function(sink, error, stackTrace) {
      $.Zone__current.toString;
      sink._addError$2(error, stackTrace);
    },
    Timer_Timer: function(duration, callback) {
      var t1 = $.Zone__current;
      if (t1 === C.C__RootZone) {
        t1.toString;
        return P.Timer__createTimer(duration, callback);
      }
      return P.Timer__createTimer(duration, t1.bindCallback$2$runGuarded(callback, true));
    },
    Timer_Timer$periodic: function(duration, callback) {
      var t1, boundCallback;
      t1 = $.Zone__current;
      if (t1 === C.C__RootZone) {
        t1.toString;
        return P.Timer__createPeriodicTimer(duration, callback);
      }
      boundCallback = t1.bindUnaryCallback$2$runGuarded(callback, true);
      $.Zone__current.toString;
      return P.Timer__createPeriodicTimer(duration, boundCallback);
    },
    Timer__createTimer: function(duration, callback) {
      var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
      return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    Timer__createPeriodicTimer: function(duration, callback) {
      var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
      return H.TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, stackTrace));
    },
    _rootRun: function($self, $parent, zone, f) {
      var old, t1;
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary: function($self, $parent, zone, f, arg) {
      var old, t1;
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
      var old, t1;
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootScheduleMicrotask: function($self, $parent, zone, f) {
      var t1 = C.C__RootZone !== zone;
      if (t1)
        f = zone.bindCallback$2$runGuarded(f, !(!t1 || false));
      P._scheduleAsyncCallback(f);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: {
      "^": "Closure:0;_box_0",
      call$1: [function(_) {
        var t1, f;
        --init.globalState.topEventLoop._activeJsAsyncCount;
        t1 = this._box_0;
        f = t1.storedCallback;
        t1.storedCallback = null;
        f.call$0();
      }, null, null, 2, 0, null, 4, "call"]
    },
    _AsyncRun__initializeScheduleImmediate_closure: {
      "^": "Closure:52;_box_0,div,span",
      call$1: function(callback) {
        var t1, t2;
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._box_0.storedCallback = callback;
        t1 = this.div;
        t2 = this.span;
        t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
      }
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
      "^": "Closure:1;callback",
      call$0: [function() {
        --init.globalState.topEventLoop._activeJsAsyncCount;
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
      "^": "Closure:1;callback",
      call$0: [function() {
        --init.globalState.topEventLoop._activeJsAsyncCount;
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _awaitOnObject_closure: {
      "^": "Closure:0;bodyFunction",
      call$1: [function(result) {
        return this.bodyFunction.call$2(0, result);
      }, null, null, 2, 0, null, 7, "call"]
    },
    _awaitOnObject_closure0: {
      "^": "Closure:18;bodyFunction",
      call$2: [function(error, stackTrace) {
        this.bodyFunction.call$2(1, new H.ExceptionAndStackTrace(error, stackTrace));
      }, null, null, 4, 0, null, 2, 6, "call"]
    },
    _wrapJsFunctionForAsync_closure: {
      "^": "Closure:46;$protected",
      call$2: function(errorCode, result) {
        this.$protected(errorCode, result);
      }
    },
    _BroadcastStream: {
      "^": "_ControllerStream;_controller,$ti"
    },
    _BroadcastSubscription: {
      "^": "_ControllerSubscription;_eventState@,_async$_next@,_async$_previous@,_controller,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending,$ti",
      _expectsEvent$1: function(eventId) {
        return (this._eventState & 1) === eventId;
      },
      _toggleEventId$0: function() {
        this._eventState ^= 1;
      },
      get$_isFiring: function() {
        return (this._eventState & 2) !== 0;
      },
      _setRemoveAfterFiring$0: function() {
        this._eventState |= 4;
      },
      get$_removeAfterFiring: function() {
        return (this._eventState & 4) !== 0;
      },
      _onPause$0: [function() {
      }, "call$0", "get$_onPause", 0, 0, 2],
      _onResume$0: [function() {
      }, "call$0", "get$_onResume", 0, 0, 2]
    },
    _BroadcastStreamController: {
      "^": "Object;_state<,$ti",
      get$stream: function(_) {
        return new P._BroadcastStream(this, this.$ti);
      },
      get$isPaused: function() {
        return false;
      },
      get$_mayAddEvent: function() {
        return this._state < 4;
      },
      _addListener$1: function(subscription) {
        var oldLast;
        subscription.set$_eventState(this._state & 1);
        oldLast = this._lastSubscription;
        this._lastSubscription = subscription;
        subscription.set$_async$_next(null);
        subscription.set$_async$_previous(oldLast);
        if (oldLast == null)
          this._firstSubscription = subscription;
        else
          oldLast.set$_async$_next(subscription);
      },
      _removeListener$1: function(subscription) {
        var previous, next;
        previous = subscription.get$_async$_previous();
        next = subscription.get$_async$_next();
        if (previous == null)
          this._firstSubscription = next;
        else
          previous.set$_async$_next(next);
        if (next == null)
          this._lastSubscription = previous;
        else
          next.set$_async$_previous(previous);
        subscription.set$_async$_previous(subscription);
        subscription.set$_async$_next(subscription);
      },
      _async$_subscribe$4: function(onData, onError, onDone, cancelOnError) {
        var t1, t2, subscription;
        if ((this._state & 4) !== 0) {
          if (onDone == null)
            onDone = P.async___nullDoneHandler$closure();
          t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
          t1._schedule$0();
          return t1;
        }
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        subscription = new P._BroadcastSubscription(0, null, null, this, null, null, null, t1, t2, null, null, this.$ti);
        subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
        subscription._async$_previous = subscription;
        subscription._async$_next = subscription;
        this._addListener$1(subscription);
        t1 = this._firstSubscription;
        t2 = this._lastSubscription;
        if (t1 == null ? t2 == null : t1 === t2)
          P._runGuarded(this.onListen);
        return subscription;
      },
      _recordCancel$1: function(sub) {
        if (sub.get$_async$_next() === sub)
          return;
        if (sub.get$_isFiring())
          sub._setRemoveAfterFiring$0();
        else {
          this._removeListener$1(sub);
          if ((this._state & 2) === 0 && this._firstSubscription == null)
            this._callOnCancel$0();
        }
        return;
      },
      _recordPause$1: function(subscription) {
      },
      _recordResume$1: function(subscription) {
      },
      _addEventError$0: ["super$_BroadcastStreamController$_addEventError", function() {
        if ((this._state & 4) !== 0)
          return new P.StateError("Cannot add new events after calling close");
        return new P.StateError("Cannot add new events while doing an addStream");
      }],
      _forEachListener$1: function(action) {
        var t1, subscription, id, next;
        t1 = this._state;
        if ((t1 & 2) !== 0)
          throw H.wrapException(new P.StateError("Cannot fire new event. Controller is already firing an event"));
        subscription = this._firstSubscription;
        if (subscription == null)
          return;
        id = t1 & 1;
        this._state = t1 ^ 3;
        for (; subscription != null;)
          if (subscription._expectsEvent$1(id)) {
            subscription.set$_eventState(subscription.get$_eventState() | 2);
            action.call$1(subscription);
            subscription._toggleEventId$0();
            next = subscription.get$_async$_next();
            if (subscription.get$_removeAfterFiring())
              this._removeListener$1(subscription);
            subscription.set$_eventState(subscription.get$_eventState() & 4294967293);
            subscription = next;
          } else
            subscription = subscription.get$_async$_next();
        this._state &= 4294967293;
        if (this._firstSubscription == null)
          this._callOnCancel$0();
      },
      _callOnCancel$0: function() {
        if ((this._state & 4) !== 0 && this._doneFuture._state === 0)
          this._doneFuture._asyncComplete$1(null);
        P._runGuarded(this.onCancel);
      }
    },
    _SyncBroadcastStreamController: {
      "^": "_BroadcastStreamController;onListen,onCancel,_state,_firstSubscription,_lastSubscription,_addStreamState,_doneFuture,$ti",
      get$_mayAddEvent: function() {
        return P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) === true && (this._state & 2) === 0;
      },
      _addEventError$0: function() {
        if ((this._state & 2) !== 0)
          return new P.StateError("Cannot fire new event. Controller is already firing an event");
        return this.super$_BroadcastStreamController$_addEventError();
      },
      _sendData$1: function(data) {
        var t1 = this._firstSubscription;
        if (t1 == null)
          return;
        if (t1 === this._lastSubscription) {
          this._state |= 2;
          t1._async$_add$1(0, data);
          this._state &= 4294967293;
          if (this._firstSubscription == null)
            this._callOnCancel$0();
          return;
        }
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(this, data));
      }
    },
    _SyncBroadcastStreamController__sendData_closure: {
      "^": "Closure;$this,data",
      call$1: function(subscription) {
        subscription._async$_add$1(0, this.data);
      },
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [[P._BufferingStreamSubscription, T]]};
        }, this.$this, "_SyncBroadcastStreamController");
      }
    },
    _AsyncBroadcastStreamController: {
      "^": "_BroadcastStreamController;onListen,onCancel,_state,_firstSubscription,_lastSubscription,_addStreamState,_doneFuture,$ti",
      _sendData$1: function(data) {
        var subscription, t1;
        for (subscription = this._firstSubscription, t1 = this.$ti; subscription != null; subscription = subscription.get$_async$_next())
          subscription._addPending$1(new P._DelayedData(data, null, t1));
      }
    },
    Future: {
      "^": "Object;$ti"
    },
    Future_wait_handleError: {
      "^": "Closure:3;_box_0,eagerError,cleanUp,result",
      call$2: [function(theError, theStackTrace) {
        var t1, t2;
        t1 = this._box_0;
        t2 = --t1.remaining;
        if (t1.values != null) {
          t1.values = null;
          if (t1.remaining === 0 || this.eagerError)
            this.result._completeError$2(theError, theStackTrace);
          else {
            t1.error = theError;
            t1.stackTrace = theStackTrace;
          }
        } else if (t2 === 0 && !this.eagerError)
          this.result._completeError$2(t1.error, t1.stackTrace);
      }, null, null, 4, 0, null, 27, 21, "call"]
    },
    Future_wait_closure: {
      "^": "Closure;_box_0,eagerError,cleanUp,result,pos",
      call$1: [function(value) {
        var t1, t2, t3;
        t1 = this._box_0;
        t2 = --t1.remaining;
        t3 = t1.values;
        if (t3 != null) {
          t1 = this.pos;
          if (t1 < 0 || t1 >= t3.length)
            return H.ioore(t3, t1);
          t3[t1] = value;
          if (t2 === 0)
            this.result._completeWithValue$1(t3);
        } else if (t1.remaining === 0 && !this.eagerError)
          this.result._completeError$2(t1.error, t1.stackTrace);
      }, null, null, 2, 0, null, 3, "call"],
      $signature: function() {
        return {func: 1, args: [,]};
      }
    },
    _Completer: {
      "^": "Object;future<,$ti",
      completeError$2: [function(error, stackTrace) {
        if (error == null)
          error = new P.NullThrownError();
        if (this.future._state !== 0)
          throw H.wrapException(new P.StateError("Future already completed"));
        $.Zone__current.toString;
        this._completeError$2(error, stackTrace);
      }, function(error) {
        return this.completeError$2(error, null);
      }, "completeError$1", "call$2", "call$1", "get$completeError", 2, 2, 9, 1]
    },
    _AsyncCompleter: {
      "^": "_Completer;future,$ti",
      complete$1: [function(_, value) {
        var t1 = this.future;
        if (t1._state !== 0)
          throw H.wrapException(new P.StateError("Future already completed"));
        t1._asyncComplete$1(value);
      }, function($receiver) {
        return this.complete$1($receiver, null);
      }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 19, 1, 3],
      _completeError$2: function(error, stackTrace) {
        this.future._asyncCompleteError$2(error, stackTrace);
      }
    },
    _SyncCompleter: {
      "^": "_Completer;future,$ti",
      complete$1: [function(_, value) {
        var t1 = this.future;
        if (t1._state !== 0)
          throw H.wrapException(new P.StateError("Future already completed"));
        t1._complete$1(value);
      }, function($receiver) {
        return this.complete$1($receiver, null);
      }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 19, 1, 3],
      _completeError$2: function(error, stackTrace) {
        this.future._completeError$2(error, stackTrace);
      }
    },
    _FutureListener: {
      "^": "Object;_nextListener@,result>,state,callback<,errorCallback",
      get$_zone: function() {
        return this.result._zone;
      },
      get$handlesValue: function() {
        return (this.state & 1) !== 0;
      },
      get$handlesError: function() {
        return (this.state & 2) !== 0;
      },
      get$handlesComplete: function() {
        return this.state === 8;
      },
      get$hasErrorCallback: function() {
        return this.errorCallback != null;
      },
      handleValue$1: function(sourceResult) {
        return this.result._zone.runUnary$2(this.callback, sourceResult);
      },
      matchesErrorTest$1: function(asyncError) {
        if (this.state !== 6)
          return true;
        return this.result._zone.runUnary$2(this.callback, J.get$error$x(asyncError));
      },
      handleError$1: function(asyncError) {
        var t1, t2, t3;
        t1 = this.errorCallback;
        t2 = J.getInterceptor$x(asyncError);
        t3 = this.result._zone;
        if (H.functionTypeTest(t1, {func: 1, args: [,,]}))
          return t3.runBinary$3(t1, t2.get$error(asyncError), asyncError.get$stackTrace());
        else
          return t3.runUnary$2(t1, t2.get$error(asyncError));
      },
      handleWhenComplete$0: function() {
        return this.result._zone.run$1(this.callback);
      }
    },
    _Future: {
      "^": "Object;_state<,_zone<,_resultOrListeners<,$ti",
      get$_isChained: function() {
        return this._state === 2;
      },
      get$_isComplete: function() {
        return this._state >= 4;
      },
      get$_hasError: function() {
        return this._state === 8;
      },
      _setChained$1: function(source) {
        this._state = 2;
        this._resultOrListeners = source;
      },
      then$2$onError: function(f, onError) {
        var currentZone = $.Zone__current;
        if (currentZone !== C.C__RootZone) {
          currentZone.toString;
          if (onError != null)
            onError = P._registerErrorHandler(onError, currentZone);
        }
        return this._thenNoZoneRegistration$2(f, onError);
      },
      then$1: function(f) {
        return this.then$2$onError(f, null);
      },
      _thenNoZoneRegistration$2: function(f, onError) {
        var result = new P._Future(0, $.Zone__current, null, [null]);
        this._addListener$1(new P._FutureListener(null, result, onError == null ? 1 : 3, f, onError));
        return result;
      },
      catchError$2$test: function(onError, test) {
        var t1, result;
        t1 = $.Zone__current;
        result = new P._Future(0, t1, null, this.$ti);
        if (t1 !== C.C__RootZone)
          onError = P._registerErrorHandler(onError, t1);
        this._addListener$1(new P._FutureListener(null, result, 2, test, onError));
        return result;
      },
      catchError$1: function(onError) {
        return this.catchError$2$test(onError, null);
      },
      whenComplete$1: function(action) {
        var t1, result;
        t1 = $.Zone__current;
        result = new P._Future(0, t1, null, this.$ti);
        if (t1 !== C.C__RootZone)
          t1.toString;
        this._addListener$1(new P._FutureListener(null, result, 8, action, null));
        return result;
      },
      _setPendingComplete$0: function() {
        this._state = 1;
      },
      _clearPendingComplete$0: function() {
        this._state = 0;
      },
      get$_error: function() {
        return this._resultOrListeners;
      },
      get$_chainSource: function() {
        return this._resultOrListeners;
      },
      _setValue$1: function(value) {
        this._state = 4;
        this._resultOrListeners = value;
      },
      _setErrorObject$1: function(error) {
        this._state = 8;
        this._resultOrListeners = error;
      },
      _cloneResult$1: function(source) {
        this._state = source.get$_state();
        this._resultOrListeners = source.get$_resultOrListeners();
      },
      _addListener$1: function(listener) {
        var t1, source;
        t1 = this._state;
        if (t1 <= 1) {
          listener._nextListener = this._resultOrListeners;
          this._resultOrListeners = listener;
        } else {
          if (t1 === 2) {
            source = this._resultOrListeners;
            if (!source.get$_isComplete()) {
              source._addListener$1(listener);
              return;
            }
            this._state = source.get$_state();
            this._resultOrListeners = source.get$_resultOrListeners();
          }
          t1 = this._zone;
          t1.toString;
          P._rootScheduleMicrotask(null, null, t1, new P._Future__addListener_closure(this, listener));
        }
      },
      _prependListeners$1: function(listeners) {
        var _box_0, t1, existingListeners, cursor, source;
        _box_0 = {};
        _box_0.listeners = listeners;
        if (listeners == null)
          return;
        t1 = this._state;
        if (t1 <= 1) {
          existingListeners = this._resultOrListeners;
          this._resultOrListeners = listeners;
          if (existingListeners != null) {
            for (cursor = listeners; cursor.get$_nextListener() != null;)
              cursor = cursor.get$_nextListener();
            cursor.set$_nextListener(existingListeners);
          }
        } else {
          if (t1 === 2) {
            source = this._resultOrListeners;
            if (!source.get$_isComplete()) {
              source._prependListeners$1(listeners);
              return;
            }
            this._state = source.get$_state();
            this._resultOrListeners = source.get$_resultOrListeners();
          }
          _box_0.listeners = this._reverseListeners$1(listeners);
          t1 = this._zone;
          t1.toString;
          P._rootScheduleMicrotask(null, null, t1, new P._Future__prependListeners_closure(_box_0, this));
        }
      },
      _removeListeners$0: function() {
        var current = this._resultOrListeners;
        this._resultOrListeners = null;
        return this._reverseListeners$1(current);
      },
      _reverseListeners$1: function(listeners) {
        var current, prev, next;
        for (current = listeners, prev = null; current != null; prev = current, current = next) {
          next = current.get$_nextListener();
          current.set$_nextListener(prev);
        }
        return prev;
      },
      _complete$1: function(value) {
        var t1, listeners;
        t1 = this.$ti;
        if (H.checkSubtype(value, "$isFuture", t1, "$asFuture"))
          if (H.checkSubtype(value, "$is_Future", t1, null))
            P._Future__chainCoreFuture(value, this);
          else
            P._Future__chainForeignFuture(value, this);
        else {
          listeners = this._removeListeners$0();
          this._state = 4;
          this._resultOrListeners = value;
          P._Future__propagateToListeners(this, listeners);
        }
      },
      _completeWithValue$1: function(value) {
        var listeners = this._removeListeners$0();
        this._state = 4;
        this._resultOrListeners = value;
        P._Future__propagateToListeners(this, listeners);
      },
      _completeError$2: [function(error, stackTrace) {
        var listeners = this._removeListeners$0();
        this._state = 8;
        this._resultOrListeners = new P.AsyncError(error, stackTrace);
        P._Future__propagateToListeners(this, listeners);
      }, function(error) {
        return this._completeError$2(error, null);
      }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 9, 1, 2, 6],
      _asyncComplete$1: function(value) {
        var t1;
        if (H.checkSubtype(value, "$isFuture", this.$ti, "$asFuture")) {
          this._chainFuture$1(value);
          return;
        }
        this._state = 1;
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure(this, value));
      },
      _chainFuture$1: function(value) {
        var t1;
        if (H.checkSubtype(value, "$is_Future", this.$ti, null)) {
          if (value._state === 8) {
            this._state = 1;
            t1 = this._zone;
            t1.toString;
            P._rootScheduleMicrotask(null, null, t1, new P._Future__chainFuture_closure(this, value));
          } else
            P._Future__chainCoreFuture(value, this);
          return;
        }
        P._Future__chainForeignFuture(value, this);
      },
      _asyncCompleteError$2: function(error, stackTrace) {
        var t1;
        this._state = 1;
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncCompleteError_closure(this, error, stackTrace));
      },
      $isFuture: 1,
      static: {
        _Future$value: function(value, $T) {
          var t1 = new P._Future(0, $.Zone__current, null, [$T]);
          t1._state = 4;
          t1._resultOrListeners = value;
          return t1;
        },
        _Future__chainForeignFuture: function(source, target) {
          var e, s, exception;
          target._setPendingComplete$0();
          try {
            source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
          }
        },
        _Future__chainCoreFuture: function(source, target) {
          var listeners;
          for (; source.get$_isChained();)
            source = source.get$_chainSource();
          if (source.get$_isComplete()) {
            listeners = target._removeListeners$0();
            target._cloneResult$1(source);
            P._Future__propagateToListeners(target, listeners);
          } else {
            listeners = target.get$_resultOrListeners();
            target._setChained$1(source);
            source._prependListeners$1(listeners);
          }
        },
        _Future__propagateToListeners: function(source, listeners) {
          var _box_1, t1, _box_0, hasError, asyncError, t2, t3, listeners0, sourceResult, zone, oldZone, result;
          _box_1 = {};
          _box_1.source = source;
          for (t1 = source; true;) {
            _box_0 = {};
            hasError = t1.get$_hasError();
            if (listeners == null) {
              if (hasError) {
                asyncError = _box_1.source.get$_error();
                t1 = _box_1.source.get$_zone();
                t2 = J.get$error$x(asyncError);
                t3 = asyncError.get$stackTrace();
                t1.toString;
                P._rootHandleUncaughtError(null, null, t1, t2, t3);
              }
              return;
            }
            for (; listeners.get$_nextListener() != null; listeners = listeners0) {
              listeners0 = listeners.get$_nextListener();
              listeners.set$_nextListener(null);
              P._Future__propagateToListeners(_box_1.source, listeners);
            }
            sourceResult = _box_1.source.get$_resultOrListeners();
            _box_0.listenerHasError = hasError;
            _box_0.listenerValueOrError = sourceResult;
            t1 = !hasError;
            if (!t1 || listeners.get$handlesValue() || listeners.get$handlesComplete()) {
              zone = listeners.get$_zone();
              if (hasError) {
                t2 = _box_1.source.get$_zone();
                t2.toString;
                t2 = t2 == null ? zone == null : t2 === zone;
                if (!t2)
                  zone.toString;
                else
                  t2 = true;
                t2 = !t2;
              } else
                t2 = false;
              if (t2) {
                asyncError = _box_1.source.get$_error();
                t1 = _box_1.source.get$_zone();
                t2 = J.get$error$x(asyncError);
                t3 = asyncError.get$stackTrace();
                t1.toString;
                P._rootHandleUncaughtError(null, null, t1, t2, t3);
                return;
              }
              oldZone = $.Zone__current;
              if (oldZone == null ? zone != null : oldZone !== zone)
                $.Zone__current = zone;
              else
                oldZone = null;
              if (listeners.get$handlesComplete())
                new P._Future__propagateToListeners_handleWhenCompleteCallback(_box_1, _box_0, hasError, listeners).call$0();
              else if (t1) {
                if (listeners.get$handlesValue())
                  new P._Future__propagateToListeners_handleValueCallback(_box_0, listeners, sourceResult).call$0();
              } else if (listeners.get$handlesError())
                new P._Future__propagateToListeners_handleError(_box_1, _box_0, listeners).call$0();
              if (oldZone != null)
                $.Zone__current = oldZone;
              t1 = _box_0.listenerValueOrError;
              if (!!J.getInterceptor(t1).$isFuture) {
                result = J.get$result$x(listeners);
                if (t1._state >= 4) {
                  listeners = result._removeListeners$0();
                  result._cloneResult$1(t1);
                  _box_1.source = t1;
                  continue;
                } else
                  P._Future__chainCoreFuture(t1, result);
                return;
              }
            }
            result = J.get$result$x(listeners);
            listeners = result._removeListeners$0();
            t1 = _box_0.listenerHasError;
            t2 = _box_0.listenerValueOrError;
            if (!t1)
              result._setValue$1(t2);
            else
              result._setErrorObject$1(t2);
            _box_1.source = result;
            t1 = result;
          }
        }
      }
    },
    _Future__addListener_closure: {
      "^": "Closure:1;$this,listener",
      call$0: function() {
        P._Future__propagateToListeners(this.$this, this.listener);
      }
    },
    _Future__prependListeners_closure: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        P._Future__propagateToListeners(this.$this, this._box_0.listeners);
      }
    },
    _Future__chainForeignFuture_closure: {
      "^": "Closure:0;target",
      call$1: [function(value) {
        var t1 = this.target;
        t1._clearPendingComplete$0();
        t1._complete$1(value);
      }, null, null, 2, 0, null, 3, "call"]
    },
    _Future__chainForeignFuture_closure0: {
      "^": "Closure:49;target",
      call$2: [function(error, stackTrace) {
        this.target._completeError$2(error, stackTrace);
      }, function(error) {
        return this.call$2(error, null);
      }, "call$1", null, null, null, 2, 2, null, 1, 2, 6, "call"]
    },
    _Future__chainForeignFuture_closure1: {
      "^": "Closure:1;target,e,s",
      call$0: function() {
        this.target._completeError$2(this.e, this.s);
      }
    },
    _Future__asyncComplete_closure: {
      "^": "Closure:1;$this,typedValue",
      call$0: function() {
        this.$this._completeWithValue$1(this.typedValue);
      }
    },
    _Future__chainFuture_closure: {
      "^": "Closure:1;$this,value",
      call$0: function() {
        P._Future__chainCoreFuture(this.value, this.$this);
      }
    },
    _Future__asyncCompleteError_closure: {
      "^": "Closure:1;$this,error,stackTrace",
      call$0: function() {
        this.$this._completeError$2(this.error, this.stackTrace);
      }
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: {
      "^": "Closure:2;_box_1,_box_0,hasError,listener",
      call$0: function() {
        var completeResult, e, s, exception, t1, t2, originalSource;
        completeResult = null;
        try {
          completeResult = this.listener.handleWhenComplete$0();
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          if (this.hasError) {
            t1 = J.get$error$x(this._box_1.source.get$_error());
            t2 = e;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
          t2 = this._box_0;
          if (t1)
            t2.listenerValueOrError = this._box_1.source.get$_error();
          else
            t2.listenerValueOrError = new P.AsyncError(e, s);
          t2.listenerHasError = true;
          return;
        }
        if (!!J.getInterceptor(completeResult).$isFuture) {
          if (completeResult instanceof P._Future && completeResult.get$_state() >= 4) {
            if (completeResult.get$_state() === 8) {
              t1 = this._box_0;
              t1.listenerValueOrError = completeResult.get$_resultOrListeners();
              t1.listenerHasError = true;
            }
            return;
          }
          originalSource = this._box_1.source;
          t1 = this._box_0;
          t1.listenerValueOrError = completeResult.then$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource));
          t1.listenerHasError = false;
        }
      }
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
      "^": "Closure:0;originalSource",
      call$1: [function(_) {
        return this.originalSource;
      }, null, null, 2, 0, null, 4, "call"]
    },
    _Future__propagateToListeners_handleValueCallback: {
      "^": "Closure:2;_box_0,listener,sourceResult",
      call$0: function() {
        var e, s, exception, t1;
        try {
          this._box_0.listenerValueOrError = this.listener.handleValue$1(this.sourceResult);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = this._box_0;
          t1.listenerValueOrError = new P.AsyncError(e, s);
          t1.listenerHasError = true;
        }
      }
    },
    _Future__propagateToListeners_handleError: {
      "^": "Closure:2;_box_1,_box_0,listener",
      call$0: function() {
        var asyncError, e, s, t1, t2, exception, t3, t4;
        try {
          asyncError = this._box_1.source.get$_error();
          t1 = this.listener;
          if (t1.matchesErrorTest$1(asyncError) === true && t1.get$hasErrorCallback()) {
            t2 = this._box_0;
            t2.listenerValueOrError = t1.handleError$1(asyncError);
            t2.listenerHasError = false;
          }
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = this._box_1;
          t2 = J.get$error$x(t1.source.get$_error());
          t3 = e;
          t4 = this._box_0;
          if (t2 == null ? t3 == null : t2 === t3)
            t4.listenerValueOrError = t1.source.get$_error();
          else
            t4.listenerValueOrError = new P.AsyncError(e, s);
          t4.listenerHasError = true;
        }
      }
    },
    _AsyncCallbackEntry: {
      "^": "Object;callback<,next*"
    },
    Stream: {
      "^": "Object;$ti",
      map$1: function(_, convert) {
        return new P._MapStream(convert, this, [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
      },
      handleError$2$test: function(onError, test) {
        return new P._HandleErrorStream(onError, test, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      },
      handleError$1: function(onError) {
        return this.handleError$2$test(onError, null);
      },
      forEach$1: function(_, action) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [null]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
        return future;
      },
      get$length: function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.int]);
        t1.count = 0;
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
        return future;
      },
      get$isEmpty: function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
        return future;
      },
      toList$0: function(_) {
        var t1, result, future;
        t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
        result = H.setRuntimeTypeInfo([], [t1]);
        future = new P._Future(0, $.Zone__current, null, [[P.List, t1]]);
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(result, future), future.get$_completeError());
        return future;
      }
    },
    Stream_forEach_closure: {
      "^": "Closure;_box_0,$this,action,future",
      call$1: [function(element) {
        P._runUserCode(new P.Stream_forEach__closure(this.action, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this._box_0.subscription, this.future));
      }, null, null, 2, 0, null, 50, "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    Stream_forEach__closure: {
      "^": "Closure:1;action,element",
      call$0: function() {
        return this.action.call$1(this.element);
      }
    },
    Stream_forEach__closure0: {
      "^": "Closure:0;",
      call$1: function(_) {
      }
    },
    Stream_forEach_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        this.future._complete$1(null);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_length_closure: {
      "^": "Closure:0;_box_0",
      call$1: [function(_) {
        ++this._box_0.count;
      }, null, null, 2, 0, null, 4, "call"]
    },
    Stream_length_closure0: {
      "^": "Closure:1;_box_0,future",
      call$0: [function() {
        this.future._complete$1(this._box_0.count);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_isEmpty_closure: {
      "^": "Closure:0;_box_0,future",
      call$1: [function(_) {
        P._cancelAndValue(this._box_0.subscription, this.future, false);
      }, null, null, 2, 0, null, 4, "call"]
    },
    Stream_isEmpty_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        this.future._complete$1(true);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_toList_closure: {
      "^": "Closure;$this,result",
      call$1: [function(data) {
        this.result.push(data);
      }, null, null, 2, 0, null, 10, "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    Stream_toList_closure0: {
      "^": "Closure:1;result,future",
      call$0: [function() {
        this.future._complete$1(this.result);
      }, null, null, 0, 0, null, "call"]
    },
    StreamSubscription: {
      "^": "Object;$ti"
    },
    _StreamController: {
      "^": "Object;_state<,$ti",
      get$isPaused: function() {
        var t1 = this._state;
        return (t1 & 1) !== 0 ? this.get$_subscription().get$_isInputPaused() : (t1 & 2) === 0;
      },
      get$_pendingEvents: function() {
        if ((this._state & 8) === 0)
          return this._varData;
        return this._varData.get$varData();
      },
      _ensurePendingEvents$0: function() {
        var t1, state;
        if ((this._state & 8) === 0) {
          t1 = this._varData;
          if (t1 == null) {
            t1 = new P._StreamImplEvents(null, null, 0, this.$ti);
            this._varData = t1;
          }
          return t1;
        }
        state = this._varData;
        state.get$varData();
        return state.get$varData();
      },
      get$_subscription: function() {
        if ((this._state & 8) !== 0)
          return this._varData.get$varData();
        return this._varData;
      },
      _badEventState$0: function() {
        if ((this._state & 4) !== 0)
          return new P.StateError("Cannot add event after closing");
        return new P.StateError("Cannot add event while adding a stream");
      },
      _async$_add$1: function(_, value) {
        var t1 = this._state;
        if ((t1 & 1) !== 0)
          this._sendData$1(value);
        else if ((t1 & 3) === 0)
          this._ensurePendingEvents$0().add$1(0, new P._DelayedData(value, null, this.$ti));
      },
      _async$_subscribe$4: function(onData, onError, onDone, cancelOnError) {
        var t1, t2, subscription, pendingEvents, addState;
        if ((this._state & 3) !== 0)
          throw H.wrapException(new P.StateError("Stream has already been listened to."));
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        subscription = new P._ControllerSubscription(this, null, null, null, t1, t2, null, null, this.$ti);
        subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
        pendingEvents = this.get$_pendingEvents();
        t2 = this._state |= 1;
        if ((t2 & 8) !== 0) {
          addState = this._varData;
          addState.set$varData(subscription);
          addState.resume$0(0);
        } else
          this._varData = subscription;
        subscription._setPendingEvents$1(pendingEvents);
        subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
        return subscription;
      },
      _recordCancel$1: function(subscription) {
        var result, e, s, t1, exception, result0;
        result = null;
        if ((this._state & 8) !== 0)
          result = this._varData.cancel$0(0);
        this._varData = null;
        this._state = this._state & 4294967286 | 2;
        t1 = this.onCancel;
        if (t1 != null)
          if (result == null)
            try {
              result = t1.call$0();
            } catch (exception) {
              e = H.unwrapException(exception);
              s = H.getTraceFromException(exception);
              result0 = new P._Future(0, $.Zone__current, null, [null]);
              result0._asyncCompleteError$2(e, s);
              result = result0;
            }
          else
            result = result.whenComplete$1(t1);
        t1 = new P._StreamController__recordCancel_complete(this);
        if (result != null)
          result = result.whenComplete$1(t1);
        else
          t1.call$0();
        return result;
      },
      _recordPause$1: function(subscription) {
        if ((this._state & 8) !== 0)
          this._varData.pause$0(0);
        P._runGuarded(this.onPause);
      },
      _recordResume$1: function(subscription) {
        if ((this._state & 8) !== 0)
          this._varData.resume$0(0);
        P._runGuarded(this.onResume);
      }
    },
    _StreamController__subscribe_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        P._runGuarded(this.$this.onListen);
      }
    },
    _StreamController__recordCancel_complete: {
      "^": "Closure:2;$this",
      call$0: function() {
        var t1 = this.$this._doneFuture;
        if (t1 != null && t1._state === 0)
          t1._asyncComplete$1(null);
      }
    },
    _AsyncStreamControllerDispatch: {
      "^": "Object;$ti",
      _sendData$1: function(data) {
        this.get$_subscription()._addPending$1(new P._DelayedData(data, null, [H.getTypeArgumentByIndex(this, 0)]));
      }
    },
    _AsyncStreamController: {
      "^": "_StreamController+_AsyncStreamControllerDispatch;_varData,_state,_doneFuture,onListen,onPause,onResume,onCancel,$ti"
    },
    _ControllerStream: {
      "^": "_StreamImpl;_controller,$ti",
      get$hashCode: function(_) {
        return (H.Primitives_objectHashCode(this._controller) ^ 892482866) >>> 0;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof P._ControllerStream))
          return false;
        return other._controller === this._controller;
      }
    },
    _ControllerSubscription: {
      "^": "_BufferingStreamSubscription;_controller,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending,$ti",
      _onCancel$0: function() {
        return this._controller._recordCancel$1(this);
      },
      _onPause$0: [function() {
        this._controller._recordPause$1(this);
      }, "call$0", "get$_onPause", 0, 0, 2],
      _onResume$0: [function() {
        this._controller._recordResume$1(this);
      }, "call$0", "get$_onResume", 0, 0, 2]
    },
    _BufferingStreamSubscription: {
      "^": "Object;_zone<,_state<,$ti",
      _setPendingEvents$1: function(pendingEvents) {
        if (pendingEvents == null)
          return;
        this._pending = pendingEvents;
        if (!pendingEvents.get$isEmpty(pendingEvents)) {
          this._state = (this._state | 64) >>> 0;
          this._pending.schedule$1(this);
        }
      },
      pause$1: function(_, resumeSignal) {
        var t1 = this._state;
        if ((t1 & 8) !== 0)
          return;
        this._state = (t1 + 128 | 4) >>> 0;
        if (t1 < 128 && this._pending != null)
          this._pending.cancelSchedule$0();
        if ((t1 & 4) === 0 && (this._state & 32) === 0)
          this._guardCallback$1(this.get$_onPause());
      },
      pause$0: function($receiver) {
        return this.pause$1($receiver, null);
      },
      resume$0: function(_) {
        var t1 = this._state;
        if ((t1 & 8) !== 0)
          return;
        if (t1 >= 128) {
          t1 -= 128;
          this._state = t1;
          if (t1 < 128) {
            if ((t1 & 64) !== 0) {
              t1 = this._pending;
              t1 = !t1.get$isEmpty(t1);
            } else
              t1 = false;
            if (t1)
              this._pending.schedule$1(this);
            else {
              t1 = (this._state & 4294967291) >>> 0;
              this._state = t1;
              if ((t1 & 32) === 0)
                this._guardCallback$1(this.get$_onResume());
            }
          }
        }
      },
      cancel$0: function(_) {
        var t1 = (this._state & 4294967279) >>> 0;
        this._state = t1;
        if ((t1 & 8) === 0)
          this._cancel$0();
        t1 = this._cancelFuture;
        return t1 == null ? $.$get$Future__nullFuture() : t1;
      },
      get$_isInputPaused: function() {
        return (this._state & 4) !== 0;
      },
      get$isPaused: function() {
        return this._state >= 128;
      },
      _cancel$0: function() {
        var t1 = (this._state | 8) >>> 0;
        this._state = t1;
        if ((t1 & 64) !== 0)
          this._pending.cancelSchedule$0();
        if ((this._state & 32) === 0)
          this._pending = null;
        this._cancelFuture = this._onCancel$0();
      },
      _async$_add$1: ["super$_BufferingStreamSubscription$_add", function(_, data) {
        var t1 = this._state;
        if ((t1 & 8) !== 0)
          return;
        if (t1 < 32)
          this._sendData$1(data);
        else
          this._addPending$1(new P._DelayedData(data, null, [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]));
      }],
      _addError$2: ["super$_BufferingStreamSubscription$_addError", function(error, stackTrace) {
        var t1 = this._state;
        if ((t1 & 8) !== 0)
          return;
        if (t1 < 32)
          this._sendError$2(error, stackTrace);
        else
          this._addPending$1(new P._DelayedError(error, stackTrace, null));
      }],
      _async$_close$0: function() {
        var t1 = this._state;
        if ((t1 & 8) !== 0)
          return;
        t1 = (t1 | 2) >>> 0;
        this._state = t1;
        if (t1 < 32)
          this._sendDone$0();
        else
          this._addPending$1(C.C__DelayedDone);
      },
      _onPause$0: [function() {
      }, "call$0", "get$_onPause", 0, 0, 2],
      _onResume$0: [function() {
      }, "call$0", "get$_onResume", 0, 0, 2],
      _onCancel$0: function() {
        return;
      },
      _addPending$1: function($event) {
        var pending, t1;
        pending = this._pending;
        if (pending == null) {
          pending = new P._StreamImplEvents(null, null, 0, [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]);
          this._pending = pending;
        }
        pending.add$1(0, $event);
        t1 = this._state;
        if ((t1 & 64) === 0) {
          t1 = (t1 | 64) >>> 0;
          this._state = t1;
          if (t1 < 128)
            this._pending.schedule$1(this);
        }
      },
      _sendData$1: function(data) {
        var t1 = this._state;
        this._state = (t1 | 32) >>> 0;
        this._zone.runUnaryGuarded$2(this._onData, data);
        this._state = (this._state & 4294967263) >>> 0;
        this._checkState$1((t1 & 4) !== 0);
      },
      _sendError$2: function(error, stackTrace) {
        var t1, t2;
        t1 = this._state;
        t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
        if ((t1 & 1) !== 0) {
          this._state = (t1 | 16) >>> 0;
          this._cancel$0();
          t1 = this._cancelFuture;
          if (!!J.getInterceptor(t1).$isFuture && t1 !== $.$get$Future__nullFuture())
            t1.whenComplete$1(t2);
          else
            t2.call$0();
        } else {
          t2.call$0();
          this._checkState$1((t1 & 4) !== 0);
        }
      },
      _sendDone$0: function() {
        var t1, t2;
        t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
        this._cancel$0();
        this._state = (this._state | 16) >>> 0;
        t2 = this._cancelFuture;
        if (!!J.getInterceptor(t2).$isFuture && t2 !== $.$get$Future__nullFuture())
          t2.whenComplete$1(t1);
        else
          t1.call$0();
      },
      _guardCallback$1: function(callback) {
        var t1 = this._state;
        this._state = (t1 | 32) >>> 0;
        callback.call$0();
        this._state = (this._state & 4294967263) >>> 0;
        this._checkState$1((t1 & 4) !== 0);
      },
      _checkState$1: function(wasInputPaused) {
        var t1, isInputPaused;
        if ((this._state & 64) !== 0) {
          t1 = this._pending;
          t1 = t1.get$isEmpty(t1);
        } else
          t1 = false;
        if (t1) {
          t1 = (this._state & 4294967231) >>> 0;
          this._state = t1;
          if ((t1 & 4) !== 0)
            if (t1 < 128) {
              t1 = this._pending;
              t1 = t1 == null || t1.get$isEmpty(t1);
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            this._state = (this._state & 4294967291) >>> 0;
        }
        for (; true; wasInputPaused = isInputPaused) {
          t1 = this._state;
          if ((t1 & 8) !== 0) {
            this._pending = null;
            return;
          }
          isInputPaused = (t1 & 4) !== 0;
          if (wasInputPaused === isInputPaused)
            break;
          this._state = (t1 ^ 32) >>> 0;
          if (isInputPaused)
            this._onPause$0();
          else
            this._onResume$0();
          this._state = (this._state & 4294967263) >>> 0;
        }
        t1 = this._state;
        if ((t1 & 64) !== 0 && t1 < 128)
          this._pending.schedule$1(this);
      },
      _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
        var handleData, t1;
        handleData = onData == null ? P.async___nullDataHandler$closure() : onData;
        t1 = this._zone;
        t1.toString;
        this._onData = handleData;
        this._onError = P._registerErrorHandler(onError == null ? P.async___nullErrorHandler$closure() : onError, t1);
        this._onDone = onDone == null ? P.async___nullDoneHandler$closure() : onDone;
      }
    },
    _BufferingStreamSubscription__sendError_sendError: {
      "^": "Closure:2;$this,error,stackTrace",
      call$0: function() {
        var t1, t2, t3, t4, t5, t6;
        t1 = this.$this;
        t2 = t1._state;
        if ((t2 & 8) !== 0 && (t2 & 16) === 0)
          return;
        t1._state = (t2 | 32) >>> 0;
        t2 = t1._onError;
        t3 = H.functionTypeTest(t2, {func: 1, args: [P.Object, P.StackTrace]});
        t4 = t1._zone;
        t5 = this.error;
        t6 = t1._onError;
        if (t3)
          t4.runBinaryGuarded$3(t6, t5, this.stackTrace);
        else
          t4.runUnaryGuarded$2(t6, t5);
        t1._state = (t1._state & 4294967263) >>> 0;
      }
    },
    _BufferingStreamSubscription__sendDone_sendDone: {
      "^": "Closure:2;$this",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._state;
        if ((t2 & 16) === 0)
          return;
        t1._state = (t2 | 42) >>> 0;
        t1._zone.runGuarded$1(t1._onDone);
        t1._state = (t1._state & 4294967263) >>> 0;
      }
    },
    _StreamImpl: {
      "^": "Stream;$ti",
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        return this._controller._async$_subscribe$4(onData, onError, onDone, true === cancelOnError);
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }
    },
    _DelayedEvent: {
      "^": "Object;next*"
    },
    _DelayedData: {
      "^": "_DelayedEvent;value>,next,$ti",
      perform$1: function(dispatch) {
        dispatch._sendData$1(this.value);
      }
    },
    _DelayedError: {
      "^": "_DelayedEvent;error>,stackTrace<,next",
      perform$1: function(dispatch) {
        dispatch._sendError$2(this.error, this.stackTrace);
      }
    },
    _DelayedDone: {
      "^": "Object;",
      perform$1: function(dispatch) {
        dispatch._sendDone$0();
      },
      get$next: function(_) {
        return;
      },
      set$next: function(_, _0) {
        throw H.wrapException(new P.StateError("No events after a done."));
      }
    },
    _PendingEvents: {
      "^": "Object;_state<",
      schedule$1: function(dispatch) {
        var t1 = this._state;
        if (t1 === 1)
          return;
        if (t1 >= 1) {
          this._state = 1;
          return;
        }
        P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
        this._state = 1;
      },
      cancelSchedule$0: function() {
        if (this._state === 1)
          this._state = 3;
      }
    },
    _PendingEvents_schedule_closure: {
      "^": "Closure:1;$this,dispatch",
      call$0: function() {
        var t1, oldState, $event, t2;
        t1 = this.$this;
        oldState = t1._state;
        t1._state = 0;
        if (oldState === 3)
          return;
        $event = t1.firstPendingEvent;
        t2 = J.get$next$x($event);
        t1.firstPendingEvent = t2;
        if (t2 == null)
          t1.lastPendingEvent = null;
        $event.perform$1(this.dispatch);
      }
    },
    _StreamImplEvents: {
      "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state,$ti",
      get$isEmpty: function(_) {
        return this.lastPendingEvent == null;
      },
      add$1: function(_, $event) {
        var t1 = this.lastPendingEvent;
        if (t1 == null) {
          this.lastPendingEvent = $event;
          this.firstPendingEvent = $event;
        } else {
          t1.set$next(0, $event);
          this.lastPendingEvent = $event;
        }
      }
    },
    _DoneStreamSubscription: {
      "^": "Object;_zone<,_state<,_onDone,$ti",
      get$isPaused: function() {
        return this._state >= 4;
      },
      _schedule$0: function() {
        if ((this._state & 2) !== 0)
          return;
        var t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, this.get$_sendDone());
        this._state = (this._state | 2) >>> 0;
      },
      pause$1: function(_, resumeSignal) {
        this._state += 4;
      },
      pause$0: function($receiver) {
        return this.pause$1($receiver, null);
      },
      resume$0: function(_) {
        var t1 = this._state;
        if (t1 >= 4) {
          t1 -= 4;
          this._state = t1;
          if (t1 < 4 && (t1 & 1) === 0)
            this._schedule$0();
        }
      },
      cancel$0: function(_) {
        return $.$get$Future__nullFuture();
      },
      _sendDone$0: [function() {
        var t1 = (this._state & 4294967293) >>> 0;
        this._state = t1;
        if (t1 >= 4)
          return;
        this._state = (t1 | 1) >>> 0;
        t1 = this._onDone;
        if (t1 != null)
          this._zone.runGuarded$1(t1);
      }, "call$0", "get$_sendDone", 0, 0, 2]
    },
    _StreamIterator: {
      "^": "Object;_subscription,_stateData,_isPaused,$ti"
    },
    _cancelAndError_closure: {
      "^": "Closure:1;future,error,stackTrace",
      call$0: function() {
        return this.future._completeError$2(this.error, this.stackTrace);
      }
    },
    _cancelAndErrorClosure_closure: {
      "^": "Closure:18;subscription,future",
      call$2: function(error, stackTrace) {
        P._cancelAndError(this.subscription, this.future, error, stackTrace);
      }
    },
    _cancelAndValue_closure: {
      "^": "Closure:1;future,value",
      call$0: function() {
        return this.future._complete$1(this.value);
      }
    },
    _ForwardingStream: {
      "^": "Stream;$ti",
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      },
      _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
        return P._ForwardingStreamSubscription$(this, onData, onError, onDone, cancelOnError, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0), H.getRuntimeTypeArgument(this, "_ForwardingStream", 1));
      },
      _handleData$2: function(data, sink) {
        sink._async$_add$1(0, data);
      },
      _handleError$3: function(error, stackTrace, sink) {
        sink._addError$2(error, stackTrace);
      },
      $asStream: function($S, $T) {
        return [$T];
      }
    },
    _ForwardingStreamSubscription: {
      "^": "_BufferingStreamSubscription;_stream,_subscription,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending,$ti",
      _async$_add$1: function(_, data) {
        if ((this._state & 2) !== 0)
          return;
        this.super$_BufferingStreamSubscription$_add(0, data);
      },
      _addError$2: function(error, stackTrace) {
        if ((this._state & 2) !== 0)
          return;
        this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
      },
      _onPause$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.pause$0(0);
      }, "call$0", "get$_onPause", 0, 0, 2],
      _onResume$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.resume$0(0);
      }, "call$0", "get$_onResume", 0, 0, 2],
      _onCancel$0: function() {
        var t1 = this._subscription;
        if (t1 != null) {
          this._subscription = null;
          return t1.cancel$0(0);
        }
        return;
      },
      _handleData$1: [function(data) {
        this._stream._handleData$2(data, this);
      }, "call$1", "get$_handleData", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S]};
        }, this.$receiver, "_ForwardingStreamSubscription");
      }, 10],
      _handleError$2: [function(error, stackTrace) {
        this._stream._handleError$3(error, stackTrace, this);
      }, "call$2", "get$_handleError", 4, 0, 39, 2, 6],
      _handleDone$0: [function() {
        this._async$_close$0();
      }, "call$0", "get$_handleDone", 0, 0, 2],
      _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
        this._subscription = this._stream._async$_source.listen$3$onDone$onError(this.get$_handleData(), this.get$_handleDone(), this.get$_handleError());
      },
      $as_BufferingStreamSubscription: function($S, $T) {
        return [$T];
      },
      static: {
        _ForwardingStreamSubscription$: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError ? 1 : 0;
          t2 = new P._ForwardingStreamSubscription(_stream, null, null, null, null, t1, t2, null, null, [$S, $T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._ForwardingStreamSubscription$5(_stream, onData, onError, onDone, cancelOnError, $S, $T);
          return t2;
        }
      }
    },
    _MapStream: {
      "^": "_ForwardingStream;_transform,_async$_source,$ti",
      _handleData$2: function(inputEvent, sink) {
        var outputEvent, e, s, exception;
        outputEvent = null;
        try {
          outputEvent = this._transform.call$1(inputEvent);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          return;
        }
        sink._async$_add$1(0, outputEvent);
      }
    },
    _HandleErrorStream: {
      "^": "_ForwardingStream;_transform,_test,_async$_source,$ti",
      _handleError$3: function(error, stackTrace, sink) {
        var matches, e, s, exception, t1;
        matches = true;
        if (matches === true)
          try {
            P._invokeErrorHandler(this._transform, error, stackTrace);
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            t1 = e;
            if (t1 == null ? error == null : t1 === error)
              sink._addError$2(error, stackTrace);
            else
              P._addErrorWithReplacement(sink, e, s);
            return;
          }
        else
          sink._addError$2(error, stackTrace);
      },
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null
    },
    Timer: {
      "^": "Object;"
    },
    AsyncError: {
      "^": "Object;error>,stackTrace<",
      toString$0: function(_) {
        return H.S(this.error);
      },
      $isError: 1
    },
    _Zone: {
      "^": "Object;"
    },
    _rootHandleUncaughtError_closure: {
      "^": "Closure:1;_box_0,stackTrace",
      call$0: function() {
        var t1, t2, error;
        t1 = this._box_0;
        t2 = t1.error;
        if (t2 == null) {
          error = new P.NullThrownError();
          t1.error = error;
          t1 = error;
        } else
          t1 = t2;
        t2 = this.stackTrace;
        if (t2 == null)
          throw H.wrapException(t1);
        error = H.wrapException(t1);
        error.stack = J.toString$0$(t2);
        throw error;
      }
    },
    _RootZone: {
      "^": "_Zone;",
      get$parent: function(_) {
        return;
      },
      runGuarded$1: function(f) {
        var e, s, t1, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            t1 = f.call$0();
            return t1;
          }
          t1 = P._rootRun(null, null, this, f);
          return t1;
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = P._rootHandleUncaughtError(null, null, this, e, s);
          return t1;
        }
      },
      runUnaryGuarded$2: function(f, arg) {
        var e, s, t1, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            t1 = f.call$1(arg);
            return t1;
          }
          t1 = P._rootRunUnary(null, null, this, f, arg);
          return t1;
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = P._rootHandleUncaughtError(null, null, this, e, s);
          return t1;
        }
      },
      runBinaryGuarded$3: function(f, arg1, arg2) {
        var e, s, t1, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            t1 = f.call$2(arg1, arg2);
            return t1;
          }
          t1 = P._rootRunBinary(null, null, this, f, arg1, arg2);
          return t1;
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = P._rootHandleUncaughtError(null, null, this, e, s);
          return t1;
        }
      },
      bindCallback$2$runGuarded: function(f, runGuarded) {
        if (runGuarded)
          return new P._RootZone_bindCallback_closure(this, f);
        else
          return new P._RootZone_bindCallback_closure0(this, f);
      },
      bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
        return new P._RootZone_bindUnaryCallback_closure(this, f);
      },
      $index: function(_, key) {
        return;
      },
      run$1: function(f) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$0();
        return P._rootRun(null, null, this, f);
      },
      runUnary$2: function(f, arg) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$1(arg);
        return P._rootRunUnary(null, null, this, f, arg);
      },
      runBinary$3: function(f, arg1, arg2) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$2(arg1, arg2);
        return P._rootRunBinary(null, null, this, f, arg1, arg2);
      }
    },
    _RootZone_bindCallback_closure: {
      "^": "Closure:1;$this,f",
      call$0: function() {
        return this.$this.runGuarded$1(this.f);
      }
    },
    _RootZone_bindCallback_closure0: {
      "^": "Closure:1;$this,f",
      call$0: function() {
        return this.$this.run$1(this.f);
      }
    },
    _RootZone_bindUnaryCallback_closure: {
      "^": "Closure:0;$this,f",
      call$1: [function(arg) {
        return this.$this.runUnaryGuarded$2(this.f, arg);
      }, null, null, 2, 0, null, 23, "call"]
    }
  }], ["dart.collection", "dart:collection",, P, {
    "^": "",
    LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
      return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
    },
    LinkedHashMap__makeEmpty: function() {
      return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
    },
    LinkedHashMap__makeLiteral: function(keyValuePairs) {
      return H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]));
    },
    IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (P._isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = [];
      t1 = $.$get$_toStringVisiting();
      t1.push(iterable);
      try {
        P._iterablePartsToStrings(iterable, parts);
      } finally {
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      }
      t1 = P.StringBuffer__writeAll(leftDelimiter, parts, ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1, t2;
      if (P._isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new P.StringBuffer(leftDelimiter);
      t1 = $.$get$_toStringVisiting();
      t1.push(iterable);
      try {
        t2 = buffer;
        t2.set$_contents(P.StringBuffer__writeAll(t2.get$_contents(), iterable, ", "));
      } finally {
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      }
      t1 = buffer;
      t1.set$_contents(t1.get$_contents() + rightDelimiter);
      t1 = buffer.get$_contents();
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _isToStringVisiting: function(o) {
      var i, t1;
      for (i = 0; t1 = $.$get$_toStringVisiting(), i < t1.length; ++i)
        if (o === t1[i])
          return true;
      return false;
    },
    _iterablePartsToStrings: function(iterable, parts) {
      var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
      it = iterable.get$iterator(iterable);
      $length = 0;
      count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current());
        parts.push(next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        ultimateString = parts.pop();
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current();
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            parts.push(H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          if (0 >= parts.length)
            return H.ioore(parts, -1);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current();
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current();
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                if (0 >= parts.length)
                  return H.ioore(parts, -1);
                $length -= parts.pop().length + 2;
                --count;
              }
              parts.push("...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        parts.push(elision);
      parts.push(penultimateString);
      parts.push(ultimateString);
    },
    LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
      return new P._LinkedHashSet(0, null, null, null, null, null, 0, [$E]);
    },
    Maps_mapToString: function(m) {
      var t1, result, t2;
      t1 = {};
      if (P._isToStringVisiting(m))
        return "{...}";
      result = new P.StringBuffer("");
      try {
        $.$get$_toStringVisiting().push(m);
        t2 = result;
        t2.set$_contents(t2.get$_contents() + "{");
        t1.first = true;
        m.forEach$1(0, new P.Maps_mapToString_closure(t1, result));
        t1 = result;
        t1.set$_contents(t1.get$_contents() + "}");
      } finally {
        t1 = $.$get$_toStringVisiting();
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      }
      t1 = result.get$_contents();
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _LinkedIdentityHashMap: {
      "^": "JsLinkedHashMap;_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      internalComputeHashCode$1: function(key) {
        return H.objectHashCode(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].get$hashMapCellKey();
          if (t1 == null ? key == null : t1 === key)
            return i;
        }
        return -1;
      },
      static: {
        _LinkedIdentityHashMap__LinkedIdentityHashMap$es6: function($K, $V) {
          return new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0, [$K, $V]);
        }
      }
    },
    _LinkedHashSet: {
      "^": "_HashSetBase;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications,$ti",
      get$iterator: function(_) {
        var t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null);
        t1._collection$_cell = this._collection$_first;
        return t1;
      },
      get$length: function(_) {
        return this._collection$_length;
      },
      get$isEmpty: function(_) {
        return this._collection$_length === 0;
      },
      contains$1: function(_, object) {
        var strings, nums;
        if (typeof object === "string" && object !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null)
            return false;
          return strings[object] != null;
        } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
          nums = this._collection$_nums;
          if (nums == null)
            return false;
          return nums[object] != null;
        } else
          return this._contains$1(object);
      },
      _contains$1: function(object) {
        var rest = this._collection$_rest;
        if (rest == null)
          return false;
        return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
      },
      lookup$1: function(object) {
        var t1;
        if (!(typeof object === "string" && object !== "__proto__"))
          t1 = typeof object === "number" && (object & 0x3ffffff) === object;
        else
          t1 = true;
        if (t1)
          return this.contains$1(0, object) ? object : null;
        else
          return this._lookup$1(object);
      },
      _lookup$1: function(object) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return;
        bucket = rest[this._computeHashCode$1(object)];
        index = this._findBucketIndex$2(bucket, object);
        if (index < 0)
          return;
        return J.$index$asx(bucket, index).get$_element();
      },
      forEach$1: function(_, action) {
        var cell, modifications;
        cell = this._collection$_first;
        modifications = this._collection$_modifications;
        for (; cell != null;) {
          action.call$1(cell.get$_element());
          if (modifications !== this._collection$_modifications)
            throw H.wrapException(new P.ConcurrentModificationError(this));
          cell = cell.get$_collection$_next();
        }
      },
      add$1: function(_, element) {
        var strings, table, nums;
        if (typeof element === "string" && element !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null) {
            table = Object.create(null);
            table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_strings = table;
            strings = table;
          }
          return this._collection$_addHashTableEntry$2(strings, element);
        } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
          nums = this._collection$_nums;
          if (nums == null) {
            table = Object.create(null);
            table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_nums = table;
            nums = table;
          }
          return this._collection$_addHashTableEntry$2(nums, element);
        } else
          return this._add$1(0, element);
      },
      _add$1: function(_, element) {
        var rest, hash, bucket;
        rest = this._collection$_rest;
        if (rest == null) {
          rest = P._LinkedHashSet__newHashTable();
          this._collection$_rest = rest;
        }
        hash = this._computeHashCode$1(element);
        bucket = rest[hash];
        if (bucket == null)
          rest[hash] = [this._collection$_newLinkedCell$1(element)];
        else {
          if (this._findBucketIndex$2(bucket, element) >= 0)
            return false;
          bucket.push(this._collection$_newLinkedCell$1(element));
        }
        return true;
      },
      remove$1: function(_, object) {
        if (typeof object === "string" && object !== "__proto__")
          return this._collection$_removeHashTableEntry$2(this._collection$_strings, object);
        else if (typeof object === "number" && (object & 0x3ffffff) === object)
          return this._collection$_removeHashTableEntry$2(this._collection$_nums, object);
        else
          return this._remove$1(0, object);
      },
      _remove$1: function(_, object) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return false;
        bucket = rest[this._computeHashCode$1(object)];
        index = this._findBucketIndex$2(bucket, object);
        if (index < 0)
          return false;
        this._collection$_unlinkCell$1(bucket.splice(index, 1)[0]);
        return true;
      },
      clear$0: function(_) {
        if (this._collection$_length > 0) {
          this._collection$_last = null;
          this._collection$_first = null;
          this._collection$_rest = null;
          this._collection$_nums = null;
          this._collection$_strings = null;
          this._collection$_length = 0;
          this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
        }
      },
      _collection$_addHashTableEntry$2: function(table, element) {
        if (table[element] != null)
          return false;
        table[element] = this._collection$_newLinkedCell$1(element);
        return true;
      },
      _collection$_removeHashTableEntry$2: function(table, element) {
        var cell;
        if (table == null)
          return false;
        cell = table[element];
        if (cell == null)
          return false;
        this._collection$_unlinkCell$1(cell);
        delete table[element];
        return true;
      },
      _collection$_newLinkedCell$1: function(element) {
        var cell, last;
        cell = new P._LinkedHashSetCell(element, null, null);
        if (this._collection$_first == null) {
          this._collection$_last = cell;
          this._collection$_first = cell;
        } else {
          last = this._collection$_last;
          cell._collection$_previous = last;
          last._collection$_next = cell;
          this._collection$_last = cell;
        }
        ++this._collection$_length;
        this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
        return cell;
      },
      _collection$_unlinkCell$1: function(cell) {
        var previous, next;
        previous = cell.get$_collection$_previous();
        next = cell.get$_collection$_next();
        if (previous == null)
          this._collection$_first = next;
        else
          previous._collection$_next = next;
        if (next == null)
          this._collection$_last = previous;
        else
          next.set$_collection$_previous(previous);
        --this._collection$_length;
        this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
      },
      _computeHashCode$1: function(element) {
        return J.get$hashCode$(element) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i].get$_element(), element))
            return i;
        return -1;
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      static: {
        _LinkedHashSet__newHashTable: function() {
          var table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          return table;
        }
      }
    },
    _LinkedHashSetCell: {
      "^": "Object;_element<,_collection$_next<,_collection$_previous@"
    },
    _LinkedHashSetIterator: {
      "^": "Object;_set,_collection$_modifications,_collection$_cell,_collection$_current",
      get$current: function() {
        return this._collection$_current;
      },
      moveNext$0: function() {
        var t1 = this._set;
        if (this._collection$_modifications !== t1._collection$_modifications)
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        else {
          t1 = this._collection$_cell;
          if (t1 == null) {
            this._collection$_current = null;
            return false;
          } else {
            this._collection$_current = t1.get$_element();
            this._collection$_cell = this._collection$_cell.get$_collection$_next();
            return true;
          }
        }
      }
    },
    _HashSetBase: {
      "^": "SetBase;$ti"
    },
    IterableBase: {
      "^": "Iterable;$ti"
    },
    ListBase: {
      "^": "Object_ListMixin;$ti"
    },
    Object_ListMixin: {
      "^": "Object+ListMixin;",
      $asList: null,
      $asEfficientLengthIterable: null,
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    ListMixin: {
      "^": "Object;$ti",
      get$iterator: function(receiver) {
        return new H.ListIterator(receiver, this.get$length(receiver), 0, null);
      },
      elementAt$1: function(receiver, index) {
        return this.$index(receiver, index);
      },
      forEach$1: function(receiver, action) {
        var $length, i;
        $length = this.get$length(receiver);
        for (i = 0; i < $length; ++i) {
          action.call$1(this.$index(receiver, i));
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
      },
      get$isEmpty: function(receiver) {
        return this.get$length(receiver) === 0;
      },
      map$1: function(receiver, f) {
        return new H.MappedListIterable(receiver, f, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0), null]);
      },
      skip$1: function(receiver, count) {
        return H.SubListIterable$(receiver, count, null, H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
      },
      toList$1$growable: function(receiver, growable) {
        var result, i, t1;
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(receiver));
        for (i = 0; i < this.get$length(receiver); ++i) {
          t1 = this.$index(receiver, i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t1;
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      fillRange$3: function(receiver, start, end, fill) {
        var i;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        for (i = start; i < end; ++i)
          this.$indexSet(receiver, i, fill);
      },
      setRange$4: ["super$ListMixin$setRange", function(receiver, start, end, iterable, skipCount) {
        var $length, otherStart, otherList, t1, t2, i;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length === 0)
          return;
        if (J.$lt$n(skipCount, 0))
          H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
        if (H.checkSubtype(iterable, "$isList", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asList")) {
          otherStart = skipCount;
          otherList = iterable;
        } else {
          otherList = J.skip$1$ax(iterable, skipCount).toList$1$growable(0, false);
          otherStart = 0;
        }
        t1 = J.getInterceptor$ns(otherStart);
        t2 = J.getInterceptor$asx(otherList);
        if (t1.$add(otherStart, $length) > t2.get$length(otherList))
          throw H.wrapException(H.IterableElementError_tooFew());
        if (t1.$lt(otherStart, start))
          for (i = $length - 1; i >= 0; --i)
            this.$indexSet(receiver, start + i, t2.$index(otherList, t1.$add(otherStart, i)));
        else
          for (i = 0; i < $length; ++i)
            this.$indexSet(receiver, start + i, t2.$index(otherList, t1.$add(otherStart, i)));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 6, 2, null, 24],
      replaceRange$3: function(receiver, start, end, newContents) {
        var removeLength, insertLength, t1, delta, insertEnd, newLength;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        newContents = C.JSString_methods.toList$0(newContents);
        removeLength = J.$sub$n(end, start);
        insertLength = newContents.length;
        t1 = J.getInterceptor$ns(start);
        if (removeLength >= insertLength) {
          delta = removeLength - insertLength;
          insertEnd = t1.$add(start, insertLength);
          newLength = this.get$length(receiver) - delta;
          this.setRange$3(receiver, start, insertEnd, newContents);
          if (delta !== 0) {
            this.setRange$4(receiver, insertEnd, newLength, receiver, end);
            this.set$length(receiver, newLength);
          }
        } else {
          newLength = this.get$length(receiver) + (insertLength - removeLength);
          insertEnd = t1.$add(start, insertLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, newContents);
        }
      },
      indexOf$2: function(receiver, element, startIndex) {
        var i;
        if (startIndex >= this.get$length(receiver))
          return -1;
        if (startIndex < 0)
          startIndex = 0;
        for (i = startIndex; i < this.get$length(receiver); ++i)
          if (J.$eq$(this.$index(receiver, i), element))
            return i;
        return -1;
      },
      indexOf$1: function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      },
      setAll$2: function(receiver, index, iterable) {
        this.setRange$3(receiver, index, index + iterable.length, iterable);
      },
      toString$0: function(receiver) {
        return P.IterableBase_iterableToFullString(receiver, "[", "]");
      },
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null
    },
    _UnmodifiableMapMixin: {
      "^": "Object;",
      $indexSet: function(_, key, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable map"));
      },
      $isMap: 1,
      $asMap: null
    },
    MapView: {
      "^": "Object;",
      $index: function(_, key) {
        return J.$index$asx(this._collection$_map, key);
      },
      $indexSet: function(_, key, value) {
        J.$indexSet$ax(this._collection$_map, key, value);
      },
      containsKey$1: function(_, key) {
        return J.containsKey$1$x(this._collection$_map, key);
      },
      forEach$1: function(_, action) {
        J.forEach$1$ax(this._collection$_map, action);
      },
      get$isEmpty: function(_) {
        return J.get$isEmpty$asx(this._collection$_map);
      },
      get$length: function(_) {
        return J.get$length$asx(this._collection$_map);
      },
      get$keys: function(_) {
        return J.get$keys$x(this._collection$_map);
      },
      toString$0: function(_) {
        return J.toString$0$(this._collection$_map);
      },
      $isMap: 1,
      $asMap: null
    },
    UnmodifiableMapView: {
      "^": "MapView+_UnmodifiableMapMixin;_collection$_map,$ti",
      $asMap: null,
      $isMap: 1
    },
    Maps_mapToString_closure: {
      "^": "Closure:3;_box_0,result",
      call$2: function(k, v) {
        var t1, t2;
        t1 = this._box_0;
        if (!t1.first)
          this.result._contents += ", ";
        t1.first = false;
        t1 = this.result;
        t2 = t1._contents += H.S(k);
        t1._contents = t2 + ": ";
        t1._contents += H.S(v);
      }
    },
    ListQueue: {
      "^": "ListIterable;_table,_head,_tail,_modificationCount,$ti",
      get$iterator: function(_) {
        return new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null);
      },
      forEach$1: function(_, action) {
        var modificationCount, i, t1;
        modificationCount = this._modificationCount;
        for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
          t1 = this._table;
          if (i < 0 || i >= t1.length)
            return H.ioore(t1, i);
          action.call$1(t1[i]);
          if (modificationCount !== this._modificationCount)
            H.throwExpression(new P.ConcurrentModificationError(this));
        }
      },
      get$isEmpty: function(_) {
        return this._head === this._tail;
      },
      get$length: function(_) {
        return (this._tail - this._head & this._table.length - 1) >>> 0;
      },
      elementAt$1: function(_, index) {
        var $length, t1, t2, t3;
        $length = (this._tail - this._head & this._table.length - 1) >>> 0;
        if (0 > index || index >= $length)
          H.throwExpression(P.IndexError$(index, this, "index", null, $length));
        t1 = this._table;
        t2 = t1.length;
        t3 = (this._head + index & t2 - 1) >>> 0;
        if (t3 < 0 || t3 >= t2)
          return H.ioore(t1, t3);
        return t1[t3];
      },
      toList$1$growable: function(_, growable) {
        var list = H.setRuntimeTypeInfo([], this.$ti);
        C.JSArray_methods.set$length(list, this.get$length(this));
        this._writeToList$1(list);
        return list;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      clear$0: function(_) {
        var i, t1, t2, t3, t4;
        i = this._head;
        t1 = this._tail;
        if (i !== t1) {
          for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
            if (i < 0 || i >= t3)
              return H.ioore(t2, i);
            t2[i] = null;
          }
          this._tail = 0;
          this._head = 0;
          ++this._modificationCount;
        }
      },
      toString$0: function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      },
      removeFirst$0: function() {
        var t1, t2, t3, result;
        t1 = this._head;
        if (t1 === this._tail)
          throw H.wrapException(H.IterableElementError_noElement());
        ++this._modificationCount;
        t2 = this._table;
        t3 = t2.length;
        if (t1 >= t3)
          return H.ioore(t2, t1);
        result = t2[t1];
        t2[t1] = null;
        this._head = (t1 + 1 & t3 - 1) >>> 0;
        return result;
      },
      _add$1: function(_, element) {
        var t1, t2, t3;
        t1 = this._table;
        t2 = this._tail;
        t3 = t1.length;
        if (t2 < 0 || t2 >= t3)
          return H.ioore(t1, t2);
        t1[t2] = element;
        t3 = (t2 + 1 & t3 - 1) >>> 0;
        this._tail = t3;
        if (this._head === t3)
          this._grow$0();
        ++this._modificationCount;
      },
      _grow$0: function() {
        var t1, newTable, t2, split;
        t1 = new Array(this._table.length * 2);
        t1.fixed$length = Array;
        newTable = H.setRuntimeTypeInfo(t1, this.$ti);
        t1 = this._table;
        t2 = this._head;
        split = t1.length - t2;
        C.JSArray_methods.setRange$4(newTable, 0, split, t1, t2);
        C.JSArray_methods.setRange$4(newTable, split, split + this._head, this._table, 0);
        this._head = 0;
        this._tail = this._table.length;
        this._table = newTable;
      },
      _writeToList$1: function(target) {
        var t1, t2, t3, $length, firstPartSize;
        t1 = this._head;
        t2 = this._tail;
        t3 = this._table;
        if (t1 <= t2) {
          $length = t2 - t1;
          C.JSArray_methods.setRange$4(target, 0, $length, t3, t1);
          return $length;
        } else {
          firstPartSize = t3.length - t1;
          C.JSArray_methods.setRange$4(target, 0, firstPartSize, t3, t1);
          C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + this._tail, this._table, 0);
          return this._tail + firstPartSize;
        }
      },
      ListQueue$1: function(initialCapacity, $E) {
        var t1 = new Array(8);
        t1.fixed$length = Array;
        this._table = H.setRuntimeTypeInfo(t1, [$E]);
      },
      $asEfficientLengthIterable: null,
      static: {
        ListQueue$: function(initialCapacity, $E) {
          var t1 = new P.ListQueue(null, 0, 0, 0, [$E]);
          t1.ListQueue$1(initialCapacity, $E);
          return t1;
        }
      }
    },
    _ListQueueIterator: {
      "^": "Object;_queue,_end,_modificationCount,_collection$_position,_collection$_current",
      get$current: function() {
        return this._collection$_current;
      },
      moveNext$0: function() {
        var t1, t2, t3;
        t1 = this._queue;
        if (this._modificationCount !== t1._modificationCount)
          H.throwExpression(new P.ConcurrentModificationError(t1));
        t2 = this._collection$_position;
        if (t2 === this._end) {
          this._collection$_current = null;
          return false;
        }
        t1 = t1._table;
        t3 = t1.length;
        if (t2 >= t3)
          return H.ioore(t1, t2);
        this._collection$_current = t1[t2];
        this._collection$_position = (t2 + 1 & t3 - 1) >>> 0;
        return true;
      }
    },
    SetMixin: {
      "^": "Object;$ti",
      get$isEmpty: function(_) {
        return this._collection$_length === 0;
      },
      toList$1$growable: function(_, growable) {
        var result, t1, i, element, i0;
        result = H.setRuntimeTypeInfo([], this.$ti);
        C.JSArray_methods.set$length(result, this._collection$_length);
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null), t1._collection$_cell = this._collection$_first, i = 0; t1.moveNext$0(); i = i0) {
          element = t1._collection$_current;
          i0 = i + 1;
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = element;
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      map$1: function(_, f) {
        return new H.EfficientLengthMappedIterable(this, f, [H.getTypeArgumentByIndex(this, 0), null]);
      },
      toString$0: function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      },
      forEach$1: function(_, f) {
        var t1;
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null), t1._collection$_cell = this._collection$_first; t1.moveNext$0();)
          f.call$1(t1._collection$_current);
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null
    },
    SetBase: {
      "^": "SetMixin;$ti"
    }
  }], ["dart.convert", "dart:convert",, P, {
    "^": "",
    _convertJsonToDartLazy: function(object) {
      var i;
      if (object == null)
        return;
      if (typeof object != "object")
        return object;
      if (Object.getPrototypeOf(object) !== Array.prototype)
        return new P._JsonMap(object, Object.create(null), null);
      for (i = 0; i < object.length; ++i)
        object[i] = P._convertJsonToDartLazy(object[i]);
      return object;
    },
    _parseJson: function(source, reviver) {
      var parsed, e, exception, t1;
      if (typeof source !== "string")
        throw H.wrapException(H.argumentErrorValue(source));
      parsed = null;
      try {
        parsed = JSON.parse(source);
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = String(e);
        throw H.wrapException(new P.FormatException(t1, null, null));
      }
      t1 = P._convertJsonToDartLazy(parsed);
      return t1;
    },
    _JsonMap: {
      "^": "Object;_original,_processed,_convert$_data",
      $index: function(_, key) {
        var t1, result;
        t1 = this._processed;
        if (t1 == null)
          return this._convert$_data.$index(0, key);
        else if (typeof key !== "string")
          return;
        else {
          result = t1[key];
          return typeof result == "undefined" ? this._process$1(key) : result;
        }
      },
      get$length: function(_) {
        var t1;
        if (this._processed == null) {
          t1 = this._convert$_data;
          t1 = t1.get$length(t1);
        } else
          t1 = this._computeKeys$0().length;
        return t1;
      },
      get$isEmpty: function(_) {
        var t1;
        if (this._processed == null) {
          t1 = this._convert$_data;
          t1 = t1.get$length(t1);
        } else
          t1 = this._computeKeys$0().length;
        return t1 === 0;
      },
      get$keys: function(_) {
        var t1;
        if (this._processed == null) {
          t1 = this._convert$_data;
          return t1.get$keys(t1);
        }
        return new P._JsonMapKeyIterable(this);
      },
      $indexSet: function(_, key, value) {
        var processed, original;
        if (this._processed == null)
          this._convert$_data.$indexSet(0, key, value);
        else if (this.containsKey$1(0, key)) {
          processed = this._processed;
          processed[key] = value;
          original = this._original;
          if (original == null ? processed != null : original !== processed)
            original[key] = null;
        } else
          this._upgrade$0().$indexSet(0, key, value);
      },
      containsKey$1: function(_, key) {
        if (this._processed == null)
          return this._convert$_data.containsKey$1(0, key);
        if (typeof key !== "string")
          return false;
        return Object.prototype.hasOwnProperty.call(this._original, key);
      },
      forEach$1: function(_, f) {
        var keys, i, key, value;
        if (this._processed == null)
          return this._convert$_data.forEach$1(0, f);
        keys = this._computeKeys$0();
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          value = this._processed[key];
          if (typeof value == "undefined") {
            value = P._convertJsonToDartLazy(this._original[key]);
            this._processed[key] = value;
          }
          f.call$2(key, value);
          if (keys !== this._convert$_data)
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
      },
      toString$0: function(_) {
        return P.Maps_mapToString(this);
      },
      _computeKeys$0: function() {
        var keys = this._convert$_data;
        if (keys == null) {
          keys = Object.keys(this._original);
          this._convert$_data = keys;
        }
        return keys;
      },
      _upgrade$0: function() {
        var result, keys, i, t1, key;
        if (this._processed == null)
          return this._convert$_data;
        result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
        keys = this._computeKeys$0();
        for (i = 0; t1 = keys.length, i < t1; ++i) {
          key = keys[i];
          result.$indexSet(0, key, this.$index(0, key));
        }
        if (t1 === 0)
          keys.push(null);
        else
          C.JSArray_methods.set$length(keys, 0);
        this._processed = null;
        this._original = null;
        this._convert$_data = result;
        return result;
      },
      _process$1: function(key) {
        var result;
        if (!Object.prototype.hasOwnProperty.call(this._original, key))
          return;
        result = P._convertJsonToDartLazy(this._original[key]);
        return this._processed[key] = result;
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      }
    },
    _JsonMapKeyIterable: {
      "^": "ListIterable;_convert$_parent",
      get$length: function(_) {
        var t1 = this._convert$_parent;
        if (t1._processed == null) {
          t1 = t1._convert$_data;
          t1 = t1.get$length(t1);
        } else
          t1 = t1._computeKeys$0().length;
        return t1;
      },
      elementAt$1: function(_, index) {
        var t1 = this._convert$_parent;
        if (t1._processed == null)
          t1 = t1.get$keys(t1).elementAt$1(0, index);
        else {
          t1 = t1._computeKeys$0();
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          t1 = t1[index];
        }
        return t1;
      },
      get$iterator: function(_) {
        var t1 = this._convert$_parent;
        if (t1._processed == null) {
          t1 = t1.get$keys(t1);
          t1 = t1.get$iterator(t1);
        } else {
          t1 = t1._computeKeys$0();
          t1 = new J.ArrayIterator(t1, t1.length, 0, null);
        }
        return t1;
      },
      $asListIterable: function() {
        return [P.String];
      },
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $asIterable: function() {
        return [P.String];
      }
    },
    Base64Codec: {
      "^": "Codec;_encoder",
      normalize$3: function(_, source, start, end) {
        var t1, inverseAlphabet, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, digit1, digit2, char0, value, t2, t3, endLength, $length;
        t1 = J.getInterceptor$asx(source);
        end = P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
        if (typeof end !== "number")
          return H.iae(end);
        i = start;
        sliceStart = i;
        buffer = null;
        firstPadding = -1;
        firstPaddingSourceIndex = -1;
        paddingCount = 0;
        for (; i < end; i = i0) {
          i0 = i + 1;
          char = t1.codeUnitAt$1(source, i);
          if (char === 37) {
            i1 = i0 + 2;
            if (i1 <= end) {
              digit1 = H.hexDigitValue(t1.codeUnitAt$1(source, i0));
              digit2 = H.hexDigitValue(t1.codeUnitAt$1(source, i0 + 1));
              char0 = digit1 * 16 + digit2 - (digit2 & 256);
              if (char0 === 37)
                char0 = -1;
              i0 = i1;
            } else
              char0 = -1;
          } else
            char0 = char;
          if (0 <= char0 && char0 <= 127) {
            if (char0 < 0 || char0 >= inverseAlphabet.length)
              return H.ioore(inverseAlphabet, char0);
            value = inverseAlphabet[char0];
            if (value >= 0) {
              char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
              if (char0 === char)
                continue;
              char = char0;
            } else {
              if (value === -1) {
                if (firstPadding < 0) {
                  t2 = buffer == null ? buffer : buffer._contents.length;
                  if (t2 == null)
                    t2 = 0;
                  firstPadding = J.$add$ns(t2, i - sliceStart);
                  firstPaddingSourceIndex = i;
                }
                ++paddingCount;
                if (char === 61)
                  continue;
              }
              char = char0;
            }
            if (value !== -2) {
              if (buffer == null)
                buffer = new P.StringBuffer("");
              buffer._contents += t1.substring$2(source, sliceStart, i);
              buffer._contents += H.Primitives_stringFromCharCode(char);
              sliceStart = i0;
              continue;
            }
          }
          throw H.wrapException(new P.FormatException("Invalid base64 data", source, i));
        }
        if (buffer != null) {
          t2 = buffer._contents += t1.substring$2(source, sliceStart, end);
          t3 = t2.length;
          if (firstPadding >= 0)
            P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, t3);
          else {
            endLength = C.JSInt_methods.$mod(t3 - 1, 4) + 1;
            if (endLength === 1)
              throw H.wrapException(new P.FormatException("Invalid base64 encoding length ", source, end));
            for (; endLength < 4;) {
              t2 += "=";
              buffer._contents = t2;
              ++endLength;
            }
          }
          t2 = buffer._contents;
          return t1.replaceRange$3(source, start, end, t2.charCodeAt(0) == 0 ? t2 : t2);
        }
        $length = end - start;
        if (firstPadding >= 0)
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
        else {
          endLength = C.JSNumber_methods.$mod($length, 4);
          if (endLength === 1)
            throw H.wrapException(new P.FormatException("Invalid base64 encoding length ", source, end));
          if (endLength > 1)
            source = t1.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
        }
        return source;
      },
      static: {
        Base64Codec__checkPadding: function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
          if (C.JSNumber_methods.$mod($length, 4) !== 0)
            throw H.wrapException(new P.FormatException("Invalid base64 padding, padded length must be multiple of four, is " + H.S($length), source, sourceEnd));
          if (firstPadding + paddingCount !== $length)
            throw H.wrapException(new P.FormatException("Invalid base64 padding, '=' not at the end", source, sourceIndex));
          if (paddingCount > 2)
            throw H.wrapException(new P.FormatException("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
        }
      }
    },
    Base64Encoder: {
      "^": "Converter;_urlSafe"
    },
    Codec: {
      "^": "Object;"
    },
    Converter: {
      "^": "Object;"
    },
    Encoding: {
      "^": "Codec;"
    },
    JsonCodec: {
      "^": "Codec;_reviver,_toEncodable",
      decode$2$reviver: function(source, reviver) {
        var t1 = P._parseJson(source, this.get$decoder()._reviver);
        return t1;
      },
      decode$1: function(source) {
        return this.decode$2$reviver(source, null);
      },
      get$decoder: function() {
        return C.JsonDecoder_null;
      }
    },
    JsonDecoder: {
      "^": "Converter;_reviver"
    },
    Utf8Codec: {
      "^": "Encoding;_allowMalformed",
      get$name: function(_) {
        return "utf-8";
      }
    },
    Utf8Decoder: {
      "^": "Converter;_allowMalformed",
      convert$3: function(codeUnits, start, end) {
        var $length, buffer, decoder, t1;
        $length = J.get$length$asx(codeUnits);
        P.RangeError_checkValidRange(start, end, $length, null, null, null);
        buffer = new P.StringBuffer("");
        decoder = new P._Utf8Decoder(false, buffer, true, 0, 0, 0);
        decoder.convert$3(codeUnits, start, $length);
        decoder.flush$2(0, codeUnits, $length);
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      convert$1: function(codeUnits) {
        return this.convert$3(codeUnits, 0, null);
      }
    },
    _Utf8Decoder: {
      "^": "Object;_allowMalformed,_stringSink,_isFirstCharacter,_convert$_value,_expectedUnits,_extraUnits",
      flush$2: function(_, source, offset) {
        if (this._expectedUnits > 0)
          throw H.wrapException(new P.FormatException("Unfinished UTF-8 octet sequence", source, offset));
      },
      flush$0: function($receiver) {
        return this.flush$2($receiver, null, null);
      },
      convert$3: function(codeUnits, startIndex, endIndex) {
        var value, expectedUnits, extraUnits, scanOneByteCharacters, addSingleBytes, t1, t2, i, unit, t3, oneBytes, i0, i1, t4;
        value = this._convert$_value;
        expectedUnits = this._expectedUnits;
        extraUnits = this._extraUnits;
        this._convert$_value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
        scanOneByteCharacters = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
        addSingleBytes = new P._Utf8Decoder_convert_addSingleBytes(this, codeUnits, startIndex, endIndex);
        $loop$0:
          for (t1 = J.getInterceptor$asx(codeUnits), t2 = this._stringSink, i = startIndex; true; i = i1) {
            $multibyte$2:
              if (expectedUnits > 0) {
                do {
                  if (i === endIndex)
                    break $loop$0;
                  unit = t1.$index(codeUnits, i);
                  t3 = J.getInterceptor$n(unit);
                  if (t3.$and(unit, 192) !== 128) {
                    t3 = new P.FormatException("Bad UTF-8 encoding 0x" + t3.toRadixString$1(unit, 16), codeUnits, i);
                    throw H.wrapException(t3);
                  } else {
                    value = (value << 6 | t3.$and(unit, 63)) >>> 0;
                    --expectedUnits;
                    ++i;
                  }
                } while (expectedUnits > 0);
                t3 = extraUnits - 1;
                if (t3 < 0 || t3 >= 4)
                  return H.ioore(C.List_127_2047_65535_1114111, t3);
                if (value <= C.List_127_2047_65535_1114111[t3]) {
                  t3 = new P.FormatException("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                  throw H.wrapException(t3);
                }
                if (value > 1114111) {
                  t3 = new P.FormatException("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                  throw H.wrapException(t3);
                }
                if (!this._isFirstCharacter || value !== 65279)
                  t2._contents += H.Primitives_stringFromCharCode(value);
                this._isFirstCharacter = false;
              }
            for (t3 = i < endIndex; t3;) {
              oneBytes = scanOneByteCharacters.call$2(codeUnits, i);
              if (J.$gt$n(oneBytes, 0)) {
                this._isFirstCharacter = false;
                if (typeof oneBytes !== "number")
                  return H.iae(oneBytes);
                i0 = i + oneBytes;
                addSingleBytes.call$2(i, i0);
                if (i0 === endIndex)
                  break;
              } else
                i0 = i;
              i1 = i0 + 1;
              unit = t1.$index(codeUnits, i0);
              t4 = J.getInterceptor$n(unit);
              if (t4.$lt(unit, 0)) {
                t4 = new P.FormatException("Negative UTF-8 code unit: -0x" + J.toRadixString$1$n(t4.$negate(unit), 16), codeUnits, i1 - 1);
                throw H.wrapException(t4);
              } else {
                if (t4.$and(unit, 224) === 192) {
                  value = t4.$and(unit, 31);
                  expectedUnits = 1;
                  extraUnits = 1;
                  continue $loop$0;
                }
                if (t4.$and(unit, 240) === 224) {
                  value = t4.$and(unit, 15);
                  expectedUnits = 2;
                  extraUnits = 2;
                  continue $loop$0;
                }
                if (t4.$and(unit, 248) === 240 && t4.$lt(unit, 245)) {
                  value = t4.$and(unit, 7);
                  expectedUnits = 3;
                  extraUnits = 3;
                  continue $loop$0;
                }
                t4 = new P.FormatException("Bad UTF-8 encoding 0x" + t4.toRadixString$1(unit, 16), codeUnits, i1 - 1);
                throw H.wrapException(t4);
              }
            }
            break $loop$0;
          }
        if (expectedUnits > 0) {
          this._convert$_value = value;
          this._expectedUnits = expectedUnits;
          this._extraUnits = extraUnits;
        }
      }
    },
    _Utf8Decoder_convert_scanOneByteCharacters: {
      "^": "Closure:53;endIndex",
      call$2: function(units, from) {
        var to, t1, i, unit;
        to = this.endIndex;
        for (t1 = J.getInterceptor$asx(units), i = from; i < to; ++i) {
          unit = t1.$index(units, i);
          if (J.$and$n(unit, 127) !== unit)
            return i - from;
        }
        return to - from;
      }
    },
    _Utf8Decoder_convert_addSingleBytes: {
      "^": "Closure:65;$this,codeUnits,startIndex,endIndex",
      call$2: function(from, to) {
        this.$this._stringSink._contents += P.String_String$fromCharCodes(this.codeUnits, from, to);
      }
    }
  }], ["dart.core", "dart:core",, P, {
    "^": "",
    String__stringFromIterable: function(charCodes, start, end) {
      var t1, it, i, list;
      if (start < 0)
        throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), null, null));
      t1 = end == null;
      if (!t1 && end < start)
        throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), null, null));
      it = J.get$iterator$ax(charCodes);
      for (i = 0; i < start; ++i)
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(start, 0, i, null, null));
      list = [];
      if (t1)
        for (; it.moveNext$0();)
          list.push(it.get$current());
      else
        for (i = start; i < end; ++i) {
          if (!it.moveNext$0())
            throw H.wrapException(P.RangeError$range(end, start, i, null, null));
          list.push(it.get$current());
        }
      return H.Primitives_stringFromCharCodes(list);
    },
    Comparable_compare: [function(a, b) {
      return J.compareTo$1$ns(a, b);
    }, "call$2", "core_Comparable_compare$closure", 4, 0, 74, 15, 16],
    Exception_Exception: function(message) {
      return new P._Exception(message);
    },
    List_List$from: function(elements, growable, $E) {
      var list, t1;
      list = H.setRuntimeTypeInfo([], [$E]);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        list.push(t1.get$current());
      if (growable)
        return list;
      list.fixed$length = Array;
      return list;
    },
    List_List$generate: function($length, generator, growable, $E) {
      var result, i, t1;
      result = H.setRuntimeTypeInfo([], [$E]);
      C.JSArray_methods.set$length(result, $length);
      for (i = 0; i < $length; ++i) {
        t1 = generator.call$1(i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    num_parse: function(input, onError) {
      var source, result;
      source = J.trim$0$s(input);
      result = H.Primitives_parseInt(source, null, P.core_num__returnIntNull$closure());
      if (result != null)
        return result;
      result = H.Primitives_parseDouble(source, P.core_num__returnDoubleNull$closure());
      if (result != null)
        return result;
      throw H.wrapException(new P.FormatException(input, null, null));
    },
    num__returnIntNull: [function(_) {
      return;
    }, "call$1", "core_num__returnIntNull$closure", 2, 0, 75],
    num__returnDoubleNull: [function(_) {
      return;
    }, "call$1", "core_num__returnDoubleNull$closure", 2, 0, 76],
    print: function(object) {
      H.printString(H.S(object));
    },
    RegExp_RegExp: function(source, caseSensitive, multiLine) {
      return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, false, true, false), null, null);
    },
    String_String$fromCharCodes: function(charCodes, start, end) {
      var len;
      if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array) {
        len = charCodes.length;
        end = P.RangeError_checkValidRange(start, end, len, null, null, null);
        return H.Primitives_stringFromCharCodes(start > 0 || J.$lt$n(end, len) ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
      }
      if (!!J.getInterceptor(charCodes).$isNativeUint8List)
        return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, end, charCodes.length, null, null, null));
      return P.String__stringFromIterable(charCodes, start, end);
    },
    Uri_base: function() {
      var uri = H.Primitives_currentUri();
      if (uri != null)
        return P.Uri_parse(uri, 0, null);
      throw H.wrapException(new P.UnsupportedError("'Uri.base' is not supported"));
    },
    Uri_parse: function(uri, start, end) {
      var t1, delta, indices, t2, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, isSimple, scheme, t3, schemeAuth;
      end = uri.length;
      t1 = start + 5;
      if (end >= t1) {
        delta = ((C.JSString_methods._codeUnitAt$1(uri, start + 4) ^ 58) * 3 | C.JSString_methods._codeUnitAt$1(uri, start) ^ 100 | C.JSString_methods._codeUnitAt$1(uri, start + 1) ^ 97 | C.JSString_methods._codeUnitAt$1(uri, start + 2) ^ 116 | C.JSString_methods._codeUnitAt$1(uri, start + 3) ^ 97) >>> 0;
        if (delta === 0)
          return P.UriData__parse(start > 0 || end < end ? C.JSString_methods.substring$2(uri, start, end) : uri, 5, null).get$uri();
        else if (delta === 32)
          return P.UriData__parse(C.JSString_methods.substring$2(uri, t1, end), 0, null).get$uri();
      }
      indices = H.setRuntimeTypeInfo(new Array(8), [P.int]);
      indices[0] = 0;
      t2 = start - 1;
      indices[1] = t2;
      indices[2] = t2;
      indices[7] = t2;
      indices[3] = start;
      indices[4] = start;
      indices[5] = end;
      indices[6] = end;
      if (P._scan(uri, start, end, 0, indices) >= 14)
        indices[7] = end;
      schemeEnd = indices[1];
      if (typeof schemeEnd !== "number")
        return schemeEnd.$ge();
      if (schemeEnd >= start)
        if (P._scan(uri, start, schemeEnd, 20, indices) === 20)
          indices[7] = schemeEnd;
      t2 = indices[2];
      if (typeof t2 !== "number")
        return t2.$add();
      hostStart = t2 + 1;
      portStart = indices[3];
      pathStart = indices[4];
      queryStart = indices[5];
      fragmentStart = indices[6];
      if (typeof fragmentStart !== "number")
        return fragmentStart.$lt();
      if (typeof queryStart !== "number")
        return H.iae(queryStart);
      if (fragmentStart < queryStart)
        queryStart = fragmentStart;
      if (typeof pathStart !== "number")
        return pathStart.$lt();
      if (pathStart < hostStart || pathStart <= schemeEnd)
        pathStart = queryStart;
      if (typeof portStart !== "number")
        return portStart.$lt();
      if (portStart < hostStart)
        portStart = pathStart;
      t2 = indices[7];
      if (typeof t2 !== "number")
        return t2.$lt();
      isSimple = t2 < start;
      if (isSimple)
        if (hostStart > schemeEnd + 3) {
          scheme = null;
          isSimple = false;
        } else {
          t2 = portStart > start;
          if (t2 && portStart + 1 === pathStart) {
            scheme = null;
            isSimple = false;
          } else {
            if (!(queryStart < end && queryStart === pathStart + 2 && C.JSString_methods.startsWith$2(uri, "..", pathStart)))
              t3 = queryStart > pathStart + 2 && C.JSString_methods.startsWith$2(uri, "/..", queryStart - 3);
            else
              t3 = true;
            if (t3) {
              scheme = null;
              isSimple = false;
            } else {
              if (schemeEnd === start + 4)
                if (C.JSString_methods.startsWith$2(uri, "file", start)) {
                  if (hostStart <= start) {
                    if (!C.JSString_methods.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = schemeAuth + C.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= start;
                    t1 = delta - start;
                    queryStart += t1;
                    fragmentStart += t1;
                    end = uri.length;
                    start = 0;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else if (pathStart === queryStart)
                    if (start === 0 && true) {
                      uri = C.JSString_methods.replaceRange$3(uri, pathStart, queryStart, "/");
                      ++queryStart;
                      ++fragmentStart;
                      ++end;
                    } else {
                      uri = C.JSString_methods.substring$2(uri, start, pathStart) + "/" + C.JSString_methods.substring$2(uri, queryStart, end);
                      schemeEnd -= start;
                      hostStart -= start;
                      portStart -= start;
                      pathStart -= start;
                      t1 = 1 - start;
                      queryStart += t1;
                      fragmentStart += t1;
                      end = uri.length;
                      start = 0;
                    }
                  scheme = "file";
                } else if (C.JSString_methods.startsWith$2(uri, "http", start)) {
                  if (t2 && portStart + 3 === pathStart && C.JSString_methods.startsWith$2(uri, "80", portStart + 1))
                    if (start === 0 && true) {
                      uri = C.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                      pathStart -= 3;
                      queryStart -= 3;
                      fragmentStart -= 3;
                      end -= 3;
                    } else {
                      uri = C.JSString_methods.substring$2(uri, start, portStart) + C.JSString_methods.substring$2(uri, pathStart, end);
                      schemeEnd -= start;
                      hostStart -= start;
                      portStart -= start;
                      t1 = 3 + start;
                      pathStart -= t1;
                      queryStart -= t1;
                      fragmentStart -= t1;
                      end = uri.length;
                      start = 0;
                    }
                  scheme = "http";
                } else
                  scheme = null;
              else if (schemeEnd === t1 && C.JSString_methods.startsWith$2(uri, "https", start)) {
                if (t2 && portStart + 4 === pathStart && C.JSString_methods.startsWith$2(uri, "443", portStart + 1))
                  if (start === 0 && true) {
                    uri = C.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                    pathStart -= 4;
                    queryStart -= 4;
                    fragmentStart -= 4;
                    end -= 3;
                  } else {
                    uri = C.JSString_methods.substring$2(uri, start, portStart) + C.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= start;
                    hostStart -= start;
                    portStart -= start;
                    t1 = 4 + start;
                    pathStart -= t1;
                    queryStart -= t1;
                    fragmentStart -= t1;
                    end = uri.length;
                    start = 0;
                  }
                scheme = "https";
              } else
                scheme = null;
              isSimple = true;
            }
          }
        }
      else
        scheme = null;
      if (isSimple) {
        if (start > 0 || end < uri.length) {
          uri = C.JSString_methods.substring$2(uri, start, end);
          schemeEnd -= start;
          hostStart -= start;
          portStart -= start;
          pathStart -= start;
          queryStart -= start;
          fragmentStart -= start;
        }
        return new P._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme, null);
      }
      return P._Uri__Uri$notSimple(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
    },
    Uri_splitQueryString: function(query, encoding) {
      return C.JSArray_methods.fold$2(query.split("&"), P.LinkedHashMap__makeEmpty(), new P.Uri_splitQueryString_closure(encoding));
    },
    Uri__parseIPv4Address: function(host, start, end) {
      var error, t1, result, i, partStart, partIndex, char, part, partIndex0;
      error = new P.Uri__parseIPv4Address_error(host);
      t1 = H._checkLength(4);
      result = new Uint8Array(t1);
      for (i = start, partStart = i, partIndex = 0; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char !== 46) {
          if ((char ^ 48) > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2("IPv4 address should contain exactly 4 parts", i);
          part = H.Primitives_parseInt(C.JSString_methods.substring$2(host, partStart, i), null, null);
          if (J.$gt$n(part, 255))
            error.call$2("each part must be in the range 0..255", partStart);
          partIndex0 = partIndex + 1;
          if (partIndex >= t1)
            return H.ioore(result, partIndex);
          result[partIndex] = part;
          partStart = i + 1;
          partIndex = partIndex0;
        }
      }
      if (partIndex !== 3)
        error.call$2("IPv4 address should contain exactly 4 parts", end);
      part = H.Primitives_parseInt(C.JSString_methods.substring$2(host, partStart, end), null, null);
      if (J.$gt$n(part, 255))
        error.call$2("each part must be in the range 0..255", partStart);
      if (partIndex >= t1)
        return H.ioore(result, partIndex);
      result[partIndex] = part;
      return result;
    },
    Uri_parseIPv6Address: function(host, start, end) {
      var error, parseHex, parts, i, partStart, wildcardSeen, seenDot, char, atEnd, isLastWildcard, last, t1, t2, bytes, index, value, wildCardLength, j;
      if (end == null)
        end = host.length;
      error = new P.Uri_parseIPv6Address_error(host);
      parseHex = new P.Uri_parseIPv6Address_parseHex(host, error);
      if (host.length < 2)
        error.call$1("address is too short");
      parts = [];
      for (i = start, partStart = i, wildcardSeen = false, seenDot = false; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char === 58) {
          if (i === start) {
            ++i;
            if (C.JSString_methods.codeUnitAt$1(host, i) !== 58)
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          if (i === partStart) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            parts.push(-1);
            wildcardSeen = true;
          } else
            parts.push(parseHex.call$2(partStart, i));
          partStart = i + 1;
        } else if (char === 46)
          seenDot = true;
      }
      if (parts.length === 0)
        error.call$1("too few parts");
      atEnd = partStart === end;
      isLastWildcard = J.$eq$(C.JSArray_methods.get$last(parts), -1);
      if (atEnd && !isLastWildcard)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          parts.push(parseHex.call$2(partStart, end));
        else {
          last = P.Uri__parseIPv4Address(host, partStart, end);
          t1 = J.$shl$n(last[0], 8);
          t2 = last[1];
          if (typeof t2 !== "number")
            return H.iae(t2);
          parts.push((t1 | t2) >>> 0);
          t2 = J.$shl$n(last[2], 8);
          t1 = last[3];
          if (typeof t1 !== "number")
            return H.iae(t1);
          parts.push((t2 | t1) >>> 0);
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$1("an address with a wildcard must have less than 7 parts");
      } else if (parts.length !== 8)
        error.call$1("an address without a wildcard must contain exactly 8 parts");
      bytes = new Uint8Array(16);
      for (i = 0, index = 0; i < parts.length; ++i) {
        value = parts[i];
        t1 = J.getInterceptor(value);
        if (t1.$eq(value, -1)) {
          wildCardLength = 9 - parts.length;
          for (j = 0; j < wildCardLength; ++j) {
            if (index < 0 || index >= 16)
              return H.ioore(bytes, index);
            bytes[index] = 0;
            t1 = index + 1;
            if (t1 >= 16)
              return H.ioore(bytes, t1);
            bytes[t1] = 0;
            index += 2;
          }
        } else {
          t2 = t1.$shr(value, 8);
          if (index < 0 || index >= 16)
            return H.ioore(bytes, index);
          bytes[index] = t2;
          t2 = index + 1;
          t1 = t1.$and(value, 255);
          if (t2 >= 16)
            return H.ioore(bytes, t2);
          bytes[t2] = t1;
          index += 2;
        }
      }
      return bytes;
    },
    _createTables: function() {
      var tables, t1, t2, t3, b;
      tables = P.List_List$generate(22, new P._createTables_closure(), true, P.Uint8List);
      t1 = new P._createTables_build(tables);
      t2 = new P._createTables_setChars();
      t3 = new P._createTables_setRange();
      b = t1.call$2(0, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 14);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 3);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(14, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 15);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(15, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(1, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(2, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 139);
      t2.call$3(b, "/", 131);
      t2.call$3(b, ".", 146);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(3, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 68);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(4, 229);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(5, 229);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(6, 231);
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(7, 231);
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      t2.call$3(t1.call$2(8, 8), "]", 5);
      b = t1.call$2(9, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 16);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(16, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 17);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(17, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(10, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(18, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 19);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(19, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(11, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(12, 236);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 12);
      t2.call$3(b, "?", 12);
      t2.call$3(b, "#", 205);
      b = t1.call$2(13, 237);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 13);
      t2.call$3(b, "?", 13);
      t3.call$3(t1.call$2(20, 245), "az", 21);
      b = t1.call$2(21, 245);
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    },
    _scan: function(uri, start, end, state, indices) {
      var tables, i, table, char, transition, t1;
      tables = $.$get$_scannerTables();
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      for (; i < end; ++i) {
        if (state < 0 || state >= tables.length)
          return H.ioore(tables, state);
        table = tables[state];
        char = C.JSString_methods._codeUnitAt$1(uri, i) ^ 96;
        transition = J.$index$asx(table, char > 95 ? 31 : char);
        t1 = J.getInterceptor$n(transition);
        state = t1.$and(transition, 31);
        t1 = t1.$shr(transition, 5);
        if (t1 >= 8)
          return H.ioore(indices, t1);
        indices[t1] = i;
      }
      return state;
    },
    NoSuchMethodError_toString_closure: {
      "^": "Closure:34;_box_0,sb",
      call$2: [function(key, value) {
        var t1, t2, t3;
        t1 = this.sb;
        t2 = this._box_0;
        t1._contents += t2.comma;
        t3 = t1._contents += H.S(key.get$__internal$_name());
        t1._contents = t3 + ": ";
        t1._contents += H.S(P.Error_safeToString(value));
        t2.comma = ", ";
      }, null, null, 4, 0, null, 8, 3, "call"]
    },
    bool: {
      "^": "Object;"
    },
    "+bool": 0,
    Comparable: {
      "^": "Object;"
    },
    DateTime: {
      "^": "Object;_value<,isUtc",
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.DateTime))
          return false;
        return this._value === other._value && this.isUtc === other.isUtc;
      },
      compareTo$1: function(_, other) {
        return C.JSNumber_methods.compareTo$1(this._value, other.get$_value());
      },
      get$hashCode: function(_) {
        var t1 = this._value;
        return (t1 ^ C.JSNumber_methods._shrOtherPositive$1(t1, 30)) & 1073741823;
      },
      toString$0: function(_) {
        var y, m, d, h, min, sec, ms;
        y = P.DateTime__fourDigits(H.Primitives_getYear(this));
        m = P.DateTime__twoDigits(H.Primitives_getMonth(this));
        d = P.DateTime__twoDigits(H.Primitives_getDay(this));
        h = P.DateTime__twoDigits(H.Primitives_getHours(this));
        min = P.DateTime__twoDigits(H.Primitives_getMinutes(this));
        sec = P.DateTime__twoDigits(H.Primitives_getSeconds(this));
        ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(this));
        if (this.isUtc)
          return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
        else
          return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
      },
      get$millisecondsSinceEpoch: function() {
        return this._value;
      },
      DateTime$_withValue$2$isUtc: function(_value, isUtc) {
        var t1;
        if (!(Math.abs(this._value) > 864e13))
          t1 = false;
        else
          t1 = true;
        if (t1)
          throw H.wrapException(P.ArgumentError$(this.get$millisecondsSinceEpoch()));
      },
      $isComparable: 1,
      $asComparable: function() {
        return [P.DateTime];
      },
      static: {
        DateTime__fourDigits: function(n) {
          var absN, sign;
          absN = Math.abs(n);
          sign = n < 0 ? "-" : "";
          if (absN >= 1000)
            return "" + n;
          if (absN >= 100)
            return sign + "0" + H.S(absN);
          if (absN >= 10)
            return sign + "00" + H.S(absN);
          return sign + "000" + H.S(absN);
        },
        DateTime__threeDigits: function(n) {
          if (n >= 100)
            return "" + n;
          if (n >= 10)
            return "0" + n;
          return "00" + n;
        },
        DateTime__twoDigits: function(n) {
          if (n >= 10)
            return "" + n;
          return "0" + n;
        }
      }
    },
    double: {
      "^": "num;",
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      }
    },
    "+double": 0,
    Duration: {
      "^": "Object;_duration<",
      $add: function(_, other) {
        return new P.Duration(this._duration + other.get$_duration());
      },
      $sub: function(_, other) {
        return new P.Duration(this._duration - other.get$_duration());
      },
      $mul: function(_, factor) {
        if (typeof factor !== "number")
          return H.iae(factor);
        return new P.Duration(C.JSNumber_methods.round$0(this._duration * factor));
      },
      $tdiv: function(_, quotient) {
        if (quotient === 0)
          throw H.wrapException(new P.IntegerDivisionByZeroException());
        if (typeof quotient !== "number")
          return H.iae(quotient);
        return new P.Duration(C.JSNumber_methods.$tdiv(this._duration, quotient));
      },
      $lt: function(_, other) {
        return this._duration < other.get$_duration();
      },
      $gt: function(_, other) {
        return this._duration > other.get$_duration();
      },
      $le: function(_, other) {
        return this._duration <= other.get$_duration();
      },
      $ge: function(_, other) {
        return this._duration >= other.get$_duration();
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.Duration))
          return false;
        return this._duration === other._duration;
      },
      get$hashCode: function(_) {
        return this._duration & 0x1FFFFFFF;
      },
      compareTo$1: function(_, other) {
        return C.JSNumber_methods.compareTo$1(this._duration, other.get$_duration());
      },
      toString$0: function(_) {
        var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
        t1 = new P.Duration_toString_twoDigits();
        t2 = this._duration;
        if (t2 < 0)
          return "-" + new P.Duration(0 - t2).toString$0(0);
        twoDigitMinutes = t1.call$1(C.JSNumber_methods._tdivFast$1(t2, 60000000) % 60);
        twoDigitSeconds = t1.call$1(C.JSNumber_methods._tdivFast$1(t2, 1000000) % 60);
        sixDigitUs = new P.Duration_toString_sixDigits().call$1(t2 % 1000000);
        return H.S(C.JSNumber_methods._tdivFast$1(t2, 3600000000)) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
      },
      abs$0: function(_) {
        return new P.Duration(Math.abs(this._duration));
      },
      $negate: function(_) {
        return new P.Duration(0 - this._duration);
      },
      $isComparable: 1,
      $asComparable: function() {
        return [P.Duration];
      },
      static: {
        Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
          return new P.Duration(864e8 * days + 3600000000 * hours + 60000000 * minutes + 1000000 * seconds + 1000 * milliseconds + microseconds);
        }
      }
    },
    Duration_toString_sixDigits: {
      "^": "Closure:21;",
      call$1: function(n) {
        if (n >= 100000)
          return H.S(n);
        if (n >= 10000)
          return "0" + H.S(n);
        if (n >= 1000)
          return "00" + H.S(n);
        if (n >= 100)
          return "000" + H.S(n);
        if (n >= 10)
          return "0000" + H.S(n);
        return "00000" + H.S(n);
      }
    },
    Duration_toString_twoDigits: {
      "^": "Closure:21;",
      call$1: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }
    },
    Error: {
      "^": "Object;",
      get$stackTrace: function() {
        return H.getTraceFromException(this.$thrownJsError);
      },
      static: {
        Error_safeToString: function(object) {
          if (typeof object === "number" || typeof object === "boolean" || null == object)
            return J.toString$0$(object);
          if (typeof object === "string")
            return JSON.stringify(object);
          return P.Error__objectToString(object);
        },
        Error__objectToString: function(object) {
          var t1 = J.getInterceptor(object);
          if (!!t1.$isClosure)
            return t1.toString$0(object);
          return H.Primitives_objectToHumanReadableString(object);
        }
      }
    },
    NullThrownError: {
      "^": "Error;",
      toString$0: function(_) {
        return "Throw of null.";
      }
    },
    ArgumentError: {
      "^": "Error;_hasValue,invalidValue,name>,message",
      get$_errorName: function() {
        return "Invalid argument" + (!this._hasValue ? "(s)" : "");
      },
      get$_errorExplanation: function() {
        return "";
      },
      toString$0: function(_) {
        var t1, nameString, message, prefix, explanation, errorValue;
        t1 = this.name;
        nameString = t1 != null ? " (" + t1 + ")" : "";
        t1 = this.message;
        message = t1 == null ? "" : ": " + H.S(t1);
        prefix = this.get$_errorName() + nameString + message;
        if (!this._hasValue)
          return prefix;
        explanation = this.get$_errorExplanation();
        errorValue = P.Error_safeToString(this.invalidValue);
        return prefix + explanation + ": " + H.S(errorValue);
      },
      static: {
        ArgumentError$: function(message) {
          return new P.ArgumentError(false, null, null, message);
        },
        ArgumentError$value: function(value, $name, message) {
          return new P.ArgumentError(true, value, $name, message);
        },
        ArgumentError$notNull: function($name) {
          return new P.ArgumentError(false, null, $name, "Must not be null");
        }
      }
    },
    RangeError: {
      "^": "ArgumentError;start>,end>,_hasValue,invalidValue,name,message",
      get$_errorName: function() {
        return "RangeError";
      },
      get$_errorExplanation: function() {
        var t1, explanation, t2, t3;
        t1 = this.start;
        if (t1 == null) {
          t1 = this.end;
          explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
        } else {
          t2 = this.end;
          if (t2 == null)
            explanation = ": Not greater than or equal to " + H.S(t1);
          else {
            t3 = J.getInterceptor$n(t2);
            if (t3.$gt(t2, t1))
              explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
            else
              explanation = t3.$lt(t2, t1) ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
          }
        }
        return explanation;
      },
      static: {
        RangeError$: function(message) {
          return new P.RangeError(null, null, false, null, null, message);
        },
        RangeError$value: function(value, $name, message) {
          return new P.RangeError(null, null, true, value, $name, "Value not in range");
        },
        RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
          return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
        },
        RangeError_checkValueInInterval: function(value, minValue, maxValue, $name, message) {
          if (typeof value !== "number")
            return value.$lt();
          if (value < minValue || value > maxValue)
            throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, message));
        },
        RangeError_checkValidRange: function(start, end, $length, startName, endName, message) {
          var t1;
          if (typeof start !== "number")
            return H.iae(start);
          if (!(0 > start)) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = start > $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.RangeError$range(start, 0, $length, "start", message));
          if (end != null) {
            if (typeof end !== "number")
              return H.iae(end);
            if (!(start > end)) {
              if (typeof $length !== "number")
                return H.iae($length);
              t1 = end > $length;
            } else
              t1 = true;
            if (t1)
              throw H.wrapException(P.RangeError$range(end, start, $length, "end", message));
            return end;
          }
          return $length;
        }
      }
    },
    IndexError: {
      "^": "ArgumentError;indexable,length>,_hasValue,invalidValue,name,message",
      get$start: function(_) {
        return 0;
      },
      get$end: function(_) {
        return J.$sub$n(this.length, 1);
      },
      get$_errorName: function() {
        return "RangeError";
      },
      get$_errorExplanation: function() {
        if (J.$lt$n(this.invalidValue, 0))
          return ": index must not be negative";
        var t1 = this.length;
        if (t1 === 0)
          return ": no indices are valid";
        return ": index should be less than " + H.S(t1);
      },
      static: {
        IndexError$: function(invalidValue, indexable, $name, message, $length) {
          var t1 = $length != null ? $length : J.get$length$asx(indexable);
          return new P.IndexError(indexable, t1, true, invalidValue, $name, "Index out of range");
        }
      }
    },
    NoSuchMethodError: {
      "^": "Error;_core$_receiver,_memberName,_core$_arguments,_namedArguments,_existingArgumentNames",
      toString$0: function(_) {
        var _box_0, sb, t1, t2, _i, argument, receiverText, actualParameters;
        _box_0 = {};
        sb = new P.StringBuffer("");
        _box_0.comma = "";
        for (t1 = this._core$_arguments, t2 = t1.length, _i = 0; _i < t2; ++_i) {
          argument = t1[_i];
          sb._contents += _box_0.comma;
          sb._contents += H.S(P.Error_safeToString(argument));
          _box_0.comma = ", ";
        }
        this._namedArguments.forEach$1(0, new P.NoSuchMethodError_toString_closure(_box_0, sb));
        receiverText = P.Error_safeToString(this._core$_receiver);
        actualParameters = sb.toString$0(0);
        t1 = "NoSuchMethodError: method not found: '" + H.S(this._memberName.__internal$_name) + "'\nReceiver: " + H.S(receiverText) + "\nArguments: [" + actualParameters + "]";
        return t1;
      },
      static: {
        NoSuchMethodError$: function(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
          return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames);
        }
      }
    },
    UnsupportedError: {
      "^": "Error;message",
      toString$0: function(_) {
        return "Unsupported operation: " + this.message;
      }
    },
    UnimplementedError: {
      "^": "Error;message",
      toString$0: function(_) {
        var t1 = this.message;
        return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
      }
    },
    StateError: {
      "^": "Error;message",
      toString$0: function(_) {
        return "Bad state: " + H.S(this.message);
      }
    },
    ConcurrentModificationError: {
      "^": "Error;modifiedObject",
      toString$0: function(_) {
        var t1 = this.modifiedObject;
        if (t1 == null)
          return "Concurrent modification during iteration.";
        return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
      }
    },
    OutOfMemoryError: {
      "^": "Object;",
      toString$0: function(_) {
        return "Out of Memory";
      },
      get$stackTrace: function() {
        return;
      },
      $isError: 1
    },
    StackOverflowError: {
      "^": "Object;",
      toString$0: function(_) {
        return "Stack Overflow";
      },
      get$stackTrace: function() {
        return;
      },
      $isError: 1
    },
    CyclicInitializationError: {
      "^": "Error;variableName",
      toString$0: function(_) {
        var t1 = this.variableName;
        return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + H.S(t1) + "' during its initialization";
      }
    },
    _Exception: {
      "^": "Object;message",
      toString$0: function(_) {
        var t1 = this.message;
        if (t1 == null)
          return "Exception";
        return "Exception: " + H.S(t1);
      }
    },
    FormatException: {
      "^": "Object;message,source,offset",
      toString$0: function(_) {
        var t1, report, offset, source, lineNum, lineStart, previousCharWasCR, i, char, lineEnd, end, start, prefix, postfix, slice;
        t1 = this.message;
        report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
        offset = this.offset;
        source = this.source;
        if (typeof source !== "string")
          return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
        if (offset != null) {
          t1 = J.getInterceptor$n(offset);
          t1 = t1.$lt(offset, 0) || t1.$gt(offset, source.length);
        } else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          if (source.length > 78)
            source = C.JSString_methods.substring$2(source, 0, 75) + "...";
          return report + "\n" + source;
        }
        if (typeof offset !== "number")
          return H.iae(offset);
        lineNum = 1;
        lineStart = 0;
        previousCharWasCR = false;
        i = 0;
        for (; i < offset; ++i) {
          char = C.JSString_methods._codeUnitAt$1(source, i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + H.S(offset - lineStart + 1) + ")\n") : report + (" (at character " + H.S(offset + 1) + ")\n");
        lineEnd = source.length;
        for (i = offset; i < source.length; ++i) {
          char = C.JSString_methods.codeUnitAt$1(source, i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = C.JSString_methods.substring$2(source, start, end);
        return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      }
    },
    IntegerDivisionByZeroException: {
      "^": "Object;",
      toString$0: function(_) {
        return "IntegerDivisionByZeroException";
      }
    },
    Expando: {
      "^": "Object;name>,_jsWeakMapOrKey",
      toString$0: function(_) {
        return "Expando:" + H.S(this.name);
      },
      $index: function(_, object) {
        var t1, values;
        t1 = this._jsWeakMapOrKey;
        if (typeof t1 !== "string") {
          if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
            H.throwExpression(P.ArgumentError$value(object, "Expandos are not allowed on strings, numbers, booleans or null", null));
          return t1.get(object);
        }
        values = H.Primitives_getProperty(object, "expando$values");
        return values == null ? null : H.Primitives_getProperty(values, t1);
      },
      $indexSet: function(_, object, value) {
        var t1, values;
        t1 = this._jsWeakMapOrKey;
        if (typeof t1 !== "string")
          t1.set(object, value);
        else {
          values = H.Primitives_getProperty(object, "expando$values");
          if (values == null) {
            values = new P.Object();
            H.Primitives_setProperty(object, "expando$values", values);
          }
          H.Primitives_setProperty(values, t1, value);
        }
      }
    },
    int: {
      "^": "num;",
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      }
    },
    "+int": 0,
    Iterable: {
      "^": "Object;$ti",
      map$1: function(_, f) {
        return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "Iterable", 0), null);
      },
      forEach$1: function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          f.call$1(t1.get$current());
      },
      toList$1$growable: function(_, growable) {
        return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "Iterable", 0));
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      get$length: function(_) {
        var it, count;
        it = this.get$iterator(this);
        for (count = 0; it.moveNext$0();)
          ++count;
        return count;
      },
      get$isEmpty: function(_) {
        return !this.get$iterator(this).moveNext$0();
      },
      elementAt$1: function(_, index) {
        var t1, elementIndex, element;
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        if (index < 0)
          H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
        for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
          element = t1.get$current();
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      },
      toString$0: function(_) {
        return P.IterableBase_iterableToShortString(this, "(", ")");
      }
    },
    Iterator: {
      "^": "Object;"
    },
    List: {
      "^": "Object;$ti",
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null
    },
    "+List": 0,
    Map: {
      "^": "Object;$ti",
      $asMap: null
    },
    Null: {
      "^": "Object;",
      get$hashCode: function(_) {
        return P.Object.prototype.get$hashCode.call(this, this);
      },
      toString$0: function(_) {
        return "null";
      }
    },
    "+Null": 0,
    num: {
      "^": "Object;",
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      }
    },
    "+num": 0,
    Object: {
      "^": ";",
      $eq: function(_, other) {
        return this === other;
      },
      get$hashCode: function(_) {
        return H.Primitives_objectHashCode(this);
      },
      toString$0: ["super$Object$toString", function(_) {
        return H.Primitives_objectToHumanReadableString(this);
      }],
      noSuchMethod$1: function(_, invocation) {
        throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      },
      toString: function() {
        return this.toString$0(this);
      }
    },
    Match: {
      "^": "Object;"
    },
    StackTrace: {
      "^": "Object;"
    },
    Stopwatch: {
      "^": "Object;_core$_start,_stop",
      start$0: [function(_) {
        if (this._stop != null) {
          this._core$_start = J.$add$ns(this._core$_start, J.$sub$n($.Primitives_timerTicks.call$0(), this._stop));
          this._stop = null;
        }
      }, "call$0", "get$start", 0, 0, 2]
    },
    String: {
      "^": "Object;",
      $isComparable: 1,
      $asComparable: function() {
        return [P.String];
      }
    },
    "+String": 0,
    StringBuffer: {
      "^": "Object;_contents@",
      get$length: function(_) {
        return this._contents.length;
      },
      get$isEmpty: function(_) {
        return this._contents.length === 0;
      },
      toString$0: function(_) {
        var t1 = this._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      static: {
        StringBuffer__writeAll: function(string, objects, separator) {
          var iterator = J.get$iterator$ax(objects);
          if (!iterator.moveNext$0())
            return string;
          if (separator.length === 0) {
            do
              string += H.S(iterator.get$current());
            while (iterator.moveNext$0());
          } else {
            string += H.S(iterator.get$current());
            for (; iterator.moveNext$0();)
              string = string + separator + H.S(iterator.get$current());
          }
          return string;
        }
      }
    },
    Symbol0: {
      "^": "Object;"
    },
    Uri_splitQueryString_closure: {
      "^": "Closure:3;encoding",
      call$2: function(map, element) {
        var t1, index, key, value;
        t1 = J.getInterceptor$asx(element);
        index = t1.indexOf$1(element, "=");
        if (index === -1) {
          if (!t1.$eq(element, ""))
            J.$indexSet$ax(map, P._Uri__uriDecode(element, 0, t1.get$length(element), this.encoding, true), "");
        } else if (index !== 0) {
          key = t1.substring$2(element, 0, index);
          value = t1.substring$1(element, index + 1);
          t1 = this.encoding;
          J.$indexSet$ax(map, P._Uri__uriDecode(key, 0, key.length, t1, true), P._Uri__uriDecode(value, 0, value.length, t1, true));
        }
        return map;
      }
    },
    Uri__parseIPv4Address_error: {
      "^": "Closure:41;host",
      call$2: function(msg, position) {
        throw H.wrapException(new P.FormatException("Illegal IPv4 address, " + msg, this.host, position));
      }
    },
    Uri_parseIPv6Address_error: {
      "^": "Closure:43;host",
      call$2: function(msg, position) {
        throw H.wrapException(new P.FormatException("Illegal IPv6 address, " + msg, this.host, position));
      },
      call$1: function(msg) {
        return this.call$2(msg, null);
      }
    },
    Uri_parseIPv6Address_parseHex: {
      "^": "Closure:44;host,error",
      call$2: function(start, end) {
        var value, t1;
        if (end - start > 4)
          this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
        value = H.Primitives_parseInt(C.JSString_methods.substring$2(this.host, start, end), 16, null);
        t1 = J.getInterceptor$n(value);
        if (t1.$lt(value, 0) || t1.$gt(value, 65535))
          this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
        return value;
      }
    },
    _Uri: {
      "^": "Object;scheme<,_userInfo,_host,_port,path>,_query,_fragment,_pathSegments,_core$_text,_hashCodeCache,_queryParameters,_queryParameterLists",
      get$userInfo: function() {
        return this._userInfo;
      },
      get$host: function(_) {
        var t1 = this._host;
        if (t1 == null)
          return "";
        if (C.JSString_methods.startsWith$1(t1, "["))
          return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
        return t1;
      },
      get$port: function(_) {
        var t1 = this._port;
        if (t1 == null)
          return P._Uri__defaultPort(this.scheme);
        return t1;
      },
      get$query: function(_) {
        var t1 = this._query;
        return t1 == null ? "" : t1;
      },
      get$fragment: function() {
        var t1 = this._fragment;
        return t1 == null ? "" : t1;
      },
      get$queryParameters: function() {
        var t1, t2;
        t1 = this._queryParameters;
        if (t1 == null) {
          t1 = this._query;
          t2 = P.String;
          t2 = new P.UnmodifiableMapView(P.Uri_splitQueryString(t1 == null ? "" : t1, C.Utf8Codec_false), [t2, t2]);
          this._queryParameters = t2;
          t1 = t2;
        }
        return t1;
      },
      get$hasAuthority: function() {
        return this._host != null;
      },
      get$hasQuery: function() {
        return this._query != null;
      },
      get$hasFragment: function() {
        return this._fragment != null;
      },
      toString$0: function(_) {
        var t1 = this._core$_text;
        if (t1 == null) {
          t1 = this._initializeText$0();
          this._core$_text = t1;
        }
        return t1;
      },
      _initializeText$0: function() {
        var t1, t2, t3, t4;
        t1 = this.scheme;
        t2 = t1.length !== 0 ? t1 + ":" : "";
        t3 = this._host;
        t4 = t3 == null;
        if (!t4 || t1 === "file") {
          t1 = t2 + "//";
          t2 = this._userInfo;
          if (t2.length !== 0)
            t1 = t1 + H.S(t2) + "@";
          if (!t4)
            t1 += t3;
          t2 = this._port;
          if (t2 != null)
            t1 = t1 + ":" + H.S(t2);
        } else
          t1 = t2;
        t1 += H.S(this.path);
        t2 = this._query;
        if (t2 != null)
          t1 = t1 + "?" + t2;
        t2 = this._fragment;
        if (t2 != null)
          t1 = t1 + "#" + t2;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      $eq: function(_, other) {
        var t1, t2, t3;
        if (other == null)
          return false;
        if (this === other)
          return true;
        t1 = J.getInterceptor(other);
        if (!!t1.$isUri) {
          if (this.scheme === other.get$scheme())
            if (this._host != null === other.get$hasAuthority()) {
              t2 = this._userInfo;
              t3 = other.get$userInfo();
              if (t2 == null ? t3 == null : t2 === t3) {
                t2 = this.get$host(this);
                t3 = t1.get$host(other);
                if (t2 == null ? t3 == null : t2 === t3)
                  if (J.$eq$(this.get$port(this), t1.get$port(other)))
                    if (J.$eq$(this.path, t1.get$path(other))) {
                      t2 = this._query;
                      t3 = t2 == null;
                      if (!t3 === other.get$hasQuery()) {
                        if (t3)
                          t2 = "";
                        if (t2 === t1.get$query(other)) {
                          t1 = this._fragment;
                          t2 = t1 == null;
                          if (!t2 === other.get$hasFragment()) {
                            if (t2)
                              t1 = "";
                            t1 = t1 === other.get$fragment();
                          } else
                            t1 = false;
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
              } else
                t1 = false;
            } else
              t1 = false;
          else
            t1 = false;
          return t1;
        }
        return false;
      },
      get$hashCode: function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = this._core$_text;
          if (t1 == null) {
            t1 = this._initializeText$0();
            this._core$_text = t1;
          }
          t1 = C.JSString_methods.get$hashCode(t1);
          this._hashCodeCache = t1;
        }
        return t1;
      },
      $isUri: 1,
      static: {
        _Uri__Uri$notSimple: function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
          var userInfoStart, userInfo, host, t1, port, path, query;
          if (scheme == null) {
            if (typeof schemeEnd !== "number")
              return schemeEnd.$gt();
            if (schemeEnd > start)
              scheme = P._Uri__makeScheme(uri, start, schemeEnd);
            else {
              if (schemeEnd === start)
                P._Uri__fail(uri, start, "Invalid empty scheme");
              scheme = "";
            }
          }
          if (hostStart > start) {
            if (typeof schemeEnd !== "number")
              return schemeEnd.$add();
            userInfoStart = schemeEnd + 3;
            userInfo = userInfoStart < hostStart ? P._Uri__makeUserInfo(uri, userInfoStart, hostStart - 1) : "";
            host = P._Uri__makeHost(uri, hostStart, portStart, false);
            if (typeof portStart !== "number")
              return portStart.$add();
            t1 = portStart + 1;
            if (typeof pathStart !== "number")
              return H.iae(pathStart);
            port = t1 < pathStart ? P._Uri__makePort(H.Primitives_parseInt(C.JSString_methods.substring$2(uri, t1, pathStart), null, new P.closure(uri, portStart)), scheme) : null;
          } else {
            userInfo = "";
            host = null;
            port = null;
          }
          path = P._Uri__makePath(uri, pathStart, queryStart, null, scheme, host != null);
          if (typeof queryStart !== "number")
            return queryStart.$lt();
          if (typeof fragmentStart !== "number")
            return H.iae(fragmentStart);
          query = queryStart < fragmentStart ? P._Uri__makeQuery(uri, queryStart + 1, fragmentStart, null) : null;
          if (typeof end !== "number")
            return H.iae(end);
          return new P._Uri(scheme, userInfo, host, port, path, query, fragmentStart < end ? P._Uri__makeFragment(uri, fragmentStart + 1, end) : null, null, null, null, null, null);
        },
        _Uri__defaultPort: function(scheme) {
          if (scheme === "http")
            return 80;
          if (scheme === "https")
            return 443;
          return 0;
        },
        _Uri__fail: function(uri, index, message) {
          throw H.wrapException(new P.FormatException(message, uri, index));
        },
        _Uri__makePort: function(port, scheme) {
          if (port != null && J.$eq$(port, P._Uri__defaultPort(scheme)))
            return;
          return port;
        },
        _Uri__makeHost: function(host, start, end, strictIPv6) {
          var t1, i;
          if (start === end)
            return "";
          if (C.JSString_methods.codeUnitAt$1(host, start) === 91) {
            if (typeof end !== "number")
              return end.$sub();
            t1 = end - 1;
            if (C.JSString_methods.codeUnitAt$1(host, t1) !== 93)
              P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
            P.Uri_parseIPv6Address(host, start + 1, t1);
            return C.JSString_methods.substring$2(host, start, end).toLowerCase();
          }
          if (typeof end !== "number")
            return H.iae(end);
          i = start;
          for (; i < end; ++i)
            if (C.JSString_methods.codeUnitAt$1(host, i) === 58) {
              P.Uri_parseIPv6Address(host, start, end);
              return "[" + host + "]";
            }
          return P._Uri__normalizeRegName(host, start, end);
        },
        _Uri__normalizeRegName: function(host, start, end) {
          var index, sectionStart, buffer, isNormalized, char, replacement, t1, slice, t2, sourceLength, tail;
          if (typeof end !== "number")
            return H.iae(end);
          index = start;
          sectionStart = index;
          buffer = null;
          isNormalized = true;
          for (; index < end;) {
            char = C.JSString_methods.codeUnitAt$1(host, index);
            if (char === 37) {
              replacement = P._Uri__normalizeEscape(host, index, true);
              t1 = replacement == null;
              if (t1 && isNormalized) {
                index += 3;
                continue;
              }
              if (buffer == null)
                buffer = new P.StringBuffer("");
              slice = C.JSString_methods.substring$2(host, sectionStart, index);
              t2 = buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
              if (t1) {
                replacement = C.JSString_methods.substring$2(host, index, index + 3);
                sourceLength = 3;
              } else if (replacement === "%") {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
              buffer._contents = t2 + replacement;
              index += sourceLength;
              sectionStart = index;
              isNormalized = true;
            } else {
              if (char < 127) {
                t1 = char >>> 4;
                if (t1 >= 8)
                  return H.ioore(C.List_qNA, t1);
                t1 = (C.List_qNA[t1] & 1 << (char & 15)) !== 0;
              } else
                t1 = false;
              if (t1) {
                if (isNormalized && 65 <= char && 90 >= char) {
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  if (sectionStart < index) {
                    buffer._contents += C.JSString_methods.substring$2(host, sectionStart, index);
                    sectionStart = index;
                  }
                  isNormalized = false;
                }
                ++index;
              } else {
                if (char <= 93) {
                  t1 = char >>> 4;
                  if (t1 >= 8)
                    return H.ioore(C.List_2Vk, t1);
                  t1 = (C.List_2Vk[t1] & 1 << (char & 15)) !== 0;
                } else
                  t1 = false;
                if (t1)
                  P._Uri__fail(host, index, "Invalid character");
                else {
                  if ((char & 64512) === 55296 && index + 1 < end) {
                    tail = C.JSString_methods.codeUnitAt$1(host, index + 1);
                    if ((tail & 64512) === 56320) {
                      char = 65536 | (char & 1023) << 10 | tail & 1023;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  slice = C.JSString_methods.substring$2(host, sectionStart, index);
                  buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
                  buffer._contents += P._Uri__escapeChar(char);
                  index += sourceLength;
                  sectionStart = index;
                }
              }
            }
          }
          if (buffer == null)
            return C.JSString_methods.substring$2(host, start, end);
          if (sectionStart < end) {
            slice = C.JSString_methods.substring$2(host, sectionStart, end);
            buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          }
          t1 = buffer._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        },
        _Uri__makeScheme: function(scheme, start, end) {
          var i, containsUpperCase, codeUnit, t1;
          if (start === end)
            return "";
          if (!P._Uri__isAlphabeticCharacter(C.JSString_methods._codeUnitAt$1(scheme, start)))
            P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
          if (typeof end !== "number")
            return H.iae(end);
          i = start;
          containsUpperCase = false;
          for (; i < end; ++i) {
            codeUnit = C.JSString_methods._codeUnitAt$1(scheme, i);
            if (codeUnit < 128) {
              t1 = codeUnit >>> 4;
              if (t1 >= 8)
                return H.ioore(C.List_JYB, t1);
              t1 = (C.List_JYB[t1] & 1 << (codeUnit & 15)) !== 0;
            } else
              t1 = false;
            if (!t1)
              P._Uri__fail(scheme, i, "Illegal scheme character");
            if (65 <= codeUnit && codeUnit <= 90)
              containsUpperCase = true;
          }
          scheme = C.JSString_methods.substring$2(scheme, start, end);
          return P._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
        },
        _Uri__canonicalizeScheme: function(scheme) {
          if (scheme === "http")
            return "http";
          if (scheme === "file")
            return "file";
          if (scheme === "https")
            return "https";
          if (scheme === "package")
            return "package";
          return scheme;
        },
        _Uri__makeUserInfo: function(userInfo, start, end) {
          var t1 = P._Uri__normalize(userInfo, start, end, C.List_gRj, false);
          return t1 == null ? C.JSString_methods.substring$2(userInfo, start, end) : t1;
        },
        _Uri__makePath: function(path, start, end, pathSegments, scheme, hasAuthority) {
          var isFile, ensureLeadingSlash, result;
          isFile = scheme === "file";
          ensureLeadingSlash = isFile || hasAuthority;
          result = P._Uri__normalize(path, start, end, C.List_qg4, false);
          if (result == null)
            result = C.JSString_methods.substring$2(path, start, end);
          if (result.length === 0) {
            if (isFile)
              return "/";
          } else if (ensureLeadingSlash && !C.JSString_methods.startsWith$1(result, "/"))
            result = "/" + result;
          return P._Uri__normalizePath(result, scheme, hasAuthority);
        },
        _Uri__normalizePath: function(path, scheme, hasAuthority) {
          var t1 = scheme.length === 0;
          if (t1 && !hasAuthority && !C.JSString_methods.startsWith$1(path, "/"))
            return P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
          return P._Uri__removeDotSegments(path);
        },
        _Uri__makeQuery: function(query, start, end, queryParameters) {
          var t1 = P._Uri__normalize(query, start, end, C.List_CVk, false);
          return t1 == null ? C.JSString_methods.substring$2(query, start, end) : t1;
        },
        _Uri__makeFragment: function(fragment, start, end) {
          var t1 = P._Uri__normalize(fragment, start, end, C.List_CVk, false);
          return t1 == null ? C.JSString_methods.substring$2(fragment, start, end) : t1;
        },
        _Uri__normalizeEscape: function(source, index, lowerCase) {
          var t1, t2, t3, firstDigit, secondDigit, firstDigitValue, secondDigitValue, value;
          if (typeof index !== "number")
            return index.$add();
          t1 = index + 2;
          t2 = J.getInterceptor$asx(source);
          t3 = t2.get$length(source);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1 >= t3)
            return "%";
          firstDigit = t2.codeUnitAt$1(source, index + 1);
          secondDigit = t2.codeUnitAt$1(source, t1);
          firstDigitValue = H.hexDigitValue(firstDigit);
          secondDigitValue = H.hexDigitValue(secondDigit);
          if (firstDigitValue < 0 || secondDigitValue < 0)
            return "%";
          value = firstDigitValue * 16 + secondDigitValue;
          if (value < 127) {
            t1 = C.JSInt_methods._shrOtherPositive$1(value, 4);
            if (t1 >= 8)
              return H.ioore(C.List_nxB, t1);
            t1 = (C.List_nxB[t1] & 1 << (value & 15)) !== 0;
          } else
            t1 = false;
          if (t1)
            return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
          if (firstDigit >= 97 || secondDigit >= 97)
            return t2.substring$2(source, index, index + 3).toUpperCase();
          return;
        },
        _Uri__escapeChar: function(char) {
          var codeUnits, flag, encodedBytes, t1, index, byte, t2, t3;
          if (char < 128) {
            codeUnits = new Array(3);
            codeUnits.fixed$length = Array;
            codeUnits[0] = 37;
            codeUnits[1] = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", char >>> 4);
            codeUnits[2] = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", char & 15);
          } else {
            if (char > 2047)
              if (char > 65535) {
                flag = 240;
                encodedBytes = 4;
              } else {
                flag = 224;
                encodedBytes = 3;
              }
            else {
              flag = 192;
              encodedBytes = 2;
            }
            t1 = 3 * encodedBytes;
            codeUnits = new Array(t1);
            codeUnits.fixed$length = Array;
            for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
              byte = C.JSInt_methods._shrReceiverPositive$1(char, 6 * encodedBytes) & 63 | flag;
              if (index >= t1)
                return H.ioore(codeUnits, index);
              codeUnits[index] = 37;
              t2 = index + 1;
              t3 = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte >>> 4);
              if (t2 >= t1)
                return H.ioore(codeUnits, t2);
              codeUnits[t2] = t3;
              t3 = index + 2;
              t2 = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte & 15);
              if (t3 >= t1)
                return H.ioore(codeUnits, t3);
              codeUnits[t3] = t2;
              index += 3;
            }
          }
          return P.String_String$fromCharCodes(codeUnits, 0, null);
        },
        _Uri__normalize: function(component, start, end, charTable, escapeDelimiters) {
          var t1, t2, index, sectionStart, buffer, char, t3, replacement, sourceLength, tail;
          t1 = J.getInterceptor$s(component);
          t2 = !escapeDelimiters;
          index = start;
          sectionStart = index;
          buffer = null;
          while (true) {
            if (typeof index !== "number")
              return index.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(index < end))
              break;
            c$0: {
              char = t1.codeUnitAt$1(component, index);
              if (char < 127) {
                t3 = char >>> 4;
                if (t3 >= 8)
                  return H.ioore(charTable, t3);
                t3 = (charTable[t3] & 1 << (char & 15)) !== 0;
              } else
                t3 = false;
              if (t3)
                ++index;
              else {
                if (char === 37) {
                  replacement = P._Uri__normalizeEscape(component, index, false);
                  if (replacement == null) {
                    index += 3;
                    break c$0;
                  }
                  if ("%" === replacement) {
                    replacement = "%25";
                    sourceLength = 1;
                  } else
                    sourceLength = 3;
                } else {
                  if (t2)
                    if (char <= 93) {
                      t3 = char >>> 4;
                      if (t3 >= 8)
                        return H.ioore(C.List_2Vk, t3);
                      t3 = (C.List_2Vk[t3] & 1 << (char & 15)) !== 0;
                    } else
                      t3 = false;
                  else
                    t3 = false;
                  if (t3) {
                    P._Uri__fail(component, index, "Invalid character");
                    replacement = null;
                    sourceLength = null;
                  } else {
                    if ((char & 64512) === 55296) {
                      t3 = index + 1;
                      if (t3 < end) {
                        tail = t1.codeUnitAt$1(component, t3);
                        if ((tail & 64512) === 56320) {
                          char = 65536 | (char & 1023) << 10 | tail & 1023;
                          sourceLength = 2;
                        } else
                          sourceLength = 1;
                      } else
                        sourceLength = 1;
                    } else
                      sourceLength = 1;
                    replacement = P._Uri__escapeChar(char);
                  }
                }
                if (buffer == null)
                  buffer = new P.StringBuffer("");
                buffer._contents += t1.substring$2(component, sectionStart, index);
                buffer._contents += H.S(replacement);
                if (typeof sourceLength !== "number")
                  return H.iae(sourceLength);
                index += sourceLength;
                sectionStart = index;
              }
            }
          }
          if (buffer == null)
            return;
          if (typeof sectionStart !== "number")
            return sectionStart.$lt();
          if (sectionStart < end)
            buffer._contents += t1.substring$2(component, sectionStart, end);
          t1 = buffer._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        },
        _Uri__mayContainDotSegments: function(path) {
          if (C.JSString_methods.startsWith$1(path, "."))
            return true;
          return C.JSString_methods.indexOf$1(path, "/.") !== -1;
        },
        _Uri__removeDotSegments: function(path) {
          var output, t1, t2, appendSlash, _i, segment, t3;
          if (!P._Uri__mayContainDotSegments(path))
            return path;
          output = [];
          for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            segment = t1[_i];
            if (J.$eq$(segment, "..")) {
              t3 = output.length;
              if (t3 !== 0) {
                if (0 >= t3)
                  return H.ioore(output, -1);
                output.pop();
                if (output.length === 0)
                  output.push("");
              }
              appendSlash = true;
            } else if ("." === segment)
              appendSlash = true;
            else {
              output.push(segment);
              appendSlash = false;
            }
          }
          if (appendSlash)
            output.push("");
          return C.JSArray_methods.join$1(output, "/");
        },
        _Uri__normalizeRelativePath: function(path, allowScheme) {
          var output, t1, t2, appendSlash, _i, segment;
          if (!P._Uri__mayContainDotSegments(path))
            return !allowScheme ? P._Uri__escapeScheme(path) : path;
          output = [];
          for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            segment = t1[_i];
            if (".." === segment)
              if (output.length !== 0 && !J.$eq$(C.JSArray_methods.get$last(output), "..")) {
                if (0 >= output.length)
                  return H.ioore(output, -1);
                output.pop();
                appendSlash = true;
              } else {
                output.push("..");
                appendSlash = false;
              }
            else if ("." === segment)
              appendSlash = true;
            else {
              output.push(segment);
              appendSlash = false;
            }
          }
          t1 = output.length;
          if (t1 !== 0)
            if (t1 === 1) {
              if (0 >= t1)
                return H.ioore(output, 0);
              t1 = J.get$isEmpty$asx(output[0]) === true;
            } else
              t1 = false;
          else
            t1 = true;
          if (t1)
            return "./";
          if (appendSlash || J.$eq$(C.JSArray_methods.get$last(output), ".."))
            output.push("");
          if (!allowScheme) {
            if (0 >= output.length)
              return H.ioore(output, 0);
            t1 = P._Uri__escapeScheme(output[0]);
            if (0 >= output.length)
              return H.ioore(output, 0);
            output[0] = t1;
          }
          return C.JSArray_methods.join$1(output, "/");
        },
        _Uri__escapeScheme: function(path) {
          var t1, i, t2, char;
          t1 = J.getInterceptor$asx(path);
          if (J.$ge$n(t1.get$length(path), 2) && P._Uri__isAlphabeticCharacter(t1.codeUnitAt$1(path, 0))) {
            i = 1;
            while (true) {
              t2 = t1.get$length(path);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              char = t1.codeUnitAt$1(path, i);
              if (char === 58)
                return t1.substring$2(path, 0, i) + "%3A" + t1.substring$1(path, i + 1);
              if (char <= 127) {
                t2 = char >>> 4;
                if (t2 >= 8)
                  return H.ioore(C.List_JYB, t2);
                t2 = (C.List_JYB[t2] & 1 << (char & 15)) === 0;
              } else
                t2 = true;
              if (t2)
                break;
              ++i;
            }
          }
          return path;
        },
        _Uri__hexCharPairToByte: function(s, pos) {
          var t1, byte, i, charCode;
          for (t1 = J.getInterceptor$s(s), byte = 0, i = 0; i < 2; ++i) {
            charCode = t1.codeUnitAt$1(s, pos + i);
            if (48 <= charCode && charCode <= 57)
              byte = byte * 16 + charCode - 48;
            else {
              charCode |= 32;
              if (97 <= charCode && charCode <= 102)
                byte = byte * 16 + charCode - 87;
              else
                throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
            }
          }
          return byte;
        },
        _Uri__uriDecode: function(text, start, end, encoding, plusToSpace) {
          var t1, i, simple, codeUnit, t2, bytes;
          if (typeof end !== "number")
            return H.iae(end);
          t1 = J.getInterceptor$asx(text);
          i = start;
          while (true) {
            if (!(i < end)) {
              simple = true;
              break;
            }
            codeUnit = t1.codeUnitAt$1(text, i);
            if (codeUnit <= 127)
              if (codeUnit !== 37)
                t2 = codeUnit === 43;
              else
                t2 = true;
            else
              t2 = true;
            if (t2) {
              simple = false;
              break;
            }
            ++i;
          }
          if (simple) {
            if (C.Utf8Codec_false !== encoding)
              t2 = false;
            else
              t2 = true;
            if (t2)
              return t1.substring$2(text, start, end);
            else
              bytes = new H.CodeUnits(t1.substring$2(text, start, end));
          } else {
            bytes = [];
            for (i = start; i < end; ++i) {
              codeUnit = t1.codeUnitAt$1(text, i);
              if (codeUnit > 127)
                throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
              if (codeUnit === 37) {
                t2 = t1.get$length(text);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                if (i + 3 > t2)
                  throw H.wrapException(P.ArgumentError$("Truncated URI"));
                bytes.push(P._Uri__hexCharPairToByte(text, i + 1));
                i += 2;
              } else if (codeUnit === 43)
                bytes.push(32);
              else
                bytes.push(codeUnit);
            }
          }
          return new P.Utf8Decoder(false).convert$1(bytes);
        },
        _Uri__isAlphabeticCharacter: function(codeUnit) {
          var lowerCase = codeUnit | 32;
          return 97 <= lowerCase && lowerCase <= 122;
        }
      }
    },
    closure: {
      "^": "Closure:0;uri,portStart",
      call$1: function(_) {
        var t1 = this.portStart;
        if (typeof t1 !== "number")
          return t1.$add();
        throw H.wrapException(new P.FormatException("Invalid port", this.uri, t1 + 1));
      }
    },
    UriData: {
      "^": "Object;_core$_text,_separatorIndices,_uriCache",
      get$uri: function() {
        var t1, t2, t3, queryIndex, end, t4, query, path;
        t1 = this._uriCache;
        if (t1 != null)
          return t1;
        t1 = this._separatorIndices;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t2 = this._core$_text;
        t1 = t1[0] + 1;
        t3 = J.getInterceptor$asx(t2);
        queryIndex = t3.indexOf$2(t2, "?", t1);
        end = t3.get$length(t2);
        if (queryIndex >= 0) {
          t4 = queryIndex + 1;
          query = P._Uri__normalize(t2, t4, end, C.List_CVk, false);
          if (query == null)
            query = t3.substring$2(t2, t4, end);
          end = queryIndex;
        } else
          query = null;
        path = P._Uri__normalize(t2, t1, end, C.List_qg4, false);
        t1 = new P._DataUri(this, "data", null, null, null, path == null ? t3.substring$2(t2, t1, end) : path, query, null, null, null, null, null, null);
        this._uriCache = t1;
        return t1;
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this._separatorIndices;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t2 = this._core$_text;
        return t1[0] === -1 ? "data:" + H.S(t2) : t2;
      },
      static: {
        UriData__parse: function(text, start, sourceUri) {
          var indices, t1, i, slashIndex, char, t2, equalsIndex, lastSeparator, data;
          indices = [start - 1];
          t1 = J.getInterceptor$asx(text);
          i = start;
          slashIndex = -1;
          char = null;
          while (true) {
            t2 = t1.get$length(text);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            c$0: {
              char = t1.codeUnitAt$1(text, i);
              if (char === 44 || char === 59)
                break;
              if (char === 47) {
                if (slashIndex < 0) {
                  slashIndex = i;
                  break c$0;
                }
                throw H.wrapException(new P.FormatException("Invalid MIME type", text, i));
              }
            }
            ++i;
          }
          if (slashIndex < 0 && i > start)
            throw H.wrapException(new P.FormatException("Invalid MIME type", text, i));
          for (; char !== 44;) {
            indices.push(i);
            ++i;
            equalsIndex = -1;
            while (true) {
              t2 = t1.get$length(text);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              char = t1.codeUnitAt$1(text, i);
              if (char === 61) {
                if (equalsIndex < 0)
                  equalsIndex = i;
              } else if (char === 59 || char === 44)
                break;
              ++i;
            }
            if (equalsIndex >= 0)
              indices.push(equalsIndex);
            else {
              lastSeparator = C.JSArray_methods.get$last(indices);
              if (char !== 44 || i !== lastSeparator + 7 || !t1.startsWith$2(text, "base64", lastSeparator + 1))
                throw H.wrapException(new P.FormatException("Expecting '='", text, i));
              break;
            }
          }
          indices.push(i);
          t2 = i + 1;
          if ((indices.length & 1) === 1)
            text = C.Base64Codec_Base64Encoder_false.normalize$3(0, text, t2, t1.get$length(text));
          else {
            data = P._Uri__normalize(text, t2, t1.get$length(text), C.List_CVk, true);
            if (data != null)
              text = t1.replaceRange$3(text, t2, t1.get$length(text), data);
          }
          return new P.UriData(text, indices, sourceUri);
        }
      }
    },
    _createTables_closure: {
      "^": "Closure:0;",
      call$1: function(_) {
        return new Uint8Array(H._checkLength(96));
      }
    },
    _createTables_build: {
      "^": "Closure:45;tables",
      call$2: function(state, defaultTransition) {
        var t1 = this.tables;
        if (state >= t1.length)
          return H.ioore(t1, state);
        t1 = t1[state];
        J.fillRange$3$ax(t1, 0, 96, defaultTransition);
        return t1;
      }
    },
    _createTables_setChars: {
      "^": "Closure:22;",
      call$3: function(target, chars, transition) {
        var t1, t2, i;
        for (t1 = chars.length, t2 = J.getInterceptor$ax(target), i = 0; i < t1; ++i)
          t2.$indexSet(target, C.JSString_methods._codeUnitAt$1(chars, i) ^ 96, transition);
      }
    },
    _createTables_setRange: {
      "^": "Closure:22;",
      call$3: function(target, range, transition) {
        var i, n, t1;
        for (i = C.JSString_methods._codeUnitAt$1(range, 0), n = C.JSString_methods._codeUnitAt$1(range, 1), t1 = J.getInterceptor$ax(target); i <= n; ++i)
          t1.$indexSet(target, (i ^ 96) >>> 0, transition);
      }
    },
    _SimpleUri: {
      "^": "Object;_uri,_schemeEnd,_hostStart,_portStart,_pathStart,_queryStart,_fragmentStart,_schemeCache,_hashCodeCache",
      get$hasAuthority: function() {
        return this._hostStart > 0;
      },
      get$hasQuery: function() {
        var t1, t2;
        t1 = this._queryStart;
        t2 = this._fragmentStart;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return t1 < t2;
      },
      get$hasFragment: function() {
        var t1 = this._fragmentStart;
        if (typeof t1 !== "number")
          return t1.$lt();
        return t1 < this._uri.length;
      },
      get$scheme: function() {
        var t1, t2;
        t1 = this._schemeEnd;
        if (typeof t1 !== "number")
          return t1.$le();
        if (t1 <= 0)
          return "";
        t2 = this._schemeCache;
        if (t2 != null)
          return t2;
        t2 = t1 === 4;
        if (t2 && C.JSString_methods.startsWith$1(this._uri, "http")) {
          this._schemeCache = "http";
          t1 = "http";
        } else if (t1 === 5 && C.JSString_methods.startsWith$1(this._uri, "https")) {
          this._schemeCache = "https";
          t1 = "https";
        } else if (t2 && C.JSString_methods.startsWith$1(this._uri, "file")) {
          this._schemeCache = "file";
          t1 = "file";
        } else if (t1 === 7 && C.JSString_methods.startsWith$1(this._uri, "package")) {
          this._schemeCache = "package";
          t1 = "package";
        } else {
          t1 = C.JSString_methods.substring$2(this._uri, 0, t1);
          this._schemeCache = t1;
        }
        return t1;
      },
      get$userInfo: function() {
        var t1, t2;
        t1 = this._hostStart;
        t2 = this._schemeEnd;
        if (typeof t2 !== "number")
          return t2.$add();
        t2 += 3;
        return t1 > t2 ? C.JSString_methods.substring$2(this._uri, t2, t1 - 1) : "";
      },
      get$host: function(_) {
        var t1 = this._hostStart;
        return t1 > 0 ? C.JSString_methods.substring$2(this._uri, t1, this._portStart) : "";
      },
      get$port: function(_) {
        var t1, t2;
        if (this._hostStart > 0) {
          t1 = this._portStart;
          if (typeof t1 !== "number")
            return t1.$add();
          t2 = this._pathStart;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 + 1 < t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1) {
          t1 = this._portStart;
          if (typeof t1 !== "number")
            return t1.$add();
          return H.Primitives_parseInt(C.JSString_methods.substring$2(this._uri, t1 + 1, this._pathStart), null, null);
        }
        t1 = this._schemeEnd;
        if (t1 === 4 && C.JSString_methods.startsWith$1(this._uri, "http"))
          return 80;
        if (t1 === 5 && C.JSString_methods.startsWith$1(this._uri, "https"))
          return 443;
        return 0;
      },
      get$path: function(_) {
        return C.JSString_methods.substring$2(this._uri, this._pathStart, this._queryStart);
      },
      get$query: function(_) {
        var t1, t2;
        t1 = this._queryStart;
        t2 = this._fragmentStart;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return t1 < t2 ? C.JSString_methods.substring$2(this._uri, t1 + 1, t2) : "";
      },
      get$fragment: function() {
        var t1, t2;
        t1 = this._fragmentStart;
        t2 = this._uri;
        if (typeof t1 !== "number")
          return t1.$lt();
        return t1 < t2.length ? C.JSString_methods.substring$1(t2, t1 + 1) : "";
      },
      get$queryParameters: function() {
        var t1, t2;
        t1 = this._queryStart;
        t2 = this._fragmentStart;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 >= t2)
          return C.Map_empty;
        t1 = P.String;
        return new P.UnmodifiableMapView(P.Uri_splitQueryString(this.get$query(this), C.Utf8Codec_false), [t1, t1]);
      },
      get$hashCode: function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = C.JSString_methods.get$hashCode(this._uri);
          this._hashCodeCache = t1;
        }
        return t1;
      },
      $eq: function(_, other) {
        var t1;
        if (other == null)
          return false;
        if (this === other)
          return true;
        t1 = J.getInterceptor(other);
        if (!!t1.$isUri)
          return this._uri === t1.toString$0(other);
        return false;
      },
      toString$0: function(_) {
        return this._uri;
      },
      $isUri: 1
    },
    _DataUri: {
      "^": "_Uri;_core$_data,scheme,_userInfo,_host,_port,path,_query,_fragment,_pathSegments,_core$_text,_hashCodeCache,_queryParameters,_queryParameterLists"
    }
  }], ["dart.dom.html", "dart:html",, W, {
    "^": "",
    window: function() {
      return window;
    },
    CanvasElement_CanvasElement: function(height, width) {
      var e = document.createElement("canvas");
      e.width = width;
      e.height = height;
      return e;
    },
    CssStyleDeclaration__camelCase: function(hyphenated) {
      return hyphenated.replace(/^-ms-/, "ms-").replace(/-([\da-z])/ig, function(_, letter) {
        return letter.toUpperCase();
      });
    },
    Element__determineMouseWheelEventType: [function(e) {
      return "wheel";
    }, "call$1", "html_Element__determineMouseWheelEventType$closure", 2, 0, 77, 0],
    _ElementFactoryProvider_createElement_tag: function(tag, typeExtension) {
      return document.createElement(tag);
    },
    HttpRequest_getString: function(url, onProgress, withCredentials) {
      return W.HttpRequest_request(url, null, null, onProgress, null, null, null, withCredentials).then$1(new W.HttpRequest_getString_closure());
    },
    HttpRequest_request: function(url, method, mimeType, onProgress, requestHeaders, responseType, sendData, withCredentials) {
      var t1, t2, completer, xhr;
      t1 = W.HttpRequest;
      t2 = new P._Future(0, $.Zone__current, null, [t1]);
      completer = new P._AsyncCompleter(t2, [t1]);
      xhr = new XMLHttpRequest();
      C.HttpRequest_methods.open$3$async(xhr, "GET", url, true);
      if (responseType != null)
        xhr.responseType = responseType;
      t1 = W.ProgressEvent;
      W._EventStreamSubscription$(xhr, "load", new W.HttpRequest_request_closure(completer, xhr), false, t1);
      W._EventStreamSubscription$(xhr, "error", completer.get$completeError(), false, t1);
      xhr.send();
      return t2;
    },
    ImageElement_ImageElement: function(height, src, width) {
      var e = document.createElement("img");
      return e;
    },
    _JenkinsSmiHash_combine: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    _JenkinsSmiHash_finish: function(hash) {
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    _convertNativeToDart_Window: function(win) {
      if (win == null)
        return;
      return W._DOMWindowCrossFrame__createSafe(win);
    },
    _convertNativeToDart_EventTarget: function(e) {
      var $window;
      if (e == null)
        return;
      if ("postMessage" in e) {
        $window = W._DOMWindowCrossFrame__createSafe(e);
        if (!!J.getInterceptor($window).$isEventTarget)
          return $window;
        return;
      } else
        return e;
    },
    _convertNativeToDart_XHR_Response: function(o) {
      var t1;
      if (!!J.getInterceptor(o).$isDocument)
        return o;
      t1 = new P._AcceptStructuredCloneDart2Js([], [], false);
      t1.mustCopy = true;
      return t1.walk$1(o);
    },
    _wrapZone: function(callback) {
      var t1 = $.Zone__current;
      if (t1 === C.C__RootZone)
        return callback;
      return t1.bindUnaryCallback$2$runGuarded(callback, true);
    },
    HtmlElement: {
      "^": "Element;",
      "%": "HTMLBRElement|HTMLContentElement|HTMLDListElement|HTMLDataListElement|HTMLDetailsElement|HTMLDialogElement|HTMLDirectoryElement|HTMLDivElement|HTMLFontElement|HTMLFrameElement|HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLLabelElement|HTMLLegendElement|HTMLMarqueeElement|HTMLModElement|HTMLOptGroupElement|HTMLParagraphElement|HTMLPictureElement|HTMLPreElement|HTMLQuoteElement|HTMLShadowElement|HTMLSpanElement|HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement|HTMLTableRowElement|HTMLTableSectionElement|HTMLTemplateElement|HTMLTitleElement|HTMLTrackElement|HTMLUListElement|HTMLUnknownElement;HTMLElement"
    },
    AnchorElement: {
      "^": "HtmlElement;target=,type=",
      toString$0: function(receiver) {
        return String(receiver);
      },
      $isInterceptor: 1,
      $isObject: 1,
      "%": "HTMLAnchorElement"
    },
    Animation: {
      "^": "EventTarget;id=,startTime%",
      "%": "Animation"
    },
    AnimationEffectTiming: {
      "^": "Interceptor;duration=",
      "%": "AnimationEffectTiming"
    },
    ApplicationCacheErrorEvent: {
      "^": "Event0;url=",
      "%": "ApplicationCacheErrorEvent"
    },
    AreaElement: {
      "^": "HtmlElement;target=",
      toString$0: function(receiver) {
        return String(receiver);
      },
      $isInterceptor: 1,
      $isObject: 1,
      "%": "HTMLAreaElement"
    },
    AudioTrack: {
      "^": "Interceptor;id=",
      $isObject: 1,
      "%": "AudioTrack"
    },
    AudioTrackList: {
      "^": "EventTarget_ListMixin_ImmutableListMixin;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.AudioTrack];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.AudioTrack];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.AudioTrack];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.AudioTrack];
      },
      "%": "AudioTrackList"
    },
    EventTarget_ListMixin: {
      "^": "EventTarget+ListMixin;",
      $asList: function() {
        return [W.AudioTrack];
      },
      $asEfficientLengthIterable: function() {
        return [W.AudioTrack];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    EventTarget_ListMixin_ImmutableListMixin: {
      "^": "EventTarget_ListMixin+ImmutableListMixin;",
      $asList: function() {
        return [W.AudioTrack];
      },
      $asEfficientLengthIterable: function() {
        return [W.AudioTrack];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    BarProp: {
      "^": "Interceptor;visible=",
      "%": "BarProp"
    },
    BaseElement: {
      "^": "HtmlElement;target=",
      "%": "HTMLBaseElement"
    },
    Blob: {
      "^": "Interceptor;type=",
      $isBlob: 1,
      "%": ";Blob"
    },
    Body: {
      "^": "Interceptor;",
      text$0: [function(receiver) {
        return receiver.text();
      }, "call$0", "get$text", 0, 0, 10],
      "%": "Response;Body"
    },
    BodyElement: {
      "^": "HtmlElement;",
      $isEventTarget: 1,
      $isInterceptor: 1,
      $isObject: 1,
      "%": "HTMLBodyElement"
    },
    ButtonElement: {
      "^": "HtmlElement;name=,type=,value=",
      "%": "HTMLButtonElement"
    },
    CacheStorage: {
      "^": "Interceptor;",
      keys$0: [function(receiver) {
        return receiver.keys();
      }, "call$0", "get$keys", 0, 0, 10],
      "%": "CacheStorage"
    },
    CanvasElement: {
      "^": "HtmlElement;height=,width%",
      getContext$2: function(receiver, contextId, attributes) {
        var t1 = receiver.getContext(contextId, P.convertDartToNative_Dictionary(attributes, null));
        return t1;
      },
      get$context2D: function(receiver) {
        return receiver.getContext("2d");
      },
      getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil: function(receiver, alpha, antialias, depth, premultipliedAlpha, preserveDrawingBuffer, stencil) {
        var options, context;
        options = P.LinkedHashMap__makeLiteral(["alpha", false, "depth", false, "stencil", true, "antialias", false, "premultipliedAlpha", true, "preserveDrawingBuffer", false]);
        context = this.getContext$2(receiver, "webgl", options);
        return context == null ? this.getContext$2(receiver, "experimental-webgl", options) : context;
      },
      $isCanvasElement: 1,
      $isObject: 1,
      "%": "HTMLCanvasElement"
    },
    CanvasRenderingContext2D: {
      "^": "Interceptor;globalAlpha=",
      putImageData$7: function(receiver, imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
        receiver.putImageData(P.convertDartToNative_ImageData(imagedata), dx, dy);
        return;
      },
      putImageData$3: function($receiver, imagedata, dx, dy) {
        return this.putImageData$7($receiver, imagedata, dx, dy, null, null, null, null);
      },
      $isObject: 1,
      "%": "CanvasRenderingContext2D"
    },
    CharacterData: {
      "^": "Node;length=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "CDATASection|Comment|Text;CharacterData"
    },
    Client: {
      "^": "Interceptor;id=,url=",
      "%": "Client|WindowClient"
    },
    CompositorWorker: {
      "^": "EventTarget;",
      $isEventTarget: 1,
      $isInterceptor: 1,
      $isObject: 1,
      "%": "CompositorWorker"
    },
    Credential: {
      "^": "Interceptor;id=,name=,type=",
      "%": "Credential|FederatedCredential|PasswordCredential"
    },
    CryptoKey: {
      "^": "Interceptor;type=",
      "%": "CryptoKey"
    },
    CssFontFaceRule: {
      "^": "CssRule;style=",
      "%": "CSSFontFaceRule"
    },
    CssKeyframeRule: {
      "^": "CssRule;style=",
      "%": "CSSKeyframeRule|MozCSSKeyframeRule|WebKitCSSKeyframeRule"
    },
    CssKeyframesRule: {
      "^": "CssRule;name=",
      "%": "CSSKeyframesRule|MozCSSKeyframesRule|WebKitCSSKeyframesRule"
    },
    CssPageRule: {
      "^": "CssRule;style=",
      "%": "CSSPageRule"
    },
    CssRule: {
      "^": "Interceptor;type=",
      $isObject: 1,
      "%": "CSSCharsetRule|CSSGroupingRule|CSSImportRule|CSSMediaRule|CSSNamespaceRule|CSSSupportsRule;CSSRule"
    },
    CssStyleDeclaration: {
      "^": "Interceptor_CssStyleDeclarationBase;length=",
      getPropertyValue$1: function(receiver, propertyName) {
        var propValue = this._getPropertyValueHelper$1(receiver, propertyName);
        return propValue != null ? propValue : "";
      },
      _getPropertyValueHelper$1: function(receiver, propertyName) {
        if (W.CssStyleDeclaration__camelCase(propertyName) in receiver)
          return receiver.getPropertyValue(propertyName);
        else
          return receiver.getPropertyValue(P.Device_cssPrefix() + propertyName);
      },
      setProperty$3: function(receiver, propertyName, value, priority) {
        var t1 = this._browserPropertyName$1(receiver, propertyName);
        receiver.setProperty(t1, value, priority);
        return;
      },
      _browserPropertyName$1: function(receiver, propertyName) {
        var t1, $name;
        t1 = $.$get$CssStyleDeclaration__propertyCache();
        $name = t1[propertyName];
        if (typeof $name === "string")
          return $name;
        $name = W.CssStyleDeclaration__camelCase(propertyName) in receiver ? propertyName : P.Device_cssPrefix() + propertyName;
        t1[propertyName] = $name;
        return $name;
      },
      set$display: function(receiver, value) {
        receiver.display = value;
      },
      set$font: function(receiver, value) {
        receiver.font = value;
      },
      get$height: function(receiver) {
        return receiver.height;
      },
      set$height: function(receiver, value) {
        receiver.height = value;
      },
      set$verticalAlign: function(receiver, value) {
        receiver.verticalAlign = value;
      },
      get$width: function(receiver) {
        return receiver.width;
      },
      set$width: function(receiver, value) {
        receiver.width = value;
      },
      "%": "CSS2Properties|CSSStyleDeclaration|MSStyleCSSProperties"
    },
    Interceptor_CssStyleDeclarationBase: {
      "^": "Interceptor+CssStyleDeclarationBase;"
    },
    _CssStyleDeclarationSet: {
      "^": "Object_CssStyleDeclarationBase;_elementIterable,_elementCssStyleDeclarationSetIterable",
      getPropertyValue$1: function(_, propertyName) {
        var t1 = this._elementCssStyleDeclarationSetIterable;
        return J.getPropertyValue$1$x(t1.get$first(t1), propertyName);
      },
      setProperty$3: function(_, propertyName, value, priority) {
        this._elementCssStyleDeclarationSetIterable.forEach$1(0, new W._CssStyleDeclarationSet_setProperty_closure(propertyName, value, priority));
      },
      _setAll$2: function(propertyName, value) {
        var t1;
        for (t1 = this._elementIterable, t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null); t1.moveNext$0();)
          t1.__internal$_current.style[propertyName] = value;
      },
      set$display: function(_, value) {
        this._setAll$2("display", value);
      },
      set$font: function(_, value) {
        this._setAll$2("font", value);
      },
      set$height: function(_, value) {
        this._setAll$2("height", value);
      },
      set$verticalAlign: function(_, value) {
        this._setAll$2("verticalAlign", value);
      },
      set$width: function(_, value) {
        this._setAll$2("width", value);
      },
      _CssStyleDeclarationSet$1: function(_elementIterable) {
        var t1 = P.List_List$from(this._elementIterable, true, null);
        this._elementCssStyleDeclarationSetIterable = new H.MappedListIterable(t1, new W._CssStyleDeclarationSet_closure(), [H.getTypeArgumentByIndex(t1, 0), null]);
      },
      static: {
        _CssStyleDeclarationSet$: function(_elementIterable) {
          var t1 = new W._CssStyleDeclarationSet(_elementIterable, null);
          t1._CssStyleDeclarationSet$1(_elementIterable);
          return t1;
        }
      }
    },
    Object_CssStyleDeclarationBase: {
      "^": "Object+CssStyleDeclarationBase;"
    },
    _CssStyleDeclarationSet_closure: {
      "^": "Closure:0;",
      call$1: [function(e) {
        return J.get$style$x(e);
      }, null, null, 2, 0, null, 0, "call"]
    },
    _CssStyleDeclarationSet_setProperty_closure: {
      "^": "Closure:0;propertyName,value,priority",
      call$1: function(e) {
        return J.setProperty$3$x(e, this.propertyName, this.value, this.priority);
      }
    },
    CssStyleDeclarationBase: {
      "^": "Object;",
      get$height: function(receiver) {
        return this.getPropertyValue$1(receiver, "height");
      },
      get$mask: function(receiver) {
        return this.getPropertyValue$1(receiver, "mask");
      },
      get$width: function(receiver) {
        return this.getPropertyValue$1(receiver, "width");
      },
      set$width: function(receiver, value) {
        this.setProperty$3(receiver, "width", value, "");
      }
    },
    CssStyleRule: {
      "^": "CssRule;style=",
      "%": "CSSStyleRule"
    },
    CssViewportRule: {
      "^": "CssRule;style=",
      "%": "CSSViewportRule"
    },
    DataTransferItem: {
      "^": "Interceptor;type=",
      "%": "DataTransferItem"
    },
    DataTransferItemList: {
      "^": "Interceptor;length=",
      $index: function(receiver, index) {
        return receiver[index];
      },
      "%": "DataTransferItemList"
    },
    DeviceAcceleration: {
      "^": "Interceptor;x=,y=",
      "%": "DeviceAcceleration"
    },
    DeviceLightEvent: {
      "^": "Event0;value=",
      "%": "DeviceLightEvent"
    },
    DeviceOrientationEvent: {
      "^": "Event0;alpha=",
      "%": "DeviceOrientationEvent"
    },
    DeviceRotationRate: {
      "^": "Interceptor;alpha=",
      "%": "DeviceRotationRate"
    },
    Document: {
      "^": "Node;",
      querySelector$1: function(receiver, selectors) {
        return receiver.querySelector(selectors);
      },
      _querySelectorAll$1: function(receiver, selectors) {
        return receiver.querySelectorAll(selectors);
      },
      querySelectorAll$1: function(receiver, selectors) {
        return new W._FrozenElementList(receiver.querySelectorAll(selectors), [null]);
      },
      $isDocument: 1,
      "%": "Document|HTMLDocument|XMLDocument"
    },
    DocumentFragment: {
      "^": "Node;",
      querySelectorAll$1: function(receiver, selectors) {
        return new W._FrozenElementList(receiver.querySelectorAll(selectors), [null]);
      },
      querySelector$1: function(receiver, selectors) {
        return receiver.querySelector(selectors);
      },
      _querySelectorAll$1: function(receiver, selectors) {
        return receiver.querySelectorAll(selectors);
      },
      $isInterceptor: 1,
      $isObject: 1,
      "%": "DocumentFragment|ShadowRoot"
    },
    DomError: {
      "^": "Interceptor;name=",
      "%": "DOMError|FileError"
    },
    DomException: {
      "^": "Interceptor;",
      get$name: function(receiver) {
        var errorName = receiver.name;
        if (P.Device_isWebKit() === true && errorName === "SECURITY_ERR")
          return "SecurityError";
        if (P.Device_isWebKit() === true && errorName === "SYNTAX_ERR")
          return "SyntaxError";
        return errorName;
      },
      toString$0: function(receiver) {
        return String(receiver);
      },
      "%": "DOMException"
    },
    DomIterator: {
      "^": "Interceptor;",
      next$1: [function(receiver, value) {
        return receiver.next(value);
      }, function($receiver) {
        return $receiver.next();
      }, "next$0", "call$1", "call$0", "get$next", 0, 2, 50, 1, 3],
      "%": "Iterator"
    },
    DomParser: {
      "^": "Interceptor;",
      parseFromString$2: function(receiver, str, type) {
        return receiver.parseFromString(str, type);
      },
      "%": "DOMParser"
    },
    DomPoint: {
      "^": "DomPointReadOnly;",
      get$x: function(receiver) {
        return receiver.x;
      },
      set$x: function(receiver, value) {
        receiver.x = value;
      },
      get$y: function(receiver) {
        return receiver.y;
      },
      set$y: function(receiver, value) {
        receiver.y = value;
      },
      "%": "DOMPoint"
    },
    DomPointReadOnly: {
      "^": "Interceptor;",
      get$x: function(receiver) {
        return receiver.x;
      },
      get$y: function(receiver) {
        return receiver.y;
      },
      "%": ";DOMPointReadOnly"
    },
    DomRectReadOnly: {
      "^": "Interceptor;",
      toString$0: function(receiver) {
        return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
      },
      $eq: function(receiver, other) {
        var t1;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        if (!t1.$isRectangle)
          return false;
        return receiver.left === t1.get$left(other) && receiver.top === t1.get$top(other) && this.get$width(receiver) === t1.get$width(other) && this.get$height(receiver) === t1.get$height(other);
      },
      get$hashCode: function(receiver) {
        var t1, t2, t3, t4;
        t1 = receiver.left;
        t2 = receiver.top;
        t3 = this.get$width(receiver);
        t4 = this.get$height(receiver);
        return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1 & 0x1FFFFFFF), t2 & 0x1FFFFFFF), t3 & 0x1FFFFFFF), t4 & 0x1FFFFFFF));
      },
      get$bottom: function(receiver) {
        return receiver.bottom;
      },
      get$height: function(receiver) {
        return receiver.height;
      },
      get$left: function(receiver) {
        return receiver.left;
      },
      get$right: function(receiver) {
        return receiver.right;
      },
      get$top: function(receiver) {
        return receiver.top;
      },
      get$width: function(receiver) {
        return receiver.width;
      },
      get$x: function(receiver) {
        return receiver.x;
      },
      get$y: function(receiver) {
        return receiver.y;
      },
      $isRectangle: 1,
      $asRectangle: Isolate.functionThatReturnsNull,
      $isObject: 1,
      "%": ";DOMRectReadOnly"
    },
    DomStringList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [P.String];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [P.String];
      },
      "%": "DOMStringList"
    },
    Interceptor_ListMixin: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [P.String];
      },
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin: {
      "^": "Interceptor_ListMixin+ImmutableListMixin;",
      $asList: function() {
        return [P.String];
      },
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    DomTokenList: {
      "^": "Interceptor;length=,value=",
      "%": "DOMTokenList"
    },
    _FrozenElementList: {
      "^": "ListBase;_nodeList,$ti",
      get$length: function(_) {
        return this._nodeList.length;
      },
      $index: function(_, index) {
        var t1 = this._nodeList;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return t1[index];
      },
      $indexSet: function(_, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify list"));
      },
      set$length: function(_, newLength) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify list"));
      },
      get$style: function(_) {
        return W._CssStyleDeclarationSet$(this);
      },
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null
    },
    Element: {
      "^": "Node;style=,id=,_namespaceUri:namespaceURI=,tagName=",
      get$attributes: function(receiver) {
        return new W._ElementAttributeMap(receiver);
      },
      querySelectorAll$1: function(receiver, selectors) {
        return new W._FrozenElementList(receiver.querySelectorAll(selectors), [null]);
      },
      get$client: function(receiver) {
        return P.Rectangle$(receiver.clientLeft, receiver.clientTop, receiver.clientWidth, receiver.clientHeight, null);
      },
      toString$0: function(receiver) {
        return receiver.localName;
      },
      get$offsetTop: function(receiver) {
        return C.JSNumber_methods.round$0(receiver.offsetTop);
      },
      getAttribute$1: function(receiver, $name) {
        return receiver.getAttribute($name);
      },
      querySelector$1: function(receiver, selectors) {
        return receiver.querySelector(selectors);
      },
      _querySelectorAll$1: function(receiver, selectors) {
        return receiver.querySelectorAll(selectors);
      },
      $isElement: 1,
      $isEventTarget: 1,
      $isObject: 1,
      $isInterceptor: 1,
      "%": ";Element"
    },
    EmbedElement: {
      "^": "HtmlElement;height=,name=,type=,width%",
      "%": "HTMLEmbedElement"
    },
    Entry: {
      "^": "Interceptor;name=",
      _html$_remove$2: function(receiver, successCallback, errorCallback) {
        return receiver.remove(H.convertDartClosureToJS(successCallback, 0), H.convertDartClosureToJS(errorCallback, 1));
      },
      remove$0: function(receiver) {
        var t1, completer;
        t1 = new P._Future(0, $.Zone__current, null, [null]);
        completer = new P._AsyncCompleter(t1, [null]);
        this._html$_remove$2(receiver, new W.Entry_remove_closure(completer), new W.Entry_remove_closure0(completer));
        return t1;
      },
      "%": "DirectoryEntry|Entry|FileEntry"
    },
    Entry_remove_closure: {
      "^": "Closure:1;completer",
      call$0: [function() {
        this.completer.complete$0(0);
      }, null, null, 0, 0, null, "call"]
    },
    Entry_remove_closure0: {
      "^": "Closure:0;completer",
      call$1: [function(error) {
        this.completer.completeError$1(error);
      }, null, null, 2, 0, null, 2, "call"]
    },
    ErrorEvent: {
      "^": "Event0;error=",
      "%": "ErrorEvent"
    },
    Event0: {
      "^": "Interceptor;type=",
      get$currentTarget: function(receiver) {
        return W._convertNativeToDart_EventTarget(receiver.currentTarget);
      },
      get$target: function(receiver) {
        return W._convertNativeToDart_EventTarget(receiver.target);
      },
      preventDefault$0: function(receiver) {
        return receiver.preventDefault();
      },
      stopImmediatePropagation$0: function(receiver) {
        return receiver.stopImmediatePropagation();
      },
      stopPropagation$0: function(receiver) {
        return receiver.stopPropagation();
      },
      $isEvent0: 1,
      $isObject: 1,
      "%": "AnimationEvent|AnimationPlayerEvent|AutocompleteErrorEvent|BeforeInstallPromptEvent|BeforeUnloadEvent|BlobEvent|ClipboardEvent|CloseEvent|CustomEvent|DeviceMotionEvent|ExtendableEvent|ExtendableMessageEvent|FetchEvent|FontFaceSetLoadEvent|GamepadEvent|HashChangeEvent|IDBVersionChangeEvent|InstallEvent|MIDIConnectionEvent|MIDIMessageEvent|MediaEncryptedEvent|MediaKeyMessageEvent|MediaQueryListEvent|MediaStreamEvent|MediaStreamTrackEvent|MessageEvent|NotificationEvent|OfflineAudioCompletionEvent|PageTransitionEvent|PopStateEvent|PresentationConnectionAvailableEvent|PresentationConnectionCloseEvent|PromiseRejectionEvent|PushEvent|RTCDTMFToneChangeEvent|RTCDataChannelEvent|RTCIceCandidateEvent|RTCPeerConnectionIceEvent|RelatedEvent|SecurityPolicyViolationEvent|ServicePortConnectEvent|ServiceWorkerMessageEvent|SpeechRecognitionEvent|SyncEvent|TrackEvent|TransitionEvent|USBConnectionEvent|WebKitTransitionEvent;Event|InputEvent"
    },
    EventSource: {
      "^": "EventTarget;url=",
      "%": "EventSource"
    },
    EventTarget: {
      "^": "Interceptor;",
      addEventListener$3: function(receiver, type, listener, useCapture) {
        if (listener != null)
          this._addEventListener$3(receiver, type, listener, useCapture);
      },
      addEventListener$2: function($receiver, type, listener) {
        return this.addEventListener$3($receiver, type, listener, null);
      },
      removeEventListener$3: function(receiver, type, listener, useCapture) {
        if (listener != null)
          this._removeEventListener$3(receiver, type, listener, false);
      },
      _addEventListener$3: function(receiver, type, listener, options) {
        return receiver.addEventListener(type, H.convertDartClosureToJS(listener, 1), options);
      },
      dispatchEvent$1: function(receiver, $event) {
        return receiver.dispatchEvent($event);
      },
      _removeEventListener$3: function(receiver, type, listener, options) {
        return receiver.removeEventListener(type, H.convertDartClosureToJS(listener, 1), false);
      },
      $isEventTarget: 1,
      $isObject: 1,
      "%": "ApplicationCache|BatteryManager|BluetoothDevice|BluetoothRemoteGATTCharacteristic|CrossOriginServiceWorkerClient|DOMApplicationCache|MIDIAccess|MediaQueryList|Notification|OfflineResourceList|Performance|PermissionStatus|PresentationReceiver|RTCPeerConnection|ServicePortCollection|ServiceWorkerContainer|ServiceWorkerRegistration|SpeechSynthesis|USB|WorkerPerformance|mozRTCPeerConnection|webkitRTCPeerConnection;EventTarget;EventTarget_ListMixin|EventTarget_ListMixin_ImmutableListMixin|EventTarget_ListMixin0|EventTarget_ListMixin_ImmutableListMixin0|EventTarget_ListMixin1|EventTarget_ListMixin_ImmutableListMixin1"
    },
    FieldSetElement: {
      "^": "HtmlElement;name=,type=",
      "%": "HTMLFieldSetElement"
    },
    File: {
      "^": "Blob;name=",
      $isFile: 1,
      $isObject: 1,
      "%": "File"
    },
    FileList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin0;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isFileList: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.File];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.File];
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [W.File];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.File];
      },
      "%": "FileList"
    },
    Interceptor_ListMixin0: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.File];
      },
      $asEfficientLengthIterable: function() {
        return [W.File];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin0: {
      "^": "Interceptor_ListMixin0+ImmutableListMixin;",
      $asList: function() {
        return [W.File];
      },
      $asEfficientLengthIterable: function() {
        return [W.File];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    FileReader: {
      "^": "EventTarget;error=",
      get$result: function(receiver) {
        var res = receiver.result;
        if (!!J.getInterceptor(res).$isByteBuffer)
          return H.NativeUint8List_NativeUint8List$view(res, 0, null);
        return res;
      },
      "%": "FileReader"
    },
    FileStream: {
      "^": "Interceptor;type=",
      "%": "Stream"
    },
    FileSystem: {
      "^": "Interceptor;name=",
      "%": "DOMFileSystem"
    },
    FileWriter: {
      "^": "EventTarget;error=,length=",
      "%": "FileWriter"
    },
    FontFace: {
      "^": "Interceptor;loaded=,style%",
      "%": "FontFace"
    },
    FontFaceSet: {
      "^": "EventTarget;",
      forEach$2: function(receiver, callback, thisArg) {
        return receiver.forEach(H.convertDartClosureToJS(callback, 3), thisArg);
      },
      forEach$1: function($receiver, callback) {
        callback = H.convertDartClosureToJS(callback, 3);
        return $receiver.forEach(callback);
      },
      "%": "FontFaceSet"
    },
    FormElement: {
      "^": "HtmlElement;length=,name=,target=",
      "%": "HTMLFormElement"
    },
    Gamepad: {
      "^": "Interceptor;id=",
      $isObject: 1,
      "%": "Gamepad"
    },
    GamepadButton: {
      "^": "Interceptor;value=",
      "%": "GamepadButton"
    },
    GeofencingEvent: {
      "^": "Event0;id=",
      "%": "GeofencingEvent"
    },
    GeofencingRegion: {
      "^": "Interceptor;id=",
      "%": "CircularGeofencingRegion|GeofencingRegion"
    },
    History: {
      "^": "Interceptor;length=",
      $isObject: 1,
      "%": "History"
    },
    HtmlCollection: {
      "^": "Interceptor_ListMixin_ImmutableListMixin1;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Node];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Node];
      },
      "%": "HTMLCollection|HTMLFormControlsCollection|HTMLOptionsCollection"
    },
    Interceptor_ListMixin1: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.Node];
      },
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin1: {
      "^": "Interceptor_ListMixin1+ImmutableListMixin;",
      $asList: function() {
        return [W.Node];
      },
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    HttpRequest: {
      "^": "HttpRequestEventTarget;responseText=",
      open$5$async$password$user: function(receiver, method, url, async, password, user) {
        return receiver.open(method, url, true, user, password);
      },
      open$3$async: function($receiver, method, url, async) {
        return $receiver.open(method, url, async);
      },
      get$response: function(receiver) {
        return W._convertNativeToDart_XHR_Response(receiver.response);
      },
      send$1: function(receiver, body_OR_data) {
        return receiver.send(body_OR_data);
      },
      $isHttpRequest: 1,
      $isEventTarget: 1,
      $isObject: 1,
      "%": "XMLHttpRequest"
    },
    HttpRequest_getString_closure: {
      "^": "Closure:23;",
      call$1: [function(xhr) {
        return J.get$responseText$x(xhr);
      }, null, null, 2, 0, null, 28, "call"]
    },
    HttpRequest_request_closure: {
      "^": "Closure:0;completer,xhr",
      call$1: function(e) {
        var t1, t2, accepted, unknownRedirect, t3;
        t1 = this.xhr;
        t2 = t1.status;
        if (typeof t2 !== "number")
          return t2.$ge();
        accepted = t2 >= 200 && t2 < 300;
        unknownRedirect = t2 > 307 && t2 < 400;
        t2 = accepted || t2 === 0 || t2 === 304 || unknownRedirect;
        t3 = this.completer;
        if (t2)
          t3.complete$1(0, t1);
        else
          t3.completeError$1(e);
      }
    },
    HttpRequestEventTarget: {
      "^": "EventTarget;",
      "%": "XMLHttpRequestUpload;XMLHttpRequestEventTarget"
    },
    IFrameElement: {
      "^": "HtmlElement;height=,name=,width%",
      "%": "HTMLIFrameElement"
    },
    ImageBitmap: {
      "^": "Interceptor;height=,width=",
      $isImageBitmap: 1,
      "%": "ImageBitmap"
    },
    ImageData: {
      "^": "Interceptor;data=,height=,width=",
      $isImageData: 1,
      "%": "ImageData"
    },
    ImageElement: {
      "^": "HtmlElement;complete=,height=,width%",
      complete$1: function($receiver, arg0) {
        return $receiver.complete.call$1(arg0);
      },
      $isImageElement: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isObject: 1,
      "%": "HTMLImageElement"
    },
    InputElement: {
      "^": "HtmlElement;height=,name=,type=,value=,width%",
      $isElement: 1,
      $isInterceptor: 1,
      $isObject: 1,
      $isEventTarget: 1,
      $isNode: 1,
      "%": "HTMLInputElement"
    },
    IntersectionObserverEntry: {
      "^": "Interceptor;target=,time=",
      "%": "IntersectionObserverEntry"
    },
    KeyboardEvent: {
      "^": "UIEvent;keyCode=,altKey=,ctrlKey=,shiftKey=",
      $isKeyboardEvent: 1,
      $isEvent0: 1,
      $isObject: 1,
      "%": "KeyboardEvent"
    },
    KeygenElement: {
      "^": "HtmlElement;name=,type=",
      "%": "HTMLKeygenElement"
    },
    LIElement: {
      "^": "HtmlElement;value=",
      "%": "HTMLLIElement"
    },
    LengthValue: {
      "^": "StyleValue;",
      "%": "CalcLength;LengthValue"
    },
    LinkElement: {
      "^": "HtmlElement;type=",
      "%": "HTMLLinkElement"
    },
    Location: {
      "^": "Interceptor;",
      toString$0: function(receiver) {
        return String(receiver);
      },
      $isObject: 1,
      "%": "Location"
    },
    MapElement: {
      "^": "HtmlElement;name=",
      "%": "HTMLMapElement"
    },
    MediaElement: {
      "^": "HtmlElement;duration=,error=,loop=,muted=,volume%",
      "%": "HTMLAudioElement;HTMLMediaElement"
    },
    MediaKeySession: {
      "^": "EventTarget;closed=",
      remove$0: function(receiver) {
        return receiver.remove();
      },
      "%": "MediaKeySession"
    },
    MediaList: {
      "^": "Interceptor;length=",
      "%": "MediaList"
    },
    MediaRecorder: {
      "^": "EventTarget;",
      start$1: [function(receiver, timeslice) {
        return receiver.start(timeslice);
      }, function($receiver) {
        return $receiver.start();
      }, "start$0", "call$1", "call$0", "get$start", 0, 2, 30, 1],
      "%": "MediaRecorder"
    },
    MediaSource: {
      "^": "EventTarget;duration=",
      "%": "MediaSource"
    },
    MediaStream: {
      "^": "EventTarget;id=",
      $isMediaStream: 1,
      $isEventTarget: 1,
      $isObject: 1,
      "%": "MediaStream"
    },
    MediaStreamTrack: {
      "^": "EventTarget;id=,muted=",
      "%": "CanvasCaptureMediaStreamTrack|MediaStreamTrack"
    },
    MenuElement: {
      "^": "HtmlElement;type=",
      "%": "HTMLMenuElement"
    },
    MenuItemElement: {
      "^": "HtmlElement;type=",
      "%": "HTMLMenuItemElement"
    },
    MessagePort: {
      "^": "EventTarget;",
      start$0: [function(receiver) {
        return receiver.start();
      }, "call$0", "get$start", 0, 0, 2],
      "%": "MessagePort"
    },
    MetaElement: {
      "^": "HtmlElement;name=",
      "%": "HTMLMetaElement"
    },
    MeterElement: {
      "^": "HtmlElement;value=",
      "%": "HTMLMeterElement"
    },
    MidiOutput: {
      "^": "MidiPort;",
      send$2: function(receiver, data, timestamp) {
        return receiver.send(data, timestamp);
      },
      send$1: function($receiver, data) {
        return $receiver.send(data);
      },
      "%": "MIDIOutput"
    },
    MidiPort: {
      "^": "EventTarget;id=,name=,type=",
      "%": "MIDIInput;MIDIPort"
    },
    MimeType: {
      "^": "Interceptor;type=",
      $isObject: 1,
      "%": "MimeType"
    },
    MimeTypeArray: {
      "^": "Interceptor_ListMixin_ImmutableListMixin2;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.MimeType];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.MimeType];
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [W.MimeType];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.MimeType];
      },
      "%": "MimeTypeArray"
    },
    Interceptor_ListMixin2: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.MimeType];
      },
      $asEfficientLengthIterable: function() {
        return [W.MimeType];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin2: {
      "^": "Interceptor_ListMixin2+ImmutableListMixin;",
      $asList: function() {
        return [W.MimeType];
      },
      $asEfficientLengthIterable: function() {
        return [W.MimeType];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    MouseEvent0: {
      "^": "UIEvent;altKey=,button=,ctrlKey=,shiftKey=",
      get$client: function(receiver) {
        return new P.Point0(receiver.clientX, receiver.clientY, [null]);
      },
      $isMouseEvent0: 1,
      $isEvent0: 1,
      $isObject: 1,
      "%": ";DragEvent|MouseEvent"
    },
    MutationRecord: {
      "^": "Interceptor;target=,type=",
      "%": "MutationRecord"
    },
    Navigator: {
      "^": "Interceptor;",
      getUserMedia$2$audio$video: function(receiver, audio, video) {
        var t1, t2, completer, options;
        t1 = W.MediaStream;
        t2 = new P._Future(0, $.Zone__current, null, [t1]);
        completer = new P._AsyncCompleter(t2, [t1]);
        options = P.LinkedHashMap__makeLiteral(["audio", true, "video", false]);
        if (!receiver.getUserMedia)
          receiver.getUserMedia = receiver.getUserMedia || receiver.webkitGetUserMedia || receiver.mozGetUserMedia || receiver.msGetUserMedia;
        this._getUserMedia$3(receiver, new P._StructuredCloneDart2Js([], []).walk$1(options), new W.Navigator_getUserMedia_closure(completer), new W.Navigator_getUserMedia_closure0(completer));
        return t2;
      },
      getUserMedia$1$audio: function($receiver, audio) {
        return this.getUserMedia$2$audio$video($receiver, audio, false);
      },
      _getUserMedia$3: function(receiver, options, success, error) {
        return receiver.getUserMedia(options, H.convertDartClosureToJS(success, 1), H.convertDartClosureToJS(error, 1));
      },
      $isInterceptor: 1,
      $isObject: 1,
      "%": "Navigator"
    },
    Navigator_getUserMedia_closure: {
      "^": "Closure:0;completer",
      call$1: [function(stream) {
        this.completer.complete$1(0, stream);
      }, null, null, 2, 0, null, 29, "call"]
    },
    Navigator_getUserMedia_closure0: {
      "^": "Closure:0;completer",
      call$1: [function(error) {
        this.completer.completeError$1(error);
      }, null, null, 2, 0, null, 2, "call"]
    },
    NavigatorUserMediaError: {
      "^": "Interceptor;name=",
      "%": "NavigatorUserMediaError"
    },
    NetworkInformation: {
      "^": "EventTarget;type=",
      "%": "NetworkInformation"
    },
    Node: {
      "^": "EventTarget;childNodes=,parent:parentElement=,text:textContent%",
      remove$0: function(receiver) {
        var t1 = receiver.parentNode;
        if (t1 != null)
          t1.removeChild(receiver);
      },
      toString$0: function(receiver) {
        var value = receiver.nodeValue;
        return value == null ? this.super$Interceptor$toString(receiver) : value;
      },
      append$1: function(receiver, node) {
        return receiver.appendChild(node);
      },
      $isNode: 1,
      $isEventTarget: 1,
      $isObject: 1,
      "%": ";Node"
    },
    NodeList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin3;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      get$first: function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(new P.StateError("No elements"));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Node];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Node];
      },
      "%": "NodeList|RadioNodeList"
    },
    Interceptor_ListMixin3: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.Node];
      },
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin3: {
      "^": "Interceptor_ListMixin3+ImmutableListMixin;",
      $asList: function() {
        return [W.Node];
      },
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    NumberValue: {
      "^": "StyleValue;value=",
      "%": "NumberValue"
    },
    OListElement: {
      "^": "HtmlElement;start=,type=",
      "%": "HTMLOListElement"
    },
    ObjectElement: {
      "^": "HtmlElement;height=,name=,type=,width%",
      "%": "HTMLObjectElement"
    },
    OffscreenCanvas: {
      "^": "Interceptor;height=,width%",
      "%": "OffscreenCanvas"
    },
    OptionElement: {
      "^": "HtmlElement;value=",
      "%": "HTMLOptionElement"
    },
    OutputElement: {
      "^": "HtmlElement;name=,type=,value=",
      "%": "HTMLOutputElement"
    },
    ParamElement: {
      "^": "HtmlElement;name=,value=",
      "%": "HTMLParamElement"
    },
    Path2D: {
      "^": "Interceptor;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "Path2D"
    },
    PerformanceEntry: {
      "^": "Interceptor;duration=,name=,startTime=",
      "%": "PerformanceCompositeTiming|PerformanceEntry|PerformanceMark|PerformanceMeasure|PerformanceRenderTiming|PerformanceResourceTiming"
    },
    PerformanceNavigation: {
      "^": "Interceptor;type=",
      "%": "PerformanceNavigation"
    },
    Perspective: {
      "^": "TransformComponent;length=",
      "%": "Perspective"
    },
    Plugin: {
      "^": "Interceptor;length=,name=",
      $isObject: 1,
      "%": "Plugin"
    },
    PluginArray: {
      "^": "Interceptor_ListMixin_ImmutableListMixin4;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.Plugin];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Plugin];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Plugin];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Plugin];
      },
      "%": "PluginArray"
    },
    Interceptor_ListMixin4: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.Plugin];
      },
      $asEfficientLengthIterable: function() {
        return [W.Plugin];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin4: {
      "^": "Interceptor_ListMixin4+ImmutableListMixin;",
      $asList: function() {
        return [W.Plugin];
      },
      $asEfficientLengthIterable: function() {
        return [W.Plugin];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    PointerEvent: {
      "^": "MouseEvent0;height=,width=",
      "%": "PointerEvent"
    },
    PositionValue: {
      "^": "StyleValue;x=,y=",
      "%": "PositionValue"
    },
    PresentationAvailability: {
      "^": "EventTarget;value=",
      "%": "PresentationAvailability"
    },
    PresentationConnection: {
      "^": "EventTarget;id=",
      send$1: function(receiver, data_OR_message) {
        return receiver.send(data_OR_message);
      },
      "%": "PresentationConnection"
    },
    PresentationRequest: {
      "^": "EventTarget;",
      start$0: [function(receiver) {
        return receiver.start();
      }, "call$0", "get$start", 0, 0, 10],
      "%": "PresentationRequest"
    },
    ProcessingInstruction: {
      "^": "CharacterData;target=",
      "%": "ProcessingInstruction"
    },
    ProgressElement: {
      "^": "HtmlElement;value=",
      "%": "HTMLProgressElement"
    },
    ProgressEvent: {
      "^": "Event0;loaded=,total=",
      $isProgressEvent: 1,
      $isEvent0: 1,
      $isObject: 1,
      "%": "ProgressEvent|ResourceProgressEvent"
    },
    PushMessageData: {
      "^": "Interceptor;",
      text$0: [function(receiver) {
        return receiver.text();
      }, "call$0", "get$text", 0, 0, 62],
      "%": "PushMessageData"
    },
    ReadableByteStreamReader: {
      "^": "Interceptor;closed=",
      "%": "ReadableByteStreamReader"
    },
    ReadableStreamReader: {
      "^": "Interceptor;closed=",
      "%": "ReadableStreamReader"
    },
    Rotation: {
      "^": "TransformComponent;x=,y=",
      "%": "Rotation"
    },
    RtcDataChannel: {
      "^": "EventTarget;id=",
      send$1: function(receiver, data) {
        return receiver.send(data);
      },
      "%": "DataChannel|RTCDataChannel"
    },
    RtcDtmfSender: {
      "^": "EventTarget;duration=",
      "%": "RTCDTMFSender"
    },
    RtcSessionDescription: {
      "^": "Interceptor;type=",
      "%": "RTCSessionDescription|mozRTCSessionDescription"
    },
    RtcStatsReport: {
      "^": "Interceptor;id=,type=",
      $isRtcStatsReport: 1,
      $isObject: 1,
      "%": "RTCStatsReport"
    },
    RtcStatsResponse: {
      "^": "Interceptor;",
      result$0: [function(receiver) {
        return receiver.result();
      }, "call$0", "get$result", 0, 0, 63],
      "%": "RTCStatsResponse"
    },
    Screen: {
      "^": "Interceptor;height=,width=",
      "%": "Screen"
    },
    ScreenOrientation: {
      "^": "EventTarget;type=",
      "%": "ScreenOrientation"
    },
    ScriptElement: {
      "^": "HtmlElement;type=",
      "%": "HTMLScriptElement"
    },
    ScrollState: {
      "^": "Interceptor;deltaX=,deltaY=",
      "%": "ScrollState"
    },
    SelectElement: {
      "^": "HtmlElement;length=,name=,type=,value=",
      "%": "HTMLSelectElement"
    },
    Selection: {
      "^": "Interceptor;type=",
      "%": "Selection"
    },
    ServicePort: {
      "^": "Interceptor;name=",
      "%": "ServicePort"
    },
    SharedWorker: {
      "^": "EventTarget;",
      $isEventTarget: 1,
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SharedWorker"
    },
    SharedWorkerGlobalScope: {
      "^": "WorkerGlobalScope;name=",
      "%": "SharedWorkerGlobalScope"
    },
    SimpleLength: {
      "^": "LengthValue;type=,value=",
      "%": "SimpleLength"
    },
    SlotElement: {
      "^": "HtmlElement;name=",
      "%": "HTMLSlotElement"
    },
    SourceBuffer: {
      "^": "EventTarget;",
      $isEventTarget: 1,
      $isObject: 1,
      "%": "SourceBuffer"
    },
    SourceBufferList: {
      "^": "EventTarget_ListMixin_ImmutableListMixin0;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.SourceBuffer];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SourceBuffer];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.SourceBuffer];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.SourceBuffer];
      },
      "%": "SourceBufferList"
    },
    EventTarget_ListMixin0: {
      "^": "EventTarget+ListMixin;",
      $asList: function() {
        return [W.SourceBuffer];
      },
      $asEfficientLengthIterable: function() {
        return [W.SourceBuffer];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    EventTarget_ListMixin_ImmutableListMixin0: {
      "^": "EventTarget_ListMixin0+ImmutableListMixin;",
      $asList: function() {
        return [W.SourceBuffer];
      },
      $asEfficientLengthIterable: function() {
        return [W.SourceBuffer];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    SourceElement: {
      "^": "HtmlElement;type=",
      "%": "HTMLSourceElement"
    },
    SourceInfo: {
      "^": "Interceptor;id=",
      "%": "SourceInfo"
    },
    SpeechGrammar: {
      "^": "Interceptor;",
      $isObject: 1,
      "%": "SpeechGrammar"
    },
    SpeechGrammarList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin5;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechGrammar];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechGrammar];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.SpeechGrammar];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.SpeechGrammar];
      },
      "%": "SpeechGrammarList"
    },
    Interceptor_ListMixin5: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.SpeechGrammar];
      },
      $asEfficientLengthIterable: function() {
        return [W.SpeechGrammar];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin5: {
      "^": "Interceptor_ListMixin5+ImmutableListMixin;",
      $asList: function() {
        return [W.SpeechGrammar];
      },
      $asEfficientLengthIterable: function() {
        return [W.SpeechGrammar];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    SpeechRecognition: {
      "^": "EventTarget;",
      start$0: [function(receiver) {
        return receiver.start();
      }, "call$0", "get$start", 0, 0, 2],
      "%": "SpeechRecognition"
    },
    SpeechRecognitionError: {
      "^": "Event0;error=",
      "%": "SpeechRecognitionError"
    },
    SpeechRecognitionResult: {
      "^": "Interceptor;length=",
      $isObject: 1,
      "%": "SpeechRecognitionResult"
    },
    SpeechSynthesisEvent: {
      "^": "Event0;name=",
      "%": "SpeechSynthesisEvent"
    },
    SpeechSynthesisUtterance: {
      "^": "EventTarget;text%,voice=,volume%",
      "%": "SpeechSynthesisUtterance"
    },
    SpeechSynthesisVoice: {
      "^": "Interceptor;name=",
      "%": "SpeechSynthesisVoice"
    },
    Storage: {
      "^": "Interceptor;",
      containsKey$1: function(receiver, key) {
        return receiver.getItem(key) != null;
      },
      $index: function(receiver, key) {
        return receiver.getItem(key);
      },
      $indexSet: function(receiver, key, value) {
        receiver.setItem(key, value);
      },
      forEach$1: function(receiver, f) {
        var i, key;
        for (i = 0; true; ++i) {
          key = receiver.key(i);
          if (key == null)
            return;
          f.call$2(key, receiver.getItem(key));
        }
      },
      get$keys: function(receiver) {
        var keys = H.setRuntimeTypeInfo([], [P.String]);
        this.forEach$1(receiver, new W.Storage_keys_closure(keys));
        return keys;
      },
      get$length: function(receiver) {
        return receiver.length;
      },
      get$isEmpty: function(receiver) {
        return receiver.key(0) == null;
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, P.String];
      },
      $isObject: 1,
      "%": "Storage"
    },
    Storage_keys_closure: {
      "^": "Closure:3;keys",
      call$2: function(k, v) {
        return this.keys.push(k);
      }
    },
    StorageEvent: {
      "^": "Event0;url=",
      "%": "StorageEvent"
    },
    StyleElement: {
      "^": "HtmlElement;type=",
      "%": "HTMLStyleElement"
    },
    StyleMedia: {
      "^": "Interceptor;type=",
      "%": "StyleMedia"
    },
    StyleSheet: {
      "^": "Interceptor;type=",
      $isObject: 1,
      "%": "CSSStyleSheet|StyleSheet"
    },
    StyleValue: {
      "^": "Interceptor;",
      "%": "KeywordValue|TransformValue;StyleValue"
    },
    TextAreaElement: {
      "^": "HtmlElement;name=,type=,value=",
      "%": "HTMLTextAreaElement"
    },
    TextMetrics: {
      "^": "Interceptor;width=",
      "%": "TextMetrics"
    },
    TextTrack: {
      "^": "EventTarget;id=",
      $isEventTarget: 1,
      $isObject: 1,
      "%": "TextTrack"
    },
    TextTrackCue: {
      "^": "EventTarget;endTime%,id=,startTime%",
      $isEventTarget: 1,
      $isObject: 1,
      "%": ";TextTrackCue"
    },
    TextTrackCueList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin6;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.TextTrackCue];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.TextTrackCue];
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [W.TextTrackCue];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrackCue];
      },
      "%": "TextTrackCueList"
    },
    Interceptor_ListMixin6: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.TextTrackCue];
      },
      $asEfficientLengthIterable: function() {
        return [W.TextTrackCue];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin6: {
      "^": "Interceptor_ListMixin6+ImmutableListMixin;",
      $asList: function() {
        return [W.TextTrackCue];
      },
      $asEfficientLengthIterable: function() {
        return [W.TextTrackCue];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    TextTrackList: {
      "^": "EventTarget_ListMixin_ImmutableListMixin1;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.TextTrack];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.TextTrack];
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [W.TextTrack];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrack];
      },
      "%": "TextTrackList"
    },
    EventTarget_ListMixin1: {
      "^": "EventTarget+ListMixin;",
      $asList: function() {
        return [W.TextTrack];
      },
      $asEfficientLengthIterable: function() {
        return [W.TextTrack];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    EventTarget_ListMixin_ImmutableListMixin1: {
      "^": "EventTarget_ListMixin1+ImmutableListMixin;",
      $asList: function() {
        return [W.TextTrack];
      },
      $asEfficientLengthIterable: function() {
        return [W.TextTrack];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    TimeRanges: {
      "^": "Interceptor;length=",
      end$1: [function(receiver, index) {
        return receiver.end(index);
      }, "call$1", "get$end", 2, 0, 24],
      start$1: [function(receiver, index) {
        return receiver.start(index);
      }, "call$1", "get$start", 2, 0, 24],
      "%": "TimeRanges"
    },
    Touch: {
      "^": "Interceptor;",
      get$target: function(receiver) {
        return W._convertNativeToDart_EventTarget(receiver.target);
      },
      get$client: function(receiver) {
        return new P.Point0(C.JSNumber_methods.round$0(receiver.clientX), C.JSNumber_methods.round$0(receiver.clientY), [null]);
      },
      $isObject: 1,
      "%": "Touch"
    },
    TouchEvent0: {
      "^": "UIEvent;altKey=,changedTouches=,ctrlKey=,shiftKey=",
      $isTouchEvent0: 1,
      $isEvent0: 1,
      $isObject: 1,
      "%": "TouchEvent"
    },
    TouchList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin7;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.Touch];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Touch];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Touch];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Touch];
      },
      "%": "TouchList"
    },
    Interceptor_ListMixin7: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.Touch];
      },
      $asEfficientLengthIterable: function() {
        return [W.Touch];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin7: {
      "^": "Interceptor_ListMixin7+ImmutableListMixin;",
      $asList: function() {
        return [W.Touch];
      },
      $asEfficientLengthIterable: function() {
        return [W.Touch];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    TrackDefault: {
      "^": "Interceptor;type=",
      "%": "TrackDefault"
    },
    TrackDefaultList: {
      "^": "Interceptor;length=",
      "%": "TrackDefaultList"
    },
    TransformComponent: {
      "^": "Interceptor;",
      "%": "Matrix|Skew;TransformComponent"
    },
    Translation: {
      "^": "TransformComponent;x=,y=",
      "%": "Translation"
    },
    UIEvent: {
      "^": "Event0;",
      "%": "CompositionEvent|FocusEvent|SVGZoomEvent|TextEvent;UIEvent"
    },
    UnderlyingSourceBase: {
      "^": "Interceptor;",
      start$1: [function(receiver, stream) {
        return receiver.start(stream);
      }, "call$1", "get$start", 2, 0, 72],
      "%": "UnderlyingSourceBase"
    },
    Url: {
      "^": "Interceptor;",
      toString$0: function(receiver) {
        return String(receiver);
      },
      $isInterceptor: 1,
      $isObject: 1,
      "%": "URL"
    },
    VideoElement: {
      "^": "MediaElement;height=,width%",
      $isVideoElement: 1,
      $isObject: 1,
      "%": "HTMLVideoElement"
    },
    VideoTrack: {
      "^": "Interceptor;id=",
      "%": "VideoTrack"
    },
    VideoTrackList: {
      "^": "EventTarget;length=",
      "%": "VideoTrackList"
    },
    VttCue: {
      "^": "TextTrackCue;text%",
      "%": "VTTCue"
    },
    VttRegion: {
      "^": "Interceptor;height=,id=,width%",
      "%": "VTTRegion"
    },
    VttRegionList: {
      "^": "Interceptor;length=",
      "%": "VTTRegionList"
    },
    WebSocket: {
      "^": "EventTarget;url=",
      send$1: function(receiver, data) {
        return receiver.send(data);
      },
      "%": "WebSocket"
    },
    WheelEvent: {
      "^": "MouseEvent0;",
      get$deltaY: function(receiver) {
        if (receiver.deltaY !== undefined)
          return receiver.deltaY;
        throw H.wrapException(new P.UnsupportedError("deltaY is not supported"));
      },
      get$deltaX: function(receiver) {
        if (receiver.deltaX !== undefined)
          return receiver.deltaX;
        throw H.wrapException(new P.UnsupportedError("deltaX is not supported"));
      },
      $isWheelEvent: 1,
      $isMouseEvent0: 1,
      $isEvent0: 1,
      $isObject: 1,
      "%": "WheelEvent"
    },
    Window: {
      "^": "EventTarget;closed=,name=",
      set$location: function(receiver, value) {
        receiver.location = value;
      },
      _requestAnimationFrame$1: function(receiver, callback) {
        return receiver.requestAnimationFrame(H.convertDartClosureToJS(callback, 1));
      },
      _ensureRequestAnimationFrame$0: function(receiver) {
        if (!!(receiver.requestAnimationFrame && receiver.cancelAnimationFrame))
          return;
        (function($this) {
          var vendors = ['ms', 'moz', 'webkit', 'o'];
          for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
            $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
            $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
          }
          if ($this.requestAnimationFrame && $this.cancelAnimationFrame)
            return;
          $this.requestAnimationFrame = function(callback) {
            return window.setTimeout(function() {
              callback(Date.now());
            }, 16);
          };
          $this.cancelAnimationFrame = function(id) {
            clearTimeout(id);
          };
        })(receiver);
      },
      get$parent: function(receiver) {
        return W._convertNativeToDart_Window(receiver.parent);
      },
      $isWindow: 1,
      $isInterceptor: 1,
      $isObject: 1,
      $isEventTarget: 1,
      "%": "DOMWindow|Window"
    },
    Worker: {
      "^": "EventTarget;",
      $isEventTarget: 1,
      $isInterceptor: 1,
      $isObject: 1,
      "%": "Worker"
    },
    WorkerGlobalScope: {
      "^": "EventTarget;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "CompositorWorkerGlobalScope|DedicatedWorkerGlobalScope|ServiceWorkerGlobalScope;WorkerGlobalScope"
    },
    _Attr: {
      "^": "Node;name=,_namespaceUri:namespaceURI=,value=",
      "%": "Attr"
    },
    _ClientRect: {
      "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
      toString$0: function(receiver) {
        return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
      },
      $eq: function(receiver, other) {
        var t1, t2, t3;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        if (!t1.$isRectangle)
          return false;
        t2 = receiver.left;
        t3 = t1.get$left(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = receiver.top;
          t3 = t1.get$top(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = receiver.width;
            t3 = t1.get$width(other);
            if (t2 == null ? t3 == null : t2 === t3) {
              t2 = receiver.height;
              t1 = t1.get$height(other);
              t1 = t2 == null ? t1 == null : t2 === t1;
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
        return t1;
      },
      get$hashCode: function(receiver) {
        var t1, t2, t3, t4;
        t1 = J.get$hashCode$(receiver.left);
        t2 = J.get$hashCode$(receiver.top);
        t3 = J.get$hashCode$(receiver.width);
        t4 = J.get$hashCode$(receiver.height);
        return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
      },
      $isRectangle: 1,
      $asRectangle: Isolate.functionThatReturnsNull,
      $isObject: 1,
      "%": "ClientRect"
    },
    _ClientRectList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin8;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [P.Rectangle];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [P.Rectangle];
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.Rectangle];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Rectangle];
      },
      "%": "ClientRectList|DOMRectList"
    },
    Interceptor_ListMixin8: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [P.Rectangle];
      },
      $asEfficientLengthIterable: function() {
        return [P.Rectangle];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin8: {
      "^": "Interceptor_ListMixin8+ImmutableListMixin;",
      $asList: function() {
        return [P.Rectangle];
      },
      $asEfficientLengthIterable: function() {
        return [P.Rectangle];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    _CssRuleList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin9;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.CssRule];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.CssRule];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.CssRule];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.CssRule];
      },
      "%": "CSSRuleList"
    },
    Interceptor_ListMixin9: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.CssRule];
      },
      $asEfficientLengthIterable: function() {
        return [W.CssRule];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin9: {
      "^": "Interceptor_ListMixin9+ImmutableListMixin;",
      $asList: function() {
        return [W.CssRule];
      },
      $asEfficientLengthIterable: function() {
        return [W.CssRule];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    _DocumentType: {
      "^": "Node;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "DocumentType"
    },
    _DomRect: {
      "^": "DomRectReadOnly;",
      get$height: function(receiver) {
        return receiver.height;
      },
      get$width: function(receiver) {
        return receiver.width;
      },
      set$width: function(receiver, value) {
        receiver.width = value;
      },
      get$x: function(receiver) {
        return receiver.x;
      },
      set$x: function(receiver, value) {
        receiver.x = value;
      },
      get$y: function(receiver) {
        return receiver.y;
      },
      set$y: function(receiver, value) {
        receiver.y = value;
      },
      "%": "DOMRect"
    },
    _GamepadList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin10;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Gamepad];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Gamepad];
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [W.Gamepad];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Gamepad];
      },
      "%": "GamepadList"
    },
    Interceptor_ListMixin10: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.Gamepad];
      },
      $asEfficientLengthIterable: function() {
        return [W.Gamepad];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin10: {
      "^": "Interceptor_ListMixin10+ImmutableListMixin;",
      $asList: function() {
        return [W.Gamepad];
      },
      $asEfficientLengthIterable: function() {
        return [W.Gamepad];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    _HTMLFrameSetElement: {
      "^": "HtmlElement;",
      $isEventTarget: 1,
      $isInterceptor: 1,
      $isObject: 1,
      "%": "HTMLFrameSetElement"
    },
    _NamedNodeMap: {
      "^": "Interceptor_ListMixin_ImmutableListMixin11;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Node];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Node];
      },
      "%": "MozNamedAttrMap|NamedNodeMap"
    },
    Interceptor_ListMixin11: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.Node];
      },
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin11: {
      "^": "Interceptor_ListMixin11+ImmutableListMixin;",
      $asList: function() {
        return [W.Node];
      },
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    _Request: {
      "^": "Body;url=",
      "%": "Request"
    },
    _ServiceWorker: {
      "^": "EventTarget;",
      $isEventTarget: 1,
      $isInterceptor: 1,
      $isObject: 1,
      "%": "ServiceWorker"
    },
    _SpeechRecognitionResultList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin12;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechRecognitionResult];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isObject: 1,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.SpeechRecognitionResult];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.SpeechRecognitionResult];
      },
      "%": "SpeechRecognitionResultList"
    },
    Interceptor_ListMixin12: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.SpeechRecognitionResult];
      },
      $asEfficientLengthIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin12: {
      "^": "Interceptor_ListMixin12+ImmutableListMixin;",
      $asList: function() {
        return [W.SpeechRecognitionResult];
      },
      $asEfficientLengthIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    _StyleSheetList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin13;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.StyleSheet];
      },
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.StyleSheet];
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [W.StyleSheet];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.StyleSheet];
      },
      "%": "StyleSheetList"
    },
    Interceptor_ListMixin13: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [W.StyleSheet];
      },
      $asEfficientLengthIterable: function() {
        return [W.StyleSheet];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin13: {
      "^": "Interceptor_ListMixin13+ImmutableListMixin;",
      $asList: function() {
        return [W.StyleSheet];
      },
      $asEfficientLengthIterable: function() {
        return [W.StyleSheet];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    _WorkerLocation: {
      "^": "Interceptor;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "WorkerLocation"
    },
    _WorkerNavigator: {
      "^": "Interceptor;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "WorkerNavigator"
    },
    _AttributeMap: {
      "^": "Object;",
      forEach$1: function(_, f) {
        var t1, t2, t3, _i, key;
        for (t1 = this.get$keys(this), t2 = t1.length, t3 = this._html$_element, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          key = t1[_i];
          f.call$2(key, t3.getAttribute(key));
        }
      },
      get$keys: function(_) {
        var attributes, keys, len, i, attr, t1;
        attributes = this._html$_element.attributes;
        keys = H.setRuntimeTypeInfo([], [P.String]);
        for (len = attributes.length, i = 0; i < len; ++i) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          attr = attributes[i];
          t1 = J.getInterceptor$x(attr);
          if (t1.get$_namespaceUri(attr) == null)
            keys.push(t1.get$name(attr));
        }
        return keys;
      },
      get$isEmpty: function(_) {
        return this.get$keys(this).length === 0;
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, P.String];
      }
    },
    _ElementAttributeMap: {
      "^": "_AttributeMap;_html$_element",
      containsKey$1: function(_, key) {
        return this._html$_element.hasAttribute(key);
      },
      $index: function(_, key) {
        return this._html$_element.getAttribute(key);
      },
      $indexSet: function(_, key, value) {
        this._html$_element.setAttribute(key, value);
      },
      get$length: function(_) {
        return this.get$keys(this).length;
      }
    },
    _EventStream: {
      "^": "Stream;_html$_target,_eventType,_useCapture,$ti",
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        return W._EventStreamSubscription$(this._html$_target, this._eventType, onData, false, H.getTypeArgumentByIndex(this, 0));
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }
    },
    _ElementEventStreamImpl: {
      "^": "_EventStream;_html$_target,_eventType,_useCapture,$ti"
    },
    _EventStreamSubscription: {
      "^": "StreamSubscription;_html$_pauseCount,_html$_target,_eventType,_html$_onData,_useCapture,$ti",
      cancel$0: function(_) {
        if (this._html$_target == null)
          return;
        this._unlisten$0();
        this._html$_target = null;
        this._html$_onData = null;
        return;
      },
      pause$1: function(_, resumeSignal) {
        if (this._html$_target == null)
          return;
        ++this._html$_pauseCount;
        this._unlisten$0();
      },
      pause$0: function($receiver) {
        return this.pause$1($receiver, null);
      },
      get$isPaused: function() {
        return this._html$_pauseCount > 0;
      },
      resume$0: function(_) {
        if (this._html$_target == null || this._html$_pauseCount <= 0)
          return;
        --this._html$_pauseCount;
        this._tryResume$0();
      },
      _tryResume$0: function() {
        var t1 = this._html$_onData;
        if (t1 != null && this._html$_pauseCount <= 0)
          J.addEventListener$3$x(this._html$_target, this._eventType, t1, false);
      },
      _unlisten$0: function() {
        var t1 = this._html$_onData;
        if (t1 != null)
          J.removeEventListener$3$x(this._html$_target, this._eventType, t1, false);
      },
      _EventStreamSubscription$4: function(_target, _eventType, onData, _useCapture, $T) {
        this._tryResume$0();
      },
      static: {
        _EventStreamSubscription$: function(_target, _eventType, onData, _useCapture, $T) {
          var t1 = onData == null ? null : W._wrapZone(new W._EventStreamSubscription_closure(onData));
          t1 = new W._EventStreamSubscription(0, _target, _eventType, t1, false, [$T]);
          t1._EventStreamSubscription$4(_target, _eventType, onData, false, $T);
          return t1;
        }
      }
    },
    _EventStreamSubscription_closure: {
      "^": "Closure:0;onData",
      call$1: [function(e) {
        return this.onData.call$1(e);
      }, null, null, 2, 0, null, 0, "call"]
    },
    ImmutableListMixin: {
      "^": "Object;$ti",
      get$iterator: function(receiver) {
        return new W.FixedSizeListIterator(receiver, this.get$length(receiver), -1, null);
      },
      setRange$4: function(receiver, start, end, iterable, skipCount) {
        throw H.wrapException(new P.UnsupportedError("Cannot setRange on immutable List."));
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      replaceRange$3: function(receiver, start, end, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an immutable List."));
      },
      fillRange$3: function(receiver, start, end, fillValue) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an immutable List."));
      },
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null
    },
    FixedSizeListIterator: {
      "^": "Object;_array,_html$_length,_position,_html$_current",
      moveNext$0: function() {
        var nextPosition, t1;
        nextPosition = this._position + 1;
        t1 = this._html$_length;
        if (nextPosition < t1) {
          this._html$_current = J.$index$asx(this._array, nextPosition);
          this._position = nextPosition;
          return true;
        }
        this._html$_current = null;
        this._position = t1;
        return false;
      },
      get$current: function() {
        return this._html$_current;
      }
    },
    _DOMWindowCrossFrame: {
      "^": "Object;_window",
      get$closed: function(_) {
        return this._window.closed;
      },
      get$parent: function(_) {
        return W._DOMWindowCrossFrame__createSafe(this._window.parent);
      },
      addEventListener$3: function(_, type, listener, useCapture) {
        return H.throwExpression(new P.UnsupportedError("You can only attach EventListeners to your own window."));
      },
      addEventListener$2: function($receiver, type, listener) {
        return this.addEventListener$3($receiver, type, listener, null);
      },
      dispatchEvent$1: function(_, $event) {
        return H.throwExpression(new P.UnsupportedError("You can only attach EventListeners to your own window."));
      },
      removeEventListener$3: function(_, type, listener, useCapture) {
        return H.throwExpression(new P.UnsupportedError("You can only attach EventListeners to your own window."));
      },
      $isEventTarget: 1,
      $isInterceptor: 1,
      static: {
        _DOMWindowCrossFrame__createSafe: function(w) {
          if (w === window)
            return w;
          else
            return new W._DOMWindowCrossFrame(w);
        }
      }
    }
  }], ["html_common", "dart:html_common",, P, {
    "^": "",
    convertNativeToDart_ImageData: function(nativeImageData) {
      var t1, data;
      t1 = J.getInterceptor(nativeImageData);
      if (!!t1.$isImageData) {
        data = t1.get$data(nativeImageData);
        if (data.constructor === Array)
          if (typeof CanvasPixelArray !== "undefined") {
            data.constructor = CanvasPixelArray;
            data.BYTES_PER_ELEMENT = 1;
          }
        return nativeImageData;
      }
      return new P._TypedImageData(nativeImageData.data, nativeImageData.height, nativeImageData.width);
    },
    convertDartToNative_ImageData: function(imageData) {
      if (imageData instanceof P._TypedImageData)
        return {data: imageData.data, height: imageData.height, width: imageData.width};
      return imageData;
    },
    convertNativeToDart_Dictionary: function(object) {
      var dict, keys, t1, _i, key;
      if (object == null)
        return;
      dict = P.LinkedHashMap__makeEmpty();
      keys = Object.getOwnPropertyNames(object);
      for (t1 = keys.length, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
        key = keys[_i];
        dict.$indexSet(0, key, object[key]);
      }
      return dict;
    },
    convertDartToNative_Dictionary: [function(dict, postCreate) {
      var object;
      if (dict == null)
        return;
      object = {};
      if (postCreate != null)
        postCreate.call$1(object);
      J.forEach$1$ax(dict, new P.convertDartToNative_Dictionary_closure(object));
      return object;
    }, null, null, 2, 2, null, 1, 30, 31],
    convertNativePromiseToDartFuture: function(promise) {
      var t1, completer;
      t1 = new P._Future(0, $.Zone__current, null, [null]);
      completer = new P._AsyncCompleter(t1, [null]);
      promise.then(H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure(completer), 1))["catch"](H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure0(completer), 1));
      return t1;
    },
    Device_isOpera: function() {
      var t1 = $.Device__isOpera;
      if (t1 == null) {
        t1 = J.contains$2$asx(window.navigator.userAgent, "Opera", 0);
        $.Device__isOpera = t1;
      }
      return t1;
    },
    Device_isWebKit: function() {
      var t1 = $.Device__isWebKit;
      if (t1 == null) {
        t1 = P.Device_isOpera() !== true && J.contains$2$asx(window.navigator.userAgent, "WebKit", 0);
        $.Device__isWebKit = t1;
      }
      return t1;
    },
    Device_cssPrefix: function() {
      var prefix, t1;
      prefix = $.Device__cachedCssPrefix;
      if (prefix != null)
        return prefix;
      t1 = $.Device__isFirefox;
      if (t1 == null) {
        t1 = J.contains$2$asx(window.navigator.userAgent, "Firefox", 0);
        $.Device__isFirefox = t1;
      }
      if (t1)
        prefix = "-moz-";
      else {
        t1 = $.Device__isIE;
        if (t1 == null) {
          t1 = P.Device_isOpera() !== true && J.contains$2$asx(window.navigator.userAgent, "Trident/", 0);
          $.Device__isIE = t1;
        }
        if (t1)
          prefix = "-ms-";
        else
          prefix = P.Device_isOpera() === true ? "-o-" : "-webkit-";
      }
      $.Device__cachedCssPrefix = prefix;
      return prefix;
    },
    Device_isEventTypeSupported: function(eventType) {
      var e, e0, exception;
      try {
        e0 = document.createEvent(eventType);
        e0.initEvent("", true, true);
        e = e0;
        return !!J.getInterceptor(e).$isEvent0;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return false;
    },
    _StructuredClone: {
      "^": "Object;",
      findSlot$1: function(value) {
        var t1, $length, i;
        t1 = this.values;
        $length = t1.length;
        for (i = 0; i < $length; ++i)
          if (t1[i] === value)
            return i;
        t1.push(value);
        this.copies.push(null);
        return $length;
      },
      walk$1: function(e) {
        var t1, t2, slot, t3, t4, copy;
        t1 = {};
        if (e == null)
          return e;
        if (typeof e === "boolean")
          return e;
        if (typeof e === "number")
          return e;
        if (typeof e === "string")
          return e;
        t2 = J.getInterceptor(e);
        if (!!t2.$isDateTime)
          return new Date(e._value);
        if (!!t2.$isRegExp)
          throw H.wrapException(new P.UnimplementedError("structured clone of RegExp"));
        if (!!t2.$isFile)
          return e;
        if (!!t2.$isBlob)
          return e;
        if (!!t2.$isFileList)
          return e;
        if (!!t2.$isImageData)
          return e;
        if (!!t2.$isNativeByteBuffer || !!t2.$isNativeTypedData)
          return e;
        if (!!t2.$isMap) {
          slot = this.findSlot$1(e);
          t3 = this.copies;
          t4 = t3.length;
          if (slot >= t4)
            return H.ioore(t3, slot);
          copy = t3[slot];
          t1.copy = copy;
          if (copy != null)
            return copy;
          copy = {};
          t1.copy = copy;
          if (slot >= t4)
            return H.ioore(t3, slot);
          t3[slot] = copy;
          t2.forEach$1(e, new P._StructuredClone_walk_closure(t1, this));
          return t1.copy;
        }
        if (!!t2.$isList) {
          slot = this.findSlot$1(e);
          t1 = this.copies;
          if (slot >= t1.length)
            return H.ioore(t1, slot);
          copy = t1[slot];
          if (copy != null)
            return copy;
          return this.copyList$2(e, slot);
        }
        throw H.wrapException(new P.UnimplementedError("structured clone of other type"));
      },
      copyList$2: function(e, slot) {
        var t1, $length, copy, t2, i;
        t1 = J.getInterceptor$asx(e);
        $length = t1.get$length(e);
        copy = new Array($length);
        t2 = this.copies;
        if (slot >= t2.length)
          return H.ioore(t2, slot);
        t2[slot] = copy;
        for (i = 0; i < $length; ++i) {
          t2 = this.walk$1(t1.$index(e, i));
          if (i >= copy.length)
            return H.ioore(copy, i);
          copy[i] = t2;
        }
        return copy;
      }
    },
    _StructuredClone_walk_closure: {
      "^": "Closure:3;_box_0,$this",
      call$2: [function(key, value) {
        this._box_0.copy[key] = this.$this.walk$1(value);
      }, null, null, 4, 0, null, 8, 3, "call"]
    },
    _AcceptStructuredClone: {
      "^": "Object;",
      findSlot$1: function(value) {
        var t1, $length, i, t2;
        t1 = this.values;
        $length = t1.length;
        for (i = 0; i < $length; ++i) {
          t2 = t1[i];
          if (t2 == null ? value == null : t2 === value)
            return i;
        }
        t1.push(value);
        this.copies.push(null);
        return $length;
      },
      walk$1: function(e) {
        var _box_0, millisSinceEpoch, t1, proto, slot, t2, copy, $length, i;
        _box_0 = {};
        if (e == null)
          return e;
        if (typeof e === "boolean")
          return e;
        if (typeof e === "number")
          return e;
        if (typeof e === "string")
          return e;
        if (e instanceof Date) {
          millisSinceEpoch = e.getTime();
          t1 = new P.DateTime(millisSinceEpoch, true);
          t1.DateTime$_withValue$2$isUtc(millisSinceEpoch, true);
          return t1;
        }
        if (e instanceof RegExp)
          throw H.wrapException(new P.UnimplementedError("structured clone of RegExp"));
        if (typeof Promise != "undefined" && e instanceof Promise)
          return P.convertNativePromiseToDartFuture(e);
        proto = Object.getPrototypeOf(e);
        if (proto === Object.prototype || proto === null) {
          slot = this.findSlot$1(e);
          t1 = this.copies;
          t2 = t1.length;
          if (slot >= t2)
            return H.ioore(t1, slot);
          copy = t1[slot];
          _box_0.copy = copy;
          if (copy != null)
            return copy;
          copy = P.LinkedHashMap__makeEmpty();
          _box_0.copy = copy;
          if (slot >= t2)
            return H.ioore(t1, slot);
          t1[slot] = copy;
          this.forEachJsField$2(e, new P._AcceptStructuredClone_walk_closure(_box_0, this));
          return _box_0.copy;
        }
        if (e instanceof Array) {
          slot = this.findSlot$1(e);
          t1 = this.copies;
          if (slot >= t1.length)
            return H.ioore(t1, slot);
          copy = t1[slot];
          if (copy != null)
            return copy;
          t2 = J.getInterceptor$asx(e);
          $length = t2.get$length(e);
          copy = this.mustCopy ? new Array($length) : e;
          if (slot >= t1.length)
            return H.ioore(t1, slot);
          t1[slot] = copy;
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = J.getInterceptor$ax(copy);
          i = 0;
          for (; i < $length; ++i)
            t1.$indexSet(copy, i, this.walk$1(t2.$index(e, i)));
          return copy;
        }
        return e;
      }
    },
    _AcceptStructuredClone_walk_closure: {
      "^": "Closure:3;_box_0,$this",
      call$2: function(key, value) {
        var t1, t2;
        t1 = this._box_0.copy;
        t2 = this.$this.walk$1(value);
        J.$indexSet$ax(t1, key, t2);
        return t2;
      }
    },
    _TypedImageData: {
      "^": "Object;data>,height>,width>",
      $isImageData: 1,
      $isInterceptor: 1
    },
    convertDartToNative_Dictionary_closure: {
      "^": "Closure:16;object",
      call$2: [function(key, value) {
        this.object[key] = value;
      }, null, null, 4, 0, null, 8, 3, "call"]
    },
    _StructuredCloneDart2Js: {
      "^": "_StructuredClone;values,copies"
    },
    _AcceptStructuredCloneDart2Js: {
      "^": "_AcceptStructuredClone;values,copies,mustCopy",
      forEachJsField$2: function(object, action) {
        var t1, t2, _i, key;
        for (t1 = Object.keys(object), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          key = t1[_i];
          action.call$2(key, object[key]);
        }
      }
    },
    convertNativePromiseToDartFuture_closure: {
      "^": "Closure:0;completer",
      call$1: [function(result) {
        return this.completer.complete$1(0, result);
      }, null, null, 2, 0, null, 7, "call"]
    },
    convertNativePromiseToDartFuture_closure0: {
      "^": "Closure:0;completer",
      call$1: [function(result) {
        return this.completer.completeError$1(result);
      }, null, null, 2, 0, null, 7, "call"]
    }
  }], ["dart.dom.indexed_db", "dart:indexed_db",, P, {
    "^": "",
    Cursor: {
      "^": "Interceptor;",
      next$1: [function(receiver, key) {
        if (key == null)
          receiver.continue();
        else
          receiver.continue(key);
      }, function($receiver) {
        return this.next$1($receiver, null);
      }, "next$0", "call$1", "call$0", "get$next", 0, 2, 31, 1, 8],
      "%": ";IDBCursor"
    },
    CursorWithValue: {
      "^": "Cursor;",
      get$value: function(receiver) {
        return new P._AcceptStructuredCloneDart2Js([], [], false).walk$1(receiver.value);
      },
      "%": "IDBCursorWithValue"
    },
    Database: {
      "^": "EventTarget;name=",
      "%": "IDBDatabase"
    },
    Index: {
      "^": "Interceptor;name=",
      "%": "IDBIndex"
    },
    KeyRange: {
      "^": "Interceptor;",
      $isKeyRange: 1,
      "%": "IDBKeyRange"
    },
    ObjectStore: {
      "^": "Interceptor;name=",
      "%": "IDBObjectStore"
    },
    Request: {
      "^": "EventTarget;error=",
      get$result: function(receiver) {
        return new P._AcceptStructuredCloneDart2Js([], [], false).walk$1(receiver.result);
      },
      "%": "IDBOpenDBRequest|IDBRequest|IDBVersionChangeRequest"
    },
    Transaction: {
      "^": "EventTarget;error=",
      "%": "IDBTransaction"
    }
  }], ["dart.js", "dart:js",, P, {
    "^": "",
    _callDartFunction: [function(callback, captureThis, $self, $arguments) {
      var arguments0, dartArgs, t1;
      if (captureThis === true) {
        arguments0 = [$self];
        C.JSArray_methods.addAll$1(arguments0, $arguments);
        $arguments = arguments0;
      }
      dartArgs = P.List_List$from(J.map$1$ax($arguments, P.js___convertToDart$closure()), true, null);
      t1 = H.Primitives_applyFunctionWithPositionalArguments(callback, dartArgs);
      return P._convertToJS(t1);
    }, null, null, 8, 0, null, 32, 33, 34, 35],
    _defineProperty: function(o, $name, value) {
      var exception;
      try {
        if (Object.isExtensible(o) && !Object.prototype.hasOwnProperty.call(o, $name)) {
          Object.defineProperty(o, $name, {value: value});
          return true;
        }
      } catch (exception) {
        H.unwrapException(exception);
      }
      return false;
    },
    _getOwnProperty: function(o, $name) {
      if (Object.prototype.hasOwnProperty.call(o, $name))
        return o[$name];
      return;
    },
    _convertToJS: [function(o) {
      var t1;
      if (o == null || typeof o === "string" || typeof o === "number" || typeof o === "boolean")
        return o;
      t1 = J.getInterceptor(o);
      if (!!t1.$isJsObject)
        return o._js$_jsObject;
      if (!!t1.$isBlob || !!t1.$isEvent0 || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode || !!t1.$isTypedData || !!t1.$isWindow)
        return o;
      if (!!t1.$isDateTime)
        return H.Primitives_lazyAsJsDate(o);
      if (!!t1.$isFunction)
        return P._getJsProxy(o, "$dart_jsFunction", new P._convertToJS_closure());
      return P._getJsProxy(o, "_$dart_jsObject", new P._convertToJS_closure0($.$get$_dartProxyCtor()));
    }, "call$1", "js___convertToJS$closure", 2, 0, 0, 11],
    _getJsProxy: function(o, propertyName, createProxy) {
      var jsProxy = P._getOwnProperty(o, propertyName);
      if (jsProxy == null) {
        jsProxy = createProxy.call$1(o);
        P._defineProperty(o, propertyName, jsProxy);
      }
      return jsProxy;
    },
    _convertToDart: [function(o) {
      var t1, t2;
      if (o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean")
        return o;
      else {
        if (o instanceof Object) {
          t1 = J.getInterceptor(o);
          t1 = !!t1.$isBlob || !!t1.$isEvent0 || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode || !!t1.$isTypedData || !!t1.$isWindow;
        } else
          t1 = false;
        if (t1)
          return o;
        else if (o instanceof Date) {
          t1 = 0 + o.getTime();
          t2 = new P.DateTime(t1, false);
          t2.DateTime$_withValue$2$isUtc(t1, false);
          return t2;
        } else if (o.constructor === $.$get$_dartProxyCtor())
          return o.o;
        else
          return P._wrapToDart(o);
      }
    }, "call$1", "js___convertToDart$closure", 2, 0, 78, 11],
    _wrapToDart: function(o) {
      if (typeof o == "function")
        return P._getDartProxy(o, $.$get$DART_CLOSURE_PROPERTY_NAME(), new P._wrapToDart_closure());
      if (o instanceof Array)
        return P._getDartProxy(o, $.$get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure0());
      return P._getDartProxy(o, $.$get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure1());
    },
    _getDartProxy: function(o, propertyName, createProxy) {
      var dartProxy = P._getOwnProperty(o, propertyName);
      if (dartProxy == null || !(o instanceof Object)) {
        dartProxy = createProxy.call$1(o);
        P._defineProperty(o, propertyName, dartProxy);
      }
      return dartProxy;
    },
    JsObject: {
      "^": "Object;_js$_jsObject",
      $index: ["super$JsObject$$index", function(_, property) {
        if (typeof property !== "string" && typeof property !== "number")
          throw H.wrapException(P.ArgumentError$("property is not a String or num"));
        return P._convertToDart(this._js$_jsObject[property]);
      }],
      $indexSet: ["super$JsObject$$indexSet", function(_, property, value) {
        if (typeof property !== "string" && typeof property !== "number")
          throw H.wrapException(P.ArgumentError$("property is not a String or num"));
        this._js$_jsObject[property] = P._convertToJS(value);
      }],
      get$hashCode: function(_) {
        return 0;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof P.JsObject && this._js$_jsObject === other._js$_jsObject;
      },
      hasProperty$1: function(property) {
        return property in this._js$_jsObject;
      },
      toString$0: function(_) {
        var t1, exception;
        try {
          t1 = String(this._js$_jsObject);
          return t1;
        } catch (exception) {
          H.unwrapException(exception);
          t1 = this.super$Object$toString(this);
          return t1;
        }
      },
      callMethod$2: function(method, args) {
        var t1, t2;
        t1 = this._js$_jsObject;
        t2 = args == null ? null : P.List_List$from(new H.MappedListIterable(args, P.js___convertToJS$closure(), [H.getTypeArgumentByIndex(args, 0), null]), true, null);
        return P._convertToDart(t1[method].apply(t1, t2));
      }
    },
    JsFunction: {
      "^": "JsObject;_js$_jsObject",
      apply$2$thisArg: function(args, thisArg) {
        var t1, t2;
        t1 = P._convertToJS(thisArg);
        t2 = P.List_List$from(args.map$1(0, P.js___convertToJS$closure()), true, null);
        return P._convertToDart(this._js$_jsObject.apply(t1, t2));
      },
      apply$1: function(args) {
        return this.apply$2$thisArg(args, null);
      }
    },
    JsArray: {
      "^": "JsObject_ListMixin;_js$_jsObject,$ti",
      $index: function(_, index) {
        var t1;
        if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index)) {
          if (typeof index === "number" && Math.floor(index) === index)
            t1 = index < 0 || index >= this.get$length(this);
          else
            t1 = false;
          if (t1)
            H.throwExpression(P.RangeError$range(index, 0, this.get$length(this), null, null));
        }
        return this.super$JsObject$$index(0, index);
      },
      $indexSet: function(_, index, value) {
        var t1;
        if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index)) {
          if (typeof index === "number" && Math.floor(index) === index)
            t1 = index < 0 || index >= this.get$length(this);
          else
            t1 = false;
          if (t1)
            H.throwExpression(P.RangeError$range(index, 0, this.get$length(this), null, null));
        }
        this.super$JsObject$$indexSet(0, index, value);
      },
      get$length: function(_) {
        var len = this._js$_jsObject.length;
        if (typeof len === "number" && len >>> 0 === len)
          return len;
        throw H.wrapException(new P.StateError("Bad JsArray length"));
      },
      set$length: function(_, $length) {
        this.super$JsObject$$indexSet(0, "length", $length);
      },
      setRange$4: function(_, start, end, iterable, skipCount) {
        var $length, args;
        P.JsArray__checkRange(start, end, this.get$length(this));
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length === 0)
          return;
        if (J.$lt$n(skipCount, 0))
          throw H.wrapException(P.ArgumentError$(skipCount));
        args = [start, $length];
        C.JSArray_methods.addAll$1(args, J.skip$1$ax(iterable, skipCount).take$1(0, $length));
        this.callMethod$2("splice", args);
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      static: {
        JsArray__checkRange: function(start, end, $length) {
          var t1 = J.getInterceptor$n(start);
          if (t1.$lt(start, 0) || t1.$gt(start, $length))
            throw H.wrapException(P.RangeError$range(start, 0, $length, null, null));
          if (typeof start !== "number")
            return H.iae(start);
          if (end < start || end > $length)
            throw H.wrapException(P.RangeError$range(end, start, $length, null, null));
        }
      }
    },
    JsObject_ListMixin: {
      "^": "JsObject+ListMixin;",
      $asList: null,
      $asEfficientLengthIterable: null,
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    _convertToJS_closure: {
      "^": "Closure:0;",
      call$1: function(o) {
        var jsFunction = function(_call, f, captureThis) {
          return function() {
            return _call(f, captureThis, this, Array.prototype.slice.apply(arguments));
          };
        }(P._callDartFunction, o, false);
        P._defineProperty(jsFunction, $.$get$DART_CLOSURE_PROPERTY_NAME(), o);
        return jsFunction;
      }
    },
    _convertToJS_closure0: {
      "^": "Closure:0;ctor",
      call$1: function(o) {
        return new this.ctor(o);
      }
    },
    _wrapToDart_closure: {
      "^": "Closure:0;",
      call$1: function(o) {
        return new P.JsFunction(o);
      }
    },
    _wrapToDart_closure0: {
      "^": "Closure:0;",
      call$1: function(o) {
        return new P.JsArray(o, [null]);
      }
    },
    _wrapToDart_closure1: {
      "^": "Closure:0;",
      call$1: function(o) {
        return new P.JsObject(o);
      }
    }
  }], ["dart.math", "dart:math",, P, {
    "^": "",
    _JenkinsSmiHash_combine0: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    _JenkinsSmiHash_finish0: function(hash) {
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    Point0: {
      "^": "Object;x>,y>,$ti",
      toString$0: function(_) {
        return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
      },
      $eq: function(_, other) {
        var t1, t2, t3;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        if (!t1.$isPoint0)
          return false;
        t2 = this.x;
        t3 = t1.get$x(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = this.y;
          t1 = t1.get$y(other);
          t1 = t2 == null ? t1 == null : t2 === t1;
        } else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        var t1, t2;
        t1 = J.get$hashCode$(this.x);
        t2 = J.get$hashCode$(this.y);
        return P._JenkinsSmiHash_finish0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, t1), t2));
      },
      $add: function(_, other) {
        var t1, t2, t3, t4;
        t1 = this.x;
        t2 = J.getInterceptor$x(other);
        t3 = t2.get$x(other);
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = this.y;
        t2 = t2.get$y(other);
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return new P.Point0(t1 + t3, t4 + t2, this.$ti);
      },
      $sub: function(_, other) {
        var t1, t2, t3, t4;
        t1 = this.x;
        t2 = J.getInterceptor$x(other);
        t3 = t2.get$x(other);
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = this.y;
        t2 = t2.get$y(other);
        if (typeof t4 !== "number")
          return t4.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return new P.Point0(t1 - t3, t4 - t2, this.$ti);
      },
      $mul: function(_, factor) {
        var t1, t2;
        t1 = this.x;
        if (typeof t1 !== "number")
          return t1.$mul();
        if (typeof factor !== "number")
          return H.iae(factor);
        t2 = this.y;
        if (typeof t2 !== "number")
          return t2.$mul();
        return new P.Point0(t1 * factor, t2 * factor, this.$ti);
      }
    },
    _RectangleBase: {
      "^": "Object;$ti",
      get$right: function(_) {
        var t1, t2;
        t1 = this.left;
        t2 = this.width;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return t1 + t2;
      },
      get$bottom: function(_) {
        var t1, t2;
        t1 = this.top;
        t2 = this.height;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return t1 + t2;
      },
      toString$0: function(_) {
        return "Rectangle (" + H.S(this.left) + ", " + H.S(this.top) + ") " + H.S(this.width) + " x " + H.S(this.height);
      },
      $eq: function(_, other) {
        var t1, t2, t3, t4;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        if (!t1.$isRectangle)
          return false;
        t2 = this.left;
        t3 = t1.get$left(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t3 = this.top;
          t4 = t1.get$top(other);
          if (t3 == null ? t4 == null : t3 === t4) {
            t4 = this.width;
            if (typeof t2 !== "number")
              return t2.$add();
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (t2 + t4 === t1.get$right(other)) {
              t2 = this.height;
              if (typeof t3 !== "number")
                return t3.$add();
              if (typeof t2 !== "number")
                return H.iae(t2);
              t1 = t3 + t2 === t1.get$bottom(other);
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        var t1, t2, t3, t4, t5, t6;
        t1 = this.left;
        t2 = J.get$hashCode$(t1);
        t3 = this.top;
        t4 = J.get$hashCode$(t3);
        t5 = this.width;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        t6 = this.height;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t6 !== "number")
          return H.iae(t6);
        return P._JenkinsSmiHash_finish0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, t2), t4), t1 + t5 & 0x1FFFFFFF), t3 + t6 & 0x1FFFFFFF));
      }
    },
    Rectangle: {
      "^": "_RectangleBase;left>,top>,width>,height>,$ti",
      $asRectangle: null,
      static: {
        Rectangle$: function(left, $top, width, height, $T) {
          var t1, t2;
          if (typeof width !== "number")
            return width.$lt();
          if (width < 0)
            t1 = -width * 0;
          else
            t1 = width;
          if (typeof height !== "number")
            return height.$lt();
          if (height < 0)
            t2 = -height * 0;
          else
            t2 = height;
          return new P.Rectangle(left, $top, t1, t2, [$T]);
        }
      }
    }
  }], ["dart.dom.svg", "dart:svg",, P, {
    "^": "",
    AElement: {
      "^": "GraphicsElement;target=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGAElement"
    },
    Angle: {
      "^": "Interceptor;value=",
      "%": "SVGAngle"
    },
    AnimationElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGAnimateElement|SVGAnimateMotionElement|SVGAnimateTransformElement|SVGAnimationElement|SVGSetElement"
    },
    FEBlendElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEBlendElement"
    },
    FEColorMatrixElement: {
      "^": "SvgElement;type=,height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEColorMatrixElement"
    },
    FEComponentTransferElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEComponentTransferElement"
    },
    FECompositeElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFECompositeElement"
    },
    FEConvolveMatrixElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEConvolveMatrixElement"
    },
    FEDiffuseLightingElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEDiffuseLightingElement"
    },
    FEDisplacementMapElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEDisplacementMapElement"
    },
    FEFloodElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEFloodElement"
    },
    FEGaussianBlurElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEGaussianBlurElement"
    },
    FEImageElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEImageElement"
    },
    FEMergeElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEMergeElement"
    },
    FEMorphologyElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEMorphologyElement"
    },
    FEOffsetElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEOffsetElement"
    },
    FEPointLightElement: {
      "^": "SvgElement;x=,y=",
      "%": "SVGFEPointLightElement"
    },
    FESpecularLightingElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFESpecularLightingElement"
    },
    FESpotLightElement: {
      "^": "SvgElement;x=,y=",
      "%": "SVGFESpotLightElement"
    },
    FETileElement: {
      "^": "SvgElement;height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFETileElement"
    },
    FETurbulenceElement: {
      "^": "SvgElement;type=,height=,result=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFETurbulenceElement"
    },
    FilterElement: {
      "^": "SvgElement;height=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFilterElement"
    },
    ForeignObjectElement: {
      "^": "GraphicsElement;height=,width=,x=,y=",
      "%": "SVGForeignObjectElement"
    },
    GeometryElement: {
      "^": "GraphicsElement;",
      "%": "SVGCircleElement|SVGEllipseElement|SVGLineElement|SVGPathElement|SVGPolygonElement|SVGPolylineElement;SVGGeometryElement"
    },
    GraphicsElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGClipPathElement|SVGDefsElement|SVGGElement|SVGSwitchElement;SVGGraphicsElement"
    },
    ImageElement0: {
      "^": "GraphicsElement;height=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGImageElement"
    },
    Length: {
      "^": "Interceptor;value=",
      $isObject: 1,
      "%": "SVGLength"
    },
    LengthList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin14;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver.getItem(index);
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        return this.$index(receiver, index);
      },
      $isList: 1,
      $asList: function() {
        return [P.Length];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Length];
      },
      $isObject: 1,
      "%": "SVGLengthList"
    },
    Interceptor_ListMixin14: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [P.Length];
      },
      $asEfficientLengthIterable: function() {
        return [P.Length];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin14: {
      "^": "Interceptor_ListMixin14+ImmutableListMixin;",
      $asList: function() {
        return [P.Length];
      },
      $asEfficientLengthIterable: function() {
        return [P.Length];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    MarkerElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGMarkerElement"
    },
    MaskElement: {
      "^": "SvgElement;height=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGMaskElement"
    },
    Number: {
      "^": "Interceptor;value=",
      $isObject: 1,
      "%": "SVGNumber"
    },
    NumberList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin15;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver.getItem(index);
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        return this.$index(receiver, index);
      },
      $isList: 1,
      $asList: function() {
        return [P.Number];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Number];
      },
      $isObject: 1,
      "%": "SVGNumberList"
    },
    Interceptor_ListMixin15: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [P.Number];
      },
      $asEfficientLengthIterable: function() {
        return [P.Number];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin15: {
      "^": "Interceptor_ListMixin15+ImmutableListMixin;",
      $asList: function() {
        return [P.Number];
      },
      $asEfficientLengthIterable: function() {
        return [P.Number];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    PatternElement: {
      "^": "SvgElement;height=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGPatternElement"
    },
    Point1: {
      "^": "Interceptor;x%,y%",
      "%": "SVGPoint"
    },
    PointList: {
      "^": "Interceptor;length=",
      "%": "SVGPointList"
    },
    Rect: {
      "^": "Interceptor;height=,width%,x%,y%",
      "%": "SVGRect"
    },
    RectElement: {
      "^": "GeometryElement;height=,width=,x=,y=",
      "%": "SVGRectElement"
    },
    ScriptElement0: {
      "^": "SvgElement;type=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGScriptElement"
    },
    StringList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin16;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver.getItem(index);
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        return this.$index(receiver, index);
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isObject: 1,
      "%": "SVGStringList"
    },
    Interceptor_ListMixin16: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [P.String];
      },
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin16: {
      "^": "Interceptor_ListMixin16+ImmutableListMixin;",
      $asList: function() {
        return [P.String];
      },
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    StyleElement0: {
      "^": "SvgElement;type=",
      "%": "SVGStyleElement"
    },
    SvgElement: {
      "^": "Element;",
      $isEventTarget: 1,
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGComponentTransferFunctionElement|SVGDescElement|SVGDiscardElement|SVGFEDistantLightElement|SVGFEFuncAElement|SVGFEFuncBElement|SVGFEFuncGElement|SVGFEFuncRElement|SVGFEMergeNodeElement|SVGMetadataElement|SVGStopElement|SVGTitleElement;SVGElement"
    },
    SvgSvgElement: {
      "^": "GraphicsElement;height=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGSVGElement"
    },
    SymbolElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGSymbolElement"
    },
    TextContentElement: {
      "^": "GraphicsElement;",
      "%": ";SVGTextContentElement"
    },
    TextPathElement: {
      "^": "TextContentElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGTextPathElement"
    },
    TextPositioningElement: {
      "^": "TextContentElement;x=,y=",
      "%": "SVGTSpanElement|SVGTextElement|SVGTextPositioningElement"
    },
    Transform: {
      "^": "Interceptor;type=",
      $isObject: 1,
      "%": "SVGTransform"
    },
    TransformList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin17;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver.getItem(index);
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        return this.$index(receiver, index);
      },
      $isList: 1,
      $asList: function() {
        return [P.Transform];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Transform];
      },
      $isObject: 1,
      "%": "SVGTransformList"
    },
    Interceptor_ListMixin17: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [P.Transform];
      },
      $asEfficientLengthIterable: function() {
        return [P.Transform];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin17: {
      "^": "Interceptor_ListMixin17+ImmutableListMixin;",
      $asList: function() {
        return [P.Transform];
      },
      $asEfficientLengthIterable: function() {
        return [P.Transform];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    UseElement: {
      "^": "GraphicsElement;height=,width=,x=,y=",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGUseElement"
    },
    ViewElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGViewElement"
    },
    ViewSpec: {
      "^": "Interceptor;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGViewSpec"
    },
    _GradientElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGGradientElement|SVGLinearGradientElement|SVGRadialGradientElement"
    },
    _SVGCursorElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGCursorElement"
    },
    _SVGFEDropShadowElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGFEDropShadowElement"
    },
    _SVGMPathElement: {
      "^": "SvgElement;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "SVGMPathElement"
    }
  }], ["dart.typed_data", "dart:typed_data",, P, {
    "^": "",
    Uint8List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      }
    },
    Float32List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isTypedData: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      }
    }
  }], ["dart.dom.web_audio", "dart:web_audio",, P, {
    "^": "",
    AudioBuffer: {
      "^": "Interceptor;duration=,length=,sampleRate=",
      getChannelData$1: function(receiver, channelIndex) {
        return receiver.getChannelData(channelIndex);
      },
      $isAudioBuffer: 1,
      $isObject: 1,
      "%": "AudioBuffer"
    },
    AudioBufferSourceNode: {
      "^": "AudioSourceNode;loop=,loopEnd=,loopStart=",
      start$3: [function(receiver, when, grainOffset, grainDuration) {
        if (!!receiver.start)
          if (grainDuration != null)
            receiver.start(when, grainOffset, grainDuration);
          else if (grainOffset != null)
            receiver.start(when, grainOffset);
          else
            receiver.start(when);
        else if (grainDuration != null)
          receiver.noteOn(when, grainOffset, grainDuration);
        else if (grainOffset != null)
          receiver.noteOn(when, grainOffset);
        else
          receiver.noteOn(when);
      }, function($receiver, when) {
        return this.start$3($receiver, when, null, null);
      }, "start$1", function($receiver, when, grainOffset) {
        return this.start$3($receiver, when, grainOffset, null);
      }, "start$2", "call$3", "call$1", "call$2", "get$start", 2, 4, 32, 1, 1],
      stop$1: function(receiver, when) {
        if (!!receiver.stop)
          receiver.stop(when);
        else
          receiver.noteOff(when);
      },
      "%": "AudioBufferSourceNode"
    },
    AudioContext: {
      "^": "EventTarget;sampleRate=",
      createGain$0: function(receiver) {
        if (receiver.createGain !== undefined)
          return receiver.createGain();
        else
          return receiver.createGainNode();
      },
      createScriptProcessor$3: function(receiver, bufferSize, numberOfInputChannels, numberOfOutputChannels) {
        var t1 = (receiver.createScriptProcessor || receiver.createJavaScriptNode).call(receiver, bufferSize, numberOfInputChannels, numberOfOutputChannels);
        return t1;
      },
      _decodeAudioData$3: function(receiver, audioData, successCallback, errorCallback) {
        return receiver.decodeAudioData(audioData, H.convertDartClosureToJS(successCallback, 1), H.convertDartClosureToJS(errorCallback, 1));
      },
      decodeAudioData$1: function(receiver, audioData) {
        var t1, t2, completer;
        t1 = P.AudioBuffer;
        t2 = new P._Future(0, $.Zone__current, null, [t1]);
        completer = new P._AsyncCompleter(t2, [t1]);
        this._decodeAudioData$3(receiver, audioData, new P.AudioContext_decodeAudioData_closure(completer), new P.AudioContext_decodeAudioData_closure0(completer));
        return t2;
      },
      "%": "AudioContext|OfflineAudioContext|webkitAudioContext"
    },
    AudioContext_decodeAudioData_closure: {
      "^": "Closure:0;completer",
      call$1: [function(value) {
        this.completer.complete$1(0, value);
      }, null, null, 2, 0, null, 3, "call"]
    },
    AudioContext_decodeAudioData_closure0: {
      "^": "Closure:0;completer",
      call$1: [function(error) {
        var t1 = this.completer;
        if (error == null)
          t1.completeError$1("");
        else
          t1.completeError$1(error);
      }, null, null, 2, 0, null, 2, "call"]
    },
    AudioNode: {
      "^": "EventTarget;",
      "%": "AnalyserNode|AudioChannelMerger|AudioChannelSplitter|AudioDestinationNode|AudioGainNode|AudioPannerNode|ChannelMergerNode|ChannelSplitterNode|ConvolverNode|DelayNode|DynamicsCompressorNode|GainNode|IIRFilterNode|JavaScriptAudioNode|MediaStreamAudioDestinationNode|PannerNode|RealtimeAnalyserNode|ScriptProcessorNode|WaveShaperNode|webkitAudioPannerNode;AudioNode"
    },
    AudioParam: {
      "^": "Interceptor;value=",
      "%": "AudioParam"
    },
    AudioProcessingEvent: {
      "^": "Event0;inputBuffer=",
      "%": "AudioProcessingEvent"
    },
    AudioSourceNode: {
      "^": "AudioNode;",
      "%": "MediaElementAudioSourceNode|MediaStreamAudioSourceNode;AudioSourceNode"
    },
    BiquadFilterNode: {
      "^": "AudioNode;type=",
      "%": "BiquadFilterNode"
    },
    OscillatorNode: {
      "^": "AudioSourceNode;type=",
      start$1: [function(receiver, when) {
        return receiver.start(when);
      }, function($receiver) {
        return $receiver.start();
      }, "start$0", "call$1", "call$0", "get$start", 0, 2, 33, 1],
      "%": "Oscillator|OscillatorNode"
    },
    StereoPannerNode: {
      "^": "AudioNode;pan=",
      "%": "StereoPannerNode"
    }
  }], ["dart.dom.web_gl", "dart:web_gl",, P, {
    "^": "",
    ActiveInfo: {
      "^": "Interceptor;name=,type=",
      "%": "WebGLActiveInfo"
    },
    ContextEvent: {
      "^": "Event0;",
      $isContextEvent: 1,
      $isEvent0: 1,
      $isObject: 1,
      "%": "WebGLContextEvent"
    },
    RenderingContext: {
      "^": "Interceptor;",
      flush$0: function(receiver) {
        return receiver.flush();
      },
      texImage2D$9: function(receiver, target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels) {
        var t1, t2;
        t1 = type == null;
        if (!t1 && format != null && typeof bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video === "number" && Math.floor(bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video) === bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video) {
          receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);
          return;
        }
        t2 = J.getInterceptor(bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video);
        if ((!!t2.$isImageData || bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && t1 && true) {
          receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, P.convertDartToNative_ImageData(bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video));
          return;
        }
        if (!!t2.$isImageElement && format == null && t1 && true) {
          receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video);
          return;
        }
        if (!!t2.$isCanvasElement && format == null && t1 && true) {
          receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video);
          return;
        }
        if (!!t2.$isVideoElement && format == null && t1 && true) {
          receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video);
          return;
        }
        if (!!t2.$isImageBitmap && format == null && t1 && true) {
          receiver.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video);
          return;
        }
        throw H.wrapException(P.ArgumentError$("Incorrect number or type of arguments"));
      },
      texImage2D$6: function($receiver, target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video) {
        return this.texImage2D$9($receiver, target, level, internalformat, format_OR_width, height_OR_type, bitmap_OR_border_OR_canvas_OR_image_OR_pixels_OR_video, null, null, null);
      },
      $isRenderingContext: 1,
      $isObject: 1,
      "%": "WebGLRenderingContext"
    },
    RenderingContext2: {
      "^": "Interceptor;",
      flush$0: function(receiver) {
        return receiver.flush();
      },
      $isInterceptor: 1,
      $isObject: 1,
      "%": "WebGL2RenderingContext"
    },
    UniformLocation: {
      "^": "Interceptor;",
      $isUniformLocation: 1,
      $isObject: 1,
      "%": "WebGLUniformLocation"
    },
    _WebGL2RenderingContextBase: {
      "^": "Interceptor;",
      $isInterceptor: 1,
      $isObject: 1,
      "%": "WebGL2RenderingContextBase"
    }
  }], ["dart.dom.web_sql", "dart:web_sql",, P, {
    "^": "",
    SqlResultSetRowList: {
      "^": "Interceptor_ListMixin_ImmutableListMixin18;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return P.convertNativeToDart_Dictionary(receiver.item(index));
      },
      $indexSet: function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot assign element of immutable List."));
      },
      set$length: function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot resize immutable List."));
      },
      elementAt$1: function(receiver, index) {
        return this.$index(receiver, index);
      },
      $isList: 1,
      $asList: function() {
        return [P.Map];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Map];
      },
      $isObject: 1,
      "%": "SQLResultSetRowList"
    },
    Interceptor_ListMixin18: {
      "^": "Interceptor+ListMixin;",
      $asList: function() {
        return [P.Map];
      },
      $asEfficientLengthIterable: function() {
        return [P.Map];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    },
    Interceptor_ListMixin_ImmutableListMixin18: {
      "^": "Interceptor_ListMixin18+ImmutableListMixin;",
      $asList: function() {
        return [P.Map];
      },
      $asEfficientLengthIterable: function() {
        return [P.Map];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1
    }
  }], ["archive", "package:archive/archive.dart",, T, {
    "^": "",
    Archive: {
      "^": "IterableBase;files,comment",
      get$length: function(_) {
        return this.files.length;
      },
      $index: function(_, index) {
        var t1 = this.files;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return t1[index];
      },
      get$isEmpty: function(_) {
        return this.files.length === 0;
      },
      get$iterator: function(_) {
        var t1 = this.files;
        return new J.ArrayIterator(t1, t1.length, 0, null);
      },
      $asIterableBase: function() {
        return [T.ArchiveFile];
      },
      $asIterable: function() {
        return [T.ArchiveFile];
      }
    },
    ArchiveFile: {
      "^": "Object;name>,size,mode,ownerId,groupId,lastModTime,isFile,unixPermissions,crc32,comment,compress,_compressionType,_rawContent,_content",
      get$content: function(_) {
        var t1, t2, t3, t4;
        t1 = this._content;
        if (t1 == null) {
          t2 = this._rawContent;
          if (t2 != null) {
            if (this._compressionType === 8) {
              t1 = T.HuffmanTable$(C.List_2Bc);
              t3 = T.HuffmanTable$(C.List_X3d);
              t4 = T.OutputStream$(0, this.size);
              new T.Inflate(t2, t4, 0, 0, 0, t1, t3)._inflate$0();
              t3 = t4._buffer.buffer;
              t4 = t4.length;
              t3.toString;
              t4 = H.NativeUint8List_NativeUint8List$view(t3, 0, t4);
              this._content = t4;
              t1 = t4;
            } else {
              t1 = t2.toUint8List$0();
              this._content = t1;
            }
            this._compressionType = 0;
          }
        }
        return t1;
      },
      toString$0: function(_) {
        return this.name;
      }
    },
    ArchiveException: {
      "^": "Object;message",
      toString$0: function(_) {
        return "ArchiveException: " + this.message;
      }
    },
    InputStream: {
      "^": "Object;buffer,offset,start>,byteOrder,_archive$_length",
      get$length: function(_) {
        var t1, t2, t3;
        t1 = this._archive$_length;
        t2 = this.offset;
        t3 = this.start;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        return t1 - (t2 - t3);
      },
      $index: function(_, index) {
        var t1, t2;
        t1 = this.buffer;
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof index !== "number")
          return H.iae(index);
        t2 += index;
        if (t2 >>> 0 !== t2 || t2 >= t1.length)
          return H.ioore(t1, t2);
        return t1[t2];
      },
      subset$2: function(position, $length) {
        var t1, t2;
        if (position == null)
          position = this.offset;
        else {
          t1 = this.start;
          if (typeof t1 !== "number")
            return H.iae(t1);
          position += t1;
        }
        if ($length == null || false) {
          t1 = this._archive$_length;
          t2 = this.start;
          if (typeof position !== "number")
            return position.$sub();
          if (typeof t2 !== "number")
            return H.iae(t2);
          $length = t1 - (position - t2);
        }
        return T.InputStream$(this.buffer, this.byteOrder, $length, position);
      },
      indexOf$2: function(_, value, offset) {
        var t1, i, t2, t3, end;
        t1 = this.offset;
        if (typeof t1 !== "number")
          return t1.$add();
        i = t1 + offset;
        t2 = this._archive$_length;
        t3 = this.start;
        if (typeof t3 !== "number")
          return H.iae(t3);
        end = t1 + (t2 - (t1 - t3));
        t1 = this.buffer;
        for (; i < end; ++i) {
          if (i < 0 || i >= t1.length)
            return H.ioore(t1, i);
          if (J.$eq$(t1[i], value))
            return i - t3;
        }
        return -1;
      },
      indexOf$1: function($receiver, value) {
        return this.indexOf$2($receiver, value, 0);
      },
      readBytes$1: function(count) {
        var t1, t2, bytes, t3, t4;
        t1 = this.offset;
        t2 = this.start;
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        bytes = this.subset$2(t1 - t2, count);
        t2 = this.offset;
        t1 = bytes._archive$_length;
        t3 = bytes.offset;
        t4 = bytes.start;
        if (typeof t3 !== "number")
          return t3.$sub();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + (t1 - (t3 - t4));
        return bytes;
      },
      readString$1: function(len) {
        return P.String_String$fromCharCodes(this.readBytes$1(len).toUint8List$0(), 0, null);
      },
      readUint16$0: function() {
        var t1, t2, b1, b2;
        t1 = this.buffer;
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b1 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b2 = J.$and$n(t1[t2], 255);
        if (this.byteOrder === 1)
          return (b1 << 8 | b2) >>> 0;
        return (b2 << 8 | b1) >>> 0;
      },
      readUint32$0: function() {
        var t1, t2, b1, b2, b3, b4;
        t1 = this.buffer;
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b1 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b2 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b3 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b4 = J.$and$n(t1[t2], 255);
        if (this.byteOrder === 1)
          return (b1 << 24 | b2 << 16 | b3 << 8 | b4) >>> 0;
        return (b4 << 24 | b3 << 16 | b2 << 8 | b1) >>> 0;
      },
      readUint64$0: function() {
        var t1, t2, b1, b2, b3, b4, b5, b6, b7, b8;
        t1 = this.buffer;
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b1 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b2 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b3 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b4 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b5 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b6 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b7 = J.$and$n(t1[t2], 255);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return t2.$add();
        this.offset = t2 + 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        b8 = J.$and$n(t1[t2], 255);
        if (this.byteOrder === 1)
          return (C.JSInt_methods._shlPositive$1(b1, 56) | C.JSInt_methods._shlPositive$1(b2, 48) | C.JSInt_methods._shlPositive$1(b3, 40) | C.JSInt_methods._shlPositive$1(b4, 32) | b5 << 24 | b6 << 16 | b7 << 8 | b8) >>> 0;
        return (C.JSInt_methods._shlPositive$1(b8, 56) | C.JSInt_methods._shlPositive$1(b7, 48) | C.JSInt_methods._shlPositive$1(b6, 40) | C.JSInt_methods._shlPositive$1(b5, 32) | b4 << 24 | b3 << 16 | b2 << 8 | b1) >>> 0;
      },
      toUint8List$0: function() {
        var t1, t2, t3, len, end, end0;
        t1 = this._archive$_length;
        t2 = this.offset;
        t3 = this.start;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        len = t1 - (t2 - t3);
        t1 = this.buffer;
        t3 = J.getInterceptor(t1);
        if (!!t3.$isUint8List) {
          t3 = t1.length;
          if (t2 + len > t3)
            len = t3 - t2;
          t1 = t1.buffer;
          t2 = this.offset;
          t1.toString;
          return H.NativeUint8List_NativeUint8List$view(t1, t2, len);
        }
        end = t2 + len;
        end0 = t1.length;
        return new Uint8Array(H._ensureNativeList(t3.sublist$2(t1, t2, end > end0 ? end0 : end)));
      },
      InputStream$4$byteOrder$length$start: function(data, byteOrder, $length, start) {
        this._archive$_length = $length == null ? this.buffer.length : $length;
        this.offset = start;
      },
      static: {
        InputStream$: function(data, byteOrder, $length, start) {
          var t1;
          H.subtypeCast(data, "$isList", [P.int], "$asList");
          t1 = new T.InputStream(data, null, start, byteOrder, null);
          t1.InputStream$4$byteOrder$length$start(data, byteOrder, $length, start);
          return t1;
        }
      }
    },
    OutputStream: {
      "^": "Object;length>,byteOrder,_buffer",
      writeBytes$2: function(bytes, len) {
        var t1, t2, t3, t4;
        len = bytes.length;
        for (; t1 = this.length, t2 = t1 + len, t3 = this._buffer, t4 = t3.length, t2 > t4;)
          this._expandBuffer$1(t2 - t4);
        C.NativeUint8List_methods.setRange$3(t3, t1, t2, bytes);
        this.length += len;
      },
      writeBytes$1: function(bytes) {
        return this.writeBytes$2(bytes, null);
      },
      writeInputStream$1: function(bytes) {
        var t1, t2, t3, t4, t5, t6;
        t1 = bytes.start;
        while (true) {
          t2 = this.length;
          t3 = bytes._archive$_length;
          t4 = bytes.offset;
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t3 = t2 + (t3 - (t4 - t1));
          t5 = this._buffer;
          t6 = t5.length;
          if (!(t3 > t6))
            break;
          this._expandBuffer$1(t3 - t6);
        }
        C.NativeUint8List_methods.setRange$4(t5, t2, t3, bytes.buffer, t4);
        t2 = this.length;
        t3 = bytes._archive$_length;
        t4 = bytes.offset;
        if (typeof t4 !== "number")
          return t4.$sub();
        this.length = t2 + (t3 - (t4 - t1));
      },
      subset$2: function(start, end) {
        var t1;
        if (start < 0)
          start = this.length + start;
        if (end == null)
          end = this.length;
        else if (end < 0)
          end = this.length + end;
        t1 = this._buffer.buffer;
        t1.toString;
        return H.NativeUint8List_NativeUint8List$view(t1, start, end - start);
      },
      subset$1: function(start) {
        return this.subset$2(start, null);
      },
      _expandBuffer$1: function(required) {
        var blockSize, t1, newBuffer;
        blockSize = required != null ? required > 32768 ? required : 32768 : 32768;
        t1 = this._buffer;
        newBuffer = new Uint8Array((t1.length + blockSize) * 2);
        t1 = this._buffer;
        C.NativeUint8List_methods.setRange$3(newBuffer, 0, t1.length, t1);
        this._buffer = newBuffer;
      },
      _expandBuffer$0: function() {
        return this._expandBuffer$1(null);
      },
      static: {
        OutputStream$: function(byteOrder, size) {
          return new T.OutputStream(0, byteOrder, new Uint8Array(H._checkLength(size == null ? 32768 : size)));
        }
      }
    },
    ZipDirectory: {
      "^": "Object;filePosition,numberOfThisDisk,diskWithTheStartOfTheCentralDirectory,totalCentralDirectoryEntriesOnThisDisk,totalCentralDirectoryEntries,centralDirectorySize,centralDirectoryOffset,zipFileComment,fileHeaders",
      _readZip64Data$1: function(input) {
        var ip, zip64, zip64DirOffset, zip64DiskNumber, zip64StartDisk, zip64NumEntriesOnDisk, zip64NumEntries, dirSize, dirOffset;
        ip = input.offset;
        zip64 = input.subset$2(this.filePosition - 20, 20);
        if (zip64.readUint32$0() !== 117853008) {
          input.offset = ip;
          return;
        }
        zip64.readUint32$0();
        zip64DirOffset = zip64.readUint64$0();
        zip64.readUint32$0();
        input.offset = zip64DirOffset;
        if (input.readUint32$0() !== 101075792) {
          input.offset = ip;
          return;
        }
        input.readUint64$0();
        input.readUint16$0();
        input.readUint16$0();
        zip64DiskNumber = input.readUint32$0();
        zip64StartDisk = input.readUint32$0();
        zip64NumEntriesOnDisk = input.readUint64$0();
        zip64NumEntries = input.readUint64$0();
        dirSize = input.readUint64$0();
        dirOffset = input.readUint64$0();
        this.numberOfThisDisk = zip64DiskNumber;
        this.diskWithTheStartOfTheCentralDirectory = zip64StartDisk;
        this.totalCentralDirectoryEntriesOnThisDisk = zip64NumEntriesOnDisk;
        this.totalCentralDirectoryEntries = zip64NumEntries;
        this.centralDirectorySize = dirSize;
        this.centralDirectoryOffset = dirOffset;
        input.offset = ip;
      },
      _findSignature$1: function(input) {
        var pos, t1, t2, ip;
        pos = input.offset;
        t1 = input._archive$_length;
        t2 = input.start;
        if (typeof pos !== "number")
          return pos.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        for (ip = t1 - (pos - t2) - 4; ip > 0; --ip) {
          input.offset = ip;
          if (input.readUint32$0() === 101010256) {
            input.offset = pos;
            return ip;
          }
        }
        throw H.wrapException(new T.ArchiveException("Could not find End of Central Directory Record"));
      },
      ZipDirectory$read$1: function(input) {
        var t1, len, dirContent, t2, t3, t4, fname_len, extra_len, comment_len, t5, bytes, t6, t7, t8, id, size;
        t1 = this._findSignature$1(input);
        this.filePosition = t1;
        input.offset = t1;
        input.readUint32$0();
        this.numberOfThisDisk = input.readUint16$0();
        this.diskWithTheStartOfTheCentralDirectory = input.readUint16$0();
        this.totalCentralDirectoryEntriesOnThisDisk = input.readUint16$0();
        this.totalCentralDirectoryEntries = input.readUint16$0();
        this.centralDirectorySize = input.readUint32$0();
        this.centralDirectoryOffset = input.readUint32$0();
        len = input.readUint16$0();
        if (len > 0)
          this.zipFileComment = input.readString$1(len);
        this._readZip64Data$1(input);
        dirContent = input.subset$2(this.centralDirectoryOffset, this.centralDirectorySize);
        t1 = dirContent.start;
        if (typeof t1 !== "number")
          return t1.$add();
        t2 = this.fileHeaders;
        while (true) {
          t3 = dirContent.offset;
          t4 = dirContent._archive$_length;
          if (typeof t3 !== "number")
            return t3.$ge();
          if (!(t3 < t1 + t4))
            break;
          if (dirContent.readUint32$0() !== 33639248)
            break;
          t3 = new T.ZipFileHeader(0, 0, 0, 0, 0, 0, null, null, null, null, null, null, null, "", [], "", null);
          t3.versionMadeBy = dirContent.readUint16$0();
          t3.versionNeededToExtract = dirContent.readUint16$0();
          t3.generalPurposeBitFlag = dirContent.readUint16$0();
          t3.compressionMethod = dirContent.readUint16$0();
          t3.lastModifiedFileTime = dirContent.readUint16$0();
          t3.lastModifiedFileDate = dirContent.readUint16$0();
          t3.crc32 = dirContent.readUint32$0();
          t3.compressedSize = dirContent.readUint32$0();
          t3.uncompressedSize = dirContent.readUint32$0();
          fname_len = dirContent.readUint16$0();
          extra_len = dirContent.readUint16$0();
          comment_len = dirContent.readUint16$0();
          t3.diskNumberStart = dirContent.readUint16$0();
          t3.internalFileAttributes = dirContent.readUint16$0();
          t3.externalFileAttributes = dirContent.readUint32$0();
          t4 = dirContent.readUint32$0();
          t3.localHeaderOffset = t4;
          if (fname_len > 0)
            t3.filename = dirContent.readString$1(fname_len);
          if (extra_len > 0) {
            t5 = dirContent.offset;
            if (typeof t5 !== "number")
              return t5.$sub();
            bytes = dirContent.subset$2(t5 - t1, extra_len);
            t5 = dirContent.offset;
            t6 = bytes._archive$_length;
            t7 = bytes.offset;
            t8 = bytes.start;
            if (typeof t7 !== "number")
              return t7.$sub();
            if (typeof t8 !== "number")
              return H.iae(t8);
            if (typeof t5 !== "number")
              return t5.$add();
            dirContent.offset = t5 + (t6 - (t7 - t8));
            t3.extraField = bytes.toUint8List$0();
            id = bytes.readUint16$0();
            size = bytes.readUint16$0();
            if (id === 1) {
              if (size >= 8)
                t3.uncompressedSize = bytes.readUint64$0();
              if (size >= 16)
                t3.compressedSize = bytes.readUint64$0();
              if (size >= 24) {
                t4 = bytes.readUint64$0();
                t3.localHeaderOffset = t4;
              }
              if (size >= 28)
                t3.diskNumberStart = bytes.readUint32$0();
            }
          }
          if (comment_len > 0)
            t3.fileComment = dirContent.readString$1(comment_len);
          input.offset = t4;
          t3.file = T.ZipFile$(input, t3);
          t2.push(t3);
        }
      },
      static: {
        ZipDirectory$read: function(input) {
          var t1 = new T.ZipDirectory(-1, 0, 0, 0, 0, null, null, "", []);
          t1.ZipDirectory$read$1(input);
          return t1;
        }
      }
    },
    ZipFile: {
      "^": "Object;signature,version,flags,compressionMethod,lastModFileTime,lastModFileDate,crc32,compressedSize,uncompressedSize,filename,extraField,header,_rawContent,_content,_computedCrc32",
      toString$0: function(_) {
        return this.filename;
      },
      ZipFile$2: function(input, header) {
        var t1, fn_len, ex_len, sigOrCrc;
        t1 = input.readUint32$0();
        this.signature = t1;
        if (t1 !== 67324752)
          throw H.wrapException(new T.ArchiveException("Invalid Zip Signature"));
        this.version = input.readUint16$0();
        this.flags = input.readUint16$0();
        this.compressionMethod = input.readUint16$0();
        this.lastModFileTime = input.readUint16$0();
        this.lastModFileDate = input.readUint16$0();
        this.crc32 = input.readUint32$0();
        this.compressedSize = input.readUint32$0();
        this.uncompressedSize = input.readUint32$0();
        fn_len = input.readUint16$0();
        ex_len = input.readUint16$0();
        this.filename = input.readString$1(fn_len);
        this.extraField = input.readBytes$1(ex_len).toUint8List$0();
        this._rawContent = input.readBytes$1(this.header.compressedSize);
        if ((this.flags & 8) !== 0) {
          sigOrCrc = input.readUint32$0();
          if (sigOrCrc === 134695760)
            this.crc32 = input.readUint32$0();
          else
            this.crc32 = sigOrCrc;
          this.compressedSize = input.readUint32$0();
          this.uncompressedSize = input.readUint32$0();
        }
      },
      static: {
        ZipFile$: function(input, header) {
          var t1 = new T.ZipFile(67324752, 0, 0, 0, 0, 0, null, null, null, "", [], header, null, null, null);
          t1.ZipFile$2(input, header);
          return t1;
        }
      }
    },
    ZipFileHeader: {
      "^": "Object;versionMadeBy,versionNeededToExtract,generalPurposeBitFlag,compressionMethod,lastModifiedFileTime,lastModifiedFileDate,crc32,compressedSize,uncompressedSize,diskNumberStart,internalFileAttributes,externalFileAttributes,localHeaderOffset,filename,extraField,fileComment,file",
      toString$0: function(_) {
        return this.filename;
      }
    },
    ZipDecoder: {
      "^": "Object;directory",
      decodeBuffer$2$verify: function(input, verify) {
        var t1, t2, t3, t4, _i, zfh, zf, t5, unixAttributes, $content, file, t6, t7, t8, t9, isDirectory, isFile;
        t1 = T.ZipDirectory$read(input);
        this.directory = t1;
        t2 = [];
        for (t1 = t1.fileHeaders, t3 = t1.length, t4 = [P.int], _i = 0; _i < t1.length; t1.length === t3 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          zfh = t1[_i];
          zf = zfh.file;
          t5 = zfh.externalFileAttributes;
          if (typeof t5 !== "number")
            return t5.$shr();
          unixAttributes = t5 >>> 16;
          $content = zf._content;
          $content = $content != null ? $content : zf._rawContent;
          t5 = zf.filename;
          file = new T.ArchiveFile(t5, zf.uncompressedSize, null, 0, 0, null, true, null, null, null, true, zf.compressionMethod, null, null);
          if (H.checkSubtype($content, "$isList", t4, "$asList")) {
            file._content = $content;
            file._rawContent = T.InputStream$($content, 0, null, 0);
          } else if ($content instanceof T.InputStream) {
            t6 = $content.buffer;
            t7 = $content.offset;
            t8 = $content.start;
            t9 = $content._archive$_length;
            file._rawContent = new T.InputStream(t6, t7, t8, $content.byteOrder, t9);
          }
          file.unixPermissions = unixAttributes & 511;
          if (zfh.versionMadeBy >>> 8 === 3) {
            isDirectory = (unixAttributes & 28672) === 16384;
            isFile = (unixAttributes & 258048) === 32768;
            if (isFile || isDirectory)
              file.isFile = isFile;
          } else
            file.isFile = !C.JSString_methods.endsWith$1(t5, "/");
          file.crc32 = zf.crc32;
          t2.push(file);
        }
        return new T.Archive(t2, null);
      }
    },
    HuffmanTable: {
      "^": "Object;table,maxCodeLength,minCodeLength",
      HuffmanTable$1: function(lengths) {
        var listSize, i, t1, size, t2, t3, t4, bitLength, code, skip, t5, rtemp, reversed, j, t6;
        listSize = lengths.length;
        for (i = 0; i < listSize; ++i) {
          t1 = lengths[i];
          if (t1 > this.maxCodeLength)
            this.maxCodeLength = t1;
          if (t1 < this.minCodeLength)
            this.minCodeLength = t1;
        }
        size = C.JSInt_methods._shlPositive$1(1, this.maxCodeLength);
        t1 = H._checkLength(size);
        t2 = new Uint32Array(t1);
        this.table = t2;
        for (t3 = this.maxCodeLength, t4 = lengths.length, bitLength = 1, code = 0, skip = 2; bitLength <= t3;) {
          for (t5 = bitLength << 16, i = 0; i < listSize; ++i) {
            if (i >= t4)
              return H.ioore(lengths, i);
            if (lengths[i] === bitLength) {
              for (rtemp = code, reversed = 0, j = 0; j < bitLength; ++j) {
                reversed = (reversed << 1 | rtemp & 1) >>> 0;
                rtemp = rtemp >>> 1;
              }
              for (t6 = (t5 | i) >>> 0, j = reversed; j < size; j += skip) {
                if (j < 0 || j >= t1)
                  return H.ioore(t2, j);
                t2[j] = t6;
              }
              ++code;
            }
          }
          ++bitLength;
          code = code << 1 >>> 0;
          skip = skip << 1 >>> 0;
        }
      },
      static: {
        HuffmanTable$: function(lengths) {
          var t1 = new T.HuffmanTable(null, 0, 2147483647);
          t1.HuffmanTable$1(lengths);
          return t1;
        }
      }
    },
    Inflate: {
      "^": "Object;input,output,_bitBuffer,_bitBufferLen,_blockPos,_fixedLiteralLengthTable,_fixedDistanceTable",
      _inflate$0: function() {
        var t1, t2, t3, t4;
        this._bitBuffer = 0;
        this._bitBufferLen = 0;
        t1 = this.input;
        t2 = t1.start;
        if (typeof t2 !== "number")
          return t2.$add();
        while (true) {
          t3 = t1.offset;
          t4 = t1._archive$_length;
          if (typeof t3 !== "number")
            return t3.$ge();
          if (!(t3 < t2 + t4))
            break;
          if (!this._parseBlock$0())
            break;
        }
      },
      _parseBlock$0: function() {
        var t1, t2, t3, t4, hdr, btype, len, bytes, t5;
        t1 = this.input;
        t2 = t1.offset;
        t3 = t1.start;
        t4 = t1._archive$_length;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t2 !== "number")
          return t2.$ge();
        if (t2 >= t3 + t4)
          return false;
        hdr = this._readBits$1(3);
        btype = hdr >>> 1;
        switch (btype) {
          case 0:
            this._bitBuffer = 0;
            this._bitBufferLen = 0;
            len = this._readBits$1(16);
            t2 = this._readBits$1(16);
            if (len !== 0 && len !== (t2 ^ 65535) >>> 0)
              H.throwExpression(new T.ArchiveException("Invalid uncompressed block header"));
            t2 = t1._archive$_length;
            t4 = t1.offset;
            if (typeof t4 !== "number")
              return t4.$sub();
            t3 = t4 - t3;
            if (len > t2 - t3)
              H.throwExpression(new T.ArchiveException("Input buffer is broken"));
            bytes = t1.subset$2(t3, len);
            t2 = t1.offset;
            t3 = bytes._archive$_length;
            t4 = bytes.offset;
            t5 = bytes.start;
            if (typeof t4 !== "number")
              return t4.$sub();
            if (typeof t5 !== "number")
              return H.iae(t5);
            if (typeof t2 !== "number")
              return t2.$add();
            t1.offset = t2 + (t3 - (t4 - t5));
            this.output.writeInputStream$1(bytes);
            break;
          case 1:
            this._decodeHuffman$2(this._fixedLiteralLengthTable, this._fixedDistanceTable);
            break;
          case 2:
            this._parseDynamicHuffmanBlock$0();
            break;
          default:
            throw H.wrapException(new T.ArchiveException("unknown BTYPE: " + btype));
        }
        return (hdr & 1) === 0;
      },
      _readBits$1: function($length) {
        var t1, t2, t3, t4, t5, octet;
        if ($length === 0)
          return 0;
        for (t1 = this.input; t2 = this._bitBufferLen, t2 < $length;) {
          t3 = t1.offset;
          t4 = t1.start;
          t5 = t1._archive$_length;
          if (typeof t4 !== "number")
            return t4.$add();
          if (typeof t3 !== "number")
            return t3.$ge();
          if (t3 >= t4 + t5)
            throw H.wrapException(new T.ArchiveException("input buffer is broken"));
          t4 = t1.buffer;
          t1.offset = t3 + 1;
          if (t3 < 0 || t3 >= t4.length)
            return H.ioore(t4, t3);
          octet = t4[t3];
          this._bitBuffer = (this._bitBuffer | J.$shl$n(octet, t2)) >>> 0;
          this._bitBufferLen += 8;
        }
        t1 = this._bitBuffer;
        t3 = C.JSInt_methods._shlPositive$1(1, $length);
        this._bitBuffer = C.JSInt_methods._shrBothPositive$1(t1, $length);
        this._bitBufferLen = t2 - $length;
        return (t1 & t3 - 1) >>> 0;
      },
      _readCodeByTable$1: function(table) {
        var codeTable, maxCodeLength, t1, t2, t3, t4, t5, octet, codeWithLength, codeLength;
        codeTable = table.table;
        maxCodeLength = table.maxCodeLength;
        for (t1 = this.input; t2 = this._bitBufferLen, t2 < maxCodeLength;) {
          t3 = t1.offset;
          t4 = t1.start;
          t5 = t1._archive$_length;
          if (typeof t4 !== "number")
            return t4.$add();
          if (typeof t3 !== "number")
            return t3.$ge();
          if (t3 >= t4 + t5)
            break;
          t4 = t1.buffer;
          t1.offset = t3 + 1;
          if (t3 < 0 || t3 >= t4.length)
            return H.ioore(t4, t3);
          octet = t4[t3];
          this._bitBuffer = (this._bitBuffer | J.$shl$n(octet, t2)) >>> 0;
          this._bitBufferLen += 8;
        }
        t1 = this._bitBuffer;
        t3 = (t1 & C.JSInt_methods._shlPositive$1(1, maxCodeLength) - 1) >>> 0;
        if (t3 >= codeTable.length)
          return H.ioore(codeTable, t3);
        codeWithLength = codeTable[t3];
        codeLength = codeWithLength >>> 16;
        this._bitBuffer = C.JSInt_methods._shrBothPositive$1(t1, codeLength);
        this._bitBufferLen = t2 - codeLength;
        return codeWithLength & 65535;
      },
      _parseDynamicHuffmanBlock$0: function() {
        var numLitLengthCodes, numDistanceCodes, numCodeLengths, t1, codeLengths, i, t2, t3, codeLengthsTable, litlenLengths, distLengths, litlen, dist;
        numLitLengthCodes = this._readBits$1(5) + 257;
        numDistanceCodes = this._readBits$1(5) + 1;
        numCodeLengths = this._readBits$1(4) + 4;
        t1 = H._checkLength(19);
        codeLengths = new Uint8Array(t1);
        for (i = 0; i < numCodeLengths; ++i) {
          if (i >= 19)
            return H.ioore(C.List_uSC, i);
          t2 = C.List_uSC[i];
          t3 = this._readBits$1(3);
          if (t2 >= t1)
            return H.ioore(codeLengths, t2);
          codeLengths[t2] = t3;
        }
        codeLengthsTable = T.HuffmanTable$(codeLengths);
        litlenLengths = new Uint8Array(H._checkLength(numLitLengthCodes));
        distLengths = new Uint8Array(H._checkLength(numDistanceCodes));
        litlen = this._decode$3(numLitLengthCodes, codeLengthsTable, litlenLengths);
        dist = this._decode$3(numDistanceCodes, codeLengthsTable, distLengths);
        this._decodeHuffman$2(T.HuffmanTable$(litlen), T.HuffmanTable$(dist));
      },
      _decodeHuffman$2: function(litlen, dist) {
        var t1, code, t2, t3, ti, codeLength, distCode, distance;
        for (t1 = this.output; true;) {
          code = this._readCodeByTable$1(litlen);
          if (code > 285)
            throw H.wrapException(new T.ArchiveException("Invalid Huffman Code " + code));
          if (code === 256)
            break;
          if (code < 256) {
            if (t1.length === t1._buffer.length)
              t1._expandBuffer$0();
            t2 = t1._buffer;
            t3 = t1.length++;
            if (t3 < 0 || t3 >= t2.length)
              return H.ioore(t2, t3);
            t2[t3] = code & 255 & 255;
            continue;
          }
          ti = code - 257;
          if (ti < 0 || ti >= 29)
            return H.ioore(C.List_qQn, ti);
          codeLength = C.List_qQn[ti] + this._readBits$1(C.List_eea[ti]);
          distCode = this._readCodeByTable$1(dist);
          if (distCode <= 29) {
            if (distCode >= 30)
              return H.ioore(C.List_i3t, distCode);
            distance = C.List_i3t[distCode] + this._readBits$1(C.List_X3d0[distCode]);
            for (t2 = -distance; codeLength > distance;) {
              t1.writeBytes$1(t1.subset$1(t2));
              codeLength -= distance;
            }
            if (codeLength === distance)
              t1.writeBytes$1(t1.subset$1(t2));
            else
              t1.writeBytes$1(t1.subset$2(t2, codeLength - distance));
          } else
            throw H.wrapException(new T.ArchiveException("Illegal unused distance symbol"));
        }
        for (t1 = this.input; t2 = this._bitBufferLen, t2 >= 8;) {
          this._bitBufferLen = t2 - 8;
          t2 = t1.offset;
          if (typeof t2 !== "number")
            return t2.$sub();
          --t2;
          t1.offset = t2;
          if (t2 < 0)
            t1.offset = 0;
        }
      },
      _decode$3: function(num, table, lengths) {
        var t1, prev, i, code, repeat, repeat0, i0;
        for (t1 = lengths.length, prev = 0, i = 0; i < num;) {
          code = this._readCodeByTable$1(table);
          switch (code) {
            case 16:
              repeat = 3 + this._readBits$1(2);
              for (; repeat0 = repeat - 1, repeat > 0; repeat = repeat0, i = i0) {
                i0 = i + 1;
                if (i < 0 || i >= t1)
                  return H.ioore(lengths, i);
                lengths[i] = prev;
              }
              break;
            case 17:
              repeat = 3 + this._readBits$1(3);
              for (; repeat0 = repeat - 1, repeat > 0; repeat = repeat0, i = i0) {
                i0 = i + 1;
                if (i < 0 || i >= t1)
                  return H.ioore(lengths, i);
                lengths[i] = 0;
              }
              prev = 0;
              break;
            case 18:
              repeat = 11 + this._readBits$1(7);
              for (; repeat0 = repeat - 1, repeat > 0; repeat = repeat0, i = i0) {
                i0 = i + 1;
                if (i < 0 || i >= t1)
                  return H.ioore(lengths, i);
                lengths[i] = 0;
              }
              prev = 0;
              break;
            default:
              if (code > 15)
                throw H.wrapException(new T.ArchiveException("Invalid Huffman Code: " + code));
              i0 = i + 1;
              if (i < 0 || i >= t1)
                return H.ioore(lengths, i);
              lengths[i] = code;
              i = i0;
              prev = code;
              break;
          }
        }
        return lengths;
      }
    }
  }], ["audio_input.assessment", "package:audio_input/src/assessment.dart",, Q, {
    "^": "",
    AssessmentInstrumentUtils_getInstrumentByID: function(id) {
      var t1, _i, inst;
      for (t1 = $.$get$AssessmentInstrumentUtils_instruments(), _i = 0; _i < 3; ++_i) {
        inst = t1[_i];
        if (inst.id === id)
          return inst;
      }
      return;
    },
    AssessmentInstrumentDO: {
      "^": "Object;id>,name>,assessmentType,transposition<,minFreq<,maxFreq<,windowWidth<,sampleRate>,pRecMethod<,pRecQuality<,overSampTimes<,requiredPitchesPerSecond<,tuningWindow<,ignoreOctave<,checkNoteStartTimes<,timeBucketLeft<,timeBucketRight<,minAmplPerc<,psMinStablePitches<,psPitchesToConsider<,psMinTotalPitchJump<,psMinPitchStabilityThresh<,asMinAmplPercRise<,asMaxAmplRiseTime<,spMinTimeBetweenSplits<,minTimeBetweenClaps,minAmplRatioToFloor,minConsecutiveQuietPeaks,minAmplSlopeScore,qNoteNudge,qNoteBucket",
      AssessmentInstrumentDO$31$asMaxAmplRiseTime$asMinAmplPercRise$checkNoteStartTimes$ignoreOctave$maxFreq$minAmplPerc$minAmplRatioToFloor$minAmplSlopeScore$minConsecutiveQuietPeaks$minFreq$minTimeBetweenClaps$overSampTimes$pRecMethod$pRecQuality$psMinPitchStabilityThresh$psMinStablePitches$psMinTotalPitchJump$psPitchesToConsider$qNoteBucket$qNoteNudge$requiredPitchesPerSecond$sampleRate$spMinTimeBetweenSplits$timeBucketLeft$timeBucketRight$transposition$tuningWindow$windowWidth: function(id, $name, assessmentType, asMaxAmplRiseTime, asMinAmplPercRise, checkNoteStartTimes, ignoreOctave, maxFreq, minAmplPerc, minAmplRatioToFloor, minAmplSlopeScore, minConsecutiveQuietPeaks, minFreq, minTimeBetweenClaps, overSampTimes, pRecMethod, pRecQuality, psMinPitchStabilityThresh, psMinStablePitches, psMinTotalPitchJump, psPitchesToConsider, qNoteBucket, qNoteNudge, requiredPitchesPerSecond, sampleRate, spMinTimeBetweenSplits, timeBucketLeft, timeBucketRight, transposition, tuningWindow, windowWidth) {
        this.transposition = transposition;
        this.minFreq = minFreq;
        this.maxFreq = maxFreq;
        this.windowWidth = windowWidth;
        this.sampleRate = sampleRate;
        this.pRecMethod = pRecMethod;
        this.pRecQuality = pRecQuality;
        this.overSampTimes = overSampTimes;
        this.requiredPitchesPerSecond = requiredPitchesPerSecond;
        this.tuningWindow = tuningWindow;
        this.ignoreOctave = ignoreOctave;
        this.checkNoteStartTimes = checkNoteStartTimes;
        this.timeBucketLeft = timeBucketLeft;
        this.timeBucketRight = timeBucketRight;
        this.minAmplPerc = minAmplPerc;
        this.psMinStablePitches = psMinStablePitches;
        this.psPitchesToConsider = psPitchesToConsider;
        this.psMinTotalPitchJump = psMinTotalPitchJump;
        this.psMinPitchStabilityThresh = psMinPitchStabilityThresh;
        this.asMinAmplPercRise = asMinAmplPercRise;
        this.asMaxAmplRiseTime = asMaxAmplRiseTime;
        this.spMinTimeBetweenSplits = spMinTimeBetweenSplits;
        this.minTimeBetweenClaps = minTimeBetweenClaps;
        this.minAmplRatioToFloor = minAmplRatioToFloor;
        this.minConsecutiveQuietPeaks = minConsecutiveQuietPeaks;
        this.minAmplSlopeScore = minAmplSlopeScore;
        this.qNoteNudge = qNoteNudge;
        this.qNoteBucket = qNoteBucket;
      },
      static: {
        AssessmentInstrumentDO$: function(id, $name, assessmentType, asMaxAmplRiseTime, asMinAmplPercRise, checkNoteStartTimes, ignoreOctave, maxFreq, minAmplPerc, minAmplRatioToFloor, minAmplSlopeScore, minConsecutiveQuietPeaks, minFreq, minTimeBetweenClaps, overSampTimes, pRecMethod, pRecQuality, psMinPitchStabilityThresh, psMinStablePitches, psMinTotalPitchJump, psPitchesToConsider, qNoteBucket, qNoteNudge, requiredPitchesPerSecond, sampleRate, spMinTimeBetweenSplits, timeBucketLeft, timeBucketRight, transposition, tuningWindow, windowWidth) {
          var t1 = new Q.AssessmentInstrumentDO(id, $name, assessmentType, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
          t1.AssessmentInstrumentDO$31$asMaxAmplRiseTime$asMinAmplPercRise$checkNoteStartTimes$ignoreOctave$maxFreq$minAmplPerc$minAmplRatioToFloor$minAmplSlopeScore$minConsecutiveQuietPeaks$minFreq$minTimeBetweenClaps$overSampTimes$pRecMethod$pRecQuality$psMinPitchStabilityThresh$psMinStablePitches$psMinTotalPitchJump$psPitchesToConsider$qNoteBucket$qNoteNudge$requiredPitchesPerSecond$sampleRate$spMinTimeBetweenSplits$timeBucketLeft$timeBucketRight$transposition$tuningWindow$windowWidth(id, $name, assessmentType, asMaxAmplRiseTime, asMinAmplPercRise, checkNoteStartTimes, ignoreOctave, maxFreq, minAmplPerc, minAmplRatioToFloor, minAmplSlopeScore, minConsecutiveQuietPeaks, minFreq, minTimeBetweenClaps, overSampTimes, pRecMethod, pRecQuality, psMinPitchStabilityThresh, psMinStablePitches, psMinTotalPitchJump, psPitchesToConsider, qNoteBucket, qNoteNudge, requiredPitchesPerSecond, sampleRate, spMinTimeBetweenSplits, timeBucketLeft, timeBucketRight, transposition, tuningWindow, windowWidth);
          return t1;
        }
      }
    },
    HitRecognizer: {
      "^": "Object;"
    },
    HitType: {
      "^": "Object;index,_assessment$_name",
      toString$0: function(_) {
        return this._assessment$_name;
      }
    },
    HitEvent: {
      "^": "Object;hitType<,time*,keycode"
    },
    KeyHitRecognizer: {
      "^": "HitRecognizer;_assessment$_context,_sendBeatEvents,_beatKey,_keyboardSub,_hitEventController",
      _onKeyDown$1: [function(e) {
        var hEvent, t1;
        hEvent = new Q.HitEvent(null, null, null);
        t1 = J.getInterceptor$x(e);
        hEvent.hitType = t1.get$keyCode(e) === this._beatKey && this._sendBeatEvents ? C.HitType_1 : C.HitType_0;
        hEvent.keycode = t1.get$keyCode(e);
        hEvent.time = this._assessment$_context.currentTime;
        t1 = this._hitEventController;
        if (!t1.get$_mayAddEvent())
          H.throwExpression(t1._addEventError$0());
        t1._sendData$1(hEvent);
      }, "call$1", "get$_onKeyDown", 2, 0, 25]
    },
    PitchRecognizer: {
      "^": "Object;_assessment$_micManager,_micSampleRate,_assessment$_quality,_minFreq,_maxFreq,_windowWidth,_overSampTimes,_pitchRecMethod,_resampleDivisor,_correlationScore,_assessment$_prEvents,_leftOverMicData,_recordDelay,_recordTimeStamp,_micSub,_pitchRecEventController",
      _assessment$_init$0: function() {
        this.setInstrument$1(Q.AssessmentInstrumentUtils_getInstrumentByID(3));
        this._micSampleRate = J.toInt$0$n(this._assessment$_micManager._mic$_context.sampleRate);
      },
      setInstrument$1: function(instDO) {
        var t1, sampleRate, t2;
        this._minFreq = instDO.get$minFreq();
        this._maxFreq = instDO.get$maxFreq();
        this._windowWidth = instDO.get$windowWidth();
        this._resampleDivisor = 1;
        t1 = J.getInterceptor$x(instDO);
        if (t1.get$sampleRate(instDO) != null) {
          sampleRate = t1.get$sampleRate(instDO);
          while (true) {
            t1 = this._micSampleRate;
            if (typeof t1 !== "number")
              return t1.$div();
            t2 = J.getInterceptor$n(sampleRate);
            if (!t2.$le(sampleRate, t1 / 2))
              break;
            t1 = this._resampleDivisor;
            if (typeof t1 !== "number")
              return t1.$mul();
            this._resampleDivisor = t1 * 2;
            sampleRate = t2.$mul(sampleRate, 2);
          }
        }
        this._assessment$_quality = instDO.get$pRecQuality();
        this._pitchRecMethod = instDO.get$pRecMethod();
        this._overSampTimes = instDO.get$overSampTimes();
      },
      _onMicData$1: [function(data) {
        var time, t1, durOfData, t2;
        time = this._assessment$_micManager._mic$_context.currentTime;
        t1 = J.getInterceptor$asx(data);
        durOfData = J.$div$n(t1.get$length(data), this._micSampleRate);
        if (this._recordDelay === -1) {
          t2 = this._recordTimeStamp;
          if (typeof time !== "number")
            return time.$sub();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = time - t2 - durOfData;
          this._recordDelay = t2;
          P.print("record delay: " + H.S(t2));
        }
        this._processData$2(t1.toList$0(data), time);
      }, "call$1", "get$_onMicData", 2, 0, 35, 10],
      _processData$2: function(data, timeStamp) {
        var t1, t2, t3, t4, pitchesToRead, secondsPerPitch, secondsPerOverSampIteration, t5, dataPos, i, t6, t7, t8, overSampIteration, t9, curData, sum, peakAmpl, j, value, t10, rms, bestMultiPeriodInterval, frequency, pRecEvent, cents, letter;
        t1 = this._leftOverMicData;
        if (t1.length > 0) {
          (t1 && C.JSArray_methods).addAll$1(t1, data);
          data = this._leftOverMicData;
        }
        t1 = J.getInterceptor$asx(data);
        t2 = t1.get$length(data);
        t3 = this._windowWidth;
        t4 = this._resampleDivisor;
        if (typeof t3 !== "number")
          return t3.$mul();
        if (typeof t4 !== "number")
          return H.iae(t4);
        pitchesToRead = C.JSInt_methods.$tdiv(t2, t3 * t4);
        t4 = this._micSampleRate;
        if (typeof t4 !== "number")
          return H.iae(t4);
        secondsPerPitch = t3 / t4;
        t4 = this._overSampTimes;
        if (typeof t4 !== "number")
          return H.iae(t4);
        secondsPerOverSampIteration = secondsPerPitch / t4;
        for (t2 = [P.double], t3 = pitchesToRead - 1, t5 = this._pitchRecEventController, dataPos = 0, i = 0; i < pitchesToRead; ++i) {
          t6 = i * secondsPerPitch;
          t7 = i < t3;
          t8 = i === t3;
          overSampIteration = 0;
          while (true) {
            if (!(overSampIteration < t4 && t7))
              t9 = t8 && overSampIteration === 0;
            else
              t9 = true;
            if (!t9)
              break;
            t4 = this._windowWidth;
            if (typeof t4 !== "number")
              return H.iae(t4);
            curData = H.setRuntimeTypeInfo(new Array(t4), t2);
            t4 = curData.length;
            sum = 0;
            peakAmpl = 0;
            j = 0;
            while (true) {
              t9 = this._windowWidth;
              if (typeof t9 !== "number")
                return H.iae(t9);
              if (!(j < t9))
                break;
              value = t1.$index(data, dataPos);
              t9 = J.getInterceptor$ns(value);
              t10 = t9.$mul(value, value);
              if (typeof t10 !== "number")
                return H.iae(t10);
              sum += t10;
              if (t9.$gt(value, peakAmpl))
                peakAmpl = value;
              if (j >= t4)
                return H.ioore(curData, j);
              curData[j] = value;
              t9 = this._resampleDivisor;
              if (typeof t9 !== "number")
                return H.iae(t9);
              dataPos += t9;
              ++j;
            }
            rms = Math.sqrt(sum / t9);
            if (typeof timeStamp !== "number")
              return timeStamp.$add();
            switch (this._pitchRecMethod) {
              case 1:
                bestMultiPeriodInterval = this._findAveragePeriodViaAverageDifferenceSums$2(curData, this._findPeriodViaProductSums$2(curData, this._getValidIntervals$1(curData)));
                t4 = this._micSampleRate;
                t9 = this._resampleDivisor;
                if (typeof t4 !== "number")
                  return t4.$div();
                if (typeof t9 !== "number")
                  return H.iae(t9);
                frequency = t4 / t9 / bestMultiPeriodInterval;
                break;
              default:
                H.printString("unsupported method! PitchRecognizer.processData()");
                frequency = null;
            }
            if (typeof frequency !== "number")
              return frequency.$gt();
            if (frequency > 0) {
              pRecEvent = new Q.PitchRecEvent(null, null, null, null, null, null, null, null, null, null, false, false, null);
              pRecEvent.frequency = frequency;
              cents = 100 * C.JSNumber_methods.round$0(69 + 17.3123404907 * Math.log(frequency / 440));
              pRecEvent.cents = cents;
              letter = $.$get$PitchUtils_centPitchNames().$index(0, C.JSDouble_methods.$mod(cents / 100, 12) * 100);
              t4 = C.JSInt_methods.toString$0(C.JSInt_methods._tdivFast$1(cents, 1200) - 1);
              if (letter == null)
                return letter.$add();
              pRecEvent.pitchName = letter + t4;
              pRecEvent.time = timeStamp + t6 + overSampIteration * secondsPerOverSampIteration;
              cents = C.JSInt_methods.$mod(cents, 100);
              pRecEvent.tuning = cents >= 50 ? cents - 100 : cents;
              pRecEvent.correlationScore = this._correlationScore;
              pRecEvent.rms = rms;
              pRecEvent.peakAmpl = peakAmpl;
              this._assessment$_prEvents.push(pRecEvent);
              if (!t5.get$_mayAddEvent())
                H.throwExpression(t5._addEventError$0());
              t5._sendData$1(pRecEvent);
            }
            ++overSampIteration;
            t4 = this._windowWidth;
            if (typeof t4 !== "number")
              return H.iae(t4);
            t9 = this._overSampTimes;
            if (typeof t9 !== "number")
              return H.iae(t9);
            dataPos = C.JSInt_methods.$tdiv(overSampIteration * t4, t9);
            t4 = t9;
          }
        }
      },
      _getValidIntervals$1: function(samplesVector) {
        var $length, validIValues, lastValue, firstPeakIndex, readyForPeak, i, distance, frequencyToCheck, t1, t2;
        $length = samplesVector.length;
        validIValues = [];
        if (0 >= $length)
          return H.ioore(samplesVector, 0);
        lastValue = samplesVector[0];
        for (firstPeakIndex = -1, readyForPeak = false, i = 0; i < $length; ++i) {
          if (J.$le$n(samplesVector[i], lastValue) && readyForPeak) {
            if (firstPeakIndex !== -1) {
              distance = i - firstPeakIndex;
              frequencyToCheck = 44100 / distance;
              t1 = this._minFreq;
              if (typeof t1 !== "number")
                return H.iae(t1);
              if (frequencyToCheck >= t1) {
                t2 = this._maxFreq;
                if (typeof t2 !== "number")
                  return H.iae(t2);
                t2 = frequencyToCheck <= t2;
              } else
                t2 = false;
              if (t2)
                validIValues.push(distance);
              else if (frequencyToCheck < t1)
                break;
            } else
              firstPeakIndex = i;
            readyForPeak = false;
          } else if (J.$gt$n(samplesVector[i], lastValue))
            readyForPeak = true;
          lastValue = samplesVector[i];
        }
        return validIValues;
      },
      _findPeriodViaProductSums$2: function(samplesVector, validIValues) {
        var $length, quality, t1, greatestSum, greatestSumsInterval, _i, interval, t2, sum, j, t3, t4;
        $length = samplesVector.length;
        quality = this._assessment$_quality;
        for (t1 = validIValues.length, greatestSum = -10, greatestSumsInterval = -1, _i = 0; _i < validIValues.length; validIValues.length === t1 || (0, H.throwConcurrentModificationError)(validIValues), ++_i) {
          interval = validIValues[_i];
          t2 = $length - interval;
          sum = 0;
          j = 0;
          while (j < t2) {
            if (j < 0 || j >= $length)
              return H.ioore(samplesVector, j);
            t3 = samplesVector[j];
            t4 = j + interval;
            if (t4 < 0 || t4 >= $length)
              return H.ioore(samplesVector, t4);
            t4 = J.$mul$ns(t3, samplesVector[t4]);
            if (typeof t4 !== "number")
              return H.iae(t4);
            sum += t4;
            if (typeof quality !== "number")
              return H.iae(quality);
            j += quality;
          }
          if (sum >= greatestSum) {
            greatestSumsInterval = interval;
            greatestSum = sum;
          }
        }
        this._correlationScore = greatestSum;
        return greatestSumsInterval;
      },
      _findAveragePeriodViaAverageDifferenceSums$2: function(samplesVector, bestSinglePeriodInterval) {
        var $length, totalPeriods, startingPoint, minIValueToCheck, i, bestIntervalIndex, bestAverage, improvedCorrelation, i0, t1, sum, j, t2, t3, currentAverage, maxIValue;
        $length = samplesVector.length;
        if (typeof bestSinglePeriodInterval !== "number")
          return H.iae(bestSinglePeriodInterval);
        totalPeriods = C.JSInt_methods.$tdiv($length, bestSinglePeriodInterval);
        if (C.JSInt_methods.$mod($length, bestSinglePeriodInterval) < 10 && totalPeriods > 1)
          --totalPeriods;
        startingPoint = totalPeriods * bestSinglePeriodInterval;
        minIValueToCheck = startingPoint - 10;
        minIValueToCheck = minIValueToCheck >= 0 ? minIValueToCheck : 0;
        for (i = startingPoint, bestIntervalIndex = i, bestAverage = -1, improvedCorrelation = false; i > minIValueToCheck; i0 = i - 1, bestIntervalIndex = i, i = i0, bestAverage = currentAverage) {
          for (t1 = $length - i, sum = 0, j = 0; j < t1; ++j) {
            if (j >= $length)
              return H.ioore(samplesVector, j);
            t2 = samplesVector[j];
            t3 = j + i;
            if (t3 >>> 0 !== t3 || t3 >= $length)
              return H.ioore(samplesVector, t3);
            t3 = J.abs$0$n(J.$sub$n(t2, samplesVector[t3]));
            if (typeof t3 !== "number")
              return H.iae(t3);
            sum += t3;
          }
          currentAverage = sum / t1;
          if (currentAverage < bestAverage || i === startingPoint)
            improvedCorrelation = i !== startingPoint && true;
          else
            break;
        }
        if (!improvedCorrelation) {
          maxIValue = startingPoint + 10;
          maxIValue = maxIValue <= $length ? maxIValue : $length;
          for (i = startingPoint; i < maxIValue; i0 = i + 1, bestIntervalIndex = i, i = i0, bestAverage = currentAverage) {
            for (t1 = $length - i, sum = 0, j = 0; j < t1; ++j) {
              if (j >= $length)
                return H.ioore(samplesVector, j);
              t2 = samplesVector[j];
              t3 = j + i;
              if (t3 >>> 0 !== t3 || t3 >= $length)
                return H.ioore(samplesVector, t3);
              t3 = J.abs$0$n(J.$sub$n(t2, samplesVector[t3]));
              if (typeof t3 !== "number")
                return H.iae(t3);
              sum += t3;
            }
            currentAverage = sum / t1;
            if (!(currentAverage < bestAverage || i === startingPoint))
              break;
          }
        }
        return bestIntervalIndex / totalPeriods;
      }
    },
    PitchRecEvent: {
      "^": "Object;frequency,cents<,pitchName<,tuning,time*,correlationScore?,centsGuessList<,amplsGuessList,rms<,peakAmpl,pitchSplit@,amplSplit@,splitCents?"
    }
  }], ["audio_input.mic", "package:audio_input/src/mic.dart",, K, {
    "^": "",
    MicManager: {
      "^": "Object;_mic$_context,_micPermissionGranted,_micDataController,_mic$_stream,_audioProcessingEventSubscription,_inputNode,_spNode",
      initMicAndGetPermission$0: function() {
        var $async$goto = 0, $async$completer = P.Completer_Completer$sync(), $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, t1, exception, $async$exception, $async$temp1;
        var $async$initMicAndGetPermission$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._micPermissionGranted) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if ($async$self._mic$_context == null)
                  throw H.wrapException("AudioContext must be set first!");
                $async$handler = 4;
                t1 = window.navigator;
                $async$temp1 = $async$self;
                $async$goto = 7;
                return P._asyncAwait((t1 && C.Navigator_methods).getUserMedia$1$audio(t1, true), $async$initMicAndGetPermission$0);
              case 7:
                // returning from await.
                $async$temp1._mic$_stream = $async$result;
                P.print("mic ready");
                $async$self._micPermissionGranted = true;
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                e = H.unwrapException($async$exception);
                P.print(J.$add$ns(J.toString$0$(e), " ...maybe make sure mic is enabled."));
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStart($async$initMicAndGetPermission$0, $async$completer);
      },
      startCapture$0: function() {
        var t1 = this._mic$_context;
        if (t1 == null)
          throw H.wrapException("AudioContext must be set first!");
        this._inputNode = t1.createMediaStreamSource(this._mic$_stream);
        t1 = J.createScriptProcessor$3$x(this._mic$_context, 1024, 1, 1);
        this._spNode = t1;
        this._audioProcessingEventSubscription = W._EventStreamSubscription$(t1, "audioprocess", new K.MicManager_startCapture_closure(this), false, P.AudioProcessingEvent);
        this._inputNode.connect(this._spNode, 0, 0);
        this._spNode.connect(this._mic$_context.destination, 0, 0);
      },
      MicManager$1: function(context) {
        if ($.MicManager__ref == null)
          $.MicManager__ref = this;
        else
          throw H.wrapException("Singleton already created - use MicManager.getInstance() instead.");
        this._mic$_context = context;
      },
      static: {
        MicManager$: function(context) {
          var t1 = new K.MicManager(null, false, new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [null]), null, null, null, null);
          t1.MicManager$1(context);
          return t1;
        }
      }
    },
    MicManager_startCapture_closure: {
      "^": "Closure:0;$this",
      call$1: function(audioProcessEvent) {
        var data, t1;
        data = J.get$inputBuffer$x(audioProcessEvent).getChannelData(0);
        if (data.length < 1)
          return;
        else {
          t1 = this.$this._micDataController;
          if (!t1.get$_mayAddEvent())
            H.throwExpression(t1._addEventError$0());
          t1._sendData$1(data);
        }
      }
    }
  }], ["score_data.data", "package:score_data/src/data.dart",, O, {
    "^": "",
    AccidentalType_getAccidentalType: function(alteration) {
      switch (alteration) {
        case 0:
          return 0;
        case 1:
          return 1;
        case 2:
          return 2;
        case 3:
          return 3;
        case -1:
          return -1;
        case -2:
          return -2;
        case -3:
          return -3;
        default:
          P.print("unsupported accidental alteration: " + H.S(alteration));
          return 100;
      }
    },
    AccidentalType_getAccidentalFromString: function($name) {
      switch ($name) {
        case "none":
          return 100;
        case "natural":
          return 0;
        case "sharp":
          return 1;
        case "flat":
          return -1;
        case "double-sharp":
          return 2;
        case "sharp-sharp":
          return 2;
        case "flat-flat":
          return -2;
        case "triple-sharp":
          return 3;
        case "triplet-flat":
          return -3;
        default:
          return 100;
      }
    },
    ArticulationType_getTypeFromName: function($name) {
      switch ($name) {
        case "staccato":
          return 0;
        case "accent":
          return 1;
        case "tenuto":
          return 2;
        default:
          return -1;
      }
    },
    ClefType_getClefType: function(sign, line) {
      switch (sign) {
        case "G":
          return "treble";
        case "F":
          return "bass";
        case "C":
          return J.$eq$(line, 4) ? "tenor" : "alto";
        default:
          return "treble";
      }
    },
    DurationType_getDurationValue: function(durationType, numDots) {
      var dotVal, duration, i;
      dotVal = C.JSInt_methods._tdivFast$1(durationType, 2);
      for (duration = durationType, i = 0; i < numDots; ++i) {
        duration += dotVal;
        dotVal = C.JSInt_methods._tdivFast$1(dotVal, 2);
      }
      return duration;
    },
    DurationType_getDurationType: function(durationName) {
      switch (durationName) {
        case "whole":
          return 4096;
        case "half":
          return 2048;
        case "quarter":
          return 1024;
        case "eighth":
          return 512;
        case "16th":
          return 256;
        case "32nd":
          return 128;
        case "64th":
          return 64;
        case "breve":
          return 8192;
        case "long":
          return 16384;
        case "maxima":
          return 32768;
        case "128th":
          return 32;
        case "256th":
          return 16;
        case "512th":
          return 8;
        case "1024th":
          return 4;
        default:
          H.printString("unsupported base duration! ScoreManager.getDurationType: " + H.S(durationName));
      }
      return -1;
    },
    DynamicType_getVolumeByType: function(type) {
      switch (type) {
        case "f":
          return 0.5;
        case "p":
          return 0.3;
        case "ff":
          return 0.6;
        case "pp":
          return 0.2;
        case "mf":
          return 0.43;
        case "mp":
          return 0.37;
        case "fff":
          return 0.65;
        case "ppp":
          return 0.15;
        case "ffff":
          return 0.7;
        case "pppp":
          return 0.1;
        default:
          return 0.45;
      }
    },
    RepeatDirection_getDirection: function(direction) {
      if (direction == null)
        return;
      switch (direction) {
        case "forward":
          return 0;
        case "backward":
          return 1;
        default:
          return;
      }
    },
    EndingType_getType: function(type) {
      if (type == null)
        return 1;
      switch (type) {
        case "start":
          return 0;
        case "stop":
          return 1;
        case "discontinue":
          return 2;
        default:
          return 1;
      }
    },
    BarlineStyle_getStyle: function(type) {
      if (type == null)
        return 0;
      switch (type) {
        case "regular":
          return 0;
        case "dotted":
          return 1;
        case "dashed":
          return 2;
        case "heavy":
          return 3;
        case "light-light":
          return 4;
        case "light-heavy":
          return 5;
        case "heavy-light":
          return 6;
        case "heavy-heavy":
          return 7;
        case "tick":
          return 8;
        case "short":
          return 9;
        case "none":
          return 10;
        default:
          return 0;
      }
    },
    BarlineLocation_getLocation: function($location) {
      if ($location == null)
        return 2;
      switch ($location) {
        case "left":
          return 0;
        case "middle":
          return 1;
        case "right":
          return 2;
        default:
          return 2;
      }
    },
    BaseDataObject: {
      "^": "Object;"
    },
    ScoreProperties: {
      "^": "Object;_rights,_software,_mmHeight,_tenths,_pageHeight,_pageWidth,_leftPageMargin,_rightPageMargin,_topPageMargin,_bottomPageMargin,_systemSpacing,_topSystemDistance,_leftSystemMargin,_rightSystemMargin,_staffSpacing,_staffLineSpacing,_stemWidth,_beamWidth,_staffLineWidth,_lightBarlineWidth,_heavyBarlineWidth,_legerLineWidth,_repeatEndingWidth,_hairpinLineWidth,_enclosureWidth,_tupletBracketWidth,_graceNoteSize,_cueNoteSize,_noteheadWidth,_clefDistanceFromBarline,_data$_qNoteWidth,_keySigWidth,_data$_timeSigWidth,_clefWidth,_measureLeadIn,_data$_minMeasureWidth",
      get$staffSpacing: function() {
        return this._staffSpacing;
      },
      get$staffLineSpacing: function() {
        return this._staffLineSpacing;
      },
      static: {
        ScoreProperties_getNewScoreProperties: function() {
          var scoreProps = new O.ScoreProperties(null, null, null, 40, null, null, null, null, null, null, null, null, null, null, null, 10, null, null, null, null, null, null, null, null, null, null, null, null, 12, 10, null, null, null, null, null, null);
          scoreProps._rights = "";
          scoreProps._mmHeight = 8.5513;
          scoreProps._pageHeight = 1307;
          scoreProps._pageWidth = 1010;
          scoreProps._leftPageMargin = 0;
          scoreProps._rightPageMargin = 0;
          scoreProps._topPageMargin = 74;
          scoreProps._bottomPageMargin = 74;
          scoreProps._systemSpacing = 71;
          scoreProps._topSystemDistance = 43;
          scoreProps._leftSystemMargin = 0;
          scoreProps._rightSystemMargin = 0;
          scoreProps._staffSpacing = 80;
          scoreProps._stemWidth = 0.7487;
          scoreProps._beamWidth = 5;
          scoreProps._staffLineWidth = 0.7487;
          scoreProps._lightBarlineWidth = 0.7487;
          scoreProps._heavyBarlineWidth = 5;
          scoreProps._legerLineWidth = 0.7487;
          scoreProps._repeatEndingWidth = 1.4583;
          scoreProps._hairpinLineWidth = 0.7487;
          scoreProps._enclosureWidth = 0.7487;
          scoreProps._tupletBracketWidth = 0.7487;
          scoreProps._graceNoteSize = 60;
          scoreProps._cueNoteSize = 60;
          scoreProps._data$_qNoteWidth = 41.176094598913394;
          scoreProps._keySigWidth = 11.11620603887893;
          scoreProps._data$_timeSigWidth = 22.23241207775786;
          scoreProps._clefWidth = 26.123084191365486;
          scoreProps._measureLeadIn = 16.674309058318396;
          scoreProps._data$_minMeasureWidth = 0;
          return scoreProps;
        }
      }
    },
    Measure: {
      "^": "BaseDataObject;_voices,_diatonicTransposition,_chromaticTransposition,_concertKey,_displayKey,_outgoingKey,_isMajorKey,_showKey,_numBeats,_beatType,_displayNumBeats,_displayBeatType,_beatGroups,_showTime,_clefs,_stack,_staff,_attachments,_notesNeedRendering,_dataID",
      getVoiceByNumber$1: function(voiceNumber) {
        var t1, t2, _i, voice, newVoice;
        for (t1 = this._voices, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          voice = t1[_i];
          if (J.$eq$(voice.get$number(), voiceNumber))
            return voice;
        }
        newVoice = new O.Voice([], null, 0, null, 0);
        newVoice._number = voiceNumber;
        newVoice._measure = this;
        t1.push(newVoice);
        return newVoice;
      },
      get$concertKey: function() {
        return this._concertKey;
      },
      get$displayKey: function() {
        return this._displayKey;
      },
      get$outgoingKey: function() {
        return this._outgoingKey;
      },
      get$diatonicTransposition: function() {
        return this._diatonicTransposition;
      },
      get$chromaticTransposition: function() {
        return this._chromaticTransposition;
      },
      get$isMajorKey: function() {
        return this._isMajorKey;
      },
      get$numBeats: function() {
        return this._numBeats;
      },
      set$numBeats: function(value) {
        this._numBeats = value;
      },
      get$beatType: function() {
        return this._beatType;
      },
      set$beatType: function(value) {
        this._beatType = value;
      },
      get$displayNumBeats: function() {
        return this._displayNumBeats;
      },
      set$displayNumBeats: function(value) {
        this._displayNumBeats = value;
      },
      get$displayBeatType: function() {
        return this._displayBeatType;
      },
      set$displayBeatType: function(value) {
        this._displayBeatType = value;
      },
      get$beatGroups: function() {
        return this._beatGroups;
      },
      set$beatGroups: function(value) {
        this._beatGroups = value;
      },
      get$clefs: function() {
        return this._clefs;
      },
      get$voices: function() {
        return this._voices;
      },
      get$showTime: function() {
        return this._showTime;
      },
      get$showKey: function() {
        return this._showKey;
      },
      set$showKey: function(value) {
        this._showKey = value;
      },
      get$stack: function() {
        return this._stack;
      },
      get$staff: function() {
        return this._staff;
      },
      set$staff: function(value) {
        this._staff = value;
      },
      get$attachments: function() {
        return this._attachments;
      },
      get$notesNeedRendering: function() {
        return this._notesNeedRendering;
      },
      set$notesNeedRendering: function(value) {
        var t1;
        this._notesNeedRendering = value;
        if (value) {
          t1 = this._stack;
          if (t1 != null)
            t1.set$needsRendering(true);
        }
      },
      get$next: function(_) {
        var measures, numMeasures, i, t1;
        measures = this._staff._measures;
        numMeasures = measures.length;
        for (i = 0; i < numMeasures; ++i) {
          if (i >= measures.length)
            return H.ioore(measures, i);
          if (J.$eq$(measures[i], this)) {
            if (i < numMeasures - 1) {
              t1 = i + 1;
              if (t1 >= measures.length)
                return H.ioore(measures, t1);
              t1 = measures[t1];
            } else
              t1 = null;
            return t1;
          }
        }
        return;
      },
      get$above: function() {
        var measures, i, t1;
        measures = this._stack._measures;
        for (i = measures.length - 1; i >= 0; --i) {
          if (i >= measures.length)
            return H.ioore(measures, i);
          if (J.$eq$(measures[i], this)) {
            if (i > 0) {
              t1 = i - 1;
              if (t1 >= measures.length)
                return H.ioore(measures, t1);
              t1 = measures[t1];
            } else
              t1 = null;
            return t1;
          }
        }
        return;
      }
    },
    MeasureStack: {
      "^": "BaseDataObject;_noteGroups,_measures<,_startTime,_endTime,_dpqLength,_beatQNotePositions,_newSystem@,_data$_width',_data$_indent,_indentAsSystemLeader,_startPosition?,_number@,_idealWidth,_maxKeySize,_newKey?,_newClef?,_tempoMarkers,barline@,repeatDOs@,_data$_previous?,_data$_next,_systemRef<,_isPickup?,_needsRendering,_dataID",
      addNoteGroup$1: function(noteGroup) {
        var numNotes, i, t1, cNoteGroup;
        numNotes = this._noteGroups.length;
        for (i = 0; i < numNotes; ++i) {
          t1 = this._noteGroups;
          if (i >= t1.length)
            return H.ioore(t1, i);
          cNoteGroup = t1[i];
          if (J.$lt$n(noteGroup.get$qNoteTime(), cNoteGroup.get$qNoteTime())) {
            C.JSArray_methods.insert$2(this._noteGroups, i, noteGroup);
            return;
          }
        }
        this._noteGroups.push(noteGroup);
      },
      addMeasure$1: function(measure) {
        this._measures.push(measure);
      },
      addNoteGroupsFromMeasure$1: function(measure) {
        var t1, t2, _i, t3, t4, _i0;
        for (t1 = measure.get$voices(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$noteGroups(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0)
            this.addNoteGroup$1(t3[_i0]);
      },
      clearNoteGroups$0: function() {
        this._noteGroups = [];
      },
      clearMeasures$0: function(_) {
        this._measures = [];
      },
      get$noteGroups: function() {
        return this._noteGroups;
      },
      get$measures: function() {
        return this._measures;
      },
      get$dpqLength: function() {
        return this._dpqLength;
      },
      get$startTime: function(_) {
        return this._startTime;
      },
      set$startTime: function(_, value) {
        this._startTime = value;
        this._dpqLength = J.$sub$n(this._endTime, value);
      },
      get$endTime: function(_) {
        return this._endTime;
      },
      set$endTime: function(_, value) {
        this._endTime = value;
        this._dpqLength = J.$sub$n(value, this._startTime);
      },
      get$newSystem: function() {
        return this._newSystem;
      },
      set$newSystem: function(value) {
        this._newSystem = value;
      },
      get$width: function(_) {
        return this._data$_width;
      },
      set$width: function(_, value) {
        this._data$_width = value;
      },
      get$indent: function() {
        return this._data$_indent;
      },
      set$indent: function(value) {
        this._data$_indent = value;
      },
      get$indentAsSystemLeader: function() {
        return this._indentAsSystemLeader;
      },
      set$indentAsSystemLeader: function(value) {
        this._indentAsSystemLeader = value;
      },
      get$startPosition: function() {
        return this._startPosition;
      },
      set$startPosition: function(value) {
        this._startPosition = value;
      },
      get$number: function() {
        return this._number;
      },
      get$idealWidth: function() {
        return this._idealWidth;
      },
      set$idealWidth: function(value) {
        this._idealWidth = value;
      },
      get$maxKeySize: function() {
        return this._maxKeySize;
      },
      set$maxKeySize: function(value) {
        this._maxKeySize = value;
      },
      get$newKey: function() {
        return this._newKey;
      },
      get$newClef: function() {
        return this._newClef;
      },
      get$tempoMarkers: function() {
        return this._tempoMarkers;
      },
      get$previous: function() {
        return this._data$_previous;
      },
      set$previous: function(value) {
        this._data$_previous = value;
      },
      get$next: function(_) {
        return this._data$_next;
      },
      set$next: function(_, value) {
        this._data$_next = value;
      },
      get$systemRef: function() {
        return this._systemRef;
      },
      set$systemRef: function(value) {
        this._systemRef = value;
      },
      get$needsRendering: function() {
        return this._needsRendering;
      },
      set$needsRendering: function(value) {
        this._needsRendering = value;
        if (value && this._systemRef != null)
          this._systemRef.set$needsRendering(true);
      }
    },
    NoteGroup: {
      "^": "BaseDataObject;_notes<,_hPos<,_stemDirection<,_stemStartPos?,_stemEndPos,_stemHPos?,_stem,_data$_duration@,_qNoteDuration?,_data$_qNoteTime@,_durationType<,_numDots<,_isGrace,attachmentNG?,_beamStates,_maxBeams,_numAccidentalLevels,_isRest<,_restVPos,_tuplets,_slurs,_clef?,_lyric,_clipStart,_clipEnd,_idealHPos,_voice,_ngcRef,_playbackStartTime,_playbackTempo,_articulations,_visible,_prevVisible,_cachedNextNG,_cachedPrevNG,_visibleNotesCache,_dataID",
      insertNote$1: function(note) {
        var t1, numNotes, t2, i;
        t1 = this._notes;
        numNotes = t1.length;
        for (t2 = note._stepsFromTopStaffLine, i = 0; i < numNotes; ++i)
          if (t1[i]._stepsFromTopStaffLine < t2)
            break;
        C.JSArray_methods.insert$2(t1, i, note);
        note._noteGroup = this;
      },
      get$notes: function() {
        return this._notes;
      },
      get$visibleNotes: function() {
        var t1, t2, _i, note;
        t1 = this._visibleNotesCache;
        if (t1 != null)
          return t1;
        if (this._isRest) {
          this._visibleNotesCache = null;
          return;
        }
        this._visibleNotesCache = [];
        for (t1 = this._notes, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          note = t1[_i];
          if (note.get$visible(note))
            this._visibleNotesCache.push(note);
        }
        return this._visibleNotesCache;
      },
      get$isRest: function() {
        return this._isRest;
      },
      get$restVPos: function() {
        return this._restVPos;
      },
      set$restVPos: function(value) {
        this._restVPos = value;
      },
      get$numDots: function() {
        return this._numDots;
      },
      get$durationType: function() {
        return this._durationType;
      },
      get$duration: function(_) {
        return this._data$_duration;
      },
      get$qNoteDuration: function() {
        return this._qNoteDuration;
      },
      get$qNoteTime: function() {
        return this._data$_qNoteTime;
      },
      set$qNoteTime: function(value) {
        this._data$_qNoteTime = value;
      },
      get$isGrace: function() {
        return this._isGrace;
      },
      get$stemStartPos: function() {
        return this._stemStartPos;
      },
      set$stemStartPos: function(value) {
        this._stemStartPos = value;
      },
      get$stemEndPos: function() {
        return this._stemEndPos;
      },
      set$stemEndPos: function(value) {
        this._stemEndPos = value;
      },
      get$stemHPos: function() {
        return this._stemHPos;
      },
      set$stemHPos: function(value) {
        this._stemHPos = value;
      },
      get$stemDirection: function() {
        return this._stemDirection;
      },
      set$stemDirection: function(value) {
        this._stemDirection = value;
      },
      get$beamStates: function() {
        return this._beamStates;
      },
      set$beamStates: function(value) {
        this._beamStates = value;
      },
      get$maxBeams: function() {
        return this._maxBeams;
      },
      get$numAccidentalLevels: function() {
        return this._numAccidentalLevels;
      },
      set$numAccidentalLevels: function(value) {
        this._numAccidentalLevels = value;
      },
      get$hPos: function() {
        return this._hPos;
      },
      set$hPos: function(value) {
        this._hPos = value;
      },
      get$tuplets: function() {
        return this._tuplets;
      },
      get$slurs: function() {
        return this._slurs;
      },
      get$clef: function() {
        return this._clef;
      },
      get$lyric: function() {
        return this._lyric;
      },
      set$lyric: function(value) {
        this._lyric = value;
      },
      get$idealHPos: function() {
        return this._idealHPos;
      },
      set$idealHPos: function(value) {
        this._idealHPos = value;
      },
      get$voice: function(_) {
        return this._voice;
      },
      get$next: function(_) {
        var t1, noteGroups, numNoteGroups, i, voiceNum, nextMeasure, voices, _i, nextVoice;
        t1 = this._cachedNextNG;
        if (t1 != null)
          return t1;
        noteGroups = this._voice._noteGroups;
        numNoteGroups = noteGroups.length;
        for (t1 = numNoteGroups - 1, i = 0; i < numNoteGroups; ++i) {
          if (i >= noteGroups.length)
            return H.ioore(noteGroups, i);
          if (J.$eq$(noteGroups[i], this))
            if (i < t1) {
              t1 = i + 1;
              if (t1 >= noteGroups.length)
                return H.ioore(noteGroups, t1);
              t1 = noteGroups[t1];
              this._cachedNextNG = t1;
              return t1;
            }
        }
        t1 = this._voice;
        voiceNum = t1._number;
        t1 = t1._measure;
        nextMeasure = t1.get$next(t1);
        for (; nextMeasure != null;) {
          voices = nextMeasure.get$voices();
          for (t1 = voices.length, _i = 0; _i < voices.length; voices.length === t1 || (0, H.throwConcurrentModificationError)(voices), ++_i) {
            nextVoice = voices[_i];
            if (J.$eq$(nextVoice.get$number(), voiceNum))
              if (nextVoice.get$noteGroups().length > 0) {
                t1 = nextVoice.get$noteGroups();
                if (0 >= t1.length)
                  return H.ioore(t1, 0);
                t1 = t1[0];
                this._cachedNextNG = t1;
                return t1;
              }
          }
          nextMeasure = J.get$next$x(nextMeasure);
        }
        return;
      },
      set$playbackStartTime: function(value) {
        this._playbackStartTime = value;
      },
      get$playbackTempo: function() {
        return this._playbackTempo;
      },
      set$playbackTempo: function(value) {
        this._playbackTempo = value;
      },
      get$articulations: function() {
        return this._articulations;
      },
      get$visible: function(_) {
        return this._visible;
      },
      set$visible: function(_, value) {
        this._prevVisible = this._visible;
        this._visible = value;
      }
    },
    Page: {
      "^": "BaseDataObject;_systems,_data$_previous?,_data$_next,_dataID",
      addSystem$1: function(system) {
        var t1, t2, prevSystem;
        t1 = this._systems;
        t2 = t1.length;
        if (t2 > 0) {
          prevSystem = t1[t2 - 1];
          prevSystem._data$_next = system;
          system._data$_previous = prevSystem;
        }
        system._data$_pageRef = this;
        t1.push(system);
      },
      removeSystem$1: function(system) {
        var t1, i;
        if (system.get$measureStacks().length === 0) {
          for (t1 = this._systems, i = t1.length - 1; i >= 0; --i)
            if (t1[i] === system) {
              C.JSArray_methods.removeAt$1(t1, i);
              if (system.get$previous() != null) {
                t1 = J.getInterceptor$x(system);
                if (t1.get$next(system) != null)
                  J.set$next$x(system.get$previous(), t1.get$next(system));
                else
                  J.set$next$x(system.get$previous(), null);
              }
              t1 = J.getInterceptor$x(system);
              if (t1.get$next(system) != null)
                if (system.get$previous() != null)
                  t1.get$next(system).set$previous(system.get$previous());
                else
                  t1.get$next(system).set$previous(null);
              return;
            }
        } else
          P.print("Attempted to remove a System that still contains MeasureStacks!");
      },
      get$systems: function() {
        return this._systems;
      },
      get$previous: function() {
        return this._data$_previous;
      },
      set$previous: function(value) {
        this._data$_previous = value;
      },
      get$next: function(_) {
        return this._data$_next;
      },
      set$next: function(_, value) {
        this._data$_next = value;
      }
    },
    Part: {
      "^": "BaseDataObject;_partID,_data$_name,_abbreviation,_staves,_diatonicTransposition,_chromaticTransposition,_visible,_midiBank,_midiPreset,_midiChannel,_muted,_volume?,_pan,_percussionMap,_assessmentInstruments,_preventTransposition,_playbackOctaveDelta,_dataID",
      getFirstNote$2: function(staffIndex, voiceIndex) {
        var t1 = this._staves;
        if (staffIndex >= t1.length)
          return H.ioore(t1, staffIndex);
        t1 = t1[staffIndex]._measures;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].get$voices();
        if (voiceIndex >= t1.length)
          return H.ioore(t1, voiceIndex);
        t1 = t1[voiceIndex].get$noteGroups();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return t1[0];
      },
      getFirstNote$0: function() {
        return this.getFirstNote$2(0, 0);
      },
      setTransposition$3: function(diatonic, chromatic, updateMeasures) {
        this._diatonicTransposition = diatonic;
        this._chromaticTransposition = chromatic;
      },
      get$staves: function() {
        return this._staves;
      },
      get$name: function(_) {
        return this._data$_name;
      },
      get$diatonicTransposition: function() {
        return this._diatonicTransposition;
      },
      get$chromaticTransposition: function() {
        return this._chromaticTransposition;
      },
      get$visible: function(_) {
        return this._visible;
      },
      set$visible: function(_, value) {
        this._visible = value;
      },
      get$measures: function() {
        var allMeasures, t1, numStaves, i, measures, numMeasures, j;
        allMeasures = [];
        t1 = this._staves;
        numStaves = t1.length;
        for (i = 0; i < numStaves; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          measures = t1[i]._measures;
          numMeasures = measures.length;
          for (j = 0; j < numMeasures; ++j) {
            if (j >= measures.length)
              return H.ioore(measures, j);
            allMeasures.push(measures[j]);
          }
        }
        return allMeasures;
      },
      get$noteGroups: function() {
        var allNoteGroups, t1, numStaves, i, measures, numMeasures, j, voices, k, noteGroups, numNoteGroups, m;
        allNoteGroups = [];
        t1 = this._staves;
        numStaves = t1.length;
        for (i = 0; i < numStaves; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          measures = t1[i]._measures;
          numMeasures = measures.length;
          for (j = 0; j < numMeasures; ++j) {
            if (j >= measures.length)
              return H.ioore(measures, j);
            voices = measures[j].get$voices();
            for (k = 0; k < voices.length; ++k) {
              noteGroups = voices[k].get$noteGroups();
              numNoteGroups = noteGroups.length;
              for (m = 0; m < numNoteGroups; ++m) {
                if (m >= noteGroups.length)
                  return H.ioore(noteGroups, m);
                allNoteGroups.push(noteGroups[m]);
              }
            }
          }
        }
        return allNoteGroups;
      },
      get$midiPreset: function() {
        return this._midiPreset;
      },
      set$midiPreset: function(value) {
        this._midiPreset = value;
      },
      get$midiChannel: function() {
        return this._midiChannel;
      },
      get$muted: function(_) {
        return false;
      },
      get$volume: function(_) {
        return this._volume;
      },
      set$volume: function(_, value) {
        this._volume = value;
      },
      get$pan: function(_) {
        return this._pan;
      },
      set$pan: function(_, value) {
        this._pan = value;
      },
      get$playbackOctaveDelta: function() {
        return this._playbackOctaveDelta;
      }
    },
    Score: {
      "^": "BaseDataObject;_scoreProperties,_data$_parts,_pages,_graceNotesNeedFixing,playbackPath<,_dataID",
      getSystems$0: function() {
        var systems, t1, t2, _i, t3, t4, _i0;
        systems = [];
        for (t1 = this._pages, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$systems(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0)
            systems.push(t3[_i0]);
        return systems;
      },
      getMeasureStacks$0: function() {
        var stacks, t1, t2, _i, t3, t4, _i0, t5, t6, _i1;
        stacks = [];
        for (t1 = this._pages, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$systems(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0)
            for (t5 = t3[_i0].get$measureStacks(), t6 = t5.length, _i1 = 0; _i1 < t5.length; t5.length === t6 || (0, H.throwConcurrentModificationError)(t5), ++_i1)
              stacks.push(t5[_i1]);
        return stacks;
      },
      removePage$1: function(page) {
        var t1, i, t2, t3, t4;
        if (page.get$systems().length === 0) {
          for (t1 = this._pages, i = t1.length - 1; i >= 0; --i)
            if (t1[i] === page) {
              t2 = i > 0;
              if (t2 && J.$eq$(t1[i - 1]._data$_next, page)) {
                t3 = i - 1;
                t4 = t1.length;
                if (t3 < 0 || t3 >= t4)
                  return H.ioore(t1, t3);
                t3 = t1[t3];
                t3._data$_next = i < t4 - 1 ? t1[i + 1] : null;
              }
              if (i < t1.length - 1 && J.$eq$(t1[i + 1]._data$_previous, page)) {
                t3 = i + 1;
                t4 = t1.length;
                if (t3 >= t4)
                  return H.ioore(t1, t3);
                t3 = t1[t3];
                if (t2) {
                  t2 = i - 1;
                  if (t2 >= t4)
                    return H.ioore(t1, t2);
                  t2 = t1[t2];
                } else
                  t2 = null;
                t3._data$_previous = t2;
              }
              C.JSArray_methods.removeAt$1(t1, i);
              return;
            }
        } else
          P.print("Attempted to remove a Page that still contains Systems!");
      },
      setPageSize$2: function(pageWidth, pageHeight) {
        var t1, systems, _i;
        t1 = this._scoreProperties;
        t1._pageWidth = pageWidth;
        t1._pageHeight = pageHeight;
        systems = this.getSystems$0();
        for (t1 = systems.length, _i = 0; _i < systems.length; systems.length === t1 || (0, H.throwConcurrentModificationError)(systems), ++_i)
          systems[_i].getSettingsFromScoreProperties$0();
      },
      updatePlaybackPath$0: function() {
        var stacks, passMap, t1, _i, stack;
        stacks = this.getMeasureStacks$0();
        passMap = P.LinkedHashMap__makeEmpty();
        for (t1 = stacks.length, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
          stack = stacks[_i];
          if (stack.get$repeatDOs() != null)
            passMap.$indexSet(0, stack, 0);
        }
        this.playbackPath = [];
        this._createPlaybackPathPair$3(stacks, passMap, 0);
      },
      _createPlaybackPathPair$3: function(stacks, passMap, startIndex) {
        var i, lastForwardRepeatIndex, t1, stack, t2, _i, rdo, t3, t4, endingTargetIndex;
        for (i = startIndex, lastForwardRepeatIndex = null; t1 = stacks.length, i < t1; ++i) {
          if (i < 0)
            return H.ioore(stacks, i);
          stack = stacks[i];
          if (stack.get$repeatDOs() != null) {
            t1 = passMap.$index(0, stack);
            if (typeof t1 !== "number")
              return t1.$add();
            passMap.$indexSet(0, stack, t1 + 1);
            for (t1 = stack.get$repeatDOs(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
              rdo = t1[_i];
              t3 = rdo.repeatDirection;
              if (t3 === 0)
                lastForwardRepeatIndex = i;
              if (t3 === 1) {
                t3 = passMap.$index(0, stack);
                t4 = rdo.repeatTimes;
                if (typeof t3 !== "number")
                  return t3.$le();
                if (typeof t4 !== "number")
                  return H.iae(t4);
                t4 = t3 <= t4;
                t3 = t4;
              } else
                t3 = false;
              if (t3) {
                if (lastForwardRepeatIndex == null)
                  lastForwardRepeatIndex = this._findPrecedingForwardRepeat$2(stacks, startIndex - 1);
                t1 = this.playbackPath;
                if (startIndex < 0 || startIndex >= stacks.length)
                  return H.ioore(stacks, startIndex);
                t1.push(J.get$startTime$x(stacks[startIndex]));
                this.playbackPath.push(J.get$endTime$x(stack));
                this._createPlaybackPathPair$3(stacks, passMap, lastForwardRepeatIndex);
                return;
              }
              if (rdo.endingType === 0 && J.indexOf$1$asx(rdo.endingNumber, "1") !== -1) {
                endingTargetIndex = this._chooseEnding$3(stacks, passMap, i);
                if (endingTargetIndex !== i) {
                  t1 = this.playbackPath;
                  if (startIndex < 0 || startIndex >= stacks.length)
                    return H.ioore(stacks, startIndex);
                  t1.push(J.get$startTime$x(stacks[startIndex]));
                  this.playbackPath.push(J.get$startTime$x(stack));
                  this._createPlaybackPathPair$3(stacks, passMap, endingTargetIndex);
                  return;
                }
              }
            }
          }
        }
        t2 = this.playbackPath;
        if (startIndex < 0 || startIndex >= t1)
          return H.ioore(stacks, startIndex);
        t2.push(J.get$startTime$x(stacks[startIndex]));
        this.playbackPath.push(J.get$endTime$x(C.JSArray_methods.get$last(stacks)));
      },
      _findPrecedingForwardRepeat$2: function(stacks, startIndex) {
        var i, stack, t1, t2, _i, t3;
        for (i = startIndex; i >= 0; --i) {
          if (i >= stacks.length)
            return H.ioore(stacks, i);
          stack = stacks[i];
          if (stack.get$repeatDOs() != null)
            for (t1 = stack.get$repeatDOs(), t2 = t1.length, _i = 0; t3 = t1.length, _i < t3; t3 === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
              if (t1[_i].repeatDirection === 0)
                return i;
        }
        return 0;
      },
      _chooseEnding$3: function(stacks, passMap, startIndex) {
        var endingTargetNum, i, lastEndingCloseIndex, stack, t1, t2, _i, t3, rdo, t4;
        if (startIndex < 0 || startIndex >= stacks.length)
          return H.ioore(stacks, startIndex);
        endingTargetNum = J.toString$0$(passMap.$index(0, stacks[startIndex]));
        for (i = startIndex, lastEndingCloseIndex = null; i < stacks.length; ++i) {
          stack = stacks[i];
          if (stack.get$repeatDOs() != null) {
            for (t1 = stack.get$repeatDOs(), t2 = t1.length, _i = 0; t3 = t1.length, _i < t3; t3 === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
              rdo = t1[_i];
              t4 = rdo.endingType;
              if (t4 === 0) {
                t4 = rdo.endingNumber;
                if (t4 != null && C.JSString_methods.indexOf$1(t4, endingTargetNum) !== -1)
                  return i;
                lastEndingCloseIndex = null;
              } else if (t4 === 2 || t4 === 1)
                lastEndingCloseIndex = i;
            }
            if (lastEndingCloseIndex != null && lastEndingCloseIndex < i)
              return i;
          }
        }
        return startIndex;
      },
      get$scoreProperties: function() {
        return this._scoreProperties;
      },
      get$parts: function() {
        return this._data$_parts;
      },
      get$pages: function() {
        return this._pages;
      },
      get$graceNotesNeedFixing: function() {
        return this._graceNotesNeedFixing;
      },
      set$graceNotesNeedFixing: function(value) {
        this._graceNotesNeedFixing = value;
      }
    },
    Staff: {
      "^": "BaseDataObject;_measures<,_partRef,_originalLyrics,_visible,_dataID",
      addMeasure$1: function(measure) {
        this._measures.push(measure);
        measure.set$staff(this);
      },
      get$measures: function() {
        return this._measures;
      },
      get$originalLyrics: function() {
        return this._originalLyrics;
      },
      set$originalLyrics: function(value) {
        this._originalLyrics = value;
      },
      get$visible: function(_) {
        return this._visible;
      },
      set$visible: function(_, value) {
        var t1, t2, atLeastOneStaffVisible, _i, t3, staff;
        if (!value) {
          for (t1 = this._partRef._staves, t2 = t1.length, atLeastOneStaffVisible = false, _i = 0; t3 = t1.length, _i < t3; t3 === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            staff = t1[_i];
            if (staff !== this && staff._visible)
              atLeastOneStaffVisible = true;
          }
          if (!atLeastOneStaffVisible)
            throw H.wrapException("Part must have at least one visible Staff");
          value = false;
        }
        this._visible = value;
      }
    },
    System: {
      "^": "BaseDataObject;_data$_scoreProps,_data$_indent,_systemWidth,_staffSpacing,_staffLineSpacing,_staffVPosOffsets,_visibleParts,_measureStacks,_data$_previous?,_data$_next,_data$_pageRef,_newPage,_needsRendering,_slurSegments,_dataID",
      getSettingsFromScoreProperties$0: function() {
        var t1 = this._data$_scoreProps;
        this._systemWidth = J.$sub$n(J.$sub$n(J.$sub$n(J.$sub$n(t1._pageWidth, t1._leftPageMargin), this._data$_scoreProps._rightPageMargin), this._data$_scoreProps._leftSystemMargin), this._data$_scoreProps._rightSystemMargin);
        t1 = this._data$_scoreProps;
        this._staffSpacing = t1._staffSpacing;
        this._staffLineSpacing = t1._staffLineSpacing;
      },
      addMeasureStack$2: function(stack, linkStacksBetweenSystems) {
        var t1, t2, prevStack;
        stack._systemRef = this;
        t1 = this._measureStacks;
        t2 = t1.length;
        if (t2 > 0) {
          prevStack = t1[t2 - 1];
          J.set$next$x(prevStack, stack);
          stack._data$_previous = prevStack;
        }
        this._measureStacks.push(stack);
      },
      addMeasureStacks$2: function(stacks, linkStacksBetweenSystems) {
        var t1, t2, prevStack, _i, stack;
        t1 = this._measureStacks;
        t2 = t1.length;
        prevStack = t2 > 0 ? t1[t2 - 1] : null;
        for (t1 = stacks.length, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i, prevStack = stack) {
          stack = stacks[_i];
          stack.set$systemRef(this);
          J.set$next$x(prevStack, stack);
          stack.set$previous(prevStack);
          this._measureStacks.push(stack);
        }
        this.linkStacksInSurroundingSystems$0();
      },
      addMeasureStacks$1: function(stacks) {
        return this.addMeasureStacks$2(stacks, true);
      },
      insertStack$2: function(stack, linkStacksBetweenSystems) {
        var t1, nextStack;
        stack.set$systemRef(this);
        C.JSArray_methods.insert$2(this._measureStacks, 0, stack);
        t1 = this._measureStacks;
        if (t1.length > 1) {
          nextStack = t1[1];
          nextStack.set$previous(stack);
          J.set$next$x(stack, nextStack);
        }
        this.linkStacksInSurroundingSystems$0();
      },
      insertStack$1: function(stack) {
        return this.insertStack$2(stack, true);
      },
      insertMeasureStacks$2: function(stacks, linkStacksBetweenSystems) {
        var t1, index, _i, stack, t2, t3, prevStack, nextStack;
        for (t1 = stacks.length, index = 0, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
          stack = stacks[_i];
          stack.set$systemRef(this);
          C.JSArray_methods.insert$2(this._measureStacks, index, stack);
          if (index > 0) {
            t2 = this._measureStacks;
            t3 = index - 1;
            if (t3 >= t2.length)
              return H.ioore(t2, t3);
            prevStack = t2[t3];
            J.set$next$x(prevStack, stack);
            stack.set$previous(prevStack);
          }
          t2 = this._measureStacks;
          if (index < t2.length - 1) {
            nextStack = t2[index + 1];
            nextStack.set$previous(stack);
            J.set$next$x(stack, nextStack);
          }
          ++index;
        }
        this.linkStacksInSurroundingSystems$0();
      },
      insertMeasureStacks$1: function(stacks) {
        return this.insertMeasureStacks$2(stacks, true);
      },
      removeStacksFromBeginning$1: function(count) {
        var t1, count0, removedStacks;
        t1 = this._measureStacks;
        count0 = t1.length;
        if (count >= count0 || count <= 0)
          count = count0;
        removedStacks = C.JSArray_methods.sublist$2(t1, 0, count);
        C.JSArray_methods.removeRange$2(this._measureStacks, 0, count);
        return removedStacks;
      },
      removeStacksFromEnd$1: function(count) {
        var t1, count0, removedStacks, t2;
        t1 = this._measureStacks;
        count0 = t1.length;
        if (count >= count0 || count <= 0)
          count = count0;
        removedStacks = C.JSArray_methods.sublist$2(t1, count0 - count, count0);
        t1 = this._measureStacks;
        t2 = t1.length;
        C.JSArray_methods.removeRange$2(t1, t2 - count, t2);
        return removedStacks;
      },
      clearAllStacks$0: function() {
        this._measureStacks = [];
      },
      linkStacksInSurroundingSystems$0: function() {
        var t1, t2, firstStack, lastStack, prevSystem, prevStack, nextSystem, nextStack;
        t1 = this._measureStacks;
        t2 = t1.length;
        if (t2 <= 0)
          return;
        firstStack = t1[0];
        lastStack = t1[t2 - 1];
        prevSystem = this._data$_previous;
        if (prevSystem == null)
          firstStack.set$previous(null);
        for (; prevSystem != null;) {
          if (prevSystem.get$measureStacks().length > 0) {
            t1 = prevSystem.get$measureStacks();
            t2 = prevSystem.get$measureStacks().length - 1;
            if (t2 < 0 || t2 >= t1.length)
              return H.ioore(t1, t2);
            prevStack = t1[t2];
            J.set$next$x(prevStack, firstStack);
            firstStack.set$previous(prevStack);
            break;
          }
          prevSystem = prevSystem.get$previous();
        }
        nextSystem = this._data$_next;
        if (nextSystem == null)
          J.set$next$x(lastStack, null);
        for (; nextSystem != null;) {
          if (nextSystem.get$measureStacks().length > 0) {
            t1 = nextSystem.get$measureStacks();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            nextStack = t1[0];
            nextStack.set$previous(lastStack);
            J.set$next$x(lastStack, nextStack);
            break;
          }
          nextSystem = J.get$next$x(nextSystem);
        }
      },
      get$requestedStackWidth: function() {
        var t1, t2, totalWidth, _i, t3;
        t1 = this._measureStacks;
        t2 = t1.length;
        if (t2 === 0)
          return 0;
        for (totalWidth = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          t3 = t1[_i].get$idealWidth();
          if (typeof t3 !== "number")
            return H.iae(t3);
          totalWidth += t3;
        }
        return totalWidth;
      },
      get$measureStacks: function() {
        return this._measureStacks;
      },
      get$indent: function() {
        return this._data$_indent;
      },
      set$indent: function(value) {
        this._data$_indent = value;
      },
      get$systemWidth: function() {
        return this._systemWidth;
      },
      get$staffSpacing: function() {
        return this._staffSpacing;
      },
      get$staffLineSpacing: function() {
        return this._staffLineSpacing;
      },
      get$staffVPosOffsets: function() {
        var t1, t2, t3, staffIndex, numStaves;
        t1 = this._measureStacks;
        t2 = t1.length;
        if (t2 === 0)
          return [];
        t3 = this._staffVPosOffsets;
        staffIndex = t3.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        numStaves = t1[0].get$measures().length;
        if (staffIndex > numStaves) {
          C.JSArray_methods.removeRange$2(t3, numStaves, staffIndex);
          staffIndex = t3.length;
        }
        for (; staffIndex < numStaves;) {
          if (staffIndex >= t3.length)
            t3.push(0);
          else
            t3[staffIndex] = 0;
          ++staffIndex;
        }
        return t3;
      },
      get$staffGroupings: function() {
        var t1, t2, groupings, measures, numMeasures, measureIndex, measure, numVisibleStaves, _i, staff, numStaves;
        t1 = this._measureStacks;
        t2 = t1.length;
        if (t2 === 0)
          return [];
        groupings = [];
        if (0 >= t2)
          return H.ioore(t1, 0);
        measures = t1[0].get$measures();
        numMeasures = measures.length;
        for (measureIndex = 0; measureIndex < numMeasures;) {
          if (measureIndex < 0 || measureIndex >= measures.length)
            return H.ioore(measures, measureIndex);
          measure = measures[measureIndex];
          for (t1 = measure.get$staff()._partRef._staves, t2 = t1.length, numVisibleStaves = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            staff = t1[_i];
            if (staff.get$visible(staff))
              ++numVisibleStaves;
          }
          numStaves = measure.get$staff()._partRef._staves.length;
          t1 = this._visibleParts;
          if ((t1 && C.JSArray_methods).indexOf$1(t1, measure.get$staff()._partRef) !== -1)
            groupings.push(numVisibleStaves);
          measureIndex += numStaves;
        }
        return groupings;
      },
      set$visibleParts: function(value) {
        this._visibleParts = value;
      },
      get$previous: function() {
        return this._data$_previous;
      },
      set$previous: function(value) {
        this._data$_previous = value;
      },
      get$next: function(_) {
        return this._data$_next;
      },
      set$next: function(_, value) {
        this._data$_next = value;
      },
      get$pageRef: function() {
        return this._data$_pageRef;
      },
      set$pageRef: function(value) {
        this._data$_pageRef = value;
      },
      get$newPage: function() {
        return this._newPage;
      },
      get$needsRendering: function() {
        return this._needsRendering;
      },
      set$needsRendering: function(value) {
        this._needsRendering = value;
      },
      get$slurSegments: function() {
        return this._slurSegments;
      },
      set$slurSegments: function(value) {
        this._slurSegments = value;
      }
    },
    Voice: {
      "^": "BaseDataObject;_noteGroups,_noteGroupContainers,_number@,_measure?,_dataID",
      addNoteGroup$1: function(noteGroup) {
        noteGroup._voice = this;
        this._noteGroups.push(noteGroup);
      },
      get$noteGroups: function() {
        return this._noteGroups;
      },
      get$number: function() {
        return this._number;
      },
      get$measure: function(_) {
        return this._measure;
      }
    },
    RepeatDO: {
      "^": "BaseDataObject;repeatDirection?,repeatTimes?,endingNumber?,endingType?,endingVPos?,_dataID"
    },
    Articulation: {
      "^": "NoteAttachment;_data$_type@,_noteGroup,_isAbove,_data$_height,_data$_width,_outsideStaff,_visible,_hPos,_vPos,_dataID",
      get$type: function(_) {
        return this._data$_type;
      }
    },
    Barline: {
      "^": "NotationObject;style*,location',_visible,_hPos,_vPos,_dataID"
    },
    Clef: {
      "^": "NotationObject;_data$_type@,_data$_qNoteTime@,_isNew?,_show?,_smallSize?,_visible,_hPos,_vPos,_dataID",
      get$type: function(_) {
        return this._data$_type;
      },
      get$qNoteTime: function() {
        return this._data$_qNoteTime;
      },
      set$qNoteTime: function(value) {
        this._data$_qNoteTime = value;
      }
    },
    Dynamic: {
      "^": "MeasureAttachment;_volume?,_data$_type@,_data$_qNoteTime,_measure,_isAbove,_data$_height,_data$_width,_visible,_hPos,_vPos,_dataID",
      get$volume: function(_) {
        return this._volume;
      },
      set$volume: function(_, value) {
        this._volume = value;
      },
      get$type: function(_) {
        return this._data$_type;
      }
    },
    Lyric: {
      "^": "NotationObject;_syllablePosition,_text,_verse,_visible,_hPos,_vPos,_dataID",
      get$text: function(_) {
        return this._text;
      },
      set$text: function(_, value) {
        this._text = value;
      }
    },
    MeasureAttachment: {
      "^": "NotationObject;_data$_qNoteTime@,_measure?,_isAbove?,_data$_height',_data$_width'",
      get$qNoteTime: function() {
        return this._data$_qNoteTime;
      },
      set$qNoteTime: function(value) {
        this._data$_qNoteTime = value;
      },
      get$isAbove: function() {
        return this._isAbove;
      },
      get$height: function(_) {
        return this._data$_height;
      },
      get$width: function(_) {
        return this._data$_width;
      },
      set$width: function(_, value) {
        this._data$_width = value;
      }
    },
    NotationObject: {
      "^": "BaseDataObject;_hPos<,_vPos<",
      get$visible: function(_) {
        return this._visible;
      },
      set$visible: function(_, value) {
        this._visible = value;
      },
      get$hPos: function() {
        return this._hPos;
      },
      set$hPos: function(value) {
        this._hPos = value;
      },
      get$vPos: function() {
        return this._vPos;
      },
      set$vPos: function(value) {
        this._vPos = value;
      }
    },
    Note: {
      "^": "NotationObject;_pitchName,_alteration,_displayCents,_playbackCents,_accidental,_showAccidental,_accidentalPos,_tieState,_legerLines,_stepsFromTopStaffLine,_prevVisible,_noteGroup,_visible,_hPos,_vPos,_dataID",
      get$tieState: function() {
        return this._tieState;
      },
      set$tieState: function(value) {
        this._tieState = value;
      },
      get$accidental: function() {
        return this._accidental;
      },
      get$showAccidental: function() {
        return this._showAccidental;
      },
      get$accidentalPos: function() {
        return this._accidentalPos;
      },
      set$accidentalPos: function(value) {
        this._accidentalPos = value;
      },
      get$pitchName: function() {
        return this._pitchName;
      },
      get$alteration: function() {
        return this._alteration;
      },
      get$displayCents: function() {
        return this._displayCents;
      },
      get$legerLines: function() {
        return this._legerLines;
      },
      get$stepsFromTopStaffLine: function() {
        return this._stepsFromTopStaffLine;
      },
      set$visible: function(_, value) {
        this._prevVisible = value;
        this._visible = value;
      },
      get$noteGroup: function() {
        return this._noteGroup;
      }
    },
    NoteAttachment: {
      "^": "NotationObject;_isAbove?,_data$_height',_data$_width'",
      get$noteGroup: function() {
        return this._noteGroup;
      },
      get$isAbove: function() {
        return this._isAbove;
      },
      set$isAbove: function(value) {
        this._isAbove = value;
      },
      get$height: function(_) {
        return this._data$_height;
      },
      get$width: function(_) {
        return this._data$_width;
      },
      set$width: function(_, value) {
        this._data$_width = value;
      },
      get$outsideStaff: function() {
        return this._outsideStaff;
      },
      set$outsideStaff: function(value) {
        this._outsideStaff = value;
      }
    },
    Slur: {
      "^": "BaseDataObject;_slurID,_above,_firstNote,_endNote,_segments,_dataID",
      get$above: function() {
        return this._above;
      },
      set$above: function(value) {
        this._above = value;
      },
      get$firstNote: function() {
        return this._firstNote;
      },
      get$endNote: function() {
        return this._endNote;
      }
    },
    SlurSegment: {
      "^": "BaseDataObject;_slur,_systemRef<,_points,_ngCoordinates,_dataID",
      get$slur: function() {
        return this._slur;
      },
      get$systemRef: function() {
        return this._systemRef;
      },
      set$systemRef: function(value) {
        this._systemRef = value;
      },
      get$points: function(_) {
        return this._points;
      }
    },
    TempoMarker: {
      "^": "BaseDataObject;_tempo,_data$_qNoteTime@,_dataID",
      get$tempo: function() {
        return this._tempo;
      },
      get$qNoteTime: function() {
        return this._data$_qNoteTime;
      },
      set$qNoteTime: function(value) {
        this._data$_qNoteTime = value;
      }
    },
    Tuplet: {
      "^": "BaseDataObject;_tupletID,_firstNote,_endNote,_numerator,_denominator,_numeratorDuration,_denominatorDuration,_above,_showBracket,_vPos<,_dataID",
      get$tupletID: function() {
        return this._tupletID;
      },
      get$firstNote: function() {
        return this._firstNote;
      },
      get$endNote: function() {
        return this._endNote;
      },
      set$endNote: function(value) {
        this._endNote = value;
      },
      get$numerator: function() {
        return this._numerator;
      },
      get$denominator: function() {
        return this._denominator;
      },
      get$denominatorDuration: function() {
        return this._denominatorDuration;
      },
      get$above: function() {
        return this._above;
      },
      set$above: function(value) {
        this._above = value;
      },
      get$showBracket: function() {
        return this._showBracket;
      },
      set$showBracket: function(value) {
        this._showBracket = value;
      },
      get$vPos: function() {
        return this._vPos;
      },
      set$vPos: function(value) {
        this._vPos = value;
      }
    }
  }], ["score_data.formatting", "package:score_data/src/formatting.dart",, L, {
    "^": "",
    ScoreFormatter: {
      "^": "Object;_musicSpacer,_beamer,_ngFormatter,_attachmentFormatter,_formatting$_score,_formatting$_parts",
      init$0: function() {
        var t1, t2;
        t1 = new L.MusicSpacer(null, null, null, null, null, null, null, null, null, null);
        t1._formatting$_score = this._formatting$_score;
        t1.initializeScoreSettings$0();
        this._musicSpacer = t1;
        this._beamer = new L.MusicBeamer(0);
        t1 = new L.NoteGroupFormatter(null);
        t1._formatting$_scoreProps = this._formatting$_score.get$scoreProperties();
        this._ngFormatter = t1;
        t1 = this._formatting$_score;
        t2 = new L.AttachmentFormatter(null);
        t2._formatting$_score = t1;
        this._attachmentFormatter = t2;
        this._formatting$_parts = t1.get$parts();
        if (this._formatting$_score.get$graceNotesNeedFixing()) {
          this.correctGraceNoteStartTimes$0();
          this._formatting$_score.set$graceNotesNeedFixing(false);
        }
        this.setPartList$1(null);
      },
      setPartList$1: function(partNames) {
        var t1, t2, _i, part, t3, index;
        if (partNames != null) {
          partNames = C.JSArray_methods.sublist$1(partNames, 0);
          this._formatting$_parts = H.setRuntimeTypeInfo([], [O.Part]);
          for (t1 = this._formatting$_score.get$parts(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            part = t1[_i];
            t3 = J.getInterceptor$x(part);
            index = C.JSArray_methods.indexOf$1(partNames, t3.get$name(part));
            if (index !== -1) {
              this._formatting$_parts.push(part);
              t3.set$visible(part, true);
              C.JSArray_methods.removeAt$1(partNames, index);
            } else
              t3.set$visible(part, false);
          }
        } else {
          t1 = this._formatting$_score.get$parts();
          this._formatting$_parts = t1;
          for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
            J.set$visible$x(t1[_i], true);
        }
        if (this._formatting$_parts.length === 0)
          this._formatting$_parts = this._formatting$_score.get$parts();
        this.updateMeasureStackNoteGroupsAndMeasures$0();
      },
      _processUpdateRequests$0: function() {
        var systems, t1, _i, system, stacks, t2, _i0, stack, measures, t3, _i1, measure;
        systems = this._formatting$_score.getSystems$0();
        for (t1 = systems.length, _i = 0; _i < systems.length; systems.length === t1 || (0, H.throwConcurrentModificationError)(systems), ++_i) {
          system = systems[_i];
          if (system.get$needsRendering()) {
            stacks = system.get$measureStacks();
            for (t2 = stacks.length, _i0 = 0; _i0 < stacks.length; stacks.length === t2 || (0, H.throwConcurrentModificationError)(stacks), ++_i0) {
              stack = stacks[_i0];
              if (stack.get$needsRendering()) {
                measures = stack.get$measures();
                for (t3 = measures.length, _i1 = 0; _i1 < measures.length; measures.length === t3 || (0, H.throwConcurrentModificationError)(measures), ++_i1) {
                  measure = measures[_i1];
                  if (measure.get$notesNeedRendering()) {
                    this._beamer.getMeasureBeamGroupings$1(measure);
                    this._ngFormatter.getMeasureStemDirections$1(measure);
                    this._ngFormatter.getMeasureNoteheadOffsets$1(measure);
                  }
                }
                this._musicSpacer.computeIdealSpacingValues$1(stack);
              }
            }
          }
        }
      },
      _getActualSpacingAndPositioning$0: function() {
        var systems, t1, _i, system, t2;
        systems = this._formatting$_score.getSystems$0();
        for (t1 = systems.length, _i = 0; _i < systems.length; systems.length === t1 || (0, H.throwConcurrentModificationError)(systems), ++_i) {
          system = systems[_i];
          if (system.get$needsRendering()) {
            this._musicSpacer.computeActualSpacingValues$1(system);
            this._ngFormatter.getSystemStemEndPositions$1(system);
            t2 = this._attachmentFormatter;
            t2._formatMeasureAttachments$1(system);
            t2._formatNoteAttachments$1(system);
          }
        }
        this._attachmentFormatter.formatLines$0();
      },
      correctGraceNoteStartTimes$0: function() {
        var t1, t2, _i, t3, t4, _i0, t5, t6, _i1, t7, t8, _i2, noteGroups, i, consecutiveGraceNotes, attachmentNG, ng;
        for (t1 = this._formatting$_parts, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$staves(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0)
            for (t5 = t3[_i0].get$measures(), t6 = t5.length, _i1 = 0; _i1 < t5.length; t5.length === t6 || (0, H.throwConcurrentModificationError)(t5), ++_i1)
              for (t7 = t5[_i1].get$voices(), t8 = t7.length, _i2 = 0; _i2 < t7.length; t7.length === t8 || (0, H.throwConcurrentModificationError)(t7), ++_i2) {
                noteGroups = t7[_i2].get$noteGroups();
                i = noteGroups.length - 1;
                for (consecutiveGraceNotes = 0, attachmentNG = null; i >= 0;) {
                  if (i >= noteGroups.length)
                    return H.ioore(noteGroups, i);
                  ng = noteGroups[i];
                  if (ng.get$isGrace()) {
                    ++consecutiveGraceNotes;
                    ng.set$qNoteTime(J.$sub$n(ng.get$qNoteTime(), consecutiveGraceNotes * 0.1));
                    ng.set$attachmentNG(attachmentNG);
                  } else {
                    attachmentNG = ng;
                    consecutiveGraceNotes = 0;
                  }
                  --i;
                }
              }
      },
      updateMeasureStackNoteGroupsAndMeasures$0: function() {
        var stacks, numMeasures, _i, stack, t1, t2, t3, t4, _i0, staff, measures, i, measure, totalKeySize;
        stacks = this._formatting$_score.getMeasureStacks$0();
        numMeasures = stacks.length;
        for (_i = 0; _i < stacks.length; stacks.length === numMeasures || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
          stack = stacks[_i];
          stack.clearNoteGroups$0();
          J.clearMeasures$0$x(stack);
          stack.set$maxKeySize(0);
        }
        for (t1 = this._formatting$_parts, t2 = t1.length, stack = null, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$staves(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0) {
            staff = t3[_i0];
            if (!staff.get$visible(staff))
              continue;
            measures = staff.get$measures();
            for (i = 0; i < numMeasures; ++i) {
              if (i >= stacks.length)
                return H.ioore(stacks, i);
              stack = stacks[i];
              if (i >= measures.length)
                return H.ioore(measures, i);
              measure = measures[i];
              stack.addNoteGroupsFromMeasure$1(measure);
              stack.addMeasure$1(measure);
              totalKeySize = S.PitchUtils_getTotalKeySize(measure.get$displayKey(), measure.get$outgoingKey());
              if (J.$gt$n(totalKeySize, stack.get$maxKeySize()))
                stack.set$maxKeySize(totalKeySize);
            }
          }
      }
    },
    AttachmentFormatter: {
      "^": "Object;_formatting$_score",
      formatLines$0: function() {
        var systems, t1, _i, t2, measuresPerStack, system, t3, staffSpacing, staffVPosOffsets, stacks, numStacks, repeatEndingHeightSet, i, stack, measures, vStaffPos, j, voices, _i0, voice, noteGroups, numNoteGroups, k, ng, slurs, x, slur, t4, t5, tupletIndex, _i1, tuplet;
        systems = this._formatting$_score.getSystems$0();
        for (t1 = systems.length, _i = 0; t2 = systems.length, _i < t2; systems.length === t1 || (0, H.throwConcurrentModificationError)(systems), ++_i)
          systems[_i].set$slurSegments([]);
        if (0 >= t2)
          return H.ioore(systems, 0);
        t1 = systems[0].get$measureStacks();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        measuresPerStack = t1[0].get$measures().length;
        for (t1 = systems.length, _i = 0; _i < systems.length; systems.length === t1 || (0, H.throwConcurrentModificationError)(systems), ++_i) {
          system = systems[_i];
          t2 = system.get$staffLineSpacing();
          if (typeof t2 !== "number")
            return t2.$mul();
          t3 = system.get$staffSpacing();
          if (typeof t3 !== "number")
            return H.iae(t3);
          staffSpacing = t2 * 4 + t3;
          staffVPosOffsets = system.get$staffVPosOffsets();
          stacks = system.get$measureStacks();
          numStacks = stacks.length;
          for (repeatEndingHeightSet = false, i = 0; i < numStacks; ++i) {
            if (i >= stacks.length)
              return H.ioore(stacks, i);
            stack = stacks[i];
            measures = stack.get$measures();
            for (vStaffPos = 0, j = 0; j < measuresPerStack; ++j) {
              if (j >= measures.length)
                return H.ioore(measures, j);
              voices = measures[j].get$voices();
              for (t2 = voices.length, _i0 = 0; _i0 < voices.length; voices.length === t2 || (0, H.throwConcurrentModificationError)(voices), ++_i0) {
                voice = voices[_i0];
                noteGroups = voice.get$noteGroups();
                numNoteGroups = noteGroups.length;
                for (k = 0; k < numNoteGroups; ++k) {
                  if (k >= noteGroups.length)
                    return H.ioore(noteGroups, k);
                  ng = noteGroups[k];
                  if (ng.get$slurs() != null) {
                    slurs = ng.get$slurs();
                    for (x = slurs.length - 1, t3 = J.getInterceptor$x(ng); x >= 0; --x) {
                      if (x >= slurs.length)
                        return H.ioore(slurs, x);
                      slur = slurs[x];
                      t4 = slur._firstNote;
                      if (t4 == null ? ng == null : t4 === ng) {
                        if (slur._endNote != null)
                          if (J.$eq$(voice.get$number(), slur._endNote._voice._number)) {
                            t4 = J.get$measure$x(t3.get$voice(ng))._staff;
                            t5 = slur._endNote._voice._measure._staff;
                            if (t4 == null ? t5 == null : t4 === t5)
                              if (!ng.get$isRest()) {
                                t4 = slur._endNote;
                                t4 = t4._isRest || t3.$eq(ng, t4);
                              } else
                                t4 = true;
                            else
                              t4 = true;
                          } else
                            t4 = true;
                        else
                          t4 = true;
                        if (t4) {
                          t4 = ng.get$slurs();
                          (t4 && C.JSArray_methods).removeAt$1(t4, x);
                          t4 = slur._endNote;
                          if (t4 != null) {
                            t4 = t4._slurs;
                            C.JSArray_methods.removeAt$1(t4, (t4 && C.JSArray_methods).indexOf$1(t4, slur));
                          }
                        } else {
                          if (j >= staffVPosOffsets.length)
                            return H.ioore(staffVPosOffsets, j);
                          this._buildSlurSegments$3(slur, k, vStaffPos + staffVPosOffsets[j]);
                        }
                      }
                    }
                  }
                  if (ng.get$tuplets() != null)
                    for (t3 = ng.get$tuplets(), t4 = t3.length, tupletIndex = 0, _i1 = 0; _i1 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i1) {
                      tuplet = t3[_i1];
                      t5 = tuplet.get$firstNote();
                      if (t5 == null ? ng == null : t5 === ng)
                        this._formatTuplet$3(ng, tuplet, ng.get$tuplets().length - 1 - tupletIndex);
                      ++tupletIndex;
                    }
                }
              }
              vStaffPos += staffSpacing;
            }
            if (!repeatEndingHeightSet && stack.get$repeatDOs() != null)
              for (t2 = stack.get$repeatDOs(), t3 = t2.length, _i0 = 0; _i0 < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i0)
                if (t2[_i0].endingType != null) {
                  this._setRepeatEndingHeight$2(stacks, i);
                  repeatEndingHeightSet = true;
                }
          }
        }
      },
      _formatMeasureAttachments$1: function(system) {
        var stacks, space, defaultAbovePos, defaultBelowPos, t1, t2, t3, _i, stack, measures, numMeasures, t4, i, t5, measure, attachments, stackWidth, _i0, attachment, voices, attachmentTime, t6, closestPrevNG, closestNextNG, matchingNG, _i1, noteGroups, numNoteGroups, t7, j, ngTime, t8, hPos, collisionNG, posRatio, notes, min, vPos, max;
        stacks = system.get$measureStacks();
        space = this._formatting$_score.get$scoreProperties()._staffLineSpacing;
        defaultAbovePos = -1 * space;
        defaultBelowPos = 5 * space;
        for (t1 = stacks.length, t2 = 1.5 * space, t3 = defaultBelowPos - t2, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
          stack = stacks[_i];
          measures = stack.get$measures();
          numMeasures = measures.length;
          for (t4 = J.getInterceptor$x(stack), i = 0; i < numMeasures; ++i) {
            if (i >= measures.length)
              return H.ioore(measures, i);
            measures[i].get$attachments();
            t5 = measures.length;
            if (i >= t5)
              return H.ioore(measures, i);
            measure = measures[i];
            attachments = measure.get$attachments();
            stackWidth = stack.get$newSystem() ? J.$sub$n(t4.get$width(stack), stack.get$indentAsSystemLeader()) : J.$sub$n(t4.get$width(stack), stack.get$indent());
            for (t5 = attachments.length, _i0 = 0; _i0 < attachments.length; attachments.length === t5 || (0, H.throwConcurrentModificationError)(attachments), ++_i0) {
              attachment = attachments[_i0];
              voices = measure.get$voices();
              if (measure.get$voices().length > 0) {
                attachmentTime = attachment.get$qNoteTime();
                for (t6 = voices.length, closestPrevNG = null, closestNextNG = null, matchingNG = null, _i1 = 0; _i1 < voices.length; voices.length === t6 || (0, H.throwConcurrentModificationError)(voices), ++_i1) {
                  noteGroups = voices[_i1].get$noteGroups();
                  numNoteGroups = noteGroups.length;
                  for (t7 = closestNextNG != null, j = 0; j < numNoteGroups; ++j) {
                    if (j >= noteGroups.length)
                      return H.ioore(noteGroups, j);
                    ngTime = noteGroups[j].get$qNoteTime();
                    t8 = J.getInterceptor$n(ngTime);
                    if (t8.$lt(ngTime, attachmentTime)) {
                      if (closestPrevNG == null || J.$lt$n(closestPrevNG.get$qNoteTime(), ngTime)) {
                        if (j >= noteGroups.length)
                          return H.ioore(noteGroups, j);
                        closestPrevNG = noteGroups[j];
                      }
                    } else if (t8.$eq(ngTime, attachmentTime)) {
                      if (j >= noteGroups.length)
                        return H.ioore(noteGroups, j);
                      matchingNG = noteGroups[j];
                      break;
                    } else if (!t7 || J.$gt$n(closestNextNG.get$qNoteTime(), ngTime)) {
                      if (j >= noteGroups.length)
                        return H.ioore(noteGroups, j);
                      closestNextNG = noteGroups[j];
                      break;
                    }
                  }
                }
                if (matchingNG != null) {
                  hPos = matchingNG.get$hPos();
                  collisionNG = matchingNG;
                } else {
                  t6 = closestNextNG != null;
                  if (t6 && closestPrevNG != null) {
                    posRatio = J.$div$n(J.$sub$n(attachmentTime, closestPrevNG.get$qNoteTime()), J.$sub$n(closestNextNG.get$qNoteTime(), closestPrevNG.get$qNoteTime()));
                    t6 = J.$sub$n(closestNextNG.get$hPos(), closestPrevNG.get$hPos());
                    if (typeof t6 !== "number")
                      return H.iae(t6);
                    t7 = closestPrevNG.get$hPos();
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    hPos = posRatio * t6 + t7;
                    t6 = closestPrevNG.get$hPos();
                    if (typeof t6 !== "number")
                      return H.iae(t6);
                    t7 = J.$sub$n(closestNextNG.get$hPos(), hPos);
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    collisionNG = hPos - t6 < t7 ? closestPrevNG : closestNextNG;
                  } else if (closestPrevNG != null) {
                    posRatio = J.$div$n(J.$sub$n(attachmentTime, closestPrevNG.get$qNoteTime()), J.$sub$n(t4.get$endTime(stack), closestPrevNG.get$qNoteTime()));
                    t6 = J.$sub$n(J.$add$ns(stack.get$startPosition(), t4.get$width(stack)), closestPrevNG.get$hPos());
                    if (typeof t6 !== "number")
                      return H.iae(t6);
                    t7 = closestPrevNG.get$hPos();
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    hPos = posRatio * t6 + t7;
                    collisionNG = closestPrevNG;
                  } else if (t6) {
                    posRatio = J.$div$n(J.$sub$n(attachmentTime, t4.get$startTime(stack)), J.$sub$n(closestNextNG.get$qNoteTime(), t4.get$startTime(stack)));
                    t6 = closestNextNG.get$hPos();
                    if (typeof t6 !== "number")
                      return H.iae(t6);
                    hPos = posRatio * t6;
                    collisionNG = closestNextNG;
                  } else {
                    t6 = J.$div$n(J.$sub$n(attachment.get$qNoteTime(), t4.get$startTime(stack)), stack.get$dpqLength());
                    if (typeof stackWidth !== "number")
                      return H.iae(stackWidth);
                    hPos = t6 * stackWidth;
                    collisionNG = null;
                  }
                }
                if (collisionNG != null && !collisionNG.get$isRest()) {
                  notes = collisionNG.get$visibleNotes();
                  if (attachment.get$isAbove()) {
                    min = collisionNG.get$stemDirection() === "up" ? collisionNG.get$stemEndPos() : (notes && C.JSArray_methods).get$last(notes).get$vPos();
                    t6 = attachment.get$height(attachment);
                    if (typeof t6 !== "number")
                      return H.iae(t6);
                    t7 = J.getInterceptor$n(min);
                    if (t7.$lt(min, defaultAbovePos + t6 + t2))
                      vPos = J.$sub$n(t7.$sub(min, t2), attachment.get$height(attachment));
                    else {
                      t6 = attachment.get$height(attachment);
                      if (typeof t6 !== "number")
                        return H.iae(t6);
                      vPos = defaultAbovePos - t6;
                    }
                  } else {
                    if (collisionNG.get$stemDirection() === "down")
                      max = collisionNG.get$stemEndPos();
                    else {
                      if (0 >= notes.length)
                        return H.ioore(notes, 0);
                      max = notes[0].get$vPos();
                    }
                    t6 = J.getInterceptor$n(max);
                    vPos = t6.$gt(max, t3) ? t6.$add(max, t2) : defaultBelowPos;
                  }
                } else if (attachment.get$isAbove()) {
                  t6 = attachment.get$height(attachment);
                  if (typeof t6 !== "number")
                    return H.iae(t6);
                  vPos = defaultAbovePos - t6;
                } else
                  vPos = defaultBelowPos;
              } else {
                t6 = J.$div$n(J.$sub$n(attachment.get$qNoteTime(), t4.get$startTime(stack)), stack.get$dpqLength());
                if (typeof stackWidth !== "number")
                  return H.iae(stackWidth);
                hPos = t6 * stackWidth;
                if (attachment.get$isAbove()) {
                  t6 = attachment.get$height(attachment);
                  if (typeof t6 !== "number")
                    return H.iae(t6);
                  vPos = defaultAbovePos - t6;
                } else
                  vPos = defaultBelowPos;
              }
              attachment.set$hPos(hPos);
              attachment.set$vPos(vPos);
            }
          }
        }
      },
      _formatNoteAttachments$1: function(system) {
        var stacks, space, defaultAbovePos, defaultBelowPos, t1, _i, measures, numMeasures, i, voices, j, noteGroups, numNoteGroups, above, k, ng, notes, t2, t3, t4, _i0, artic, above0, t5, topNote, highestNoteStaffLine, articStaffLine, t6, bottomNote, lowestNoteStaffLine;
        stacks = system.get$measureStacks();
        space = this._formatting$_score.get$scoreProperties()._staffLineSpacing;
        defaultAbovePos = -1 * space;
        defaultBelowPos = 5 * space;
        for (t1 = stacks.length, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
          measures = stacks[_i].get$measures();
          numMeasures = measures.length;
          for (i = 0; i < numMeasures; ++i) {
            if (i >= measures.length)
              return H.ioore(measures, i);
            voices = measures[i].get$voices();
            for (j = 0; j < voices.length; ++j) {
              noteGroups = voices[j].get$noteGroups();
              numNoteGroups = noteGroups.length;
              for (above = j % 2 === 0, k = 0; k < numNoteGroups; ++k) {
                if (k >= noteGroups.length)
                  return H.ioore(noteGroups, k);
                ng = noteGroups[k];
                if (ng.get$articulations() == null)
                  continue;
                notes = ng.get$visibleNotes();
                for (t2 = ng.get$articulations(), t3 = t2.length, t4 = notes && C.JSArray_methods, _i0 = 0; _i0 < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i0) {
                  artic = t2[_i0];
                  artic.set$outsideStaff(artic.get$type(artic) === 1 || ng.get$isRest());
                  above0 = voices.length > 1 ? above : ng.get$stemDirection() !== "up";
                  artic.set$isAbove(above0);
                  if (above0)
                    if (ng.get$isRest()) {
                      t5 = artic.get$width(artic);
                      if (typeof t5 !== "number")
                        return H.iae(t5);
                      artic.set$hPos(space * (1 - t5) / 2);
                      artic.set$vPos(defaultAbovePos);
                    } else {
                      topNote = t4.get$last(notes);
                      if (ng.get$stemDirection() !== "up") {
                        highestNoteStaffLine = topNote.get$stepsFromTopStaffLine();
                        articStaffLine = C.JSNumber_methods.$mod(highestNoteStaffLine, 2) === 0 && highestNoteStaffLine >= 2 ? highestNoteStaffLine - 3 : highestNoteStaffLine - 2;
                        if (artic.get$outsideStaff() && articStaffLine > -1)
                          articStaffLine = -1;
                        t5 = topNote.get$hPos();
                        t6 = artic.get$width(artic);
                        if (typeof t6 !== "number")
                          return H.iae(t6);
                        artic.set$hPos(J.$add$ns(t5, space * (1 - t6) / 2));
                        artic.set$vPos(articStaffLine * space / 2);
                      } else {
                        t5 = topNote.get$hPos();
                        t6 = artic.get$width(artic);
                        if (typeof t6 !== "number")
                          return H.iae(t6);
                        artic.set$hPos(J.$add$ns(t5, space * (1 - t6) / 2));
                        artic.set$vPos(ng.get$stemEndPos() - space);
                      }
                    }
                  else if (ng.get$isRest()) {
                    t5 = artic.get$width(artic);
                    if (typeof t5 !== "number")
                      return H.iae(t5);
                    artic.set$hPos(space * (1 - t5) / 2);
                    artic.set$vPos(defaultBelowPos);
                  } else {
                    if (0 >= notes.length)
                      return H.ioore(notes, 0);
                    bottomNote = notes[0];
                    if (ng.get$stemDirection() !== "down") {
                      lowestNoteStaffLine = bottomNote.get$stepsFromTopStaffLine();
                      articStaffLine = C.JSNumber_methods.$mod(lowestNoteStaffLine, 2) === 0 && lowestNoteStaffLine <= 6 ? lowestNoteStaffLine + 3 : lowestNoteStaffLine + 2;
                      if (artic.get$outsideStaff() && articStaffLine < 9)
                        articStaffLine = 9;
                      t5 = bottomNote.get$hPos();
                      t6 = artic.get$width(artic);
                      if (typeof t6 !== "number")
                        return H.iae(t6);
                      artic.set$hPos(J.$add$ns(t5, space * (1 - t6) / 2));
                      artic.set$vPos(articStaffLine * space / 2);
                    } else {
                      t5 = bottomNote.get$hPos();
                      t6 = artic.get$width(artic);
                      if (typeof t6 !== "number")
                        return H.iae(t6);
                      artic.set$hPos(J.$add$ns(t5, space * (1 - t6) / 2));
                      artic.set$vPos(ng.get$stemEndPos() + space);
                    }
                  }
                }
              }
            }
          }
        }
      },
      _formatTuplet$3: function(ng, tuplet, level) {
        var needBracket, nextNG, stemUpTally, stemDownTally, highPoint, lowPoint, nextNotes, t1, isAbove, t2;
        if (!ng.get$isRest())
          needBracket = tuplet.get$endNote() != null && tuplet.get$endNote()._isRest;
        else
          needBracket = true;
        for (nextNG = ng, stemUpTally = 0, stemDownTally = 0, highPoint = 1000, lowPoint = -1000; nextNG != null;) {
          nextNotes = nextNG.get$visibleNotes();
          if (nextNG.get$beamStates().length === 0)
            needBracket = true;
          if (nextNG.get$stemDirection() === "up") {
            ++stemUpTally;
            if (0 >= nextNotes.length)
              return H.ioore(nextNotes, 0);
            if (J.$gt$n(nextNotes[0].get$vPos(), lowPoint)) {
              if (0 >= nextNotes.length)
                return H.ioore(nextNotes, 0);
              lowPoint = nextNotes[0].get$vPos();
            }
            t1 = nextNG.get$stemEndPos();
            if (typeof highPoint !== "number")
              return H.iae(highPoint);
            if (t1 < highPoint)
              highPoint = nextNG.get$stemEndPos();
          } else if (nextNG.get$stemDirection() === "down") {
            ++stemDownTally;
            if (J.$lt$n((nextNotes && C.JSArray_methods).get$last(nextNotes).get$vPos(), highPoint))
              highPoint = C.JSArray_methods.get$last(nextNotes).get$vPos();
            t1 = nextNG.get$stemEndPos();
            if (typeof lowPoint !== "number")
              return H.iae(lowPoint);
            if (t1 > lowPoint)
              lowPoint = nextNG.get$stemEndPos();
          } else {
            ++stemUpTally;
            if (!nextNG.get$isRest()) {
              if (0 >= nextNotes.length)
                return H.ioore(nextNotes, 0);
              if (J.$gt$n(nextNotes[0].get$vPos(), lowPoint)) {
                if (0 >= nextNotes.length)
                  return H.ioore(nextNotes, 0);
                lowPoint = nextNotes[0].get$vPos();
              }
              if (J.$lt$n((nextNotes && C.JSArray_methods).get$last(nextNotes).get$vPos(), highPoint))
                highPoint = C.JSArray_methods.get$last(nextNotes).get$vPos();
            }
          }
          t1 = J.getInterceptor(nextNG);
          if (t1.$eq(nextNG, tuplet.get$endNote()))
            break;
          nextNG = t1.get$next(nextNG);
        }
        isAbove = stemUpTally >= stemDownTally;
        tuplet.set$above(isAbove);
        if (J.$gt$n(highPoint, 0))
          highPoint = 0;
        if (J.$lt$n(lowPoint, this._formatting$_score.get$scoreProperties()._staffLineSpacing * 4))
          lowPoint = this._formatting$_score.get$scoreProperties()._staffLineSpacing * 4;
        t1 = this._formatting$_score;
        t2 = level + 1;
        if (isAbove)
          tuplet.set$vPos(J.$sub$n(highPoint, t2 * t1.get$scoreProperties()._staffLineSpacing));
        else
          tuplet.set$vPos(J.$add$ns(lowPoint, t2 * t1.get$scoreProperties()._staffLineSpacing));
        tuplet.set$showBracket(needBracket);
      },
      _buildSlurSegments$3: function(slur, ngIndex, vStaffPos) {
        var ng1, ng2, voiceNumber, offset, measure, cSystem, isAbove, multipleVoices, segments, t1, ngCoordinates, t2, coordPos, endNoteFound, segment, breakOuterLoop, measureHPos, voices, t3, _i, voice, noteGroups, numNoteGroups, i, cng, cngNotes, t4, coordPos0, t5, topNote, bottomNote, vPos, yShift, hPos, vPos0, startPoint, firstStack, ng2TopNote, vPos1, ng2BottomNote, endPoint, lastStack, deltaX, deltaY, sp, t6, ep, defaultCPHeight, slope, t7, t8, angle, cpXOffset, cp1, cp2, numValues, j, perpSlope, intersectX, intersectY;
        ng1 = slur._firstNote;
        ng2 = slur._endNote;
        voiceNumber = ng2._voice._number;
        offset = this._formatting$_score.get$scoreProperties()._staffLineSpacing / 2;
        measure = ng1._voice._measure;
        cSystem = measure._stack._systemRef;
        isAbove = ng1._stemDirection === "down";
        multipleVoices = measure._voices.length > 1;
        segments = [];
        t1 = [P.int, P.num];
        ngCoordinates = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t1);
        ++ngIndex;
        for (t2 = [S.PointXY], coordPos = 0, endNoteFound = false, segment = null, breakOuterLoop = false; measure != null;) {
          measureHPos = J.$add$ns(cSystem.get$indent(), measure.get$stack()._startPosition);
          if (!J.$eq$(measure.get$stack()._systemRef, cSystem)) {
            segment = new O.SlurSegment(null, null, H.setRuntimeTypeInfo(new Array(4), t2), null, 0);
            segment._systemRef = cSystem;
            segment._slur = slur;
            segment._ngCoordinates = ngCoordinates;
            segments.push(segment);
            cSystem.get$slurSegments().push(segment);
            cSystem = measure.get$stack()._systemRef;
            cSystem.get$needsRendering();
            ngCoordinates = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t1);
            coordPos = 0;
          }
          voices = measure.get$voices();
          for (t3 = voices.length, _i = 0; _i < voices.length; voices.length === t3 || (0, H.throwConcurrentModificationError)(voices), ++_i) {
            voice = voices[_i];
            if (J.$eq$(voice.get$number(), voiceNumber)) {
              noteGroups = voice.get$noteGroups();
              numNoteGroups = noteGroups.length;
              for (i = ngIndex; i < numNoteGroups; ++i) {
                if (i < 0 || i >= noteGroups.length)
                  return H.ioore(noteGroups, i);
                cng = noteGroups[i];
                if (cng.get$isRest())
                  continue;
                if (cng.get$stemDirection() === "down")
                  isAbove = true;
                if (!J.$eq$(cng, ng2)) {
                  cngNotes = cng.get$visibleNotes();
                  t4 = coordPos + 1;
                  coordPos0 = coordPos + 2;
                  t5 = coordPos0 + 1;
                  if (cng.get$stemDirection() === "down") {
                    topNote = (cngNotes && C.JSArray_methods).get$last(cngNotes);
                    ngCoordinates.$indexSet(0, coordPos, J.$add$ns(cng.get$hPos(), measureHPos));
                    ngCoordinates.$indexSet(0, t4, topNote.get$vPos());
                    ngCoordinates.$indexSet(0, coordPos0, J.$add$ns(cng.get$hPos(), measureHPos));
                    ngCoordinates.$indexSet(0, t5, cng.get$stemEndPos());
                    coordPos = coordPos0 + 2;
                  } else {
                    if (0 >= cngNotes.length)
                      return H.ioore(cngNotes, 0);
                    bottomNote = cngNotes[0];
                    ngCoordinates.$indexSet(0, coordPos, J.$add$ns(cng.get$hPos(), measureHPos));
                    ngCoordinates.$indexSet(0, t4, bottomNote.get$vPos());
                    ngCoordinates.$indexSet(0, coordPos0, J.$add$ns(cng.get$hPos(), measureHPos));
                    ngCoordinates.$indexSet(0, t5, cng.get$stemDirection() === "up" ? cng.get$stemEndPos() : (cngNotes && C.JSArray_methods).get$last(cngNotes).get$vPos());
                    coordPos = coordPos0 + 2;
                  }
                } else {
                  segment = new O.SlurSegment(null, null, H.setRuntimeTypeInfo(new Array(4), t2), null, 0);
                  segment._ngCoordinates = ngCoordinates;
                  segment._systemRef = cSystem;
                  segment._slur = slur;
                  segments.push(segment);
                  cSystem.get$slurSegments().push(segment);
                  endNoteFound = true;
                  breakOuterLoop = true;
                  break;
                }
              }
              if (breakOuterLoop)
                break;
              ngIndex = 0;
            }
          }
          if (breakOuterLoop)
            break;
          measure = J.get$next$x(measure);
          if (measure.get$voices().length > 1)
            multipleVoices = true;
        }
        if (!endNoteFound) {
          t1 = ng1._slurs;
          C.JSArray_methods.removeAt$1(t1, (t1 && C.JSArray_methods).indexOf$1(t1, slur));
          t1 = slur._endNote;
          if (t1 != null) {
            t1 = t1._slurs;
            C.JSArray_methods.removeAt$1(t1, (t1 && C.JSArray_methods).indexOf$1(t1, slur));
          }
          return;
        }
        if (multipleVoices)
          isAbove = J.$eq$(ng1._voice._number, 1);
        slur._segments = segments;
        for (t1 = 2 * offset, vPos = -1 * offset, yShift = null, i = 0; i < segments.length; ++i) {
          segment = segments[i];
          t2 = i === 0;
          if (t2)
            if (isAbove) {
              if (ng1._stemDirection === "up") {
                t3 = ng1._beamStates;
                t3 = t3.length > 0 && !J.$eq$(t3[0], "end");
                t4 = segment._systemRef;
                if (t3) {
                  hPos = J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng1._voice._measure._stack._startPosition), ng1._hPos), ng1._stemHPos);
                  vPos0 = ng1._stemEndPos - offset;
                } else {
                  hPos = J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng1._voice._measure._stack._startPosition), ng1._hPos), ng1._stemHPos), offset);
                  vPos0 = ng1._stemEndPos + t1;
                }
              } else {
                hPos = J.$add$ns(J.$add$ns(J.$add$ns(segment._systemRef.get$indent(), ng1._voice._measure._stack._startPosition), ng1._hPos), offset);
                t3 = ng1.get$visibleNotes();
                vPos0 = J.$sub$n((t3 && C.JSArray_methods).get$last(t3).get$vPos(), t1);
              }
              startPoint = new S.PointXY(null, null);
              startPoint.x = hPos;
              startPoint.y = vPos0;
            } else {
              if (ng1._stemDirection === "down") {
                t3 = ng1._beamStates;
                t3 = t3.length > 0 && !J.$eq$(t3[0], "end");
                t4 = segment._systemRef;
                if (t3) {
                  hPos = J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng1._voice._measure._stack._startPosition), ng1._hPos), ng1._stemHPos);
                  vPos0 = ng1._stemEndPos + offset;
                } else {
                  hPos = J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng1._voice._measure._stack._startPosition), ng1._hPos), ng1._stemHPos), offset);
                  vPos0 = ng1._stemEndPos - t1;
                }
              } else {
                hPos = J.$add$ns(J.$add$ns(J.$add$ns(segment._systemRef.get$indent(), ng1._voice._measure._stack._startPosition), ng1._hPos), offset);
                t3 = ng1.get$visibleNotes();
                if (0 >= t3.length)
                  return H.ioore(t3, 0);
                vPos0 = J.$add$ns(t3[0].get$vPos(), t1);
              }
              startPoint = new S.PointXY(null, null);
              startPoint.x = hPos;
              startPoint.y = vPos0;
            }
          else {
            t3 = segment._systemRef.get$measureStacks();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            firstStack = t3[0];
            hPos = J.$add$ns(J.$sub$n(J.$add$ns(firstStack.get$startPosition(), firstStack.get$indentAsSystemLeader()), firstStack.get$indent()), segment._systemRef.get$indent());
            if (i === segments.length - 1)
              if (isAbove) {
                vPos0 = ng2._stemEndPos - offset;
                if (!(vPos0 < vPos)) {
                  t3 = ng2.get$visibleNotes();
                  ng2TopNote = (t3 && C.JSArray_methods).get$last(t3);
                  vPos0 = J.$lt$n(J.$sub$n(ng2TopNote.get$vPos(), offset), vPos) ? J.$sub$n(ng2TopNote.get$vPos(), offset) : vPos;
                }
              } else {
                vPos0 = 4 * this._formatting$_score.get$scoreProperties()._staffLineSpacing + offset;
                vPos1 = ng2._stemEndPos + offset;
                if (vPos1 > vPos0)
                  vPos0 = vPos1;
                else {
                  t3 = ng2.get$visibleNotes();
                  if (0 >= t3.length)
                    return H.ioore(t3, 0);
                  ng2BottomNote = t3[0];
                  if (J.$gt$n(J.$add$ns(ng2BottomNote.get$vPos(), offset), vPos0))
                    vPos0 = J.$add$ns(ng2BottomNote.get$vPos(), offset);
                }
              }
            else
              vPos0 = isAbove ? vPos : 4 * this._formatting$_score.get$scoreProperties()._staffLineSpacing + offset;
            startPoint = new S.PointXY(null, null);
            startPoint.x = hPos;
            startPoint.y = vPos0;
          }
          t3 = segment._points;
          t3[0] = startPoint;
          if (i === segments.length - 1)
            if (isAbove) {
              if (ng2._stemDirection === "up") {
                t2 = ng2._beamStates;
                t2 = t2.length > 0 && !J.$eq$(t2[0], "begin");
                t4 = segment._systemRef;
                if (t2) {
                  hPos = J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng2._voice._measure._stack._startPosition), ng2._hPos), ng2._stemHPos);
                  vPos0 = ng2._stemEndPos - offset;
                } else {
                  hPos = J.$sub$n(J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng2._voice._measure._stack._startPosition), ng2._hPos), ng2._stemHPos), offset);
                  vPos0 = ng2._stemEndPos + t1;
                }
              } else {
                hPos = J.$add$ns(J.$add$ns(J.$add$ns(segment._systemRef.get$indent(), ng2._voice._measure._stack._startPosition), ng2._hPos), offset);
                t2 = ng2.get$visibleNotes();
                vPos0 = J.$sub$n((t2 && C.JSArray_methods).get$last(t2).get$vPos(), t1);
              }
              endPoint = new S.PointXY(null, null);
              endPoint.x = hPos;
              endPoint.y = vPos0;
            } else {
              if (ng2._stemDirection === "down") {
                t2 = ng2._beamStates;
                t2 = t2.length > 0 && !J.$eq$(t2[0], "begin");
                t4 = segment._systemRef;
                if (t2) {
                  hPos = J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng2._voice._measure._stack._startPosition), ng2._hPos), ng2._stemHPos);
                  vPos0 = ng2._stemEndPos + offset;
                } else {
                  hPos = J.$sub$n(J.$add$ns(J.$add$ns(J.$add$ns(t4.get$indent(), ng2._voice._measure._stack._startPosition), ng2._hPos), ng2._stemHPos), offset);
                  vPos0 = ng2._stemEndPos - t1;
                }
              } else {
                hPos = J.$add$ns(J.$add$ns(J.$add$ns(segment._systemRef.get$indent(), ng2._voice._measure._stack._startPosition), ng2._hPos), offset);
                t2 = ng2.get$visibleNotes();
                if (0 >= t2.length)
                  return H.ioore(t2, 0);
                vPos0 = J.$add$ns(t2[0].get$vPos(), t1);
              }
              endPoint = new S.PointXY(null, null);
              endPoint.x = hPos;
              endPoint.y = vPos0;
            }
          else {
            t4 = segment._systemRef.get$measureStacks();
            t5 = segment._systemRef.get$measureStacks().length - 1;
            if (t5 < 0 || t5 >= t4.length)
              return H.ioore(t4, t5);
            lastStack = t4[t5];
            hPos = J.$add$ns(J.$add$ns(lastStack.get$startPosition(), J.get$width$x(lastStack)), segment._systemRef.get$indent());
            if (t2)
              if (isAbove)
                vPos0 = J.$lt$n(startPoint.y, vPos) ? startPoint.y : vPos;
              else {
                vPos0 = 4 * this._formatting$_score.get$scoreProperties()._staffLineSpacing + offset;
                if (J.$gt$n(startPoint.y, vPos0))
                  vPos0 = startPoint.y;
              }
            else
              vPos0 = isAbove ? vPos : 4 * this._formatting$_score.get$scoreProperties()._staffLineSpacing + offset;
            endPoint = new S.PointXY(null, null);
            endPoint.x = hPos;
            endPoint.y = vPos0;
          }
          t3[3] = endPoint;
          deltaX = J.$mul$ns(startPoint.x, -1);
          deltaY = J.$mul$ns(startPoint.y, -1);
          t2 = J.$add$ns(startPoint.x, deltaX);
          t4 = J.$add$ns(startPoint.y, deltaY);
          sp = new S.PointXY(null, null);
          sp.x = t2;
          sp.y = t4;
          t5 = J.$add$ns(endPoint.x, deltaX);
          t6 = J.$add$ns(endPoint.y, deltaY);
          ep = new S.PointXY(null, null);
          ep.x = t5;
          ep.y = t6;
          defaultCPHeight = Math.min(t1, offset * J.$div$n(J.$sub$n(t5, t2), 100));
          if (isAbove) {
            slope = J.$div$n(J.$sub$n(t6, t4), J.$sub$n(t5, t2));
            t7 = J.$sub$n(t6, t4);
            t8 = J.$sub$n(t5, t2);
            angle = Math.atan2(H.checkNum(t7), H.checkNum(t8));
            cpXOffset = J.$gt$n(J.$sub$n(t5, t2), 100) ? 10 : J.$div$n(J.$sub$n(t5, t2), 4);
            t2 = Math.cos(angle);
            t7 = J.$div$n(J.$mul$ns(J.$sub$n(t6, t4), cpXOffset), t5);
            t8 = Math.cos(angle);
            cp1 = new S.PointXY(null, null);
            cp1.x = cpXOffset * t2;
            cp1.y = t7 - defaultCPHeight * t8;
            t8 = J.$sub$n(t5, cpXOffset * Math.cos(angle));
            t5 = J.$sub$n(J.$mul$ns(J.$sub$n(t6, t4), J.$div$n(J.$sub$n(t5, cpXOffset), t5)), defaultCPHeight * Math.cos(angle));
            cp2 = new S.PointXY(null, null);
            cp2.x = t8;
            cp2.y = t5;
            ngCoordinates = segment._ngCoordinates;
            numValues = ngCoordinates.get$length(ngCoordinates);
            for (j = 0; j < numValues;) {
              ngCoordinates.$indexSet(0, j, J.$add$ns(ngCoordinates.$index(0, j), deltaX));
              t2 = j + 1;
              ngCoordinates.$indexSet(0, t2, J.$add$ns(ngCoordinates.$index(0, t2), deltaY));
              if (J.$div$n(ngCoordinates.$index(0, j), ep.x) < 0.25)
                ngCoordinates.$indexSet(0, t2, J.$sub$n(ngCoordinates.$index(0, t2), offset));
              else if (J.$div$n(ngCoordinates.$index(0, j), ep.x) > 0.75)
                ngCoordinates.$indexSet(0, t2, J.$sub$n(ngCoordinates.$index(0, t2), offset));
              if (J.$lt$n(ngCoordinates.$index(0, t2), J.$add$ns(J.$mul$ns(ngCoordinates.$index(0, j), slope), cp1.y))) {
                yShift = J.$sub$n(ngCoordinates.$index(0, t2), J.$add$ns(J.$mul$ns(ngCoordinates.$index(0, j), slope), cp1.y));
                cp1.y = J.$add$ns(cp1.y, yShift);
                cp2.y = J.$add$ns(cp2.y, yShift);
              }
              j += 2;
            }
            if (slope === 0)
              slope = 0.001;
            t2 = cp1.y;
            t4 = cp1.x;
            if (typeof t4 !== "number")
              return H.iae(t4);
            perpSlope = -1 / slope;
            intersectX = J.$div$n(J.$sub$n(t2, slope * t4), perpSlope - slope);
            intersectY = perpSlope * intersectX;
            cp1.x = J.$add$ns(cp1.x, intersectX + t1 * Math.sin(angle));
            cp1.y = J.$add$ns(cp1.y, intersectY - t1 * Math.cos(angle));
            cp2.x = J.$add$ns(cp2.x, intersectX + t1 * Math.sin(angle));
            cp2.y = J.$add$ns(cp2.y, intersectY - t1 * Math.cos(angle));
          } else {
            slope = J.$div$n(J.$sub$n(t6, t4), J.$sub$n(t5, t2));
            t7 = J.$sub$n(t6, t4);
            t8 = J.$sub$n(t5, t2);
            angle = Math.atan2(H.checkNum(t7), H.checkNum(t8));
            cpXOffset = J.$gt$n(J.$sub$n(t5, t2), 100) ? 10 : J.$div$n(J.$sub$n(t5, t2), 4);
            t2 = Math.cos(angle);
            t7 = J.$div$n(J.$mul$ns(J.$sub$n(t6, t4), cpXOffset), t5);
            t8 = Math.cos(angle);
            cp1 = new S.PointXY(null, null);
            cp1.x = cpXOffset * t2;
            cp1.y = t7 + defaultCPHeight * t8;
            t8 = J.$sub$n(t5, cpXOffset * Math.cos(angle));
            t5 = J.$add$ns(J.$mul$ns(J.$sub$n(t6, t4), J.$div$n(J.$sub$n(t5, cpXOffset), t5)), defaultCPHeight * Math.cos(angle));
            cp2 = new S.PointXY(null, null);
            cp2.x = t8;
            cp2.y = t5;
            ngCoordinates = segment._ngCoordinates;
            numValues = ngCoordinates.get$length(ngCoordinates);
            for (j = 0; j < numValues;) {
              ngCoordinates.$indexSet(0, j, J.$add$ns(ngCoordinates.$index(0, j), deltaX));
              t2 = j + 1;
              ngCoordinates.$indexSet(0, t2, J.$add$ns(ngCoordinates.$index(0, t2), deltaY));
              if (J.$div$n(ngCoordinates.$index(0, j), ep.x) < 0.25)
                ngCoordinates.$indexSet(0, t2, J.$add$ns(ngCoordinates.$index(0, t2), offset));
              else if (J.$div$n(ngCoordinates.$index(0, j), ep.x) > 0.75)
                ngCoordinates.$indexSet(0, t2, J.$add$ns(ngCoordinates.$index(0, t2), offset));
              if (J.$gt$n(ngCoordinates.$index(0, t2), J.$add$ns(J.$mul$ns(ngCoordinates.$index(0, j), slope), cp1.y))) {
                yShift = J.$sub$n(ngCoordinates.$index(0, t2), J.$add$ns(J.$mul$ns(ngCoordinates.$index(0, j), slope), cp1.y));
                cp1.y = J.$add$ns(cp1.y, yShift);
                cp2.y = J.$add$ns(cp2.y, yShift);
              }
              j += 2;
            }
            if (slope === 0)
              slope = 0.001;
            t2 = cp1.y;
            t4 = cp1.x;
            if (typeof t4 !== "number")
              return H.iae(t4);
            perpSlope = -1 / slope;
            intersectX = J.$div$n(J.$sub$n(t2, slope * t4), perpSlope - slope);
            intersectY = perpSlope * intersectX;
            cp1.x = J.$add$ns(cp1.x, intersectX - t1 * Math.sin(angle));
            cp1.y = J.$add$ns(cp1.y, intersectY + t1 * Math.cos(angle));
            cp2.x = J.$add$ns(cp2.x, intersectX - t1 * Math.sin(angle));
            cp2.y = J.$add$ns(cp2.y, intersectY + t1 * Math.cos(angle));
          }
          t3[0] = sp;
          t3[1] = cp1;
          t3[2] = cp2;
          t3[3] = ep;
          t2 = J.getInterceptor$n(deltaX);
          sp.x = J.$add$ns(sp.x, t2.$negate(deltaX));
          t4 = t3[0];
          t5 = t4.y;
          if (typeof deltaY !== "number")
            return H.iae(deltaY);
          t6 = vStaffPos - deltaY;
          t4.y = J.$add$ns(t5, t6);
          t5 = t3[1];
          t5.x = J.$add$ns(t5.x, t2.$negate(deltaX));
          t5 = t3[1];
          t5.y = J.$add$ns(t5.y, t6);
          t5 = t3[2];
          t5.x = J.$add$ns(t5.x, t2.$negate(deltaX));
          t5 = t3[2];
          t5.y = J.$add$ns(t5.y, t6);
          t5 = t3[3];
          t5.x = J.$add$ns(t5.x, t2.$negate(deltaX));
          t3 = t3[3];
          t3.y = J.$add$ns(t3.y, t6);
        }
      },
      _setRepeatEndingHeight$2: function(stacks, firstStackIndex) {
        var endingRDOs, i, highestVPos, underEndingBracket, stack, t1, t2, endingFinished, _i, rdo, t3, t4, _i0, ng, t5, noteVPos, endingVPos;
        endingRDOs = [];
        for (i = firstStackIndex, highestVPos = 2576980377, underEndingBracket = true; i < stacks.length; ++i) {
          stack = stacks[i];
          if (stack.get$repeatDOs() != null)
            for (t1 = stack.get$repeatDOs(), t2 = t1.length, endingFinished = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
              rdo = t1[_i];
              t3 = rdo.endingType;
              if (t3 === 0) {
                endingRDOs.push(rdo);
                underEndingBracket = true;
              } else if (t3 === 2 || t3 === 1) {
                endingRDOs.push(rdo);
                endingFinished = true;
              }
            }
          else
            endingFinished = false;
          if (underEndingBracket) {
            t1 = stack.get$measures();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            for (t1 = t1[0].get$voices(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
              for (t3 = t1[_i].get$noteGroups(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0) {
                ng = t3[_i0];
                if (ng.get$stemDirection() === "up") {
                  t5 = ng.get$stemEndPos();
                  if (typeof highestVPos !== "number")
                    return H.iae(highestVPos);
                  if (t5 < highestVPos)
                    highestVPos = ng.get$stemEndPos();
                } else if (ng.get$isRest()) {
                  t5 = ng.get$restVPos();
                  if (typeof highestVPos !== "number")
                    return H.iae(highestVPos);
                  if (t5 < highestVPos)
                    highestVPos = ng.get$restVPos();
                } else {
                  t5 = ng.get$visibleNotes();
                  noteVPos = (t5 && C.JSArray_methods).get$last(t5).get$vPos();
                  if (J.$lt$n(noteVPos, highestVPos))
                    highestVPos = noteVPos;
                }
              }
          }
          if (endingFinished)
            underEndingBracket = false;
        }
        if (J.$gt$n(highestVPos, 0))
          highestVPos = 0;
        endingVPos = J.$sub$n(highestVPos, this._formatting$_score.get$scoreProperties()._staffLineSpacing * 2);
        for (t1 = endingRDOs.length, _i = 0; _i < endingRDOs.length; endingRDOs.length === t1 || (0, H.throwConcurrentModificationError)(endingRDOs), ++_i)
          endingRDOs[_i].set$endingVPos(endingVPos);
      }
    },
    MusicBeamer: {
      "^": "Object;successCount",
      getMeasureBeamGroupings$1: function(measure) {
        var t1, t2, t3, t4, _i, noteGroups, currentBeamStartTimes, t5, ng1, ng2, _i0, cng, t6, i, numBeatGroups, ng1EndTime, beatGroupIndex, t7, t8, t9, t10, t11;
        for (t1 = measure.get$voices(), t2 = t1.length, t3 = [P.String], t4 = [P.int, P.num], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          noteGroups = t1[_i].get$noteGroups();
          currentBeamStartTimes = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t4);
          for (t5 = noteGroups.length, ng1 = null, ng2 = null, _i0 = 0; _i0 < noteGroups.length; noteGroups.length === t5 || (0, H.throwConcurrentModificationError)(noteGroups), ++_i0) {
            cng = noteGroups[_i0];
            t6 = new Array(cng.get$maxBeams());
            t6.fixed$length = Array;
            cng.set$beamStates(H.setRuntimeTypeInfo(t6, t3));
            for (i = 0; i < cng.get$beamStates().length; ++i) {
              t6 = cng.get$beamStates();
              if (i >= t6.length)
                return H.ioore(t6, i);
              t6[i] = "none";
            }
            if (cng.get$maxBeams() <= 0) {
              ng1 = null;
              ng2 = null;
              continue;
            } else if (cng.get$isRest())
              continue;
            if (ng2 == null) {
              ng1 = ng2;
              ng2 = cng;
              continue;
            }
            if (!(ng2.get$isGrace() && !cng.get$isGrace()))
              t6 = !ng2.get$isGrace() && cng.get$isGrace();
            else
              t6 = true;
            if (t6) {
              ng1 = ng2;
              ng2 = cng;
              continue;
            }
            numBeatGroups = measure.get$beatGroups().length;
            ng1EndTime = J.$sub$n(J.$add$ns(J.$sub$n(ng2.get$qNoteTime(), measure.get$stack()._startTime), ng2.get$qNoteDuration()), 0.001);
            t6 = J.getInterceptor$n(ng1EndTime);
            beatGroupIndex = 0;
            while (true) {
              if (beatGroupIndex < numBeatGroups) {
                t7 = measure.get$beatGroups();
                if (beatGroupIndex >= t7.length)
                  return H.ioore(t7, beatGroupIndex);
                t7 = t6.$gt(ng1EndTime, t7[beatGroupIndex]);
              } else
                t7 = false;
              if (!t7)
                break;
              ++beatGroupIndex;
            }
            if (beatGroupIndex !== numBeatGroups) {
              t6 = J.$sub$n(cng.get$qNoteTime(), measure.get$stack()._startTime);
              t7 = measure.get$beatGroups();
              if (beatGroupIndex >= t7.length)
                return H.ioore(t7, beatGroupIndex);
              t7 = J.$lt$n(t6, t7[beatGroupIndex]);
              t6 = t7;
            } else
              t6 = true;
            if (t6) {
              for (i = 0; i < ng2.get$maxBeams(); ++i) {
                if (ng2.get$beamStates().length > i) {
                  t6 = ng2.get$beamStates();
                  if (i >= t6.length)
                    return H.ioore(t6, i);
                  t6 = J.$eq$(t6[i], "none");
                } else
                  t6 = true;
                if (t6)
                  if (i < cng.get$maxBeams()) {
                    t6 = ng2.get$beamStates();
                    if (i >= t6.length)
                      return H.ioore(t6, i);
                    t6[i] = "begin";
                    currentBeamStartTimes.$indexSet(0, i, ng2.get$qNoteTime());
                  } else {
                    t6 = ng2.get$beamStates();
                    t7 = currentBeamStartTimes.$index(0, currentBeamStartTimes.get$length(currentBeamStartTimes) - 1);
                    t8 = ng2.get$qNoteTime();
                    t9 = ng2.get$qNoteDuration();
                    t10 = ng2.get$beamStates();
                    t11 = i - 1;
                    if (t11 < 0 || t11 >= t10.length)
                      return H.ioore(t10, t11);
                    t11 = this.getBeamletDirection$4(t7, t8, t9, t10[t11]);
                    if (i >= t6.length)
                      return H.ioore(t6, i);
                    t6[i] = t11;
                  }
                else if (i < cng.get$maxBeams()) {
                  t6 = ng2.get$beamStates();
                  if (i >= t6.length)
                    return H.ioore(t6, i);
                  if (J.$eq$(t6[i], "end")) {
                    t6 = ng2.get$beamStates();
                    if (i >= t6.length)
                      return H.ioore(t6, i);
                    t6[i] = "continue";
                  } else {
                    t6 = ng2.get$beamStates();
                    if (i >= t6.length)
                      return H.ioore(t6, i);
                    t6[i] = "begin";
                    currentBeamStartTimes.$indexSet(0, i, ng2.get$qNoteTime());
                  }
                }
              }
              for (i = 0; i < cng.get$maxBeams(); ++i)
                if (i < ng2.get$maxBeams()) {
                  t6 = cng.get$beamStates();
                  if (i >= t6.length)
                    return H.ioore(t6, i);
                  t6[i] = "end";
                  currentBeamStartTimes.$indexSet(0, i, -1);
                } else {
                  t6 = cng.get$beamStates();
                  t7 = currentBeamStartTimes.$index(0, currentBeamStartTimes.get$length(currentBeamStartTimes) - 1);
                  t8 = cng.get$qNoteTime();
                  t9 = cng.get$qNoteDuration();
                  t10 = cng.get$beamStates();
                  t11 = i - 1;
                  if (t11 < 0 || t11 >= t10.length)
                    return H.ioore(t10, t11);
                  t11 = this.getBeamletDirection$4(t7, t8, t9, t10[t11]);
                  if (i >= t6.length)
                    return H.ioore(t6, i);
                  t6[i] = t11;
                }
            }
            ng1 = ng2;
            ng2 = cng;
          }
        }
      },
      getBeamletDirection$4: function(beamStartTime, noteTime, noteDuration, previousBeamLevelState) {
        var t1, isEvenMultiple, t2;
        t1 = J.getInterceptor(previousBeamLevelState);
        if (t1.$eq(previousBeamLevelState, "end"))
          return "backward hook";
        else if (t1.$eq(previousBeamLevelState, "backward hook") || t1.$eq(previousBeamLevelState, "forward hook"))
          return previousBeamLevelState;
        if (noteDuration === 0)
          noteDuration = 0.25;
        t1 = J.getInterceptor$n(beamStartTime);
        while (true) {
          t2 = J.getInterceptor$n(noteTime);
          if (!t2.$ge(noteTime, t1.$sub(beamStartTime, 0.001))) {
            isEvenMultiple = false;
            break;
          }
          if (J.$lt$n(t2.$sub(noteTime, beamStartTime), 0.001)) {
            isEvenMultiple = true;
            break;
          }
          noteTime = t2.$sub(noteTime, noteDuration);
        }
        return isEvenMultiple ? "forward hook" : "backward hook";
      }
    },
    NoteGroupFormatter: {
      "^": "Object;_formatting$_scoreProps",
      getMeasureStemDirections$1: function(measure) {
        var numVoices, t1, t2, numVisibleVoices, _i, t3, t4, _i0, numVisibleVoices0, voiceIndex, noteGroups, beamGroup, currentUpScore, currentDownScore, highestUpScore, highestDownScore, numUpVotes, numDownVotes, ng, t5, visNotes;
        numVoices = measure.get$voices().length;
        for (t1 = measure.get$voices(), t2 = t1.length, numVisibleVoices = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$noteGroups(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0)
            if (J.get$visible$x(t3[_i0]) === true) {
              numVisibleVoices0 = numVisibleVoices + 1;
              numVisibleVoices = numVisibleVoices0;
              break;
            }
        for (t1 = numVisibleVoices > 1, t2 = [O.NoteGroup], voiceIndex = 0; voiceIndex < numVoices; ++voiceIndex) {
          t3 = measure.get$voices();
          if (voiceIndex >= t3.length)
            return H.ioore(t3, voiceIndex);
          noteGroups = t3[voiceIndex].get$noteGroups();
          beamGroup = H.setRuntimeTypeInfo([], t2);
          for (t3 = noteGroups.length, t4 = voiceIndex % 2 === 0, currentUpScore = 0, currentDownScore = 0, highestUpScore = 0, highestDownScore = 0, numUpVotes = 0, numDownVotes = 0, _i = 0; _i < noteGroups.length; noteGroups.length === t3 || (0, H.throwConcurrentModificationError)(noteGroups), ++_i) {
            ng = noteGroups[_i];
            if (ng.get$isRest()) {
              if (t1) {
                t5 = this._formatting$_scoreProps;
                ng.set$restVPos(t4 ? t5._staffLineSpacing * -1 : t5._staffLineSpacing * 5);
              } else
                ng.set$restVPos(this._formatting$_scoreProps._staffLineSpacing * 2);
              continue;
            }
            if (ng.get$stemDirection() === "noStem")
              continue;
            if (t1) {
              ng.set$stemDirection(t4 ? "up" : "down");
              continue;
            }
            visNotes = ng.get$visibleNotes();
            if (0 >= visNotes.length)
              return H.ioore(visNotes, 0);
            currentUpScore = visNotes[0].get$stepsFromTopStaffLine() - 4;
            currentDownScore = 4 - (visNotes && C.JSArray_methods).get$last(visNotes).get$stepsFromTopStaffLine();
            if (currentUpScore > currentDownScore)
              ++numUpVotes;
            else
              ++numDownVotes;
            if (currentUpScore > highestUpScore)
              highestUpScore = currentUpScore;
            if (currentDownScore > highestDownScore)
              highestDownScore = currentDownScore;
            if (ng.get$beamStates().length !== 0) {
              t5 = ng.get$beamStates();
              if (0 >= t5.length)
                return H.ioore(t5, 0);
              t5 = J.$eq$(t5[0], "none");
            } else
              t5 = true;
            if (t5) {
              ng.set$stemDirection(highestUpScore > highestDownScore ? "up" : "down");
              highestUpScore = 0;
              highestDownScore = 0;
              numUpVotes = 0;
              numDownVotes = 0;
            } else {
              t5 = ng.get$beamStates();
              if (0 >= t5.length)
                return H.ioore(t5, 0);
              if (J.$eq$(t5[0], "end")) {
                beamGroup.push(ng);
                if (!(highestUpScore > highestDownScore))
                  t5 = highestUpScore === highestDownScore && numUpVotes > numDownVotes;
                else
                  t5 = true;
                if (t5)
                  this.setStemDirectionsForBeamedNotes$2(beamGroup, "up");
                else
                  this.setStemDirectionsForBeamedNotes$2(beamGroup, "down");
                beamGroup = H.setRuntimeTypeInfo([], t2);
                highestUpScore = 0;
                highestDownScore = 0;
                numUpVotes = 0;
                numDownVotes = 0;
              } else
                beamGroup.push(ng);
            }
          }
        }
      },
      setStemDirectionsForBeamedNotes$2: function(beamedNotes, direction) {
        var t1, _i;
        for (t1 = beamedNotes.length, _i = 0; _i < beamedNotes.length; beamedNotes.length === t1 || (0, H.throwConcurrentModificationError)(beamedNotes), ++_i)
          beamedNotes[_i].set$stemDirection(direction);
      },
      getMeasureNoteheadOffsets$1: function(measure) {
        var t1, t2, _i, groups, t3, _i0;
        for (t1 = measure.get$voices(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          groups = t1[_i].get$noteGroups();
          for (t3 = groups.length, _i0 = 0; _i0 < groups.length; groups.length === t3 || (0, H.throwConcurrentModificationError)(groups), ++_i0)
            this.getNoteheadOffsets$1(groups[_i0]);
        }
      },
      getNoteheadOffsets$1: function(noteGroup) {
        var notes, numNotes, t1, t2, rightNotePos, stemStartPos, placeOnLeft, lastPosition, i, cNote, stemHPos, clusterFound, offset, levelClaimsList, upperBound, t3, noteIndex, lowerBound, upperBound0, cLevel, repeat, j, cLevel0;
        if (noteGroup.get$isRest())
          return;
        notes = noteGroup.get$visibleNotes();
        numNotes = notes.length;
        t1 = noteGroup.get$isGrace();
        t2 = this._formatting$_scoreProps;
        rightNotePos = !t1 ? t2._noteheadWidth : 0.65 * t2._noteheadWidth;
        if (noteGroup.get$stemDirection() === "up") {
          if (0 >= notes.length)
            return H.ioore(notes, 0);
          stemStartPos = notes[0].get$vPos();
          for (placeOnLeft = true, lastPosition = 1000, i = 0; i < numNotes; ++i) {
            if (i >= notes.length)
              return H.ioore(notes, i);
            cNote = notes[i];
            if (lastPosition - cNote.get$stepsFromTopStaffLine() <= 1) {
              placeOnLeft = !placeOnLeft;
              cNote.set$hPos(placeOnLeft ? 0 : rightNotePos);
            } else {
              cNote.set$hPos(0);
              placeOnLeft = true;
            }
            lastPosition = cNote.get$stepsFromTopStaffLine();
          }
          stemHPos = rightNotePos;
        } else if (noteGroup.get$stemDirection() === "down") {
          t1 = numNotes - 1;
          if (t1 < 0 || t1 >= notes.length)
            return H.ioore(notes, t1);
          stemStartPos = notes[t1].get$vPos();
          for (t2 = -1 * rightNotePos, i = t1, placeOnLeft = false, lastPosition = -1000, stemHPos = 0, clusterFound = false; i >= 0;) {
            if (i >= notes.length)
              return H.ioore(notes, i);
            cNote = notes[i];
            if (cNote.get$stepsFromTopStaffLine() - lastPosition <= 1) {
              placeOnLeft = !placeOnLeft;
              cNote.set$hPos(placeOnLeft ? t2 : 0);
              stemHPos = rightNotePos;
              clusterFound = true;
            } else {
              cNote.set$hPos(0);
              placeOnLeft = false;
            }
            lastPosition = cNote.get$stepsFromTopStaffLine();
            --i;
          }
          if (clusterFound)
            for (i = 0; i < numNotes; ++i) {
              if (i >= notes.length)
                return H.ioore(notes, i);
              t1 = notes[i];
              t1.set$hPos(J.$add$ns(t1.get$hPos(), rightNotePos));
            }
        } else {
          for (placeOnLeft = true, lastPosition = 1000, i = 0; i < numNotes; ++i) {
            if (i >= notes.length)
              return H.ioore(notes, i);
            cNote = notes[i];
            if (lastPosition - cNote.get$stepsFromTopStaffLine() <= 1) {
              placeOnLeft = !placeOnLeft;
              cNote.set$hPos(placeOnLeft ? 0 : rightNotePos);
            } else {
              cNote.set$hPos(0);
              placeOnLeft = true;
            }
            lastPosition = cNote.get$stepsFromTopStaffLine();
          }
          stemHPos = rightNotePos;
          stemStartPos = 0;
        }
        noteGroup.set$stemHPos(stemHPos);
        noteGroup.set$stemStartPos(stemStartPos);
        noteGroup.set$numAccidentalLevels(0);
        if (numNotes === 1) {
          if (0 >= notes.length)
            return H.ioore(notes, 0);
          if (notes[0].get$showAccidental()) {
            if (0 >= notes.length)
              return H.ioore(notes, 0);
            notes[0].set$accidentalPos(-1.1 * rightNotePos);
            noteGroup.set$numAccidentalLevels(1);
          }
        } else {
          t1 = numNotes - 1;
          if (t1 < 0 || t1 >= notes.length)
            return H.ioore(notes, t1);
          offset = -1 * notes[t1].get$stepsFromTopStaffLine();
          if (0 >= notes.length)
            return H.ioore(notes, 0);
          t1 = notes[0].get$stepsFromTopStaffLine();
          t2 = P.int;
          levelClaimsList = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t2, t2]);
          for (t2 = -1.1 * rightNotePos, upperBound = t1 + offset + 1 - 1, i = 0; i < numNotes; ++i) {
            t1 = notes.length;
            if (i % 2 === 0) {
              t3 = numNotes - C.JSInt_methods._tdivFast$1(i, 2) - 1;
              if (t3 < 0 || t3 >= t1)
                return H.ioore(notes, t3);
              cNote = notes[t3];
            } else {
              t3 = C.JSInt_methods._tdivFast$1(i, 2);
              if (t3 >= t1)
                return H.ioore(notes, t3);
              cNote = notes[t3];
            }
            if (!cNote.get$showAccidental())
              continue;
            noteIndex = cNote.get$stepsFromTopStaffLine() + offset;
            lowerBound = noteIndex - 5;
            lowerBound = lowerBound >= 0 ? lowerBound : 0;
            upperBound0 = noteIndex + 5;
            upperBound0 = upperBound0 <= upperBound ? upperBound0 : upperBound;
            for (cLevel = 1, repeat = true; repeat;) {
              j = lowerBound;
              while (true) {
                if (!(j <= upperBound0)) {
                  repeat = false;
                  break;
                }
                if (J.$eq$(levelClaimsList.$index(0, j), cLevel)) {
                  cLevel0 = cLevel + 1;
                  cLevel = cLevel0;
                  repeat = true;
                  break;
                }
                ++j;
              }
            }
            levelClaimsList.$indexSet(0, noteIndex, cLevel);
            cNote.set$accidentalPos(t2 - (cLevel - 1) * rightNotePos);
            if (cLevel > noteGroup.get$numAccidentalLevels())
              noteGroup.set$numAccidentalLevels(cLevel);
          }
        }
      },
      getSystemStemEndPositions$1: function(system) {
        var stacks, t1, _i, measures, t2, _i0;
        stacks = system.get$measureStacks();
        for (t1 = stacks.length, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
          measures = stacks[_i].get$measures();
          for (t2 = measures.length, _i0 = 0; _i0 < measures.length; measures.length === t2 || (0, H.throwConcurrentModificationError)(measures), ++_i0)
            this.getMeasureStemEndPositions$1(measures[_i0]);
        }
      },
      getMeasureStemEndPositions$1: function(measure) {
        var t1, t2, _i, noteGroups, beamedNotes, t3, firstNote, lastNote, firstNoteRP, lastNoteRP, interiorHighestRP, interiorLowestRP, beamedNoteCount, _i0, ng, requestedStemPos, t4, totalHDistance, totalRise, i, cIntNote;
        for (t1 = measure.get$voices(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          noteGroups = t1[_i].get$noteGroups();
          beamedNotes = [];
          for (t3 = noteGroups.length, firstNote = null, lastNote = null, firstNoteRP = 0, lastNoteRP = 0, interiorHighestRP = 0, interiorLowestRP = 0, beamedNoteCount = 0, _i0 = 0; _i0 < noteGroups.length; noteGroups.length === t3 || (0, H.throwConcurrentModificationError)(noteGroups), ++_i0) {
            ng = noteGroups[_i0];
            if (ng.get$isRest() || ng.get$stemDirection() === "noStem")
              continue;
            requestedStemPos = this.getRequestedStemEndPosition$1(ng);
            if (ng.get$beamStates().length !== 0) {
              t4 = ng.get$beamStates();
              if (0 >= t4.length)
                return H.ioore(t4, 0);
              t4 = J.$eq$(t4[0], "none");
            } else
              t4 = true;
            if (t4)
              ng.set$stemEndPos(this._formatting$_scoreProps._staffLineSpacing / 2 * requestedStemPos);
            else {
              t4 = ng.get$beamStates();
              if (0 >= t4.length)
                return H.ioore(t4, 0);
              if (J.$eq$(t4[0], "begin")) {
                beamedNotes = [ng];
                firstNoteRP = requestedStemPos;
                firstNote = ng;
                interiorHighestRP = 1000;
                interiorLowestRP = -1000;
                beamedNoteCount = 1;
              } else {
                t4 = ng.get$beamStates();
                if (0 >= t4.length)
                  return H.ioore(t4, 0);
                if (J.$eq$(t4[0], "continue")) {
                  if (requestedStemPos < interiorHighestRP)
                    interiorHighestRP = requestedStemPos;
                  if (requestedStemPos > interiorLowestRP)
                    interiorLowestRP = requestedStemPos;
                  beamedNotes.push(ng);
                  ++beamedNoteCount;
                } else {
                  t4 = ng.get$beamStates();
                  if (0 >= t4.length)
                    return H.ioore(t4, 0);
                  if (J.$eq$(t4[0], "end")) {
                    beamedNotes.push(ng);
                    ++beamedNoteCount;
                    if (firstNote.get$stemDirection() === "up")
                      if (firstNoteRP < interiorHighestRP || requestedStemPos < interiorHighestRP)
                        if (firstNoteRP <= requestedStemPos)
                          lastNoteRP = firstNoteRP + (requestedStemPos - firstNoteRP) / 4;
                        else {
                          firstNoteRP = requestedStemPos + (firstNoteRP - requestedStemPos) / 4;
                          lastNoteRP = requestedStemPos;
                        }
                      else {
                        lastNoteRP = interiorHighestRP;
                        firstNoteRP = lastNoteRP;
                      }
                    else if (firstNoteRP > interiorLowestRP || requestedStemPos > interiorLowestRP)
                      if (firstNoteRP >= requestedStemPos)
                        lastNoteRP = firstNoteRP - (firstNoteRP - requestedStemPos) / 4;
                      else {
                        firstNoteRP = requestedStemPos - (requestedStemPos - firstNoteRP) / 4;
                        lastNoteRP = requestedStemPos;
                      }
                    else {
                      lastNoteRP = interiorLowestRP;
                      firstNoteRP = lastNoteRP;
                    }
                    firstNote.set$stemEndPos(this._formatting$_scoreProps._staffLineSpacing / 2 * firstNoteRP);
                    ng.set$stemEndPos(this._formatting$_scoreProps._staffLineSpacing / 2 * lastNoteRP);
                    totalHDistance = J.$sub$n(ng.get$hPos(), firstNote.get$hPos());
                    totalRise = ng.get$stemEndPos() - firstNote.get$stemEndPos();
                    for (t4 = beamedNoteCount - 1, i = 1; i < t4;) {
                      if (i >= beamedNotes.length)
                        return H.ioore(beamedNotes, i);
                      cIntNote = beamedNotes[i];
                      cIntNote.set$stemEndPos(firstNote.get$stemEndPos() + totalRise * J.$div$n(J.$sub$n(cIntNote.get$hPos(), firstNote.get$hPos()), totalHDistance));
                      ++i;
                    }
                    lastNote = ng;
                  }
                }
              }
            }
          }
        }
      },
      getRequestedStemEndPosition$1: function(noteGroup) {
        var notes, decidingNote, bonusDurationLength, penaltyLength, request;
        notes = noteGroup.get$visibleNotes();
        if (noteGroup.get$stemDirection() === "up") {
          decidingNote = (notes && C.JSArray_methods).get$last(notes);
          bonusDurationLength = noteGroup.get$maxBeams() < 2 ? 0 : noteGroup.get$maxBeams() - 2;
          if (!noteGroup.get$isGrace())
            penaltyLength = (noteGroup.get$maxBeams() === 0 || noteGroup.get$beamStates().length > 0) && decidingNote.get$stepsFromTopStaffLine() < 4 ? 1 : 0;
          else
            penaltyLength = 3;
          request = decidingNote.get$stepsFromTopStaffLine() - 7 - bonusDurationLength + penaltyLength;
          return request <= 4 ? request : 4;
        } else {
          if (0 >= notes.length)
            return H.ioore(notes, 0);
          decidingNote = notes[0];
          bonusDurationLength = noteGroup.get$maxBeams() < 2 ? 0 : noteGroup.get$maxBeams() - 2;
          if (!noteGroup.get$isGrace())
            penaltyLength = (noteGroup.get$maxBeams() === 0 || noteGroup.get$beamStates().length > 0) && decidingNote.get$stepsFromTopStaffLine() > 4 ? 1 : 0;
          else
            penaltyLength = 3;
          request = decidingNote.get$stepsFromTopStaffLine() + 7 + bonusDurationLength - penaltyLength;
          return request >= 4 ? request : 4;
        }
      }
    },
    MusicSpacer: {
      "^": "Object;_formatting$_score,_qNoteWidth,_formatting$_keySigWidth,_timeSigWidth,_formatting$_clefWidth,_formatting$_clefDistanceFromBarline,_formatting$_measureLeadIn,_minMeasureWidth,_formatting$_noteheadWidth,_standardSystemWidth",
      initializeScoreSettings$0: function() {
        var sProps = this._formatting$_score.get$scoreProperties();
        this._qNoteWidth = sProps._data$_qNoteWidth;
        this._formatting$_keySigWidth = sProps._keySigWidth;
        this._timeSigWidth = sProps._data$_timeSigWidth;
        this._formatting$_clefWidth = sProps._clefWidth;
        this._formatting$_clefDistanceFromBarline = sProps._clefDistanceFromBarline;
        this._formatting$_measureLeadIn = sProps._measureLeadIn;
        this._minMeasureWidth = sProps._data$_minMeasureWidth;
        this._formatting$_noteheadWidth = sProps._noteheadWidth;
        this._standardSystemWidth = J.$sub$n(J.$sub$n(J.$sub$n(J.$sub$n(sProps._pageWidth, sProps._leftPageMargin), sProps._rightPageMargin), sProps._leftSystemMargin), sProps._rightSystemMargin);
      },
      computeIdealSpacingValues$1: function(measureStack) {
        var stacks, t1, _i;
        if (measureStack != null)
          this.computeIdealSpacingForStack$1(measureStack);
        else {
          stacks = this._formatting$_score.getMeasureStacks$0();
          for (t1 = stacks.length, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i)
            this.computeIdealSpacingForStack$1(stacks[_i]);
        }
      },
      groupMeasuresIntoSystems$1: function(measuresPerSystem) {
        var systems, originalStackGroupings, firstSystem, firstSystemsStacks, cSystem, i, stacks, t1, _i, stack, t2, totalWidth, j, t3, cStack, t4, measure, t5, t6, cPage, changeMade, prevSystem, qStack, leadStack, numNewSystems, numOriginalSystems, newSystemStacks, oldSystemStacks;
        systems = this._formatting$_score.getSystems$0();
        if (systems.length < 1)
          return;
        originalStackGroupings = H.setRuntimeTypeInfo([], [[P.List, O.MeasureStack]]);
        if (0 >= systems.length)
          return H.ioore(systems, 0);
        firstSystem = systems[0];
        firstSystemsStacks = firstSystem.get$measureStacks();
        originalStackGroupings.push(C.JSArray_methods.sublist$1(firstSystemsStacks, 0));
        for (cSystem = null, i = 1; i < systems.length; ++i) {
          cSystem = systems[i];
          stacks = cSystem.get$measureStacks();
          originalStackGroupings.push(C.JSArray_methods.sublist$1(stacks, 0));
          for (t1 = stacks.length, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
            stack = stacks[_i];
            stack.set$systemRef(firstSystem);
            firstSystemsStacks.push(stack);
          }
          cSystem.clearAllStacks$0();
        }
        for (t1 = measuresPerSystem > 0, i = 0; i < systems.length;) {
          cSystem = systems[i];
          for (t2 = J.getInterceptor$x(cSystem), totalWidth = 0, j = 0; j < cSystem.get$measureStacks().length; ++j) {
            t3 = cSystem.get$measureStacks();
            if (j >= t3.length)
              return H.ioore(t3, j);
            cStack = t3[j];
            if (j === 0) {
              cStack.set$newSystem(true);
              for (t3 = cStack.get$measures(), t4 = t3.length, _i = 0; _i < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i) {
                measure = t3[_i];
                measure.set$showKey(true);
                t5 = measure.get$clefs();
                if (0 >= t5.length)
                  return H.ioore(t5, 0);
                t5[0]._show = true;
                t5 = measure.get$clefs();
                if (0 >= t5.length)
                  return H.ioore(t5, 0);
                t5[0]._smallSize = false;
              }
              if (!cStack.get$newKey()) {
                t3 = J.$mul$ns(cStack.get$maxKeySize(), this._formatting$_keySigWidth);
                if (typeof t3 !== "number")
                  return H.iae(t3);
                totalWidth += t3;
              }
              if (!cStack.get$newClef()) {
                t3 = this._formatting$_clefWidth;
                if (typeof t3 !== "number")
                  return H.iae(t3);
                totalWidth += t3;
              }
            } else {
              cStack.set$newSystem(false);
              for (t3 = cStack.get$measures(), t4 = t3.length, _i = 0; _i < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i) {
                measure = t3[_i];
                t5 = measure.get$clefs();
                if (0 >= t5.length)
                  return H.ioore(t5, 0);
                t5 = t5[0];
                t6 = measure.get$clefs();
                if (0 >= t6.length)
                  return H.ioore(t6, 0);
                t5._show = t6[0]._isNew;
                t6 = measure.get$clefs();
                if (0 >= t6.length)
                  return H.ioore(t6, 0);
                t6[0]._smallSize = true;
                measure.set$showKey(cStack.get$newKey());
              }
            }
            t3 = cStack.get$idealWidth();
            if (typeof t3 !== "number")
              return H.iae(t3);
            totalWidth += t3;
            if (t1) {
              if (j >= measuresPerSystem) {
                if (t2.get$next(cSystem) == null)
                  systems.push(this.addSystem$1(cSystem));
                t2.get$next(cSystem).insertMeasureStacks$1(cSystem.removeStacksFromEnd$1(cSystem.get$measureStacks().length - j));
                break;
              }
            } else {
              if (j > 0) {
                t3 = J.$mul$ns(J.$sub$n(this._standardSystemWidth, cSystem.get$indent()), 0.95);
                if (typeof t3 !== "number")
                  return H.iae(t3);
                t3 = totalWidth > t3;
              } else
                t3 = false;
              if (t3) {
                if (t2.get$next(cSystem) == null)
                  systems.push(this.addSystem$1(cSystem));
                t2.get$next(cSystem).insertMeasureStacks$1(cSystem.removeStacksFromEnd$1(cSystem.get$measureStacks().length - j));
                break;
              }
            }
            if (j === cSystem.get$measureStacks().length - 1)
              if (t2.get$next(cSystem) != null)
                cSystem.addMeasureStacks$1(t2.get$next(cSystem).removeStacksFromBeginning$1(1));
          }
          ++i;
        }
        for (; cSystem.get$measureStacks().length === 0;) {
          cPage = cSystem.get$pageRef();
          cPage.removeSystem$1(cSystem);
          if (0 >= systems.length)
            return H.ioore(systems, -1);
          systems.pop();
          if (cPage.get$systems().length === 0)
            this._formatting$_score.removePage$1(cPage);
          cSystem = cSystem.get$previous();
        }
        changeMade = measuresPerSystem === 0;
        for (; changeMade;) {
          t1 = systems.length;
          t2 = t1 - 1;
          if (t2 < 0)
            return H.ioore(systems, t2);
          cSystem = systems[t2];
          for (changeMade = false; cSystem.get$previous() != null;) {
            prevSystem = cSystem.get$previous();
            t1 = prevSystem.get$measureStacks();
            t2 = prevSystem.get$measureStacks().length - 1;
            if (t2 < 0 || t2 >= t1.length)
              return H.ioore(t1, t2);
            qStack = t1[t2];
            while (true) {
              t1 = prevSystem.get$requestedStackWidth();
              t2 = qStack.get$idealWidth();
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(t1 - t2 > 0.95 * cSystem.get$requestedStackWidth()))
                break;
              t1 = cSystem.get$measureStacks();
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              leadStack = t1[0];
              leadStack.set$newSystem(false);
              for (t1 = leadStack.get$measures(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                measure = t1[_i];
                t3 = measure.get$clefs();
                if (0 >= t3.length)
                  return H.ioore(t3, 0);
                t3 = t3[0];
                t4 = measure.get$clefs();
                if (0 >= t4.length)
                  return H.ioore(t4, 0);
                t3._show = t4[0]._isNew;
                t4 = measure.get$clefs();
                if (0 >= t4.length)
                  return H.ioore(t4, 0);
                t4[0]._smallSize = true;
                measure.set$showKey(leadStack.get$newKey());
              }
              t1 = prevSystem.removeStacksFromEnd$1(1);
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              cSystem.insertStack$1(t1[0]);
              t1 = cSystem.get$measureStacks();
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              leadStack = t1[0];
              leadStack.set$newSystem(true);
              for (t1 = leadStack.get$measures(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                measure = t1[_i];
                t3 = measure.get$clefs();
                if (0 >= t3.length)
                  return H.ioore(t3, 0);
                t3[0]._show = true;
                t3 = measure.get$clefs();
                if (0 >= t3.length)
                  return H.ioore(t3, 0);
                t3[0]._smallSize = false;
                measure.set$showKey(true);
              }
              changeMade = true;
            }
            cSystem = cSystem.get$previous();
          }
        }
        numNewSystems = systems.length;
        numOriginalSystems = originalStackGroupings.length;
        for (i = 0; i < numNewSystems; ++i) {
          if (i >= systems.length)
            return H.ioore(systems, i);
          cSystem = systems[i];
          if (i >= numOriginalSystems) {
            cSystem.set$needsRendering(true);
            continue;
          }
          newSystemStacks = cSystem.get$measureStacks();
          if (i >= originalStackGroupings.length)
            return H.ioore(originalStackGroupings, i);
          oldSystemStacks = originalStackGroupings[i];
          t1 = oldSystemStacks.length;
          if (t1 === newSystemStacks.length)
            for (j = 0; j < t1; ++j) {
              if (j >= oldSystemStacks.length)
                return H.ioore(oldSystemStacks, j);
              t2 = oldSystemStacks[j];
              if (j >= newSystemStacks.length)
                return H.ioore(newSystemStacks, j);
              if (!J.$eq$(t2, newSystemStacks[j])) {
                cSystem.set$needsRendering(true);
                break;
              }
            }
          else
            cSystem.set$needsRendering(true);
        }
      },
      addSystem$1: function(currentSystem) {
        var newSystem = new O.System(null, 0, null, null, null, [], null, [], null, null, null, false, true, null, 0);
        newSystem._data$_scoreProps = this._formatting$_score.get$scoreProperties();
        newSystem.getSettingsFromScoreProperties$0();
        newSystem._data$_previous = currentSystem;
        J.set$next$x(currentSystem, newSystem);
        currentSystem.get$pageRef().addSystem$1(newSystem);
        return newSystem;
      },
      computeActualSpacingValues$1: function(system) {
        var stacks, numStacks, sysWidth, firstStack, totalIndentSpace, totalNoteIdealSpace, i, stack, t1, scale, hPos, stackIdealWidth, stackIndent, newWidth, t2, t3, t4, _i, ng, t5;
        stacks = system.get$measureStacks();
        numStacks = stacks.length;
        if (numStacks === 0)
          return;
        sysWidth = J.$sub$n(this._standardSystemWidth, system.get$indent());
        if (0 >= stacks.length)
          return H.ioore(stacks, 0);
        firstStack = stacks[0];
        totalIndentSpace = firstStack.get$indentAsSystemLeader();
        totalNoteIdealSpace = J.$sub$n(firstStack.get$idealWidth(), firstStack.get$indent());
        for (i = 1; i < numStacks; ++i) {
          if (i >= stacks.length)
            return H.ioore(stacks, i);
          stack = stacks[i];
          t1 = stack.get$indent();
          if (typeof t1 !== "number")
            return H.iae(t1);
          totalIndentSpace += t1;
          totalNoteIdealSpace = J.$add$ns(totalNoteIdealSpace, J.$sub$n(stack.get$idealWidth(), stack.get$indent()));
        }
        scale = J.$div$n(J.$sub$n(sysWidth, totalIndentSpace), totalNoteIdealSpace);
        for (hPos = 0, i = 0; i < numStacks; ++i) {
          if (i >= stacks.length)
            return H.ioore(stacks, i);
          stack = stacks[i];
          stack.set$startPosition(hPos);
          if (i === 0) {
            stackIdealWidth = J.$add$ns(J.$sub$n(stack.get$idealWidth(), stack.get$indent()), stack.get$indentAsSystemLeader());
            stackIndent = stack.get$indentAsSystemLeader();
          } else {
            stackIdealWidth = stack.get$idealWidth();
            stackIndent = stack.get$indent();
          }
          newWidth = J.$add$ns(J.$mul$ns(J.$sub$n(stackIdealWidth, stackIndent), scale), stackIndent);
          t1 = J.getInterceptor$x(stack);
          t1.set$width(stack, newWidth);
          for (t2 = stack.get$noteGroups(), t3 = t2.length, t4 = J.getInterceptor$ns(newWidth), _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
            ng = t2[_i];
            t5 = J.getInterceptor$x(ng);
            if (t5.get$visible(ng) === false) {
              ng.set$hPos(stackIndent);
              continue;
            }
            if (ng.get$isRest() && t5.get$voice(ng).get$noteGroups().length === 1)
              ng.set$hPos(J.$div$n(J.$sub$n(t4.$add(newWidth, stackIndent), this._formatting$_measureLeadIn), 2));
            else {
              t5 = ng.get$idealHPos();
              if (typeof stackIndent !== "number")
                return H.iae(stackIndent);
              ng.set$hPos((t5 + stackIndent - stackIndent) * scale + stackIndent);
            }
          }
          t1 = t1.get$width(stack);
          if (typeof t1 !== "number")
            return H.iae(t1);
          hPos += t1;
        }
      },
      computeIdealSpacingForStack$1: function(stack) {
        var t1, cTime, clefDFB, t2, showTime, repeatSpaceAtEnd, _i, t3, t4, NORMAL_MIN_WHITE_SPACE, LYRIC_LETTER_SPACE, notesAtCurrentPos, noteGroups, numNoteGroups, cTime0, cPosition, newTimePositionDelta, largestLeftExtension, largestRightExtension, prevRightExtension, minWhiteSpace, i, ng, ngLeftExtension, halfLyricWidth, ngRightExtension, ngLeftExtension0, endSpace;
        if (stack.get$noteGroups().length > 0) {
          t1 = stack.get$noteGroups();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          cTime = t1[0].get$qNoteTime();
        } else
          cTime = J.get$startTime$x(stack);
        clefDFB = this._formatting$_score.get$scoreProperties()._clefDistanceFromBarline;
        stack.set$indent(this._formatting$_measureLeadIn);
        if (stack.get$newClef()) {
          t1 = stack.get$indent();
          t2 = this._formatting$_clefWidth;
          if (typeof t2 !== "number")
            return t2.$add();
          stack.set$indent(J.$add$ns(t1, t2 + clefDFB));
        }
        if (stack.get$newKey())
          stack.set$indent(J.$add$ns(stack.get$indent(), J.$add$ns(J.$mul$ns(stack.get$maxKeySize(), this._formatting$_keySigWidth), clefDFB)));
        t1 = stack.get$measures();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        showTime = t1[0].get$showTime();
        if (showTime) {
          t1 = stack.get$indent();
          t2 = this._timeSigWidth;
          if (typeof t2 !== "number")
            return t2.$add();
          stack.set$indent(J.$add$ns(t1, t2 + clefDFB));
        }
        t1 = this._formatting$_measureLeadIn;
        t2 = this._formatting$_clefWidth;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        stack.set$indentAsSystemLeader(t1 + t2 + clefDFB);
        if (J.$gt$n(stack.get$maxKeySize(), 0)) {
          t1 = stack.get$indentAsSystemLeader();
          t2 = J.$add$ns(J.$mul$ns(stack.get$maxKeySize(), this._formatting$_keySigWidth), clefDFB);
          if (typeof t2 !== "number")
            return H.iae(t2);
          stack.set$indentAsSystemLeader(t1 + t2);
        }
        if (showTime) {
          t1 = stack.get$indentAsSystemLeader();
          t2 = this._timeSigWidth;
          if (typeof t2 !== "number")
            return t2.$add();
          stack.set$indentAsSystemLeader(t1 + (t2 + clefDFB));
        }
        if (stack.get$repeatDOs() != null)
          for (t1 = stack.get$repeatDOs(), t2 = t1.length, repeatSpaceAtEnd = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            t3 = t1[_i].repeatDirection;
            if (t3 === 0) {
              stack.set$indent(J.$add$ns(stack.get$indent(), this._formatting$_measureLeadIn));
              t3 = stack.get$indentAsSystemLeader();
              t4 = this._formatting$_measureLeadIn;
              if (typeof t4 !== "number")
                return H.iae(t4);
              stack.set$indentAsSystemLeader(t3 + t4);
            } else if (t3 === 1)
              repeatSpaceAtEnd = this._formatting$_measureLeadIn;
          }
        else
          repeatSpaceAtEnd = 0;
        t1 = this._formatting$_noteheadWidth;
        if (typeof t1 !== "number")
          return t1.$mul();
        NORMAL_MIN_WHITE_SPACE = t1 * 1.3;
        LYRIC_LETTER_SPACE = 0.9 * t1;
        notesAtCurrentPos = H.setRuntimeTypeInfo([], [O.NoteGroup]);
        noteGroups = stack.get$noteGroups();
        numNoteGroups = noteGroups.length;
        for (t1 = J.getInterceptor$x(stack), cTime0 = cTime, cPosition = 0, newTimePositionDelta = 0, largestLeftExtension = 0, largestRightExtension = 0, prevRightExtension = 0, minWhiteSpace = null, i = 0; i < numNoteGroups; ++i) {
          if (i >= noteGroups.length)
            return H.ioore(noteGroups, i);
          ng = noteGroups[i];
          t2 = J.getInterceptor$x(ng);
          if (t2.get$visible(ng) === false)
            continue;
          t3 = ng.get$numAccidentalLevels();
          t4 = this._formatting$_noteheadWidth;
          if (typeof t4 !== "number")
            return H.iae(t4);
          ngLeftExtension = t3 * t4;
          if (ngLeftExtension > 0 && J.$eq$(ng.get$qNoteTime(), t1.get$startTime(stack))) {
            t3 = this._formatting$_measureLeadIn;
            if (typeof t3 !== "number")
              return t3.$div();
            ngLeftExtension -= t3 / 2;
          }
          if (ng.get$clef() != null) {
            t3 = this._formatting$_clefWidth;
            t4 = this._formatting$_clefDistanceFromBarline;
            if (typeof t3 !== "number")
              return t3.$add();
            if (typeof t4 !== "number")
              return H.iae(t4);
            ngLeftExtension += t3 + t4;
          }
          if (ng.get$lyric() != null) {
            t3 = ng.get$lyric()._text.length;
            t4 = this._formatting$_noteheadWidth;
            if (typeof t4 !== "number")
              return t4.$div();
            halfLyricWidth = t3 * LYRIC_LETTER_SPACE / 2 - t4 / 2;
            ngRightExtension = 0 + halfLyricWidth;
            if (!J.$eq$(ng.get$qNoteTime(), t1.get$startTime(stack))) {
              if (halfLyricWidth > ngLeftExtension)
                ngLeftExtension = halfLyricWidth;
            } else {
              t3 = this._formatting$_measureLeadIn;
              if (typeof t3 !== "number")
                return H.iae(t3);
              ngLeftExtension0 = halfLyricWidth - t3;
              if (ngLeftExtension0 > ngLeftExtension)
                ngLeftExtension = ngLeftExtension0;
            }
          } else
            ngRightExtension = 0;
          if (!ng.get$isRest()) {
            if (ng.get$beamStates().length !== 0) {
              t3 = ng.get$beamStates();
              if (0 >= t3.length)
                return H.ioore(t3, 0);
              t3 = J.$eq$(t3[0], "none");
            } else
              t3 = true;
            if (t3)
              if (J.$lt$n(t2.get$duration(ng), 1024)) {
                t2 = this._formatting$_noteheadWidth;
                if (typeof t2 !== "number")
                  return H.iae(t2);
                t2 = ngRightExtension < 0.5 * t2 && ng.get$stemDirection() === "up";
              } else
                t2 = false;
            else
              t2 = false;
          } else
            t2 = false;
          if (t2) {
            t2 = this._formatting$_noteheadWidth;
            if (typeof t2 !== "number")
              return H.iae(t2);
            ngRightExtension = 0.5 * t2;
          }
          if (J.$gt$n(ng.get$qNoteTime(), cTime0)) {
            if (notesAtCurrentPos.length > 0) {
              minWhiteSpace = J.$gt$n(cTime0, cTime) ? NORMAL_MIN_WHITE_SPACE : 0;
              t2 = newTimePositionDelta - largestLeftExtension - prevRightExtension;
              if (t2 < minWhiteSpace) {
                cPosition += minWhiteSpace - t2;
                for (t2 = notesAtCurrentPos.length, _i = 0; _i < notesAtCurrentPos.length; notesAtCurrentPos.length === t2 || (0, H.throwConcurrentModificationError)(notesAtCurrentPos), ++_i)
                  notesAtCurrentPos[_i].set$idealHPos(cPosition);
              }
              prevRightExtension = largestRightExtension;
            }
            notesAtCurrentPos = [ng];
            t2 = this._qNoteWidth;
            t3 = Math.pow(1.4179, Math.log(H.checkNum(J.$sub$n(ng.get$qNoteTime(), cTime0))) / Math.log(2));
            if (typeof t2 !== "number")
              return t2.$mul();
            newTimePositionDelta = t2 * t3;
            cPosition += newTimePositionDelta;
            cTime0 = ng.get$qNoteTime();
            largestRightExtension = ngRightExtension;
            largestLeftExtension = ngLeftExtension;
          } else {
            notesAtCurrentPos.push(ng);
            if (ngLeftExtension > largestLeftExtension)
              largestLeftExtension = ngLeftExtension;
            if (ngRightExtension > largestRightExtension)
              largestRightExtension = ngRightExtension;
          }
          ng.set$idealHPos(cPosition);
        }
        if (notesAtCurrentPos.length > 0) {
          minWhiteSpace = J.$gt$n(cTime0, cTime) ? NORMAL_MIN_WHITE_SPACE : 0;
          t2 = newTimePositionDelta - largestLeftExtension - prevRightExtension;
          if (t2 < minWhiteSpace) {
            cPosition += minWhiteSpace - t2;
            for (t2 = notesAtCurrentPos.length, _i = 0; _i < notesAtCurrentPos.length; notesAtCurrentPos.length === t2 || (0, H.throwConcurrentModificationError)(notesAtCurrentPos), ++_i)
              notesAtCurrentPos[_i].set$idealHPos(cPosition);
          }
        }
        if (J.$gt$n(t1.get$endTime(stack), cTime0)) {
          t2 = this._qNoteWidth;
          t1 = Math.pow(1.4179, Math.log(H.checkNum(J.$sub$n(t1.get$endTime(stack), cTime0))) / Math.log(2));
          if (typeof t2 !== "number")
            return t2.$mul();
          if (typeof repeatSpaceAtEnd !== "number")
            return repeatSpaceAtEnd.$add();
          endSpace = repeatSpaceAtEnd + t2 * t1;
          if (endSpace < largestRightExtension)
            endSpace = largestRightExtension;
          stack.set$idealWidth(J.$add$ns(J.$add$ns(stack.get$indent(), cPosition), endSpace));
        } else {
          t1 = stack.get$indent();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t2 = this._minMeasureWidth;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (cPosition + t1 > t2) {
            t1 = stack.get$indent();
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = cPosition + t1;
          } else
            t1 = t2;
          stack.set$idealWidth(t1);
          H.printString("probably shouldn't get here... MusicSpacer.computeIdealSpacingForStack()");
        }
      }
    }
  }], ["score_data.music_creation", "package:score_data/src/music_creation.dart",, K, {
    "^": "",
    NoteManager: {
      "^": "Object;_score"
    },
    PitchNameManager: {
      "^": "Object;_score",
      showLyrics$0: function() {
        var t1, t2, _i, t3, t4, _i0, staff, originalLyrics, t5, t6, lyricIndex, _i1, t7, t8, _i2, ng, t9;
        for (t1 = this._score.get$parts(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$staves(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0) {
            staff = t3[_i0];
            if (staff.get$originalLyrics() == null)
              continue;
            originalLyrics = staff.get$originalLyrics();
            for (t5 = staff.get$measures(), t6 = t5.length, lyricIndex = 0, _i1 = 0; _i1 < t5.length; t5.length === t6 || (0, H.throwConcurrentModificationError)(t5), ++_i1) {
              t7 = t5[_i1].get$voices();
              if (0 >= t7.length)
                return H.ioore(t7, 0);
              for (t7 = t7[0].get$noteGroups(), t8 = t7.length, _i2 = 0; _i2 < t7.length; t7.length === t8 || (0, H.throwConcurrentModificationError)(t7), ++_i2) {
                ng = t7[_i2];
                t9 = originalLyrics.length;
                if (lyricIndex < t9) {
                  if (lyricIndex < 0)
                    return H.ioore(originalLyrics, lyricIndex);
                  t9 = originalLyrics[lyricIndex].containsKey$1(0, ng);
                } else
                  t9 = false;
                if (t9) {
                  if (lyricIndex < 0 || lyricIndex >= originalLyrics.length)
                    return H.ioore(originalLyrics, lyricIndex);
                  ng.set$lyric(originalLyrics[lyricIndex].$index(0, ng));
                  ++lyricIndex;
                } else
                  ng.set$lyric(null);
              }
            }
            staff.set$originalLyrics(null);
          }
      },
      showNoteNames$1: function(staff) {
        var t1, storeLyrics, vPos, hPos, t2, t3, _i, t4, t5, _i0, ng, t6, note, pitchName, t7;
        t1 = staff._originalLyrics;
        if (t1 == null) {
          t1 = [];
          staff._originalLyrics = t1;
          storeLyrics = true;
        } else
          storeLyrics = false;
        vPos = this._score.get$scoreProperties()._staffLineSpacing * -8;
        hPos = this._score.get$scoreProperties()._staffLineSpacing * 0.5;
        for (t2 = staff._measures, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
          t4 = t2[_i].get$voices();
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          for (t4 = t4[0].get$noteGroups(), t5 = t4.length, _i0 = 0; _i0 < t4.length; t4.length === t5 || (0, H.throwConcurrentModificationError)(t4), ++_i0) {
            ng = t4[_i0];
            if (ng.get$isRest() || ng.get$isGrace())
              continue;
            t6 = ng.get$visibleNotes();
            if (0 >= t6.length)
              return H.ioore(t6, 0);
            note = t6[0];
            if (storeLyrics && ng.get$lyric() != null)
              t1.push(P.LinkedHashMap__makeLiteral([ng, ng.get$lyric()]));
            if (note.get$tieState() !== "none" && note.get$tieState() !== "start") {
              ng.set$lyric(null);
              continue;
            }
            pitchName = note.get$pitchName();
            t6 = " " + (J.substring$2$s(pitchName, 0, pitchName.length - 1) + this._getAccidentalText$1(note.get$alteration()));
            t7 = new O.Lyric(null, null, 0, false, null, null, 0);
            t7._syllablePosition = "middle";
            t7._text = t6;
            t7._verse = 1;
            t7._hPos = hPos;
            t7._vPos = vPos;
            ng.set$lyric(t7);
          }
        }
      },
      _getAccidentalText$1: function(alteration) {
        switch (alteration) {
          case -2:
            return "bb";
          case 2:
            return "x";
          case -1:
            return "b";
          case 1:
            return "#";
          default:
            return "";
        }
      }
    },
    ScoreManager: {
      "^": "Object;_score,_noteManager,_transpositionManager,_pitchNameManager"
    },
    TranspositionManager: {
      "^": "Object;_score,_noteManager,_stacks,_history"
    }
  }], ["score_data.music_xml", "package:score_data/src/music_xml.dart",, S, {
    "^": "",
    MusicXmlParser2: {
      "^": "Object;_musicXML,_music_xml$_score,_currentPage,_currentSystem,_currentStack,_musicXMLString,_overrideScoreProps,_computeMaxKeySizeForRendering,_requestedScoreProps,_parsingCompleter,_lastPauseTime,_midiInstrumentsXMLList,_music_xml$_measureStacks,_currentTuplets,_currentSlurs,_partVol,_partXMLList,_cPartIndex,_partXML,_cPart,_cPartDPQ,_passedTimeDPQ,_measureIndex,_measureXMLList,_music_xml$_measure",
      getScoreProperties$1: function(defEl) {
        var sProps, t1, t2;
        if (defEl == null)
          return O.ScoreProperties_getNewScoreProperties();
        sProps = O.ScoreProperties_getNewScoreProperties();
        sProps._mmHeight = this._enum$2(defEl, "scaling millimeters");
        sProps._mmHeight = this._enum$2(defEl, "scaling millimeters");
        sProps._tenths = this._enum$2(defEl, "scaling tenths");
        sProps._pageHeight = this._enum$2(defEl, "page-layout page-height");
        sProps._pageWidth = this._enum$2(defEl, "page-layout page-width");
        sProps._leftPageMargin = this._enum$2(defEl, "page-layout page-margins left-margin");
        sProps._rightPageMargin = this._enum$2(defEl, "page-layout page-margins right-margin");
        sProps._topPageMargin = this._enum$2(defEl, "page-layout page-margins top-margin");
        sProps._bottomPageMargin = this._enum$2(defEl, "page-layout page-margins bottom-margin");
        sProps._systemSpacing = this._enum$2(defEl, "system-layout system-distance");
        sProps._topSystemDistance = this._enum$2(defEl, "system-layout top-system-distance");
        sProps._leftSystemMargin = this._enum$2(defEl, "system-layout system-margins left-margin");
        sProps._rightSystemMargin = this._enum$2(defEl, "system-layout system-margins right-margin");
        t1 = this._enum$2(defEl, "staff-layout staff-distance");
        sProps._staffSpacing = t1;
        if (J.$eq$(t1, 0))
          sProps._staffSpacing = 80;
        t1 = [null];
        t2 = new W._FrozenElementList(defEl.querySelectorAll("appearance line-width"), t1);
        t2.forEach$1(t2, new S.MusicXmlParser2_getScoreProperties_closure(this, sProps));
        t1 = new W._FrozenElementList(defEl.querySelectorAll("appearance note-size"), t1);
        t1.forEach$1(t1, new S.MusicXmlParser2_getScoreProperties_closure0(this, sProps));
        sProps._data$_qNoteWidth = 7.4083 * J.$div$n(sProps._tenths, 7.1967);
        sProps._keySigWidth = 2 * J.$div$n(sProps._tenths, 7.1967);
        sProps._data$_timeSigWidth = 4 * J.$div$n(sProps._tenths, 7.1967);
        sProps._clefWidth = 5 * J.$div$n(sProps._tenths, 7.1967);
        sProps._measureLeadIn = 4 * J.$div$n(sProps._tenths, 7.1967);
        return sProps;
      },
      _getMusicXMLObject$0: [function() {
        var parser, e, exception;
        try {
          parser = new DOMParser();
          this._musicXML = J.parseFromString$2$x(parser, this._musicXMLString, "application/xml").querySelector("score-partwise");
          this._musicXMLString = null;
        } catch (exception) {
          e = H.unwrapException(exception);
          this._parsingCompleter.completeError$1(e);
          return;
        }
        P.Timer_Timer(C.Duration_0, this.get$_parseXML());
      }, "call$0", "get$_getMusicXMLObject", 0, 0, 2],
      _parseXML$0: [function() {
        var defaultsEl, rightsEl, softwareEl, e, t1, t2, exception;
        try {
          this._lastPauseTime = new P.DateTime(Date.now(), false);
          this._midiInstrumentsXMLList = null;
          this._music_xml$_measureStacks = null;
          this._currentTuplets = null;
          this._currentSlurs = null;
          this._currentPage = null;
          this._currentSystem = null;
          this._currentStack = null;
          this._music_xml$_score = new O.Score(null, [], [], false, null, 0);
          defaultsEl = this._musicXML.querySelector("defaults");
          this._music_xml$_score._scoreProperties = this.getScoreProperties$1(defaultsEl);
          rightsEl = this._musicXML.querySelector("identification > rights");
          t1 = this._music_xml$_score._scoreProperties;
          t1._rights = rightsEl != null ? J.get$text$x(rightsEl) : null;
          if (this._overrideScoreProps === true) {
            t1 = this._music_xml$_score;
            t2 = O.ScoreProperties_getNewScoreProperties();
            t1._scoreProperties = t2;
          }
          softwareEl = this._musicXML.querySelector("identification > encoding > software");
          if (softwareEl != null)
            this._music_xml$_score._scoreProperties._software = J.get$text$x(softwareEl);
          this._music_xml$_score._graceNotesNeedFixing = true;
          t1 = [null];
          this._midiInstrumentsXMLList = new W._FrozenElementList(this._musicXML.querySelectorAll("part-list score-part midi-instrument"), t1);
          this._music_xml$_measureStacks = [];
          this._currentTuplets = [];
          this._currentSlurs = [];
          this._partVol = Math.min(1 / this._musicXML.querySelectorAll("score-partwise > part").length, 0.15);
          this._cPartIndex = 0;
          this._partXMLList = new W._FrozenElementList(this._musicXML.querySelectorAll("score-partwise > part"), t1);
          this._processNextPart$0();
        } catch (exception) {
          e = H.unwrapException(exception);
          this._parsingCompleter.completeError$1(e);
        }
      }, "call$0", "get$_parseXML", 0, 0, 2],
      _processNextPart$0: function() {
        var t1, t2, t3;
        t1 = this._cPartIndex;
        t2 = this._partXMLList._nodeList;
        t3 = t2.length;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 >= t3) {
          if (this._computeMaxKeySizeForRendering === true)
            this.computeMaxKeySizes$0();
          this._adjustMeasureLengthsToFitNotes$0();
          this._checkScoreForErrors$0();
          this._parsingCompleter.complete$1(0, this._music_xml$_score);
          return;
        }
        this._partXML = t2[t1];
        this._cPartIndex = t1 + 1;
        this._removeIncompleteSlurs$0();
        this._cPart = this._createPartObj$0();
        this._cPartDPQ = this._eint$2(this._partXML, "measure attributes divisions");
        this._passedTimeDPQ = 0;
        if (!this._createStavesForPart$0()) {
          this._processNextPart$0();
          return;
        }
        this._measureIndex = 0;
        this._measureXMLList = J.querySelectorAll$1$x(this._partXML, "measure");
        this._music_xml$_measure = null;
        this._processNextMeasure$0();
      },
      _removeIncompleteSlurs$0: function() {
        var t1, t2, _i, slur, t3, index;
        for (t1 = this._currentSlurs, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          slur = t1[_i];
          t3 = slur.get$firstNote()._slurs;
          index = (t3 && C.JSArray_methods).indexOf$1(t3, slur);
          t3 = slur.get$firstNote()._slurs;
          (t3 && C.JSArray_methods).removeAt$1(t3, index);
          if (slur.get$firstNote()._slurs.length === 0)
            slur.get$firstNote()._slurs = null;
        }
        this._currentSlurs = [];
      },
      _createPartObj$0: function() {
        var t1, t2, t3, t4, cPart;
        t1 = {};
        t1.staffName = "";
        t1.abbrName = "";
        t1.midiPreset = 0;
        t1.midiChannel = 1;
        new H.WhereIterable(new W._FrozenElementList(this._musicXML.querySelectorAll("part-list score-part"), [null]), new S.MusicXmlParser2__createPartObj_closure(this), [null]).forEach$1(0, new S.MusicXmlParser2__createPartObj_closure0(t1, this));
        t2 = J.get$attributes$x(this._partXML)._html$_element.getAttribute("id");
        t3 = t1.staffName;
        t4 = t1.abbrName;
        cPart = new O.Part(null, null, null, [], 0, 0, false, 0, 0, 0, false, 0.15, 0.5, null, [], false, 0, 0);
        cPart._partID = t2;
        cPart._data$_name = t3;
        cPart._abbreviation = t4;
        cPart._volume = this._partVol;
        cPart._midiChannel = t1.midiChannel;
        cPart._midiPreset = t1.midiPreset;
        this._music_xml$_score._data$_parts.push(cPart);
        return cPart;
      },
      _createStavesForPart$0: function() {
        var t1, measureXML, numStaves, i, t2;
        t1 = J.querySelectorAll$1$x(this._partXML, "part > measure")._nodeList;
        if (t1.length > 0) {
          measureXML = C.NodeList_methods.get$first(t1);
          numStaves = this._eint$2(measureXML, "attributes staves");
          if (J.$lt$n(numStaves, 1))
            numStaves = 1;
          if (typeof numStaves !== "number")
            return H.iae(numStaves);
          i = 0;
          for (; i < numStaves; ++i) {
            t1 = this._cPart;
            t2 = new O.Staff([], null, null, true, 0);
            t1._staves.push(t2);
            t2._partRef = t1;
          }
          if (this._estr$2(measureXML, "attributes transpose") !== "") {
            t1 = this._eint$2(measureXML, "attributes transpose diatonic");
            if (typeof t1 !== "number")
              return H.iae(t1);
            t2 = this._eint$2(measureXML, "attributes transpose chromatic");
            if (typeof t2 !== "number")
              return H.iae(t2);
            this._cPart.setTransposition$3(-1 * t1, -1 * t2, false);
          }
          return true;
        } else
          return false;
      },
      _processNextMeasure$0: [function() {
        var measureXML, staff, prevMeasure, cVoice, cNoteGroup, midMeasureClef, dpqPositionBeforeBackup, staffIndex, node, element, elemName, noteXML, clefXML, clef, line, targetMeasure, noteHasBeenAdded, voice, targetStack, targetMeasure0, dyn, targetStack0, metronomeEl, targetStack1, barline, styleEl, repeatEl, endingEl, repeatDO, repeatTimesStr, repeatDO0, staffNum, cStaff, cMeasure, voiceNum, cNote, currentTime, e, t1, t2, t3, _i, t4, prevMeasure0, t5, t6, dpqPositionBeforeBackup0, _i0, exception;
        try {
          t1 = this._measureIndex;
          t2 = this._measureXMLList._nodeList;
          t3 = t2.length;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (t1 >= t3) {
            this._checkPartForErrors$1(this._cPart);
            this._processNextPart$0();
            return;
          }
          measureXML = t2[t1];
          for (t1 = this._cPart._staves, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            staff = t1[_i];
            if (staff.get$measures().length > 0) {
              t3 = staff.get$measures();
              t4 = staff.get$measures().length - 1;
              if (t4 < 0 || t4 >= t3.length)
                return H.ioore(t3, t4);
              prevMeasure0 = t3[t4];
            } else
              prevMeasure0 = null;
            prevMeasure = prevMeasure0;
            t3 = this.createNewMeasure$3(measureXML, prevMeasure, this._measureIndex);
            this._music_xml$_measure = t3;
            if (this._music_xml$_score._data$_parts.length === 1) {
              t3 = t3._stack;
              t4 = this._passedTimeDPQ;
              t5 = this._cPartDPQ;
              if (typeof t4 !== "number")
                return t4.$div();
              if (typeof t5 !== "number")
                return H.iae(t5);
              t5 = t4 / t5;
              t3._startTime = t5;
              t3._dpqLength = J.$sub$n(t3._endTime, t5);
              t5 = this._music_xml$_measure;
              t3 = t5._stack;
              t4 = t3._startTime;
              t6 = t5._numBeats;
              t5 = t5._beatType;
              if (typeof t5 !== "number")
                return H.iae(t5);
              t5 = J.$mul$ns(t6, 4 / t5);
              if (typeof t5 !== "number")
                return H.iae(t5);
              t5 = t4 + t5;
              t3._endTime = t5;
              t3._dpqLength = t5 - t3._startTime;
            }
            staff.addMeasure$1(this._music_xml$_measure);
          }
          cVoice = null;
          cNoteGroup = null;
          midMeasureClef = null;
          dpqPositionBeforeBackup = 0;
          staffIndex = 0;
          for (t1 = J.get$childNodes$x(measureXML), t2 = t1.length, t3 = [null], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            node = t1[_i];
            if (!J.getInterceptor(node).$isElement)
              continue;
            element = H.interceptedTypeCast(node, "$isElement");
            elemName = J.toString$0$(J.get$tagName$x(element));
            noteXML = null;
            if (J.$eq$(elemName, "note"))
              noteXML = element;
            else if (J.$eq$(elemName, "backup")) {
              dpqPositionBeforeBackup0 = this._passedTimeDPQ;
              dpqPositionBeforeBackup = dpqPositionBeforeBackup0;
              t4 = this._eint$2(element, "duration");
              if (typeof dpqPositionBeforeBackup0 !== "number")
                return dpqPositionBeforeBackup0.$sub();
              if (typeof t4 !== "number")
                return H.iae(t4);
              this._passedTimeDPQ = dpqPositionBeforeBackup0 - t4;
              continue;
            } else if (J.$eq$(elemName, "forward")) {
              t4 = this._passedTimeDPQ;
              t5 = this._eint$2(element, "duration");
              if (typeof t4 !== "number")
                return t4.$add();
              if (typeof t5 !== "number")
                return H.iae(t5);
              this._passedTimeDPQ = t4 + t5;
              continue;
            } else if (this._estr$2(element, "clef") !== "") {
              for (t4 = new W._FrozenElementList(J._querySelectorAll$1$x(element, "clef"), t3), t4 = new H.ListIterator(t4, t4.get$length(t4), 0, null); t4.moveNext$0();) {
                clefXML = t4.__internal$_current;
                clef = new O.Clef(null, null, false, false, true, false, null, null, 0);
                line = this._eint$2(clefXML, "line");
                clef.set$_data$_type(O.ClefType_getClefType(this._estr$2(clefXML, "sign"), line));
                clef.set$_isNew(true);
                clef.set$_show(true);
                staffIndex = J.get$attributes$x(clefXML).$index(0, "number") != null ? J.$sub$n(H.Primitives_parseInt(J.get$attributes$x(clefXML).$index(0, "number"), null, null), 1) : 0;
                t5 = this._cPart._staves;
                t6 = staffIndex;
                if (t6 >>> 0 !== t6 || t6 >= t5.length)
                  return H.ioore(t5, t6);
                targetMeasure = C.JSArray_methods.get$last(t5[t6]._measures);
                noteHasBeenAdded = false;
                for (t5 = targetMeasure.get$voices(), t6 = t5.length, _i0 = 0; _i0 < t5.length; t5.length === t6 || (0, H.throwConcurrentModificationError)(t5), ++_i0) {
                  voice = t5[_i0];
                  if (voice.get$noteGroups().length > 0) {
                    noteHasBeenAdded = true;
                    break;
                  }
                }
                if (noteHasBeenAdded === true) {
                  targetMeasure.get$clefs().push(clef);
                  midMeasureClef = clef;
                  t5 = this._passedTimeDPQ;
                  t6 = this._cPartDPQ;
                  if (typeof t5 !== "number")
                    return t5.$div();
                  if (typeof t6 !== "number")
                    return H.iae(t6);
                  clef.set$_data$_qNoteTime(t5 / t6);
                } else {
                  clef.set$_data$_qNoteTime(targetMeasure.get$stack()._startTime);
                  if (targetMeasure.get$clefs().length === 0)
                    targetMeasure.get$clefs().push(clef);
                  else {
                    t5 = targetMeasure.get$clefs();
                    if (0 >= t5.length)
                      return H.ioore(t5, 0);
                    t5[0] = clef;
                  }
                  targetMeasure.get$stack()._newClef = true;
                  if (targetMeasure.get$stack()._newSystem) {
                    clef.set$_show(true);
                    clef.set$_smallSize(false);
                  }
                }
              }
              continue;
            } else if (J.$eq$(elemName, "sound")) {
              if (element.getAttribute("tempo") != null) {
                t4 = this._cPart._staves;
                t5 = staffIndex;
                if (t5 >>> 0 !== t5 || t5 >= t4.length)
                  return H.ioore(t4, t5);
                targetStack = C.JSArray_methods.get$last(t4[t5]._measures).get$stack();
                t5 = this._passedTimeDPQ;
                t4 = this._cPartDPQ;
                if (typeof t5 !== "number")
                  return t5.$div();
                if (typeof t4 !== "number")
                  return H.iae(t4);
                this.createTempoMarker$4(element, t5 / t4, targetStack, null);
              }
              continue;
            } else if (J.$eq$(elemName, "direction")) {
              if (J._querySelectorAll$1$x(element, "direction-type dynamics").length > 0) {
                staffIndex = this._estr$2(element, "staff") !== "" ? J.$sub$n(this._eint$2(element, "staff"), 1) : 0;
                t4 = this._cPart._staves;
                t5 = staffIndex;
                if (t5 >>> 0 !== t5 || t5 >= t4.length)
                  return H.ioore(t4, t5);
                targetMeasure0 = C.JSArray_methods.get$last(t4[t5]._measures);
                dyn = new O.Dynamic(1, null, null, null, false, null, null, false, null, null, 0);
                dyn.set$_data$_type(J.querySelector$1$x(element, "direction-type dynamics *").tagName);
                dyn.set$_isAbove(element.getAttribute("placement") === "above");
                dyn.set$_data$_qNoteTime(J.$div$n(J.$add$ns(this._eint$2(element, "offset"), this._passedTimeDPQ), this._cPartDPQ));
                dyn.set$_volume(O.DynamicType_getVolumeByType(dyn.get$_data$_type()));
                dyn.set$_measure(targetMeasure0);
                J.set$_data$_width$x(dyn, this._music_xml$_score._scoreProperties._noteheadWidth * dyn.get$_data$_type().length);
                J.set$_data$_height$x(dyn, this._music_xml$_score._scoreProperties._staffLineSpacing * 2);
                targetMeasure0.get$attachments();
                targetMeasure0.get$attachments().push(dyn);
              } else if (J.querySelector$1$x(element, "sound[tempo]") != null) {
                t4 = this._cPart._staves;
                t5 = staffIndex;
                if (t5 >>> 0 !== t5 || t5 >= t4.length)
                  return H.ioore(t4, t5);
                targetStack0 = C.JSArray_methods.get$last(t4[t5]._measures).get$stack();
                metronomeEl = J.querySelector$1$x(element, "direction-type > metronome");
                t5 = J.querySelector$1$x(element, "sound");
                t4 = this._passedTimeDPQ;
                t6 = this._cPartDPQ;
                if (typeof t4 !== "number")
                  return t4.$div();
                if (typeof t6 !== "number")
                  return H.iae(t6);
                this.createTempoMarker$4(t5, t4 / t6, targetStack0, metronomeEl);
              }
              continue;
            } else {
              if (J.$eq$(elemName, "barline")) {
                t4 = this._cPart;
                t5 = C.JSArray_methods.get$first(this._music_xml$_score._data$_parts);
                t5 = t4 == null ? t5 == null : t4 === t5;
                t4 = t5;
              } else
                t4 = false;
              if (t4) {
                t4 = this._cPart._staves;
                t5 = staffIndex;
                if (t5 >>> 0 !== t5 || t5 >= t4.length)
                  return H.ioore(t4, t5);
                targetStack1 = C.JSArray_methods.get$last(t4[t5]._measures).get$stack();
                if (targetStack1.get$barline() == null) {
                  barline = new O.Barline(null, null, false, null, null, 0);
                  J.set$location$x(barline, O.BarlineLocation_getLocation(element.getAttribute("location")));
                  styleEl = J.querySelector$1$x(element, "bar-style");
                  t4 = styleEl != null ? O.BarlineStyle_getStyle(J.get$text$x(styleEl)) : O.BarlineStyle_getStyle(null);
                  J.set$style$x(barline, t4);
                  targetStack1.set$barline(barline);
                }
                repeatEl = J.querySelector$1$x(element, "repeat");
                endingEl = J.querySelector$1$x(element, "ending");
                if ((repeatEl != null || endingEl != null) && targetStack1.get$repeatDOs() == null)
                  targetStack1.set$repeatDOs([]);
                if (repeatEl != null) {
                  repeatDO = new O.RepeatDO(null, null, null, null, null, 0);
                  repeatDO.set$repeatDirection(O.RepeatDirection_getDirection(repeatEl.getAttribute("direction")));
                  repeatTimesStr = repeatEl.getAttribute("times");
                  t4 = repeatTimesStr != null ? H.Primitives_parseInt(repeatTimesStr, null, null) : 1;
                  repeatDO.set$repeatTimes(t4);
                  targetStack1.get$repeatDOs().push(repeatDO);
                }
                if (endingEl != null) {
                  repeatDO0 = new O.RepeatDO(null, null, null, null, null, 0);
                  repeatDO0.set$endingNumber(endingEl.getAttribute("number"));
                  repeatDO0.set$endingType(O.EndingType_getType(endingEl.getAttribute("type")));
                  targetStack1.get$repeatDOs().push(repeatDO0);
                }
                continue;
              } else
                continue;
            }
            staffNum = J.querySelector$1$x(noteXML, "staff") == null ? 1 : this._eint$2(noteXML, "staff");
            t4 = this._cPart._staves;
            t5 = J.$sub$n(staffNum, 1);
            if (t5 >>> 0 !== t5 || t5 >= t4.length)
              return H.ioore(t4, t5);
            cStaff = t4[t5];
            t5 = cStaff.get$_measures();
            t4 = cStaff.get$_measures().length - 1;
            if (t4 < 0 || t4 >= t5.length)
              return H.ioore(t5, t4);
            cMeasure = t5[t4];
            voiceNum = this._eint$2(noteXML, "voice");
            cVoice = cMeasure.getVoiceByNumber$1(voiceNum);
            if (J.querySelector$1$x(noteXML, "chord") == null) {
              cNoteGroup = this.createNoteGroup$2(noteXML, cMeasure);
              cVoice.addNoteGroup$1(cNoteGroup);
              t4 = cNoteGroup;
              t5 = this._passedTimeDPQ;
              t6 = this._cPartDPQ;
              if (typeof t5 !== "number")
                return t5.$div();
              if (typeof t6 !== "number")
                return H.iae(t6);
              t4.set$_data$_qNoteTime(t5 / t6);
              cNoteGroup.set$_qNoteDuration(J.$div$n(cNoteGroup.get$_data$_duration(), this._cPartDPQ));
              t6 = this._passedTimeDPQ;
              t5 = cNoteGroup.get$_data$_duration();
              if (typeof t6 !== "number")
                return t6.$add();
              if (typeof t5 !== "number")
                return H.iae(t5);
              this._passedTimeDPQ = t6 + t5;
              cNoteGroup.set$_data$_duration(O.DurationType_getDurationValue(cNoteGroup.get$_durationType(), cNoteGroup.get$_numDots()));
              if (midMeasureClef != null && J.$le$n(midMeasureClef.get$_data$_qNoteTime(), cNoteGroup.get$_data$_qNoteTime())) {
                cNoteGroup.set$_clef(midMeasureClef);
                midMeasureClef = null;
              }
            }
            if (!cNoteGroup.get$_isRest()) {
              cNote = this.createNote$3(noteXML, cNoteGroup, cMeasure);
              cNoteGroup.insertNote$1(cNote);
              if (cNoteGroup.get$_notes().length === 1)
                cNoteGroup.set$_stemStartPos(cNote.get$_vPos());
              else {
                if (!J.$eq$(cNote.get$_hPos(), 0))
                  cNoteGroup.set$_stemHPos(this._music_xml$_score._scoreProperties._noteheadWidth);
                t4 = cNoteGroup;
                if (cNoteGroup.get$_stemDirection() === "up") {
                  t5 = cNoteGroup.get$_notes();
                  if (0 >= t5.length)
                    return H.ioore(t5, 0);
                  t5 = t5[0]._vPos;
                } else {
                  t5 = cNoteGroup.get$_notes();
                  t6 = cNoteGroup.get$_notes().length - 1;
                  if (t6 < 0 || t6 >= t5.length)
                    return H.ioore(t5, t6);
                  t6 = t5[t6]._vPos;
                  t5 = t6;
                }
                t4.set$_stemStartPos(t5);
              }
            }
          }
          t1 = this._music_xml$_measure._stack;
          if (!t1._isPickup) {
            t1 = J.round$0$n(J.$mul$ns(t1._endTime, this._cPartDPQ));
            this._passedTimeDPQ = t1;
          } else {
            t1 = this._passedTimeDPQ;
            t2 = dpqPositionBeforeBackup;
            if (typeof t1 !== "number")
              return t1.$lt();
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (t1 < t2) {
              t1 = J.round$0$n(dpqPositionBeforeBackup);
              this._passedTimeDPQ = t1;
            }
          }
          if (this._music_xml$_score._data$_parts.length === 1) {
            t2 = this._music_xml$_measure._stack;
            t3 = this._cPartDPQ;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = t1 / t3;
            t2._endTime = t3;
            t2._dpqLength = t3 - t2._startTime;
          }
          t1 = this._measureIndex;
          if (typeof t1 !== "number")
            return t1.$add();
          this._measureIndex = t1 + 1;
          currentTime = new P.DateTime(Date.now(), false);
          t1 = this._lastPauseTime;
          if (C.JSNumber_methods._tdivFast$1(P.Duration$(0, 0, 0, currentTime.get$_value() - t1._value, 0, 0)._duration, 1000) > 100) {
            this._lastPauseTime = currentTime;
            P.Timer_Timer(C.Duration_0, this.get$_processNextMeasure());
          } else
            this._processNextMeasure$0();
        } catch (exception) {
          e = H.unwrapException(exception);
          P.print("parse fail on measureIndex: " + H.S(this._measureIndex));
          this._parsingCompleter.completeError$1(e);
          return;
        }
      }, "call$0", "get$_processNextMeasure", 0, 0, 2],
      createNewMeasure$3: function(measureXML, previousMeasure, measureIndex) {
        var stack, t1, measure, t2, prevClef, t3, reParentedMidMeasureClef, clef, t4, exception, page, system, t5, prevPage, val, attXML, keyXML, mode, timeXML;
        t1 = [];
        measure = new O.Measure([], 0, 0, 0, 0, 0, false, false, 4, 4, null, null, [0, 1, 2, 3], false, t1, null, null, [], true, 0);
        t2 = previousMeasure != null;
        if (t2) {
          measure._diatonicTransposition = previousMeasure.get$diatonicTransposition();
          measure._chromaticTransposition = previousMeasure.get$chromaticTransposition();
          measure._concertKey = previousMeasure.get$concertKey();
          measure._displayKey = previousMeasure.get$displayKey();
          measure._isMajorKey = previousMeasure.get$isMajorKey();
          measure._numBeats = previousMeasure.get$numBeats();
          measure._beatType = previousMeasure.get$beatType();
          measure._beatGroups = C.JSArray_methods.sublist$1(previousMeasure.get$beatGroups(), 0);
          prevClef = C.JSArray_methods.get$last(previousMeasure.get$clefs());
          if (J.$eq$(prevClef._data$_qNoteTime, previousMeasure.get$stack()._endTime)) {
            t3 = previousMeasure.get$clefs();
            if (0 >= t3.length)
              return H.ioore(t3, -1);
            t1.push(t3.pop());
            prevClef._data$_qNoteTime = previousMeasure.get$stack()._endTime;
            prevClef._isNew = true;
            reParentedMidMeasureClef = true;
          } else {
            clef = new O.Clef(null, null, false, false, true, false, null, null, 0);
            clef._data$_type = prevClef._data$_type;
            clef._data$_qNoteTime = previousMeasure.get$stack()._endTime;
            t3 = t1.length;
            if (t3 === 0)
              t1.push(clef);
            else {
              if (0 >= t3)
                return H.ioore(t1, 0);
              t1[0] = clef;
            }
            reParentedMidMeasureClef = false;
          }
        } else {
          clef = new O.Clef(null, null, false, false, true, false, null, null, 0);
          clef._data$_type = "treble";
          clef._data$_qNoteTime = 0;
          clef._show = true;
          clef._smallSize = false;
          t1.push(clef);
          reParentedMidMeasureClef = false;
        }
        stack = null;
        t3 = this._music_xml$_measureStacks;
        t4 = t3.length;
        if (typeof measureIndex !== "number")
          return H.iae(measureIndex);
        if (t4 > measureIndex)
          stack = t3[measureIndex];
        else {
          stack = new O.MeasureStack([], [], 0, 0, 0, null, false, 200, 0, 0, 0, 1, 0, 0, false, false, null, null, null, null, null, null, false, true, 0);
          try {
            stack.set$_number(H.Primitives_parseInt(J.get$attributes$x(measureXML)._html$_element.getAttribute("number"), null, null));
          } catch (exception) {
            H.unwrapException(exception);
            t3 = this._music_xml$_measureStacks;
            if (t3.length > 1 && t3[0]._isPickup || J.get$attributes$x(measureXML)._html$_element.getAttribute("implicit") === "yes")
              stack.set$_number(measureIndex);
            else
              stack.set$_number(measureIndex + 1);
          }
          t3 = J.getInterceptor$x(measureXML);
          if (t3.get$attributes(measureXML)._html$_element.getAttribute("implicit") === "yes" && J.$eq$(stack.get$_number(), 0))
            stack.set$_isPickup(true);
          t4 = stack;
          t4.set$_startPosition(t2 ? J.$add$ns(previousMeasure.get$stack()._data$_width, previousMeasure.get$stack()._startPosition) : 0);
          t4 = stack;
          J.set$_data$_width$x(t4, t3.get$attributes(measureXML)._html$_element.getAttribute("width") != null ? P.num_parse(t3.get$attributes(measureXML)._html$_element.getAttribute("width"), null) : 0);
          t3 = this._currentStack;
          if (t3 != null) {
            t3._data$_next = stack;
            stack.set$_data$_previous(t3);
          }
        }
        this._currentStack = stack;
        measure._stack = stack;
        if (reParentedMidMeasureClef)
          stack.set$_newClef(true);
        stack.get$_measures().push(measure);
        if (stack.get$_systemRef() != null)
          this._currentSystem = stack.get$_systemRef();
        t3 = J.getInterceptor$x(measureXML);
        if (t3.querySelector$1(measureXML, "print") != null || this._music_xml$_measureStacks.length === 0) {
          if (this._estr$2(measureXML, "print page-number") === "") {
            t4 = t3.querySelectorAll$1(measureXML, "print");
            t4 = new H.WhereIterable(t4, new S.MusicXmlParser2_createNewMeasure_closure(), [H.getTypeArgumentByIndex(t4, 0)]);
            t4 = t4.get$length(t4) > 0 || measureIndex === 0;
          } else
            t4 = true;
          if (t4) {
            if (stack.get$_systemRef() == null || !stack.get$_systemRef().get$newPage()) {
              page = new O.Page([], null, null, 0);
              system = new O.System(null, 0, null, null, null, [], null, [], null, null, null, false, true, null, 0);
              system._data$_scoreProps = this._music_xml$_score._scoreProperties;
              system.getSettingsFromScoreProperties$0();
              page.addSystem$1(system);
              t4 = this._music_xml$_score._pages;
              t5 = t4.length;
              if (t5 > 0) {
                prevPage = t4[t5 - 1];
                prevPage._data$_next = page;
                page._data$_previous = prevPage;
              }
              t4.push(page);
              t4 = this._currentPage;
              if (t4 != null) {
                t4._data$_next = page;
                J.set$next$x(this._currentSystem, system);
                page._data$_previous = this._currentPage;
                system._data$_previous = this._currentSystem;
              }
              this._currentPage = page;
              this._currentSystem = system;
              system._newPage = true;
              stack.set$_newSystem(true);
              stack.set$_startPosition(0);
            }
          } else {
            t4 = t3.querySelectorAll$1(measureXML, "print");
            t4 = new H.WhereIterable(t4, new S.MusicXmlParser2_createNewMeasure_closure0(), [H.getTypeArgumentByIndex(t4, 0)]);
            if (t4.get$length(t4) > 0)
              if (!stack.get$_newSystem()) {
                system = new O.System(null, 0, null, null, null, [], null, [], null, null, null, false, true, null, 0);
                system._data$_scoreProps = this._music_xml$_score._scoreProperties;
                system.getSettingsFromScoreProperties$0();
                this._currentPage.addSystem$1(system);
                t4 = this._currentSystem;
                if (t4 != null) {
                  J.set$next$x(t4, system);
                  system._data$_previous = this._currentSystem;
                }
                this._currentSystem = system;
                stack.set$_newSystem(true);
                stack.set$_startPosition(0);
              }
          }
          val = this._enum$2(measureXML, "system-layout system-margins left-margin");
          if (!J.$eq$(val, 0))
            this._currentSystem.set$indent(val);
        }
        if (this._music_xml$_measureStacks.length <= measureIndex) {
          this._currentSystem.addMeasureStack$2(stack, false);
          this._music_xml$_measureStacks.push(stack);
        }
        if (stack.get$_newSystem()) {
          if (t1.length > 0) {
            t1 = t1[0];
            t1._show = true;
            t1._smallSize = false;
          }
          measure._showKey = true;
        }
        attXML = t3.querySelector$1(measureXML, "attributes");
        if (attXML != null) {
          if (attXML.querySelector("transpose") != null) {
            t1 = this._eint$2(attXML, "transpose diatonic");
            if (typeof t1 !== "number")
              return H.iae(t1);
            measure._diatonicTransposition = -1 * t1;
            t1 = this._eint$2(attXML, "transpose chromatic");
            if (typeof t1 !== "number")
              return H.iae(t1);
            measure._chromaticTransposition = -1 * t1;
          }
          if (this._estr$2(attXML, "key fifths") !== "") {
            keyXML = attXML.querySelector("key");
            t1 = this._eint$2(keyXML, "fifths");
            measure._displayKey = t1;
            t3 = 2 * measure._diatonicTransposition;
            measure._concertKey = J.$sub$n(t1, t3 + 7 * (measure._chromaticTransposition - t3));
            measure._outgoingKey = t2 ? previousMeasure.get$displayKey() : 0;
            if (keyXML.querySelector("mode") != null) {
              mode = this._estr$2(keyXML, "mode").toLowerCase();
              measure._isMajorKey = mode === "major" || mode === "(unknown)";
            } else
              measure._isMajorKey = true;
            measure._showKey = true;
            stack.set$_newKey(true);
          }
          if (this._estr$2(attXML, "time beats") !== "") {
            timeXML = attXML.querySelector("time");
            measure._numBeats = this._eint$2(timeXML, "beats");
            measure._beatType = this._eint$2(timeXML, "beat-type");
            measure._showTime = true;
            this._updateMeasureBeatGroups$1(measure);
          }
        }
        return measure;
      },
      _updateMeasureBeatGroups$1: function(measure) {
        var beatGroups, i, t1;
        beatGroups = [];
        i = 0;
        while (true) {
          t1 = measure.get$numBeats();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$mod$n(measure.get$beatType(), 8) !== 0 || i % 3 === 0) {
            t1 = measure.get$beatType();
            if (typeof t1 !== "number")
              return H.iae(t1);
            beatGroups.push(i * (4 / t1));
          }
          ++i;
        }
        measure.set$beatGroups(beatGroups);
      },
      createNoteGroup$2: function(noteXML, cMeasure) {
        var noteGroup, t1, t2, tupletsToRemove, notationsXML, tupletsXML, t3, tupletXML, t4, tuplet, tupActualXML, numDots, tupNormalXML, durString, tupletID, t5, _i, tup, tupletToRemove, i, slursXML, slurXML, slur, slurID, slurIndex, index, node, articulation, hPos, vPos, lyricXML, lyric, clefType, stepsFromTopStaffLine, t0, beamsXML, beamXML, stemDirection;
        noteGroup = new O.NoteGroup([], 0, "noStem", null, 0, 0, null, 1024, 1, 0, 1024, 0, false, null, [], 0, 0, false, 0, null, null, null, null, false, false, 0, null, null, 0, null, null, true, null, null, null, null, 0);
        if (noteXML.getAttribute("print-object") === "no") {
          noteGroup._prevVisible = true;
          noteGroup._visible = false;
        }
        if (noteXML.querySelector("duration") != null) {
          t1 = this._eint$2(noteXML, "duration");
          noteGroup._data$_duration = t1;
        } else {
          noteGroup._data$_duration = 0;
          t1 = 0;
        }
        t2 = noteXML.querySelector("type") != null ? O.DurationType_getDurationType(this._estr$2(noteXML, "type")) : 4096;
        noteGroup._durationType = t2;
        if (t2 === 512)
          noteGroup._maxBeams = 1;
        else if (t2 === 256)
          noteGroup._maxBeams = 2;
        else if (t2 === 128)
          noteGroup._maxBeams = 3;
        else if (t2 === 64)
          noteGroup._maxBeams = 4;
        noteGroup._isGrace = noteXML.querySelector("grace") != null || J.$eq$(t1, 0);
        noteGroup._hPos = noteXML.getAttribute("default-x") != null ? P.num_parse(noteXML.getAttribute("default-x"), null) : J.$div$n(cMeasure.get$stack()._data$_width, 2);
        t1 = [null];
        noteGroup._numDots = noteXML.querySelectorAll("dot").length;
        tupletsToRemove = [];
        notationsXML = noteXML.querySelector("notations");
        t2 = notationsXML == null;
        tupletsXML = t2 ? null : new W._FrozenElementList(notationsXML.querySelectorAll("tuplet"), t1);
        if (tupletsXML != null)
          for (t3 = new H.ListIterator(tupletsXML, tupletsXML.get$length(tupletsXML), 0, null); t3.moveNext$0();) {
            tupletXML = t3.__internal$_current;
            t4 = J.getInterceptor$x(tupletXML);
            if (J.$eq$(t4.get$attributes(tupletXML).$index(0, "type"), "start")) {
              tuplet = new O.Tuplet(0, null, null, 0, 0, 0, 0, false, false, 0, 0);
              tuplet._tupletID = t4.get$attributes(tupletXML).$index(0, "number") != null ? H.Primitives_parseInt(t4.get$attributes(tupletXML).$index(0, "number"), null, null) : 0;
              tuplet._firstNote = noteGroup;
              tuplet._above = J.$eq$(t4.get$attributes(tupletXML).$index(0, "placement"), "above");
              if (t4.querySelector$1(tupletXML, "tuplet-actual") != null) {
                tupActualXML = t4.querySelector$1(tupletXML, "tuplet-actual");
                tuplet._numerator = this._eint$2(tupActualXML, "tuplet-number");
                numDots = tupActualXML.querySelector("tuplet-dot") != null ? tupActualXML.querySelectorAll("tuplet-dot").length : 0;
                tuplet._numeratorDuration = O.DurationType_getDurationValue(O.DurationType_getDurationType(this._estr$2(tupActualXML, "tuplet-type")), numDots);
              } else {
                tuplet._numerator = this._eint$2(noteXML, "time-modification actual-notes");
                tuplet._numeratorDuration = O.DurationType_getDurationValue(noteGroup._durationType, noteGroup._numDots);
              }
              if (t4.querySelector$1(tupletXML, "tuplet-normal") != null) {
                tupNormalXML = t4.querySelector$1(tupletXML, "tuplet-normal");
                tuplet._denominator = this._eint$2(tupNormalXML, "tuplet-number");
                numDots = tupNormalXML.querySelector("tuplet-dot") != null ? tupNormalXML.querySelectorAll("tuplet-dot").length : 0;
                tuplet._denominatorDuration = O.DurationType_getDurationValue(O.DurationType_getDurationType(this._estr$2(tupNormalXML, "tuplet-type")), numDots);
              } else {
                tuplet._denominator = this._eint$2(noteXML, "time-modification normal-notes");
                numDots = noteXML.querySelectorAll("time-modification normal-dot").length;
                durString = this._estr$2(noteXML, "time-modification normal-type");
                tuplet._denominatorDuration = O.DurationType_getDurationValue(durString !== "" ? O.DurationType_getDurationType(durString) : noteGroup._durationType, numDots);
              }
              this._currentTuplets.push(tuplet);
            } else if (J.$eq$(t4.get$attributes(tupletXML).$index(0, "type"), "stop") && this._currentTuplets.length > 0) {
              tupletID = this._aint$2(tupletXML, "number");
              t4 = this._currentTuplets;
              t5 = t4.length;
              if (0 >= t5)
                return H.ioore(t4, 0);
              tuplet = t4[0];
              for (_i = 0; _i < t4.length; t4.length === t5 || (0, H.throwConcurrentModificationError)(t4), ++_i) {
                tup = t4[_i];
                if (J.$eq$(tup.get$tupletID(), tupletID)) {
                  tuplet = tup;
                  break;
                }
              }
              tuplet.set$endNote(noteGroup);
              tupletsToRemove.push(tuplet);
            }
          }
        t3 = this._currentTuplets;
        if (t3.length > 0) {
          noteGroup._tuplets = (t3 && C.JSArray_methods).sublist$1(t3, 0);
          t3 = tupletsToRemove.length;
          if (t3 > 0)
            for (_i = 0; _i < tupletsToRemove.length; tupletsToRemove.length === t3 || (0, H.throwConcurrentModificationError)(tupletsToRemove), ++_i) {
              tupletToRemove = tupletsToRemove[_i];
              for (t4 = J.getInterceptor(tupletToRemove), i = 0; t5 = this._currentTuplets, i < t5.length; ++i)
                if (t4.$eq(tupletToRemove, t5[i])) {
                  t5 = this._currentTuplets;
                  (t5 && C.JSArray_methods).removeAt$1(t5, i);
                }
            }
        }
        slursXML = !t2 ? new W._FrozenElementList(notationsXML.querySelectorAll("slur"), t1) : null;
        if (slursXML != null)
          for (t2 = new H.ListIterator(slursXML, slursXML.get$length(slursXML), 0, null); t2.moveNext$0();) {
            slurXML = t2.__internal$_current;
            t3 = J.getInterceptor$x(slurXML);
            if (J.$eq$(t3.get$attributes(slurXML).$index(0, "type"), "start")) {
              slur = new O.Slur(0, false, null, null, null, 0);
              slur._slurID = H.Primitives_parseInt(t3.get$attributes(slurXML).$index(0, "number"), null, null);
              slur._firstNote = noteGroup;
              this._currentSlurs.push(slur);
            } else if (J.$eq$(t3.get$attributes(slurXML).$index(0, "type"), "stop")) {
              slurID = H.Primitives_parseInt(t3.get$attributes(slurXML).$index(0, "number"), null, null);
              slurIndex = this._currentSlurs.length - 1;
              while (true) {
                if (!(slurIndex >= 0)) {
                  slur = null;
                  break;
                }
                t3 = this._currentSlurs;
                if (slurIndex >= t3.length)
                  return H.ioore(t3, slurIndex);
                if (J.$eq$(t3[slurIndex]._slurID, slurID)) {
                  t3 = this._currentSlurs;
                  if (slurIndex >= t3.length)
                    return H.ioore(t3, slurIndex);
                  slur = t3[slurIndex];
                  break;
                }
                --slurIndex;
              }
              if (slur != null) {
                slur._endNote = noteGroup;
                t3 = this._currentSlurs;
                index = (t3 && C.JSArray_methods).indexOf$1(t3, slur);
                t3 = this._currentSlurs;
                (t3 && C.JSArray_methods).removeAt$1(t3, index);
              }
            } else
              slur = null;
            if (slur != null) {
              t3 = noteGroup._slurs;
              if (t3 == null)
                noteGroup._slurs = [slur];
              else
                t3.push(slur);
            }
          }
        t2 = noteXML.querySelectorAll("notations");
        if (t2.length > 0) {
          t2 = J.querySelectorAll$1$x(t2[0], "articulations")._nodeList;
          t3 = t2.length;
          if (t3 > 0)
            for (t2 = t2[0].childNodes, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
              node = t2[_i];
              if (!J.getInterceptor(node).$isElement)
                continue;
              articulation = new O.Articulation(0, null, false, 0, 0, false, false, null, null, 0);
              t4 = O.ArticulationType_getTypeFromName(node.tagName);
              articulation._data$_type = t4;
              hPos = node.getAttribute("default-x");
              vPos = node.getAttribute("default-y");
              articulation._hPos = hPos != null ? P.num_parse(hPos, null) : 0;
              if (vPos != null) {
                t5 = P.num_parse(vPos, null);
                if (typeof t5 !== "number")
                  return H.iae(t5);
                t5 = -1 * t5;
              } else
                t5 = 0;
              articulation._vPos = t5;
              articulation._isAbove = node.getAttribute("placement") === "above";
              articulation._noteGroup = noteGroup;
              if (!(t4 === 0)) {
                articulation._data$_width = 1;
                articulation._data$_height = 1;
              }
              t4 = noteGroup._articulations;
              if (t4 == null) {
                t4 = [];
                noteGroup._articulations = t4;
              }
              t4.push(articulation);
            }
        }
        if (noteXML.querySelector("lyric") != null) {
          lyricXML = noteXML.querySelector("lyric");
          t2 = this._estr$2(lyricXML, "syllabic");
          t3 = this._estr$2(lyricXML, "text");
          t4 = this._aint$2(lyricXML, "number");
          t5 = this._aint$3(lyricXML, "default-y", false);
          lyric = new O.Lyric(null, null, 0, false, null, null, 0);
          lyric._syllablePosition = t2;
          lyric._text = t3;
          lyric._verse = t4;
          lyric._hPos = 0;
          lyric._vPos = t5;
          if (t5 == null)
            lyric._vPos = this._music_xml$_score._scoreProperties._staffLineSpacing * -8;
          noteGroup._lyric = lyric;
        }
        if (noteXML.querySelector("rest") != null) {
          noteGroup._isRest = true;
          if (this._estr$2(noteXML, "rest display-step") !== "") {
            if (cMeasure.get$clefs().length > 0) {
              t1 = cMeasure.get$clefs();
              t2 = cMeasure.get$clefs().length - 1;
              if (t2 < 0 || t2 >= t1.length)
                return H.ioore(t1, t2);
              clefType = t1[t2]._data$_type;
            } else
              clefType = "treble";
            t1 = this._estr$2(noteXML, "rest display-step");
            t2 = this._estr$2(noteXML, "rest display-octave");
            if (t1 == null)
              return t1.$add();
            stepsFromTopStaffLine = S.PitchUtils_getStepsFromTopStaffLine(C.JSString_methods.$add(t1, t2), clefType);
            t2 = this._music_xml$_score;
            t1 = t2._scoreProperties._staffLineSpacing / 2 * stepsFromTopStaffLine;
            noteGroup._restVPos = t1;
            t0 = t2;
            t2 = t1;
            t1 = t0;
          } else {
            t1 = this._music_xml$_score;
            t2 = t1._scoreProperties._staffLineSpacing * 2;
            noteGroup._restVPos = t2;
          }
          t3 = noteGroup._durationType;
          if (t3 === 4096)
            noteGroup._restVPos = t2 - 0.5 * t1._scoreProperties._staffLineSpacing;
          else if (t3 === 2048)
            noteGroup._restVPos = t2 - 0.3 * t1._scoreProperties._staffLineSpacing;
          return noteGroup;
        }
        beamsXML = new W._FrozenElementList(noteXML.querySelectorAll("beam"), t1);
        for (t1 = new H.ListIterator(beamsXML, beamsXML.get$length(beamsXML), 0, null); t1.moveNext$0();) {
          beamXML = t1.__internal$_current;
          C.JSArray_methods.add$1(noteGroup._beamStates, J.get$text$x(beamXML));
        }
        if (noteXML.getAttribute("default-x") != null)
          noteGroup._hPos = P.num_parse(noteXML.getAttribute("default-x"), null);
        if (noteXML.querySelector("stem") != null) {
          stemDirection = this._estr$2(noteXML, "stem");
          if (noteXML.querySelector("stem[default-y]") != null) {
            t1 = P.num_parse(noteXML.querySelector("stem[default-y]").getAttribute("default-y"), null);
            if (typeof t1 !== "number")
              return H.iae(t1);
            noteGroup._stemEndPos = -1 * t1;
          }
        } else
          stemDirection = noteGroup._durationType === 4096 ? "noStem" : "up";
        noteGroup._stemDirection = stemDirection;
        noteGroup._stemHPos = stemDirection === "up" ? this._music_xml$_score._scoreProperties._noteheadWidth : 0;
        return noteGroup;
      },
      createNote$3: function(noteXML, noteGroup, measure) {
        var note, t1, t2, instID, miXML, alteration, accidental, letter, clefType, _i, clef;
        note = new O.Note("C4", 0, 0, 0, 100, false, null, "none", 0, 0, null, null, false, null, null, 0);
        note._visible = true;
        if (!(noteXML.getAttribute("print-object") === "no"))
          if (!noteGroup._visible) {
            noteGroup._prevVisible = false;
            noteGroup._visible = true;
          }
        if (noteXML.querySelector("pitch") != null) {
          t1 = this._estr$2(noteXML, "pitch step");
          t2 = this._estr$2(noteXML, "pitch octave");
          if (t1 == null)
            return t1.$add();
          note._pitchName = C.JSString_methods.$add(t1, t2);
        } else if (noteXML.querySelector("unpitched") != null) {
          t1 = this._estr$2(noteXML, "unpitched display-step");
          t2 = this._estr$2(noteXML, "unpitched display-octave");
          if (t1 == null)
            return t1.$add();
          note._pitchName = C.JSString_methods.$add(t1, t2);
          if (noteXML.querySelector("instrument") != null && this._midiInstrumentsXMLList != null) {
            instID = noteXML.querySelector("instrument").getAttribute("id");
            for (t1 = this._midiInstrumentsXMLList, t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null); t1.moveNext$0();) {
              miXML = t1.__internal$_current;
              if (J.$eq$(J.get$attributes$x(miXML).$index(0, "id"), instID)) {
                note._playbackCents = J.$sub$n(J.$mul$ns(this._eint$2(miXML, "midi-unpitched"), 100), 100);
                break;
              }
            }
          }
        } else
          H.printString("unknown note pitch format! " + J.toString$0$(noteXML));
        alteration = this._eint$2(noteXML, "pitch alter");
        note._alteration = alteration;
        t1 = S.PitchUtils_pitchNameToDiatonicCents(note._pitchName);
        if (typeof alteration !== "number")
          return H.iae(alteration);
        t1 += 100 * alteration;
        note._displayCents = t1;
        if (alteration < 3 && alteration > -3) {
          accidental = noteXML.querySelector("accidental") != null ? O.AccidentalType_getAccidentalFromString(this._estr$2(noteXML, "accidental")) : 100;
          t1 = alteration;
        } else {
          letter = $.$get$PitchUtils_centPitchNames0().$index(0, C.JSDouble_methods.$mod(t1 / 100, 12) * 100);
          t2 = C.JSNumber_methods.toString$0(C.JSNumber_methods._tdivFast$1(t1, 1200) - 1);
          if (letter == null)
            return letter.$add();
          letter += t2;
          t1 = C.JSNumber_methods._tdivFast$1(t1 - S.PitchUtils_pitchNameToDiatonicCents(letter), 100);
          note._alteration = t1;
          note._pitchName = letter;
          accidental = 100;
        }
        if (accidental !== 100) {
          note._accidental = accidental;
          note._showAccidental = true;
        } else
          note._accidental = O.AccidentalType_getAccidentalType(t1);
        note._accidentalPos = -1 * this._music_xml$_score._scoreProperties._noteheadWidth;
        for (t1 = measure.get$clefs(), t2 = t1.length, clefType = "", _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          clef = t1[_i];
          if (J.$gt$n(J.$add$ns(noteGroup._data$_qNoteTime, 0.0001), clef.get$qNoteTime()))
            clefType = clef.get$type(clef);
          else
            break;
        }
        t1 = S.PitchUtils_getStepsFromTopStaffLine(note._pitchName, clefType);
        note._stepsFromTopStaffLine = t1;
        if (noteXML.getAttribute("default-x") != null)
          note._hPos = J.$sub$n(P.num_parse(noteXML.getAttribute("default-x"), null), noteGroup._hPos);
        note._vPos = this._music_xml$_score._scoreProperties._staffLineSpacing / 2 * t1;
        if (t1 < -1)
          note._legerLines = C.JSNumber_methods._tdivFast$1(t1, 2);
        else if (t1 > 9)
          note._legerLines = C.JSNumber_methods._tdivFast$1(t1 - 8, 2);
        t1 = noteXML.querySelectorAll("tie");
        t2 = t1.length;
        if (t2 > 0)
          note._tieState = t2 === 1 ? J.get$attributes$x(C.NodeList_methods.get$first(t1))._html$_element.getAttribute("type") : "continue";
        return note;
      },
      createTempoMarker$4: function(element, qNoteTime, targetStack, metronomeEl) {
        var tempoMarker, durationType, tempoFac, t1, t2, t3;
        tempoMarker = new O.TempoMarker(null, null, 0);
        if (metronomeEl != null)
          if (metronomeEl.querySelector("beat-unit") != null) {
            durationType = O.DurationType_getDurationType(metronomeEl.querySelector("beat-unit").textContent);
            tempoFac = O.DurationType_getDurationValue(durationType, metronomeEl.querySelector("dotted") != null ? 1 : 0) / 1024;
          } else
            tempoFac = 1;
        else
          tempoFac = 1;
        tempoMarker._data$_qNoteTime = qNoteTime;
        tempoMarker._tempo = J.$mul$ns(P.num_parse(element.getAttribute("tempo"), null), tempoFac);
        t1 = targetStack._tempoMarkers;
        if (t1 == null)
          targetStack._tempoMarkers = [tempoMarker];
        else {
          t2 = t1.length;
          t3 = t2 - 1;
          if (t3 < 0)
            return H.ioore(t1, t3);
          if (J.$lt$n(t1[t3]._data$_qNoteTime, qNoteTime))
            targetStack._tempoMarkers.push(tempoMarker);
        }
      },
      computeMaxKeySizes$0: function() {
        var stacks, numStacks, i, stack, measures, numMeasures, maxKeySize, j, measure, totalKeySize;
        stacks = this._music_xml$_score.getMeasureStacks$0();
        numStacks = stacks.length;
        for (i = 0; i < numStacks; ++i) {
          if (i >= stacks.length)
            return H.ioore(stacks, i);
          stack = stacks[i];
          measures = stack.get$measures();
          numMeasures = measures.length;
          for (maxKeySize = 0, j = 0; j < numMeasures; ++j) {
            if (j >= measures.length)
              return H.ioore(measures, j);
            measure = measures[j];
            totalKeySize = S.PitchUtils_getTotalKeySize(measure.get$displayKey(), measure.get$outgoingKey());
            if (J.$gt$n(totalKeySize, maxKeySize))
              maxKeySize = totalKeySize;
          }
          stack.set$maxKeySize(maxKeySize);
        }
      },
      _checkPartForErrors$1: function(part) {
        var t1, t2, _i, t3, t4, _i0, measure, t5, t6, _i1, t7, t8, _i2, ng, t9, t10, t11, _i3, note, nextNG, matchFound, t12, t13, _i4, nextNote;
        for (t1 = part._staves, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          for (t3 = t1[_i].get$measures(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0) {
            measure = t3[_i0];
            if (measure.get$voices().length === 0)
              measure.getVoiceByNumber$1(1);
            for (t5 = measure.get$voices(), t6 = t5.length, _i1 = 0; _i1 < t5.length; t5.length === t6 || (0, H.throwConcurrentModificationError)(t5), ++_i1)
              for (t7 = t5[_i1].get$noteGroups(), t8 = t7.length, _i2 = 0; _i2 < t7.length; t7.length === t8 || (0, H.throwConcurrentModificationError)(t7), ++_i2) {
                ng = t7[_i2];
                if (ng.get$isRest())
                  continue;
                for (t9 = ng.get$notes(), t10 = t9.length, t11 = J.getInterceptor$x(ng), _i3 = 0; _i3 < t9.length; t9.length === t10 || (0, H.throwConcurrentModificationError)(t9), ++_i3) {
                  note = t9[_i3];
                  if (note.get$tieState() === "start" || note.get$tieState() === "continue") {
                    nextNG = t11.get$next(ng);
                    if (nextNG == null || nextNG.get$isRest())
                      note.set$tieState("none");
                    else {
                      t12 = nextNG.get$notes();
                      t13 = t12.length;
                      _i4 = 0;
                      while (true) {
                        if (!(_i4 < t12.length)) {
                          matchFound = false;
                          break;
                        }
                        nextNote = t12[_i4];
                        if ((nextNote.get$tieState() === "continue" || nextNote.get$tieState() === "stop") && nextNote.get$pitchName() === note.get$pitchName() && J.$eq$(nextNote.get$alteration(), note.get$alteration())) {
                          matchFound = true;
                          break;
                        }
                        t12.length === t13 || (0, H.throwConcurrentModificationError)(t12);
                        ++_i4;
                      }
                      if (!matchFound)
                        note.set$tieState("none");
                    }
                  }
                }
              }
          }
      },
      _checkScoreForErrors$0: function() {
        var t1, firstStack, t2, _i;
        t1 = this._music_xml$_score._data$_parts;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].get$staves();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0]._measures;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        firstStack = t1[0].get$stack();
        if (!firstStack._newKey) {
          firstStack._newKey = true;
          for (t1 = firstStack._measures, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
            t1[_i].set$showKey(true);
        }
      },
      _adjustMeasureLengthsToFitNotes$0: function() {
        var stacks, t1, currentQNoteOffset, _i, stack, t2, t3, stackStartTime, t4, t5, latestNoteEndTime, _i0, measure, t6, t7, _i1, t8, t9, _i2, ng, t10, tuplet, tupletQNoteEndTime, clef, attachment, tm, stackNewQNoteDur, qNoteRemainder, newNumerator, newDenominator, mult;
        stacks = this._music_xml$_score.getMeasureStacks$0();
        for (t1 = stacks.length, currentQNoteOffset = 0, _i = 0; _i < stacks.length; stacks.length === t1 || (0, H.throwConcurrentModificationError)(stacks), ++_i) {
          stack = stacks[_i];
          t2 = J.getInterceptor$x(stack);
          t3 = t2.get$startTime(stack);
          if (typeof t3 !== "number")
            return t3.$add();
          t2.set$startTime(stack, t3 + currentQNoteOffset);
          t2.set$endTime(stack, J.$add$ns(t2.get$endTime(stack), currentQNoteOffset));
          stackStartTime = t2.get$startTime(stack);
          for (t3 = stack.get$measures(), t4 = t3.length, t5 = currentQNoteOffset !== 0, latestNoteEndTime = stackStartTime, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0) {
            measure = t3[_i0];
            for (t6 = measure.get$voices(), t7 = t6.length, _i1 = 0; _i1 < t6.length; t6.length === t7 || (0, H.throwConcurrentModificationError)(t6), ++_i1)
              for (t8 = t6[_i1].get$noteGroups(), t9 = t8.length, _i2 = 0; _i2 < t8.length; t8.length === t9 || (0, H.throwConcurrentModificationError)(t8), ++_i2) {
                ng = t8[_i2];
                ng.set$qNoteTime(J.$add$ns(ng.get$qNoteTime(), currentQNoteOffset));
                if (ng.get$tuplets() != null && ng.get$tuplets().length > 0) {
                  t10 = ng.get$tuplets();
                  if (0 >= t10.length)
                    return H.ioore(t10, 0);
                  tuplet = t10[0];
                  tupletQNoteEndTime = J.$add$ns(tuplet.get$firstNote()._data$_qNoteTime, J.$div$n(J.$mul$ns(tuplet.get$denominator(), tuplet.get$denominatorDuration()), 1024));
                  if (J.$gt$n(tupletQNoteEndTime, latestNoteEndTime))
                    latestNoteEndTime = tupletQNoteEndTime;
                } else if (J.$gt$n(J.$add$ns(ng.get$qNoteTime(), ng.get$qNoteDuration()), latestNoteEndTime))
                  latestNoteEndTime = J.$add$ns(ng.get$qNoteTime(), ng.get$qNoteDuration());
              }
            if (t5) {
              for (t6 = measure.get$clefs(), t7 = t6.length, _i1 = 0; _i1 < t6.length; t6.length === t7 || (0, H.throwConcurrentModificationError)(t6), ++_i1) {
                clef = t6[_i1];
                clef.set$qNoteTime(J.$add$ns(clef.get$qNoteTime(), currentQNoteOffset));
              }
              for (t6 = measure.get$attachments(), t7 = t6.length, _i1 = 0; _i1 < t6.length; t6.length === t7 || (0, H.throwConcurrentModificationError)(t6), ++_i1) {
                attachment = t6[_i1];
                attachment.set$qNoteTime(J.$add$ns(attachment.get$qNoteTime(), currentQNoteOffset));
              }
            }
          }
          if (t5 && stack.get$tempoMarkers() != null)
            for (t3 = stack.get$tempoMarkers(), t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0) {
              tm = t3[_i0];
              tm.set$qNoteTime(J.$add$ns(tm.get$qNoteTime(), currentQNoteOffset));
            }
          t3 = J.getInterceptor(latestNoteEndTime);
          if (!t3.$eq(latestNoteEndTime, t2.get$endTime(stack)))
            if (t3.$eq(latestNoteEndTime, t2.get$startTime(stack)))
              continue;
            else {
              stackNewQNoteDur = t3.$sub(latestNoteEndTime, stackStartTime);
              t4 = J.getInterceptor$n(stackNewQNoteDur);
              qNoteRemainder = t4.$ge(stackNewQNoteDur, 1) ? t4.remainder$1(stackNewQNoteDur, t4.floor$0(stackNewQNoteDur)) : stackNewQNoteDur;
              if (J.$eq$(qNoteRemainder, 0)) {
                newNumerator = t4.floor$0(stackNewQNoteDur);
                newDenominator = 4;
              } else {
                if (typeof qNoteRemainder !== "number")
                  return H.iae(qNoteRemainder);
                mult = 1 / qNoteRemainder;
                if (C.JSDouble_methods.floor$0(mult) === mult) {
                  newNumerator = J.floor$0$n(t4.$mul(stackNewQNoteDur, mult));
                  newDenominator = C.JSNumber_methods.floor$0(4 * mult);
                } else {
                  newNumerator = null;
                  newDenominator = null;
                }
              }
              if (newNumerator != null) {
                t3 = t3.$sub(latestNoteEndTime, t2.get$endTime(stack));
                if (typeof t3 !== "number")
                  return H.iae(t3);
                currentQNoteOffset += t3;
                t2.set$endTime(stack, latestNoteEndTime);
                for (t2 = stack.get$measures(), t3 = t2.length, _i0 = 0; _i0 < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i0) {
                  measure = t2[_i0];
                  measure.set$displayNumBeats(measure.get$numBeats());
                  measure.set$displayBeatType(measure.get$beatType());
                  measure.set$numBeats(newNumerator);
                  measure.set$beatType(newDenominator);
                  this._updateMeasureBeatGroups$1(measure);
                }
              }
            }
        }
      },
      _enum$3: function(el, selector, zeroIfNull) {
        var e, t1;
        e = J.querySelector$1$x(el, selector);
        if (e == null)
          return 0;
        else {
          t1 = e.textContent;
          return t1 !== "" ? P.num_parse(t1, null) : 0;
        }
      },
      _enum$2: function(el, selector) {
        return this._enum$3(el, selector, true);
      },
      _eint$3: function(el, selector, zeroIfNull) {
        var e, t1;
        e = J.querySelector$1$x(el, selector);
        if (e == null)
          return 0;
        else {
          t1 = e.textContent;
          return t1 !== "" ? H.Primitives_parseInt(t1, null, null) : 0;
        }
      },
      _eint$2: function(el, selector) {
        return this._eint$3(el, selector, true);
      },
      _estr$3: function(el, selector, emptyStringIfNull) {
        var e = J.querySelector$1$x(el, selector);
        if (e == null)
          return "";
        else
          return e.textContent;
      },
      _estr$2: function(el, selector) {
        return this._estr$3(el, selector, true);
      },
      _aint$3: function(el, attribute, zeroIfNull) {
        var val = J.get$attributes$x(el).$index(0, attribute);
        if (val == null)
          return zeroIfNull ? 0 : null;
        else
          return !J.$eq$(val, "") ? H.Primitives_parseInt(val, null, null) : 0;
      },
      _aint$2: function(el, attribute) {
        return this._aint$3(el, attribute, true);
      },
      _s2n$1: function(str) {
        return str != null && !J.$eq$(str, "") ? P.num_parse(str, null) : 0;
      }
    },
    MusicXmlParser2_getScoreProperties_closure: {
      "^": "Closure:6;$this,sProps",
      call$1: function(el) {
        var t1 = J.getInterceptor$x(el);
        switch (t1.get$attributes(el).$index(0, "type")) {
          case "stem":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1;
            this.sProps._stemWidth = t1;
            break;
          case "beam":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 5;
            this.sProps._beamWidth = t1;
            break;
          case "staff":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1;
            this.sProps._staffLineWidth = t1;
            break;
          case "light barline":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1.875;
            this.sProps._lightBarlineWidth = t1;
            break;
          case "heavy barline":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 5;
            this.sProps._heavyBarlineWidth = t1;
            break;
          case "leger":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1.875;
            this.sProps._legerLineWidth = t1;
            break;
          case "ending":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1;
            this.sProps._repeatEndingWidth = t1;
            break;
          case "wedge":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1;
            this.sProps._hairpinLineWidth = t1;
            break;
          case "enclosure":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1;
            this.sProps._enclosureWidth = t1;
            break;
          case "tuplet bracket":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 1;
            this.sProps._tupletBracketWidth = t1;
            break;
        }
      }
    },
    MusicXmlParser2_getScoreProperties_closure0: {
      "^": "Closure:6;$this,sProps",
      call$1: function(el) {
        var t1 = J.getInterceptor$x(el);
        switch (t1.get$attributes(el).$index(0, "type")) {
          case "grace":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 60;
            this.sProps._graceNoteSize = t1;
            break;
          case "cue":
            t1 = this.$this._s2n$1(t1.get$text(el));
            t1 = J.$gt$n(t1, 0) ? t1 : 60;
            this.sProps._cueNoteSize = t1;
            break;
        }
      }
    },
    MusicXmlParser2__createPartObj_closure: {
      "^": "Closure:6;$this",
      call$1: function(el) {
        return J.$eq$(J.get$attributes$x(el).$index(0, "id"), J.get$attributes$x(this.$this._partXML)._html$_element.getAttribute("id"));
      }
    },
    MusicXmlParser2__createPartObj_closure0: {
      "^": "Closure:6;_box_0,$this",
      call$1: function(scorePartEl) {
        var t1, t2, channel;
        t1 = this.$this;
        t2 = this._box_0;
        t2.staffName = t1._estr$2(scorePartEl, "part-name");
        t2.abbrName = t1._estr$2(scorePartEl, "part-abbreviation");
        t2.midiPreset = t1._eint$2(scorePartEl, "midi-instrument midi-program");
        channel = t1._eint$2(scorePartEl, "midi-instrument midi-channel");
        if (J.$gt$n(channel, 0))
          t2.midiChannel = channel;
      }
    },
    MusicXmlParser2_createNewMeasure_closure: {
      "^": "Closure:0;",
      call$1: function(e) {
        return J.$eq$(J.get$attributes$x(e).$index(0, "new-page"), "yes");
      }
    },
    MusicXmlParser2_createNewMeasure_closure0: {
      "^": "Closure:0;",
      call$1: function(e) {
        return J.$eq$(J.get$attributes$x(e).$index(0, "new-system"), "yes");
      }
    }
  }], ["score_data.utils", "package:score_data/src/utils.dart",, S, {
    "^": "",
    MusicXmlUtils_getMusicXmlStringFromUrl: function(url) {
      var completer, t1, exception;
      completer = new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]);
      if (url == null)
        J.complete$1$x(completer, null);
      try {
        t1 = J.getInterceptor$asx(url);
        if (t1.lastIndexOf$1(url, ".xml") === t1.get$length(url) - 4)
          W.HttpRequest_getString(url, null, null).then$1(new S.MusicXmlUtils_getMusicXmlStringFromUrl_closure(completer)).catchError$1(new S.MusicXmlUtils_getMusicXmlStringFromUrl_closure0(completer));
        else if (t1.lastIndexOf$1(url, ".mxl") === t1.get$length(url) - 4)
          W.HttpRequest_request(url, null, null, null, null, "arraybuffer", null, null).then$1(new S.MusicXmlUtils_getMusicXmlStringFromUrl_closure1(completer)).catchError$1(new S.MusicXmlUtils_getMusicXmlStringFromUrl_closure2(completer));
        else
          J.complete$1$x(completer, null);
      } catch (exception) {
        H.unwrapException(exception);
      }
      return completer.get$future();
    },
    MusicXmlUtils__verifyAndCleanMusicXmlString: function(xmlString) {
      var t1 = J.getInterceptor$asx(xmlString);
      if (t1.indexOf$1(xmlString, "score-partwise") === -1)
        return;
      return t1.replaceAll$2(xmlString, P.RegExp_RegExp("[\x03\x00]", true, false), "");
    },
    MusicXmlUtils__decompressMusicXml: function(data) {
      var t1, t2, _i, file;
      for (t1 = new T.ZipDecoder(null).decodeBuffer$2$verify(T.InputStream$(data, 0, null, 0), false).files, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        file = t1[_i];
        if (C.JSString_methods.indexOf$1(C.JSString_methods.toLowerCase$0(file.name), "meta-inf/") === -1 && C.JSString_methods.lastIndexOf$1(C.JSString_methods.toLowerCase$0(file.name), ".xml") === file.name.length - 4)
          return P.String_String$fromCharCodes(file.get$content(file), 0, null);
      }
      return;
    },
    PitchUtils_getStepsFromTopStaffLine: function(pitchName, clefType) {
      var letter, number, t1, topStaffLineStepValue;
      if (0 >= pitchName.length)
        return H.ioore(pitchName, 0);
      letter = pitchName[0];
      number = letter !== "A" && letter !== "B" ? H.Primitives_parseInt(C.JSString_methods.substring$1(pitchName, 1), null, null) : J.$add$ns(H.Primitives_parseInt(C.JSString_methods.substring$1(pitchName, 1), null, null), 1);
      if (typeof number !== "number")
        return H.iae(number);
      t1 = C.JSString_methods._codeUnitAt$1(letter, 0);
      switch (clefType) {
        case "treble":
          topStaffLineStepValue = 40;
          break;
        case "bass":
          topStaffLineStepValue = 28;
          break;
        case "tenor":
          topStaffLineStepValue = 32;
          break;
        case "alto":
          topStaffLineStepValue = 34;
          break;
        default:
          P.print(C.JSString_methods.$add("unsupported clef! nEngine.utils.PitchUtils.getStepsFromTopStaffLine: ", clefType));
          topStaffLineStepValue = 40;
      }
      return topStaffLineStepValue - (7 * number + (t1 - 65));
    },
    PitchUtils_pitchNameToDiatonicCents: function(pitchName) {
      var t1, cents;
      t1 = $.$get$PitchUtils_pitchNameCentVals();
      if (0 >= pitchName.length)
        return H.ioore(pitchName, 0);
      cents = t1.$index(0, pitchName[0]);
      t1 = J.$mul$ns(H.Primitives_parseInt(C.JSString_methods.substring$1(pitchName, 1), null, null), 1200);
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (typeof cents !== "number")
        return cents.$add();
      return cents + (1200 + t1);
    },
    PitchUtils_getTotalKeySize: function(newKey, outgoingKey) {
      var t1, t2;
      t1 = J.getInterceptor$n(newKey);
      if (t1.$lt(newKey, 0)) {
        t2 = J.getInterceptor$n(outgoingKey);
        if (t2.$lt(outgoingKey, newKey))
          return t2.$mul(outgoingKey, -1);
        else if (t2.$le(outgoingKey, 0))
          return t1.$mul(newKey, -1);
        else
          return J.$add$ns(t1.$mul(newKey, -1), outgoingKey);
      } else {
        t2 = J.getInterceptor$n(outgoingKey);
        if (t2.$gt(outgoingKey, newKey))
          return outgoingKey;
        else if (t2.$ge(outgoingKey, 0))
          return newKey;
        else
          return t1.$sub(newKey, outgoingKey);
      }
    },
    PitchUtils_getAccidentalsForNewKeySignature: function(newKey, outgoingKey) {
      var t1, numDoubleFlats, numDoubleSharps, numFlats, numNaturals, cancelStartIndex, cancelSharps, numSharps, accidentals, i, t2, t3;
      t1 = J.getInterceptor$n(newKey);
      if (t1.$lt(newKey, -7)) {
        if (typeof newKey !== "number")
          return H.iae(newKey);
        numDoubleFlats = -7 - newKey;
        newKey = -7;
        numDoubleSharps = 0;
      } else {
        if (t1.$gt(newKey, 7)) {
          numDoubleSharps = t1.$sub(newKey, 7);
          newKey = 7;
        } else
          numDoubleSharps = 0;
        numDoubleFlats = 0;
      }
      t1 = J.getInterceptor$n(outgoingKey);
      if (t1.$lt(outgoingKey, -7))
        outgoingKey = -7;
      else if (t1.$gt(outgoingKey, 7))
        outgoingKey = 7;
      if (J.$lt$n(newKey, 0)) {
        if (typeof newKey !== "number")
          return H.iae(newKey);
        numFlats = -1 * newKey;
        t1 = J.getInterceptor$n(outgoingKey);
        if (t1.$lt(outgoingKey, newKey)) {
          if (typeof outgoingKey !== "number")
            return H.iae(outgoingKey);
          numNaturals = newKey - outgoingKey;
          cancelStartIndex = newKey * -1;
          cancelSharps = false;
        } else {
          if (t1.$le(outgoingKey, 0)) {
            numNaturals = 0;
            cancelSharps = false;
          } else {
            numNaturals = outgoingKey;
            cancelSharps = true;
          }
          cancelStartIndex = 0;
        }
        numSharps = 0;
      } else {
        t1 = J.getInterceptor$n(outgoingKey);
        if (t1.$gt(outgoingKey, newKey)) {
          numNaturals = t1.$sub(outgoingKey, newKey);
          cancelStartIndex = newKey;
          cancelSharps = true;
        } else {
          if (t1.$ge(outgoingKey, 0))
            numNaturals = 0;
          else {
            if (typeof outgoingKey !== "number")
              return H.iae(outgoingKey);
            numNaturals = -1 * outgoingKey;
          }
          cancelStartIndex = 0;
          cancelSharps = false;
        }
        numSharps = newKey;
        numFlats = 0;
      }
      accidentals = H.setRuntimeTypeInfo(new Array(28), [P.int]);
      for (t1 = !cancelSharps, i = 0; i < 7; ++i) {
        if (t1) {
          t2 = J.getInterceptor$n(numNaturals);
          if (t2.$gt(numNaturals, 0)) {
            if (typeof cancelStartIndex !== "number")
              return H.iae(cancelStartIndex);
            t3 = i >= cancelStartIndex;
          } else
            t3 = false;
          if (t3) {
            accidentals[i] = 1;
            numNaturals = t2.$sub(numNaturals, 1);
            continue;
          }
        }
        accidentals[i] = 0;
      }
      for (; i < 14; ++i) {
        if (cancelSharps) {
          t1 = J.getInterceptor$n(numNaturals);
          if (t1.$gt(numNaturals, 0)) {
            if (typeof cancelStartIndex !== "number")
              return H.iae(cancelStartIndex);
            t2 = i - 7 >= cancelStartIndex;
          } else
            t2 = false;
          if (t2) {
            accidentals[i] = 1;
            numNaturals = t1.$sub(numNaturals, 1);
            continue;
          }
        }
        accidentals[i] = 0;
      }
      for (; i < 21; ++i) {
        t1 = i - 14;
        if (t1 < numDoubleFlats)
          accidentals[i] = 2;
        else if (t1 < numFlats)
          accidentals[i] = 1;
        else
          accidentals[i] = 0;
      }
      for (; i < 28; ++i) {
        t1 = i - 21;
        if (typeof numDoubleSharps !== "number")
          return H.iae(numDoubleSharps);
        if (t1 < numDoubleSharps)
          accidentals[i] = 2;
        else {
          if (typeof numSharps !== "number")
            return H.iae(numSharps);
          if (t1 < numSharps)
            accidentals[i] = 1;
          else
            accidentals[i] = 0;
        }
      }
      return accidentals;
    },
    InstrumentDO: {
      "^": "Object;id>,name>,clef<,transposition<,minKey,maxKey,ranges,fingeringMode,defaultRange",
      static: {
        InstrumentDO$: function(id, $name, clef, transposition, minKey, maxKey, ranges, defaultRange, fingeringMode) {
          var t1 = new S.InstrumentDO(id, $name, clef, transposition, minKey, maxKey, ranges, null, null);
          t1.fingeringMode = fingeringMode;
          t1.defaultRange = defaultRange;
          return t1;
        }
      }
    },
    MusicXmlUtils_getMusicXmlStringFromUrl_closure: {
      "^": "Closure:17;completer",
      call$1: [function(result) {
        var cleanString = S.MusicXmlUtils__verifyAndCleanMusicXmlString(result);
        this.completer.complete$1(0, cleanString);
      }, null, null, 2, 0, null, 7, "call"]
    },
    MusicXmlUtils_getMusicXmlStringFromUrl_closure0: {
      "^": "Closure:37;completer",
      call$1: [function(e) {
        P.print(J.toString$0$(e));
        this.completer.complete$1(0, null);
      }, null, null, 2, 0, null, 0, "call"]
    },
    MusicXmlUtils_getMusicXmlStringFromUrl_closure1: {
      "^": "Closure:23;completer",
      call$1: [function(request) {
        var data, xmlString, cleanString, t1;
        t1 = H.interceptedTypeCast(J.get$response$x(request), "$isByteBuffer");
        t1.toString;
        data = C.NativeUint8List_methods.toList$0(H.NativeUint8List_NativeUint8List$view(t1, 0, null));
        xmlString = S.MusicXmlUtils__decompressMusicXml(data);
        cleanString = xmlString != null ? S.MusicXmlUtils__verifyAndCleanMusicXmlString(xmlString) : null;
        this.completer.complete$1(0, cleanString);
      }, null, null, 2, 0, null, 37, "call"]
    },
    MusicXmlUtils_getMusicXmlStringFromUrl_closure2: {
      "^": "Closure:0;completer",
      call$1: [function(e) {
        P.print(J.toString$0$(e));
        this.completer.complete$1(0, null);
      }, null, null, 2, 0, null, 0, "call"]
    },
    PointXY: {
      "^": "Object;x*,y*"
    }
  }], ["score_performance.audio", "package:score_performance/src/audio.dart",, E, {
    "^": "",
    SFPerformanceNoteMaker: {
      "^": "Object;_sequenceBuilder,_audio$_sfLoader,_tempoRatio,_sampleTimeStamps,_beats,_countoffBeats,_qNotesPerCountoffBeat",
      _getNoteOrStackTime$1: function(ng) {
        var stackTime = J.get$measure$x(J.get$voice$x(ng))._stack._startTime;
        return J.$gt$n(ng.get$qNoteTime(), stackTime) ? ng.get$qNoteTime() : stackTime;
      },
      _getPlaybackRegions$4: function(startQNoteTime, endQNoteTime, playbackPath, measures) {
        var t1, _getNoteGroupAtTime, regions, beginningFound, latestEndRegionIndex, i, t2, ng, stackTime, t3;
        if (playbackPath == null || C.JSInt_methods.$mod(playbackPath.length, 2) !== 0) {
          t1 = new E.PlaybackRegion(null, null, null);
          t1.qNoteStartTime = startQNoteTime;
          t1.qNoteEndTime = endQNoteTime;
          return [t1];
        }
        _getNoteGroupAtTime = new E.SFPerformanceNoteMaker__getPlaybackRegions__getNoteGroupAtTime(measures);
        regions = [];
        for (beginningFound = false, latestEndRegionIndex = null, i = 0; i < playbackPath.length - 1; i += 2) {
          if (!beginningFound)
            if (J.$le$n(playbackPath[i], startQNoteTime)) {
              t1 = i + 1;
              if (t1 >= playbackPath.length)
                return H.ioore(playbackPath, t1);
              t1 = J.$gt$n(playbackPath[t1], startQNoteTime);
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            beginningFound = true;
          if (beginningFound) {
            if (i >= playbackPath.length)
              return H.ioore(playbackPath, i);
            if (J.$lt$n(playbackPath[i], endQNoteTime)) {
              t1 = i + 1;
              if (t1 >= playbackPath.length)
                return H.ioore(playbackPath, t1);
              t1 = J.$ge$n(playbackPath[t1], endQNoteTime);
            } else
              t1 = false;
            if (t1)
              latestEndRegionIndex = regions.length;
            t1 = regions.length;
            t2 = playbackPath.length;
            if (t1 === 0) {
              t1 = i + 1;
              if (t1 >= t2)
                return H.ioore(playbackPath, t1);
              t1 = playbackPath[t1];
              t2 = new E.PlaybackRegion(null, null, null);
              t2.qNoteStartTime = startQNoteTime;
              t2.qNoteEndTime = t1;
              regions.push(t2);
            } else {
              if (i >= t2)
                return H.ioore(playbackPath, i);
              ng = _getNoteGroupAtTime.call$1(playbackPath[i]);
              stackTime = J.get$measure$x(J.get$voice$x(ng))._stack._startTime;
              t1 = J.$gt$n(ng.get$qNoteTime(), stackTime) ? ng.get$qNoteTime() : stackTime;
              t2 = i + 1;
              if (t2 >= playbackPath.length)
                return H.ioore(playbackPath, t2);
              t2 = playbackPath[t2];
              t3 = new E.PlaybackRegion(null, null, null);
              t3.qNoteStartTime = t1;
              t3.qNoteEndTime = t2;
              regions.push(t3);
            }
          }
        }
        if (beginningFound && latestEndRegionIndex != null) {
          if (latestEndRegionIndex !== (latestEndRegionIndex | 0) || latestEndRegionIndex >= regions.length)
            return H.ioore(regions, latestEndRegionIndex);
          regions[latestEndRegionIndex].qNoteEndTime = endQNoteTime;
          return C.JSArray_methods.sublist$2(regions, 0, latestEndRegionIndex + 1);
        } else {
          t1 = new E.PlaybackRegion(null, null, null);
          t1.qNoteStartTime = startQNoteTime;
          t1.qNoteEndTime = endQNoteTime;
          return [t1];
        }
      },
      _getTempoMarkers$1: function(measures) {
        var numMeasures, firstStack, t1, t2, tempoMarker, lastStack, t3, markers, i, _i;
        numMeasures = measures.length;
        if (0 >= numMeasures)
          return H.ioore(measures, 0);
        firstStack = measures[0].get$stack();
        t1 = firstStack._tempoMarkers;
        if (t1 != null) {
          t2 = t1.length;
          if (t2 !== 0) {
            if (0 >= t2)
              return H.ioore(t1, 0);
            t1 = J.$gt$n(t1[0]._data$_qNoteTime, 0);
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1) {
          tempoMarker = new O.TempoMarker(null, null, 0);
          tempoMarker._tempo = 90;
          tempoMarker._data$_qNoteTime = 0;
          firstStack._tempoMarkers = [tempoMarker];
        }
        t1 = numMeasures - 1;
        if (t1 < 0 || t1 >= measures.length)
          return H.ioore(measures, t1);
        lastStack = measures[t1].get$stack();
        t1 = lastStack._tempoMarkers;
        if (t1 != null) {
          t2 = t1.length;
          if (t2 !== 0) {
            t3 = t2 - 1;
            if (t3 < 0)
              return H.ioore(t1, t3);
            t3 = J.$lt$n(t1[t3]._data$_qNoteTime, lastStack._endTime);
            t1 = t3;
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1) {
          t1 = lastStack._tempoMarkers;
          if (t1 == null) {
            t1 = [];
            lastStack._tempoMarkers = t1;
          }
          tempoMarker = new O.TempoMarker(null, null, 0);
          tempoMarker._tempo = 120;
          tempoMarker._data$_qNoteTime = lastStack._endTime;
          t1.push(tempoMarker);
        }
        markers = [];
        for (i = 0; i < numMeasures; ++i) {
          if (i >= measures.length)
            return H.ioore(measures, i);
          t1 = measures[i].get$stack()._tempoMarkers;
          if (t1 != null)
            for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
              markers.push(t1[_i]);
        }
        return markers;
      },
      _getMostRecentTempoMarker$2: function(markers, qNoteTime) {
        var tmIndex;
        for (tmIndex = markers.length - 1; tmIndex >= 0; --tmIndex) {
          if (tmIndex >= markers.length)
            return H.ioore(markers, tmIndex);
          if (J.$le$n(markers[tmIndex].get$qNoteTime(), qNoteTime)) {
            if (tmIndex >= markers.length)
              return H.ioore(markers, tmIndex);
            return markers[tmIndex];
          }
        }
        if (0 >= markers.length)
          return H.ioore(markers, 0);
        return markers[0];
      },
      _calculateQNoteStartTime$4: function(startQNoteTime, startMeasure, actualCountoffTempo, numCountoffBeats) {
        var beatType, distToBar, distToNearestBeat, t1;
        beatType = startMeasure._beatType;
        if (J.$mod$n(beatType, 8) === 0 && J.$ge$n(actualCountoffTempo, 80)) {
          if (typeof beatType !== "number")
            return H.iae(beatType);
          this._qNotesPerCountoffBeat = 3 * (4 / beatType);
        } else {
          if (typeof beatType !== "number")
            return H.iae(beatType);
          this._qNotesPerCountoffBeat = 4 / beatType;
        }
        distToBar = J.$sub$n(startMeasure._stack._endTime, startQNoteTime);
        for (distToNearestBeat = distToBar; t1 = J.getInterceptor$n(distToNearestBeat), t1.$ge(distToNearestBeat, this._qNotesPerCountoffBeat);)
          distToNearestBeat = t1.$sub(distToNearestBeat, this._qNotesPerCountoffBeat);
        if (typeof distToNearestBeat !== "number")
          return H.iae(distToNearestBeat);
        t1 = this._qNotesPerCountoffBeat;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return J.$sub$n(startQNoteTime, (numCountoffBeats - distToNearestBeat) * t1);
      },
      _createSampleTimeStamps$4: function(startQNoteTime, startNGMarkerTempo, tempoMarkers, regions) {
        var sampleTimeStamps, timeStamp, lastStampQNoteTime, cSampleToQNoteRatio, lastStampSampleTime, regionIndex, region, tm, tmIndex, t1, qNoteDelta, prevStamp, sampleTime, prevTS, endQNoteTime, finalTS;
        sampleTimeStamps = [];
        timeStamp = new E.SampleTimeStampDO(0, 0, startQNoteTime, null, null, 120);
        timeStamp.tempo = J.$mul$ns(startNGMarkerTempo, this._tempoRatio);
        sampleTimeStamps.push(timeStamp);
        lastStampQNoteTime = timeStamp.qNoteTime;
        cSampleToQNoteRatio = 44100 / J.$div$n(timeStamp.tempo, 60);
        for (lastStampSampleTime = 0, regionIndex = 0; regionIndex < regions.length; ++regionIndex) {
          region = regions[regionIndex];
          tmIndex = tempoMarkers.length - 1;
          while (true) {
            if (!(tmIndex >= 0)) {
              tm = null;
              break;
            }
            if (tmIndex >= tempoMarkers.length)
              return H.ioore(tempoMarkers, tmIndex);
            if (J.$le$n(tempoMarkers[tmIndex].get$qNoteTime(), region.get$qNoteStartTime())) {
              if (tmIndex >= tempoMarkers.length)
                return H.ioore(tempoMarkers, tmIndex);
              tm = tempoMarkers[tmIndex];
              break;
            }
            --tmIndex;
          }
          if (regionIndex > 0) {
            t1 = regionIndex - 1;
            if (t1 >= regions.length)
              return H.ioore(regions, t1);
            qNoteDelta = J.$sub$n(regions[t1].get$qNoteEndTime(), lastStampQNoteTime);
          } else {
            t1 = region.get$qNoteStartTime();
            if (0 >= sampleTimeStamps.length)
              return H.ioore(sampleTimeStamps, 0);
            qNoteDelta = J.$sub$n(t1, sampleTimeStamps[0].qNoteTime);
          }
          prevStamp = C.JSArray_methods.get$last(sampleTimeStamps);
          prevStamp.qNoteEndTime = J.$add$ns(prevStamp.qNoteTime, qNoteDelta);
          if (typeof qNoteDelta !== "number")
            return H.iae(qNoteDelta);
          sampleTime = lastStampSampleTime + C.JSDouble_methods.toInt$0(cSampleToQNoteRatio * qNoteDelta);
          timeStamp = new E.SampleTimeStampDO(sampleTime, 0, region.get$qNoteStartTime(), null, null, 120);
          timeStamp.msTime = C.JSInt_methods.$tdiv(sampleTime, 44.1);
          t1 = J.$mul$ns(tm.get$tempo(), this._tempoRatio);
          timeStamp.tempo = t1;
          cSampleToQNoteRatio = 44100 / J.$div$n(t1, 60);
          prevStamp.nextSampleTimeStampDO = timeStamp;
          sampleTimeStamps.push(timeStamp);
          region.set$timeStamps([timeStamp]);
          lastStampQNoteTime = timeStamp.qNoteTime;
          ++tmIndex;
          lastStampSampleTime = sampleTime;
          while (true) {
            t1 = tempoMarkers.length;
            if (tmIndex < t1) {
              if (tmIndex < 0)
                return H.ioore(tempoMarkers, tmIndex);
              t1 = J.$lt$n(tempoMarkers[tmIndex].get$qNoteTime(), region.get$qNoteEndTime());
            } else
              t1 = false;
            if (!t1)
              break;
            if (tmIndex < 0 || tmIndex >= tempoMarkers.length)
              return H.ioore(tempoMarkers, tmIndex);
            tm = tempoMarkers[tmIndex];
            qNoteDelta = J.$sub$n(tm.get$qNoteTime(), lastStampQNoteTime);
            prevStamp = C.JSArray_methods.get$last(sampleTimeStamps);
            prevStamp.qNoteEndTime = J.$add$ns(prevStamp.qNoteTime, qNoteDelta);
            if (typeof qNoteDelta !== "number")
              return H.iae(qNoteDelta);
            sampleTime = lastStampSampleTime + C.JSDouble_methods.toInt$0(cSampleToQNoteRatio * qNoteDelta);
            timeStamp = new E.SampleTimeStampDO(sampleTime, 0, tm.get$qNoteTime(), null, null, 120);
            timeStamp.msTime = C.JSInt_methods.$tdiv(sampleTime, 44.1);
            t1 = J.$mul$ns(tm.get$tempo(), this._tempoRatio);
            timeStamp.tempo = t1;
            cSampleToQNoteRatio = 44100 / J.$div$n(t1, 60);
            prevStamp.nextSampleTimeStampDO = timeStamp;
            sampleTimeStamps.push(timeStamp);
            region.get$timeStamps().push(timeStamp);
            lastStampQNoteTime = timeStamp.qNoteTime;
            ++tmIndex;
            lastStampSampleTime = sampleTime;
          }
        }
        if (J.$lt$n(C.JSArray_methods.get$last(sampleTimeStamps).qNoteTime, C.JSArray_methods.get$last(regions).get$qNoteEndTime())) {
          prevTS = C.JSArray_methods.get$last(sampleTimeStamps);
          endQNoteTime = C.JSArray_methods.get$last(regions).get$qNoteEndTime();
          qNoteDelta = J.$sub$n(endQNoteTime, prevTS.qNoteTime);
          prevTS.qNoteEndTime = J.$add$ns(prevTS.qNoteTime, qNoteDelta);
          t1 = J.$div$n(prevTS.tempo, 60);
          if (typeof qNoteDelta !== "number")
            return H.iae(qNoteDelta);
          sampleTime = prevTS.sampleTime + C.JSDouble_methods.toInt$0(44100 / t1 * qNoteDelta);
          finalTS = new E.SampleTimeStampDO(sampleTime, 0, endQNoteTime, null, null, 120);
          finalTS.msTime = C.JSInt_methods.$tdiv(sampleTime, 44.1);
          finalTS.tempo = prevTS.tempo;
          finalTS.qNoteEndTime = endQNoteTime;
          prevTS.nextSampleTimeStampDO = finalTS;
          sampleTimeStamps.push(finalTS);
        }
        return sampleTimeStamps;
      },
      _getTimeStamp$2: function(qNoteTime, timeStamps) {
        var tsIndex, t1;
        for (tsIndex = timeStamps.length - 1; tsIndex >= 0; --tsIndex) {
          if (tsIndex >= timeStamps.length)
            return H.ioore(timeStamps, tsIndex);
          if (J.$le$n(timeStamps[tsIndex].qNoteTime, qNoteTime)) {
            if (tsIndex >= timeStamps.length)
              return H.ioore(timeStamps, tsIndex);
            return timeStamps[tsIndex];
          }
        }
        t1 = this._sampleTimeStamps;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return t1[0];
      },
      _createPlaybackNotes$3: function(parts, playSoundFontNotes, regions) {
        var t1, timeStamp, _i, part, t2, t3, t4, noteGroups, numNoteGroups, pan, partVol, measureStartDynamic, cMeasure, _i0, region, startQNoteTime, endQNoteTime, i, ng, notes, numNotes, t5, t6, startTime, ngQnDur, duration, tempIndex, tieDuration, j, note, tempIndex0, tieEndFound, nextNG, nextNoteTimeStamp, nextNGsNotes, tieTargetFound, _i1, nextNote, t7, tieDuration0, measure, t8, noteVolume, attachment, t9, t10, pNoteDO;
        for (t1 = parts.length, timeStamp = null, _i = 0; _i < parts.length; parts.length === t1 || (0, H.throwConcurrentModificationError)(parts), ++_i) {
          part = parts[_i];
          t2 = this._sequenceBuilder;
          t3 = J.$mod$n(part.get$midiChannel(), 16);
          t4 = this._audio$_sfLoader;
          t2._preset = t3 !== 10 ? t4.getPreset$2(part.get$midiPreset(), 0) : t4.getPreset$2(0, 128);
          noteGroups = part.get$noteGroups();
          numNoteGroups = noteGroups.length;
          t2 = J.getInterceptor$x(part);
          pan = t2.get$pan(part);
          partVol = t2.get$volume(part);
          if (typeof partVol !== "number")
            return partVol.$mul();
          measureStartDynamic = partVol * 0.4;
          for (t3 = regions.length, cMeasure = null, _i0 = 0; _i0 < regions.length; regions.length === t3 || (0, H.throwConcurrentModificationError)(regions), ++_i0) {
            region = regions[_i0];
            startQNoteTime = region.get$qNoteStartTime();
            endQNoteTime = region.get$qNoteEndTime();
            for (t4 = J.getInterceptor$n(endQNoteTime), i = 0; i < numNoteGroups; ++i) {
              if (i >= noteGroups.length)
                return H.ioore(noteGroups, i);
              ng = noteGroups[i];
              if (J.$ge$n(ng.get$qNoteTime(), endQNoteTime))
                continue;
              notes = ng.get$notes();
              numNotes = notes.length;
              timeStamp = this._getTimeStamp$2(ng.get$qNoteTime(), region.get$timeStamps());
              t5 = J.$sub$n(ng.get$qNoteTime(), timeStamp.qNoteTime);
              t6 = timeStamp.tempo;
              if (typeof t6 !== "number")
                return H.iae(t6);
              startTime = timeStamp.sampleTime + J.toInt$0$n(J.$mul$ns(J.$mul$ns(t5, 60 / t6), 44100));
              if (startTime < 0)
                startTime = 0;
              ng.set$playbackStartTime(startTime);
              ng.set$playbackTempo(timeStamp.tempo);
              if (t2.get$muted(part) === true || false)
                continue;
              ngQnDur = J.$le$n(J.$add$ns(ng.get$qNoteTime(), ng.get$qNoteDuration()), endQNoteTime) ? ng.get$qNoteDuration() : t4.$sub(endQNoteTime, ng.get$qNoteTime());
              if (!ng.get$isGrace()) {
                t5 = timeStamp.tempo;
                if (typeof t5 !== "number")
                  return H.iae(t5);
                duration = J.toInt$0$n(J.$mul$ns(ngQnDur, 60 / t5 * 44100));
              } else
                duration = C.JSDouble_methods.toInt$0(2756.25);
              for (t5 = J.getInterceptor$x(ng), tempIndex = i + 1, tieDuration = 0, j = 0; j < numNotes; ++j) {
                if (j >= notes.length)
                  return H.ioore(notes, j);
                note = notes[j];
                t6 = note._tieState;
                if (t6 !== "none")
                  if (t6 === "start") {
                    tempIndex0 = tempIndex;
                    tieDuration = 0;
                    tieEndFound = false;
                    while (true) {
                      if (!(!tieEndFound && tempIndex0 < numNoteGroups))
                        break;
                      if (tempIndex0 >= noteGroups.length)
                        return H.ioore(noteGroups, tempIndex0);
                      nextNG = noteGroups[tempIndex0];
                      nextNoteTimeStamp = this._getTimeStamp$2(nextNG.get$qNoteTime(), region.get$timeStamps());
                      if (J.$eq$(J.get$voice$x(nextNG).get$number(), t5.get$voice(ng).get$number())) {
                        nextNGsNotes = nextNG.get$notes();
                        t6 = nextNGsNotes.length;
                        _i1 = 0;
                        while (true) {
                          if (!(_i1 < nextNGsNotes.length)) {
                            tieTargetFound = false;
                            break;
                          }
                          nextNote = nextNGsNotes[_i1];
                          if (nextNote.get$displayCents() === note._displayCents)
                            if (nextNote.get$tieState() === "stop") {
                              t6 = nextNG.get$qNoteDuration();
                              t7 = nextNoteTimeStamp.tempo;
                              if (typeof t7 !== "number")
                                return H.iae(t7);
                              tieDuration0 = tieDuration + C.JSNumber_methods.toInt$0(t6 * (60 / t7 * 44100));
                              tieDuration = tieDuration0;
                              tieEndFound = true;
                              tieTargetFound = true;
                              break;
                            } else if (nextNote.get$tieState() === "continue") {
                              t6 = nextNG.get$qNoteDuration();
                              t7 = nextNoteTimeStamp.tempo;
                              if (typeof t7 !== "number")
                                return H.iae(t7);
                              tieDuration0 = tieDuration + C.JSNumber_methods.toInt$0(t6 * (60 / t7 * 44100));
                              tieDuration = tieDuration0;
                              tieTargetFound = true;
                              break;
                            }
                          nextNGsNotes.length === t6 || (0, H.throwConcurrentModificationError)(nextNGsNotes);
                          ++_i1;
                        }
                        if (!tieTargetFound)
                          break;
                      }
                      ++tempIndex0;
                    }
                  } else
                    continue;
                measure = J.get$measure$x(t5.get$voice(ng));
                if (cMeasure == null ? measure != null : cMeasure !== measure) {
                  if (cMeasure != null)
                    for (t6 = cMeasure._attachments, t7 = t6.length, _i1 = 0; t8 = t6.length, _i1 < t8; t8 === t7 || (0, H.throwConcurrentModificationError)(t6), ++_i1)
                      measureStartDynamic = t6[_i1]._volume * partVol;
                  cMeasure = measure;
                }
                for (t6 = measure._attachments, t7 = t6.length, noteVolume = measureStartDynamic, _i1 = 0; _i1 < t6.length; t6.length === t7 || (0, H.throwConcurrentModificationError)(t6), ++_i1) {
                  attachment = t6[_i1];
                  if (J.$le$n(attachment.get$qNoteTime(), ng.get$qNoteTime()) && true)
                    noteVolume = attachment._volume * partVol;
                }
                if (J.$lt$n(ng.get$qNoteTime(), startQNoteTime))
                  continue;
                t6 = duration + tieDuration;
                if (J.$le$n(note._playbackCents, 0)) {
                  t7 = C.JSNumber_methods._tdivFast$1(note._displayCents, 100);
                  t8 = part.get$chromaticTransposition();
                  t9 = part.get$playbackOctaveDelta();
                  t10 = this._sequenceBuilder;
                  pNoteDO = L.PerformanceNoteDO_createPerformanceNote(t7 - t8 + 12 * t9, startTime, t6, noteVolume, pan, t10._preset);
                  if (pNoteDO != null)
                    t10._sequence.push(pNoteDO);
                } else {
                  t7 = this._sequenceBuilder;
                  pNoteDO = L.PerformanceNoteDO_createPerformanceNote(J.$tdiv$n(note._playbackCents, 100), startTime, t6, noteVolume, pan, t7._preset);
                  if (pNoteDO != null)
                    t7._sequence.push(pNoteDO);
                }
              }
            }
          }
        }
      },
      _createMetronomeBeats$3: function(parts, metronomeVolume, regions) {
        var t1, measures, actualMetVolume, beatQNoteTime, beatSampleTime, _i, region, startQNoteTime, endQNoteTime, t2, _i0, measure, t3, t4, pickupBeatDuration, pickupBeatTime, numBeats, beatType, i, timeStamp, actualMetVolume0, metronomeNote, t5, pNoteDO;
        this._beats = [];
        this._sequenceBuilder._preset = this._audio$_sfLoader.getPreset$2(0, 128);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        t1 = parts[0].get$staves();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        measures = t1[0]._measures;
        for (t1 = regions.length, actualMetVolume = metronomeVolume * 0.8, beatQNoteTime = 0, beatSampleTime = 0, _i = 0; _i < regions.length; regions.length === t1 || (0, H.throwConcurrentModificationError)(regions), ++_i) {
          region = regions[_i];
          startQNoteTime = region.get$qNoteStartTime();
          endQNoteTime = region.get$qNoteEndTime();
          for (t2 = measures.length, _i0 = 0; _i0 < measures.length; measures.length === t2 || (0, H.throwConcurrentModificationError)(measures), ++_i0) {
            measure = measures[_i0];
            if (measure.get$stack()._isPickup) {
              beatQNoteTime = measure.get$stack()._endTime;
              if (measure.get$beatGroups().length > 1) {
                t3 = measure.get$beatGroups();
                if (1 >= t3.length)
                  return H.ioore(t3, 1);
                t3 = t3[1];
                t4 = measure.get$beatGroups();
                if (0 >= t4.length)
                  return H.ioore(t4, 0);
                pickupBeatDuration = J.$sub$n(t3, t4[0]);
              } else
                pickupBeatDuration = measure.get$stack()._endTime;
              for (pickupBeatTime = beatQNoteTime; t3 = J.getInterceptor$n(pickupBeatTime), J.$ge$n(t3.$sub(pickupBeatTime, pickupBeatDuration), 0);) {
                pickupBeatTime = t3.$sub(pickupBeatTime, pickupBeatDuration);
                t3 = J.getInterceptor$n(pickupBeatTime);
                if (t3.$ge(pickupBeatTime, startQNoteTime) && t3.$lt(pickupBeatTime, endQNoteTime)) {
                  t3 = this._beats;
                  (t3 && C.JSArray_methods).insert$2(t3, 0, pickupBeatTime);
                }
              }
              continue;
            }
            beatQNoteTime = measure.get$stack()._startTime;
            numBeats = measure.get$numBeats();
            beatType = measure.get$beatType();
            if (typeof numBeats !== "number")
              return H.iae(numBeats);
            t3 = J.getInterceptor$n(beatType);
            i = 0;
            for (; i < numBeats; ++i) {
              if (typeof startQNoteTime !== "number")
                return H.iae(startQNoteTime);
              if (beatQNoteTime >= startQNoteTime) {
                if (typeof endQNoteTime !== "number")
                  return H.iae(endQNoteTime);
                t4 = beatQNoteTime < endQNoteTime;
              } else
                t4 = false;
              if (t4) {
                timeStamp = this._getTimeStamp$2(beatQNoteTime, region.get$timeStamps());
                if (t3.$mod(beatType, 8) !== 0 || i % 3 === 0 || J.$lt$n(timeStamp.tempo, 80)) {
                  this._beats.push(beatQNoteTime);
                  if (beatQNoteTime !== measure.get$stack()._startTime) {
                    actualMetVolume0 = actualMetVolume;
                    metronomeNote = 37;
                  } else {
                    actualMetVolume0 = metronomeVolume;
                    metronomeNote = 33;
                  }
                  t4 = timeStamp.qNoteTime;
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  t5 = timeStamp.tempo;
                  if (typeof t5 !== "number")
                    return H.iae(t5);
                  beatSampleTime = timeStamp.sampleTime + C.JSNumber_methods.toInt$0((beatQNoteTime - t4) * (60 / t5) * 44100);
                  if (!(beatQNoteTime < startQNoteTime)) {
                    if (typeof endQNoteTime !== "number")
                      return H.iae(endQNoteTime);
                    t4 = beatQNoteTime >= endQNoteTime;
                  } else
                    t4 = true;
                  if (t4)
                    continue;
                  t4 = this._sequenceBuilder;
                  pNoteDO = L.PerformanceNoteDO_createPerformanceNote(metronomeNote, beatSampleTime, 5512, actualMetVolume0, 0.5, t4._preset);
                  if (pNoteDO != null)
                    t4._sequence.push(pNoteDO);
                }
              }
              if (typeof beatType !== "number")
                return H.iae(beatType);
              beatQNoteTime += 4 / beatType;
            }
          }
        }
      },
      _createCountoffClicks$3: function(numCountoffBeats, startNGMarkerTempo, startQNoteTime) {
        var cSampleToQNoteRatio, qNoteTime, remainingClicks, clickPos, t1, pNoteDO;
        this._sequenceBuilder._preset = this._audio$_sfLoader.getPreset$2(0, 128);
        cSampleToQNoteRatio = 44100 / J.$div$n(J.$mul$ns(startNGMarkerTempo, this._tempoRatio), 60);
        this._countoffBeats = [];
        for (qNoteTime = startQNoteTime, remainingClicks = numCountoffBeats, clickPos = 0; remainingClicks > 0;) {
          t1 = this._sequenceBuilder;
          pNoteDO = L.PerformanceNoteDO_createPerformanceNote(37, clickPos, 5512, 0.8, 0.5, t1._preset);
          if (pNoteDO != null)
            t1._sequence.push(pNoteDO);
          t1 = this._qNotesPerCountoffBeat;
          if (typeof t1 !== "number")
            return t1.$mul();
          clickPos += C.JSNumber_methods.toInt$0(t1 * cSampleToQNoteRatio);
          --remainingClicks;
          this._countoffBeats.push(qNoteTime);
          qNoteTime = J.$add$ns(qNoteTime, this._qNotesPerCountoffBeat);
        }
      }
    },
    SFPerformanceNoteMaker__getPlaybackRegions__getNoteGroupAtTime: {
      "^": "Closure:38;measures",
      call$1: function(qNoteTime) {
        var t1, i, t2;
        for (t1 = this.measures, i = t1.length - 1; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = t1[i].get$stack()._startTime;
          if (typeof qNoteTime !== "number")
            return H.iae(qNoteTime);
          if (t2 <= qNoteTime) {
            if (i >= t1.length)
              return H.ioore(t1, i);
            t2 = t1[i].get$voices();
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            t2 = t2[0].get$noteGroups();
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            return t2[0];
          }
        }
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].get$voices();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].get$noteGroups();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return t1[0];
      }
    },
    PlaybackRegion: {
      "^": "Object;qNoteStartTime<,qNoteEndTime<,timeStamps@"
    },
    SampleTimeStampDO: {
      "^": "Object;sampleTime,msTime<,qNoteTime@,qNoteEndTime<,nextSampleTimeStampDO<,tempo<"
    }
  }], ["score_performance.stagexl", "package:score_performance/src/stagexl.dart",, F, {
    "^": "",
    SFScoreDriver: {
      "^": "Object;_drawManager,_sfLoader,_performanceNoteMaker,_sfPlayer,_micManager,_stagexl$_score,_parser,_renderer,_scoreViewer,_stagexl$_isPlaying,_assessor,_instrument,_playbackCompleteCallback,_numInitializedComponents,_initDriverCallback",
      _stagexl$_init$3: function(sf2AudioUrl, sf2XmlUrl, instrument) {
        var t1, t2, t3, t4, t5;
        this._drawManager = new F.SFDriverDrawManager(this, null, 0, 0, null);
        if ($.SFPlayer__context == null) {
          $.SFPlayer__context = new (window.AudioContext || window.webkitAudioContext)();
          t1 = new L.SFLoader(null, null, null, null, null, null, null, null, new P._AsyncStreamController(null, 0, null, null, null, null, null, [P.String]));
          this._sfLoader = t1;
          t2 = this.get$_checkDriverReady();
          t1._sfReadyCallback = t2;
          t1._numLoadedFiles = 0;
          t1._loadJsonFile$1(sf2XmlUrl);
          t3 = $.SFPlayer__context;
          t4 = new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [null]);
          t5 = new K.AudioBufferLoader(null, null, null, null, 0, null, t4, null);
          t5._context = t3;
          t5._urlList = [sf2AudioUrl];
          t5._callback = t1.get$_onSFLoaded();
          t5._bufferList = [];
          t1._bufferLoader = t5;
          t1._audioLoadProgressListener = new P._BroadcastStream(t4, [null]).listen$1(t1.get$_onAudioLoadProgress());
          t1._bufferLoader.load$0(0);
          t1 = new D.BitmapMusicRenderer(null, null, null, null, null, null, null);
          t1._rendererReadyCallback = t2;
          $.MusicTextures_onCompleteFunction = t2;
          G.MusicTextures_createTextures();
          this._renderer = t1;
        }
        t1 = $.SFPlayer__context;
        $.AudioManager_context = t1;
        this._micManager = K.MicManager$(t1);
        instrument = $.$get$InstrumentUtils_instruments()[0];
        this._instrument = instrument;
      },
      parseScore$5: function(musicXmlString, computeMaxKeySizeForRendering, overrideScoreProps, scoreProps, keepParserObject) {
        var t1, t2, t3, t4, completer, parser;
        t1 = $.Zone__current;
        t2 = [null];
        t3 = new P._Future(0, t1, null, t2);
        t4 = [null];
        completer = new P._AsyncCompleter(t3, t4);
        parser = new S.MusicXmlParser2(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        parser._musicXMLString = musicXmlString;
        parser._computeMaxKeySizeForRendering = true;
        parser._overrideScoreProps = true;
        parser._requestedScoreProps = scoreProps;
        parser._parsingCompleter = new P._AsyncCompleter(new P._Future(0, t1, null, t2), t4);
        P.Timer_Timer(C.Duration_0, parser.get$_getMusicXMLObject());
        parser._parsingCompleter.future.then$1(new F.SFScoreDriver_parseScore_closure(this, false, completer, parser)).catchError$1(new F.SFScoreDriver_parseScore_closure0(completer));
        return t3;
      },
      parseScore$3: function(musicXmlString, computeMaxKeySizeForRendering, overrideScoreProps) {
        return this.parseScore$5(musicXmlString, computeMaxKeySizeForRendering, overrideScoreProps, null, false);
      },
      play$11$assessmentType$countoffBeats$countoffSeconds$endQNoteTime$instDO$metronomeVolume$playRepeats$playSoundFontNotes$startNG$tempoRatio: function(_, playbackCompleteCallback, assessmentType, countoffBeats, countoffSeconds, endQNoteTime, instDO, metronomeVolume, playRepeats, playSoundFontNotes, startNG, tempoRatio) {
        var t1, t2, t3, playbackPath, measures, startNG0, startQNoteTime, regions, tempoMarkers, startNGMarkerTempo, realStartQNoteTime, beatList, countoffBeatList;
        t1 = this._sfPlayer;
        t2 = t1 == null;
        if (!t2 && t1._isPlaying)
          return;
        t1 = this._sfLoader;
        if (t1 == null || this._stagexl$_score == null)
          H.throwExpression("must call both initSFEngine and renderNotation before playback.");
        if (this._performanceNoteMaker == null) {
          t3 = new E.SFPerformanceNoteMaker(null, null, null, null, null, null, null);
          t3._audio$_sfLoader = t1;
          t1 = new L.SequenceBuilder(null, null);
          t1._sequence = [];
          t3._sequenceBuilder = t1;
          this._performanceNoteMaker = t3;
        }
        if (t2)
          this._sfPlayer = new L.SFPlayer(null, null, -1, null, null, false, null, 44100, []);
        countoffBeats = this._getCountoffBeatsForSeconds$3(countoffSeconds, startNG, tempoRatio);
        if (playRepeats) {
          if (this._stagexl$_score.get$playbackPath() == null)
            this._stagexl$_score.updatePlaybackPath$0();
          playbackPath = this._stagexl$_score.get$playbackPath();
        } else
          playbackPath = null;
        t1 = this._performanceNoteMaker;
        t2 = this._stagexl$_score.get$parts();
        t1._sequenceBuilder._sequence = [];
        t1._tempoRatio = tempoRatio;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t3 = t2[0].get$staves();
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        measures = t3[0]._measures;
        if (startNG == null) {
          if (0 >= measures.length)
            return H.ioore(measures, 0);
          t3 = measures[0].get$voices();
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          t3 = t3[0].get$noteGroups();
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          startNG0 = t3[0];
        } else
          startNG0 = startNG;
        startQNoteTime = t1._getNoteOrStackTime$1(startNG0);
        regions = t1._getPlaybackRegions$4(startQNoteTime, endQNoteTime == null ? C.JSArray_methods.get$last(measures).get$stack()._endTime : endQNoteTime, playbackPath, measures);
        tempoMarkers = t1._getTempoMarkers$1(measures);
        startNGMarkerTempo = t1._getMostRecentTempoMarker$2(tempoMarkers, startQNoteTime).get$tempo();
        realStartQNoteTime = t1._calculateQNoteStartTime$4(startQNoteTime, J.get$measure$x(J.get$voice$x(startNG0)), J.$mul$ns(startNGMarkerTempo, t1._tempoRatio), countoffBeats);
        t1._sampleTimeStamps = t1._createSampleTimeStamps$4(realStartQNoteTime, startNGMarkerTempo, tempoMarkers, regions);
        t1._createPlaybackNotes$3(t2, true, regions);
        t1._createMetronomeBeats$3(t2, metronomeVolume, regions);
        t1._createCountoffClicks$3(countoffBeats, startNGMarkerTempo, realStartQNoteTime);
        t1 = this._sfPlayer;
        t1._pNoteDOs = [];
        t1._pNoteDOs = this._performanceNoteMaker._sequenceBuilder.get$sequence();
        if (assessmentType === C.AssessmentType_0)
          this._assessor = null;
        else if (assessmentType === C.AssessmentType_1) {
          t1 = this._scoreViewer;
          t2 = this._sfPlayer;
          t3 = this._sfLoader;
          t1 = new F.RhythmAssessor(null, null, null, null, null, null, null, null, null, null, 0.25, null, t1, null, 0, 0, 0);
          t1._stagexl$_init$0();
          t1._sfPlayer = t2;
          t1._sfLoader = t3;
          this._assessor = t1;
        } else if (assessmentType === C.AssessmentType_3 && this._micManager._micPermissionGranted) {
          t1 = new F.PitchAssessor(null, null, null, null, null, null, null, null, null, 0.8, null, null, null, "", "", null, null, null, false, null, this._scoreViewer, null, 0, 0, 0);
          t1._stagexl$_init$0();
          this._assessor = t1;
          t2 = Q.AssessmentInstrumentUtils_getInstrumentByID(this._instrument.id);
          t1._inst = t2;
          if (t2 == null)
            H.throwExpression("InstrumentDO.id doesn't match an assessment inst");
          t1._pitchRecognizer.setInstrument$1(t2);
          t2 = t1._noteSplitter;
          t1 = t1._inst;
          t2.toString;
          if (t1.get$psMinStablePitches() != null)
            t2._osMinStablePitches = t1.get$psMinStablePitches();
          if (t1.get$psPitchesToConsider() != null)
            t2._osPitchesToConsider = t1.get$psPitchesToConsider();
          if (t1.get$psMinTotalPitchJump() != null)
            t2._osMinTotalPitchJump = t1.get$psMinTotalPitchJump();
          if (t1.get$psMinPitchStabilityThresh() != null)
            t2._osMinPitchStabilityThreshold = t1.get$psMinPitchStabilityThresh();
          if (t1.get$asMinAmplPercRise() != null)
            t2._osMinAmplPercRise = t1.get$asMinAmplPercRise();
          if (t1.get$asMaxAmplRiseTime() != null)
            t2._osAmplMaxRiseTime = t1.get$asMaxAmplRiseTime();
          if (t1.get$spMinTimeBetweenSplits() != null)
            t2._minTimeBetweenSplits = t1.get$spMinTimeBetweenSplits();
          if (t1.get$minAmplPerc() != null)
            t2._minAmplPerc = t1.get$minAmplPerc();
        }
        this._playbackCompleteCallback = playbackCompleteCallback;
        this._stagexl$_isPlaying = true;
        this._sfPlayer.play$1(0, this.get$_stagexl$_onPlaybackComplete());
        t1 = this._performanceNoteMaker;
        beatList = t1._beats;
        countoffBeatList = t1._countoffBeats;
        t2 = this._scoreViewer;
        t1 = t1._sampleTimeStamps;
        t1.toString;
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        t1.fixed$length = Array;
        t1 = t1;
        t2 = t2._stagexl$_pm;
        if (t2._vScore == null)
          H.throwExpression("must call setNewScore before using!");
        if (t1.length < 1)
          H.throwExpression("No time stamps!");
        t2._vm.disableUserScroll$0();
        t2._prepareTracking$6(t1, beatList, countoffBeatList, 0, startNG, endQNoteTime);
        t2._prepareScrolling$0();
        t2._enterFrameSubscription = t2._scoreViewer.on$1(0, "enterFrame").listen$1(t2.get$_onEnterFrame());
        t2._stagexl$_isPlaying = true;
        t1 = this._assessor;
        if (t1 != null)
          t1.start$0(0);
      },
      play$9$assessmentType$countoffSeconds$endQNoteTime$metronomeVolume$playRepeats$playSoundFontNotes$startNG$tempoRatio: function($receiver, playbackCompleteCallback, assessmentType, countoffSeconds, endQNoteTime, metronomeVolume, playRepeats, playSoundFontNotes, startNG, tempoRatio) {
        return this.play$11$assessmentType$countoffBeats$countoffSeconds$endQNoteTime$instDO$metronomeVolume$playRepeats$playSoundFontNotes$startNG$tempoRatio($receiver, playbackCompleteCallback, assessmentType, null, countoffSeconds, endQNoteTime, null, metronomeVolume, playRepeats, playSoundFontNotes, startNG, tempoRatio);
      },
      stop$0: function(_) {
        var t1 = this._sfPlayer;
        if (t1 != null) {
          t1.stop$0(0);
          this._scoreViewer._stagexl$_pm._stopPlayback$0();
          t1 = this._assessor;
          if (t1 != null)
            t1.stop$0(0);
        }
        this._stagexl$_isPlaying = false;
      },
      _stagexl$_onPlaybackComplete$0: [function() {
        this.stop$0(0);
        var t1 = this._playbackCompleteCallback;
        if (t1 != null)
          t1.call$0();
      }, "call$0", "get$_stagexl$_onPlaybackComplete", 0, 0, 2],
      _getCountoffBeatsForSeconds$3: function(seconds, startNG, tempoRatio) {
        var t1, tmList, i, tm, actualTempo, beatType, qNotesPerCountoffBeat;
        if (startNG == null) {
          t1 = this._stagexl$_score.get$parts();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = t1[0].get$staves();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = t1[0]._measures;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = t1[0].get$voices();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = t1[0].get$noteGroups();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          startNG = t1[0];
        }
        t1 = J.getInterceptor$x(startNG);
        tmList = J.get$measure$x(t1.get$voice(startNG))._stack._tempoMarkers;
        if (tmList != null)
          for (i = tmList.length - 1, tm = null; i >= 0; --i) {
            if (i >= tmList.length)
              return H.ioore(tmList, i);
            if (J.$le$n(tmList[i]._data$_qNoteTime, startNG.get$qNoteTime())) {
              if (i >= tmList.length)
                return H.ioore(tmList, i);
              tm = tmList[i];
            }
          }
        else
          tm = null;
        actualTempo = J.$mul$ns(tm != null ? tm._tempo : 90, tempoRatio);
        beatType = J.get$measure$x(t1.get$voice(startNG))._beatType;
        if (J.$mod$n(beatType, 8) === 0 && J.$ge$n(actualTempo, 80)) {
          if (typeof beatType !== "number")
            return H.iae(beatType);
          qNotesPerCountoffBeat = 3 * (4 / beatType);
        } else {
          if (typeof beatType !== "number")
            return H.iae(beatType);
          qNotesPerCountoffBeat = 4 / beatType;
        }
        if (typeof actualTempo !== "number")
          return H.iae(actualTempo);
        return C.JSDouble_methods.ceil$0(seconds / (qNotesPerCountoffBeat * (60 / actualTempo)));
      },
      _checkDriverReady$0: [function() {
        if (++this._numInitializedComponents === 2)
          this._initDriverCallback.call$0();
      }, "call$0", "get$_checkDriverReady", 0, 0, 2]
    },
    SFScoreDriver_parseScore_closure: {
      "^": "Closure:20;$this,keepParserObject,completer,parser",
      call$1: [function(score) {
        if (this.keepParserObject)
          this.$this._parser = this.parser;
        this.completer.complete$1(0, score);
      }, null, null, 2, 0, null, 17, "call"]
    },
    SFScoreDriver_parseScore_closure0: {
      "^": "Closure:0;completer",
      call$1: [function(e) {
        this.completer.completeError$1(e);
      }, null, null, 2, 0, null, 0, "call"]
    },
    SFDriverDrawManager: {
      "^": "Object;_stagexl$_driver,_scoreFormatter,_scoreViewerWidth,_scoreViewerHeight,_displayedParts",
      _renderMusic$4: function(width, height, measuresPerSystem, partNames) {
        var t1, score, t2, t3, vScore;
        this._markMeasuresForRendering$0();
        t1 = this._stagexl$_driver;
        score = t1._stagexl$_score;
        score.setPageSize$2(this._calculatePageWidth$1(width), score.get$scoreProperties()._pageHeight);
        t2 = this._scoreFormatter;
        if (t2 == null) {
          t2 = t1._stagexl$_score;
          t3 = new L.ScoreFormatter(null, null, null, null, null, null);
          t3._formatting$_score = t2;
          if (t2 != null)
            t3.init$0();
          this._scoreFormatter = t3;
          t2 = t3;
        }
        t2.setPartList$1(partNames);
        t2 = this._scoreFormatter;
        t2._musicSpacer.initializeScoreSettings$0();
        t2._processUpdateRequests$0();
        t2._musicSpacer.groupMeasuresIntoSystems$1(measuresPerSystem);
        t2._getActualSpacingAndPositioning$0();
        vScore = t1._renderer.renderScore$2(t1._stagexl$_score, partNames);
        this._displayedParts = partNames;
        this._scoreViewerWidth = width;
        this._scoreViewerHeight = height;
        t2 = t1._scoreViewer;
        if (t2 != null) {
          t2.setScore$1(vScore);
          t1._scoreViewer._vm.setWidthAndHeight$2(width, height);
        } else {
          t2 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
          t3 = $.DisplayObject__nextID;
          $.DisplayObject__nextID = t3 + 1;
          t3 = new F.ScoreViewer(null, null, null, null, null, null, null, t2, true, true, false, true, "auto", true, 0, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
          t3._stagexl$_init$3(vScore, width, height);
          t1._scoreViewer = t3;
        }
      },
      _markMeasuresForRendering$0: function() {
        var stacks, i, measures, j;
        stacks = this._stagexl$_driver._stagexl$_score.getMeasureStacks$0();
        for (i = 0; i < stacks.length; ++i) {
          measures = stacks[i].get$measures();
          for (j = 0; j < measures.length; ++j)
            measures[j].set$notesNeedRendering(true);
        }
      },
      _calculatePageWidth$1: function(displayWidth) {
        var t1 = J.getInterceptor$n(displayWidth);
        if (t1.$lt(displayWidth, 600))
          return 1010 * t1.$div(displayWidth, 900);
        else
          return 1010 * t1.$div(displayWidth, Math.min(H.checkNum(J.$add$ns(t1.$sub(displayWidth, 600), 900)), 1200));
      },
      _clearSystemIndents$0: function() {
        var systems, t1, _i;
        systems = this._stagexl$_driver._stagexl$_score.getSystems$0();
        for (t1 = systems.length, _i = 0; _i < systems.length; systems.length === t1 || (0, H.throwConcurrentModificationError)(systems), ++_i)
          systems[_i].set$indent(0);
      }
    },
    ScoreViewer: {
      "^": "Sprite;_vScore,_stagexl$_pm,_vm,_vngList,_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      _stagexl$_init$3: function(visualScore, viewerWidth, viewerHeight) {
        var t1 = new F.ScoreViewerViewManager(this, null, 500, 400, null, null, false, null, false, false, null, null, null, 0, null, null, null, null, null, 0, 0);
        t1._stagexl$_init$0();
        this._vm = t1;
        this._stagexl$_pm = new F.ScoreViewerPlaybackManager(this, t1, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0.5, 0, false, null, null);
        this.setScore$3(visualScore, viewerWidth, viewerHeight);
        this._vm.enableUserScroll$0();
      },
      setScore$3: function(visualScore, viewerWidth, viewerHeight) {
        var t1, t2, t3, command;
        this._vScore = visualScore;
        t1 = visualScore.getVisualNoteGroups$0();
        this._vngList = t1;
        C.JSArray_methods.sort$1(t1, new F.ScoreViewer_setScore_closure());
        t1 = this._vm;
        t2 = this._vScore;
        t3 = t1._vScore;
        if (t3 != null && t3._parent === t1._scoreViewer)
          t1._scoreViewer.removeChild$1(t3);
        t1._vScore = t2;
        t1._vSystems = t2.getVisualSystems$0();
        if (J.$eq$(viewerWidth, -1))
          viewerWidth = t1._viewerWidth;
        t1.setWidthAndHeight$2(viewerWidth, J.$eq$(viewerHeight, -1) ? t1._viewerHeight : viewerHeight);
        t1._scoreViewer.addChild$1(t1._vScore);
        t1 = this._stagexl$_pm;
        t2 = this._vScore;
        t3 = this._vngList;
        t1._vScore = t2;
        t1._vngList = t3;
        t3 = [U.GraphicsCommand];
        t3 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
        t2 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t2 + 1;
        t1._cursor = new A.Shape(t3, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        t3.beginPath$0(0);
        t1._cursor.graphics.moveTo$2(0, 0, 0);
        t1._cursor.graphics.lineTo$2(0, 0, t1._vScore._scoreProps._staffLineSpacing * 6);
        t3 = t1._cursor.graphics;
        command = new U.GraphicsCommandStrokeColor(1426128640, C.JSInt_methods.toDouble$0(20), C.JointStyle_1, C.CapsStyle_2, null);
        command._setGraphics$1(t3);
        t3._originalCommands.push(command);
        C.JSArray_methods.set$length(t3._compiledCommands, 0);
        t3._bounds = null;
        t1._cursor.graphics.closePath$0(0);
        t1._cursor.set$y(0, -1 * t1._vScore._scoreProps._staffLineSpacing);
        if (t1._stagexl$_isPlaying)
          t1._vScore.addChild$1(t1._cursor);
      },
      setScore$1: function(visualScore) {
        return this.setScore$3(visualScore, -1, -1);
      },
      scrollToSystem$2: function(system, seconds) {
        var t1, t2, _i, vSystem;
        for (t1 = this._vm._vSystems, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          vSystem = t1[_i];
          if (J.$eq$(vSystem.get$systemRef(), system)) {
            this._vm.scrollToSystem$2(vSystem, seconds);
            return;
          }
        }
      }
    },
    ScoreViewer_setScore_closure: {
      "^": "Closure:40;",
      call$2: function(vng1, vng2) {
        return J.$le$n(vng1.get$noteGroup().get$qNoteTime(), vng2.get$noteGroup().get$qNoteTime()) ? -1 : 1;
      }
    },
    ScoreViewerEvent: {
      "^": "Event;visualNoteGroup<,visualMeasure,qNoteTime@,contextTime<,tempo<,_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped"
    },
    ScoreViewerPlaybackManager: {
      "^": "Object;_scoreViewer,_vm,_vScore,_vngList,_lastReachedVNG,_cursor,_vngIndex,_lastSystem,_lastVNGInRegion,_useScrolling,_beatList,_beatIndex,_countoffBeatList,_countoffBeatIndex,_firstNoteReached,_timeStamps,_lastTimeStamp,_nextTimeStamp,_currentQNoteToSecondsRatio,_passedTime,_audioStartDelay,_qNoteTime,_stagexl$_isPlaying,_enterFrameSubscription,_contextStartTime",
      _prepareTracking$6: function(timeStamps, beatList, countoffBeatList, audioStartDelaySeconds, startNG, endQNoteTime) {
        var context, t1, t2, i;
        context = $.AudioManager_context;
        if (context != null) {
          t1 = context.currentTime;
          t1.toString;
          this._contextStartTime = isNaN(t1) ? 0 : context.currentTime;
        }
        this._timeStamps = timeStamps;
        t1 = timeStamps.length;
        if (0 >= t1)
          return H.ioore(timeStamps, 0);
        t2 = timeStamps[0];
        this._lastTimeStamp = t2;
        if (1 >= t1)
          return H.ioore(timeStamps, 1);
        this._nextTimeStamp = timeStamps[1];
        this._currentQNoteToSecondsRatio = J.$div$n(t2.get$tempo(), 60);
        this._audioStartDelay = audioStartDelaySeconds;
        this._passedTime = 0;
        this._beatList = this._sortAndRemoveDuplicates$1((beatList && C.JSArray_methods).sublist$1(beatList, 0));
        this._countoffBeatList = countoffBeatList;
        this._beatIndex = 0;
        this._countoffBeatIndex = 0;
        this._firstNoteReached = false;
        this._vngIndex = this._initializeCursorAndView$1(startNG);
        this._lastReachedVNG = null;
        if (endQNoteTime == null) {
          t1 = this._vngList;
          this._lastVNGInRegion = (t1 && C.JSArray_methods).get$last(t1);
        } else
          for (i = this._vngList.length - 1; i >= 0; --i) {
            t1 = this._vngList;
            if (i >= t1.length)
              return H.ioore(t1, i);
            if (J.$lt$n(t1[i].get$noteGroup().get$qNoteTime(), endQNoteTime)) {
              t1 = this._vngList;
              if (i >= t1.length)
                return H.ioore(t1, i);
              this._lastVNGInRegion = t1[i];
              break;
            }
          }
      },
      _prepareScrolling$0: function() {
        var t1, ts;
        t1 = this._vm.isNoteInView$1(this._lastVNGInRegion);
        this._useScrolling = !t1;
        if (t1) {
          t1 = this._timeStamps;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          ts = t1[0];
          for (; ts.get$nextSampleTimeStampDO() != null;) {
            if (J.$lt$n(ts.get$nextSampleTimeStampDO().qNoteTime, ts.get$qNoteEndTime())) {
              this._useScrolling = true;
              break;
            }
            ts = ts.get$nextSampleTimeStampDO();
          }
        }
      },
      _initializeCursorAndView$1: function(startNG) {
        var t1, vng, i;
        if (startNG == null) {
          t1 = this._vngList;
          vng = (t1 && C.JSArray_methods).get$first(t1);
          i = 0;
        } else {
          i = 0;
          while (true) {
            t1 = this._vngList;
            if (!(i < t1.length)) {
              vng = null;
              break;
            }
            if (J.$eq$(t1[i].get$noteGroup(), startNG)) {
              t1 = this._vngList;
              if (i >= t1.length)
                return H.ioore(t1, i);
              vng = t1[i];
              break;
            }
            ++i;
          }
        }
        if (vng == null) {
          t1 = this._vngList;
          vng = (t1 && C.JSArray_methods).get$first(t1);
          i = 0;
        }
        this._lastSystem = vng.get$vSystemRef();
        this._vScore.addChild$1(this._cursor);
        this._vm.scrollToSystem$2(this._lastSystem, 0);
        this._moveCursorToNotePosition$1(vng);
        return i;
      },
      _onEnterFrame$1: [function(e) {
        var t1, context, t2, t3, currentTime;
        t1 = this._passedTime + e.get$passedTime();
        this._passedTime = t1;
        context = $.AudioManager_context;
        t2 = this._audioStartDelay;
        if (context != null) {
          t1 = context.currentTime;
          t3 = this._contextStartTime;
          if (typeof t1 !== "number")
            return t1.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          currentTime = t1 - t3 - t2;
        } else
          currentTime = t1 - t2;
        this._qNoteTime = this._getQNoteTime$1(currentTime);
        this._updateCursorAndScrollPos$0();
        t1 = this._countoffBeatIndex;
        t2 = this._countoffBeatList;
        t3 = t2.length;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (t1 < t3 && J.$ge$n(this._qNoteTime, t2[t1])) {
          t1 = this._vm;
          t2 = this._countoffBeatList.length;
          t3 = this._countoffBeatIndex;
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1.updateVisualCountoff$1(t2 - t3);
          t3 = this._countoffBeatIndex;
          if (typeof t3 !== "number")
            return t3.$add();
          this._countoffBeatIndex = t3 + 1;
        }
        this._displayRepeatPreview$1(currentTime);
        t1 = this._vngIndex;
        t2 = this._vngList;
        if (t1 >= t2.length) {
          t1 = this._qNoteTime;
          t2 = (t2 && C.JSArray_methods).get$last(t2).get$noteGroup().get$qNoteTime();
          t3 = this._vngList;
          t3 = J.$gt$n(t1, J.$add$ns(t2, (t3 && C.JSArray_methods).get$last(t3).get$noteGroup().get$qNoteDuration()));
          t1 = t3;
        } else
          t1 = false;
        if (t1)
          this._stopPlayback$0();
      }, "call$1", "get$_onEnterFrame", 2, 0, 26, 0],
      _getQNoteTime$1: function(currentTime) {
        var t1, t2, t3, qNoteTime, newStampQNoteTime;
        while (true) {
          t1 = this._nextTimeStamp;
          if (!(t1 != null && t1.get$msTime() / 1000 <= currentTime))
            break;
          t1 = this._lastTimeStamp.get$qNoteTime();
          t2 = this._currentQNoteToSecondsRatio;
          t3 = this._lastTimeStamp.get$msTime();
          if (typeof t2 !== "number")
            return t2.$mul();
          qNoteTime = J.$add$ns(t1, t2 * (currentTime - t3 / 1000));
          if (J.$lt$n(this._nextTimeStamp.get$qNoteTime(), qNoteTime)) {
            this._vngIndex = 0;
            newStampQNoteTime = this._nextTimeStamp.get$qNoteTime();
            while (true) {
              t1 = this._vngIndex;
              t2 = this._vngList;
              if (!(t1 < t2.length && J.$lt$n(t2[t1].get$noteGroup().get$qNoteTime(), newStampQNoteTime)))
                break;
              ++this._vngIndex;
            }
            this._beatIndex = 0;
            t1 = 0;
            while (true) {
              t2 = this._beatList;
              t3 = t2.length;
              if (t1 < t3) {
                if (t1 < 0)
                  return H.ioore(t2, t1);
                t1 = J.$lt$n(t2[t1], newStampQNoteTime);
              } else
                t1 = false;
              if (!t1)
                break;
              t1 = this._beatIndex;
              if (typeof t1 !== "number")
                return t1.$add();
              ++t1;
              this._beatIndex = t1;
            }
            this._vm.removeSystemPreview$1(true);
          }
          t1 = this._nextTimeStamp;
          this._lastTimeStamp = t1;
          this._nextTimeStamp = t1.get$nextSampleTimeStampDO();
          this._currentQNoteToSecondsRatio = J.$div$n(this._lastTimeStamp.get$tempo(), 60);
        }
        t1 = this._lastTimeStamp.get$qNoteTime();
        t2 = this._currentQNoteToSecondsRatio;
        t3 = this._lastTimeStamp.get$msTime();
        if (typeof t2 !== "number")
          return t2.$mul();
        return J.$add$ns(t1, t2 * (currentTime - t3 / 1000));
      },
      _updateCursorAndScrollPos$0: function() {
        var t1, t2, mostRecentVNG, vng, vSystem, svEvent, mostRecentBeat, t3, prevNG, nextNG, prevNoteXPos, startHPos, distance, endQNoteTime, stack;
        if (this._firstNoteReached !== true) {
          t1 = this._qNoteTime;
          t2 = this._beatList;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          if (J.$lt$n(t1, t2[0]))
            return;
          this._firstNoteReached = true;
        }
        mostRecentVNG = null;
        while (true) {
          t1 = this._vngIndex;
          t2 = this._vngList;
          if (!(t1 < t2.length && J.$le$n(t2[t1].get$noteGroup().get$qNoteTime(), this._qNoteTime)))
            break;
          t1 = this._vngList;
          t2 = this._vngIndex;
          if (t2 >= t1.length)
            return H.ioore(t1, t2);
          vng = t1[t2];
          if (!(J.get$visible$x(vng.get$noteGroup()) !== true && J.$gt$n(vng.get$noteGroup().get$qNoteTime(), J.get$measure$x(J.get$voice$x(vng.get$noteGroup()))._stack._startTime) && true)) {
            this._lastReachedVNG = vng;
            vSystem = vng.get$vSystemRef();
            t1 = this._lastSystem;
            if (vSystem == null ? t1 != null : vSystem !== t1) {
              if (this._useScrolling === true)
                this._vm.scrollToSystem$2(vSystem, 0.5);
              this._lastSystem = vSystem;
            }
            mostRecentVNG = vng;
          }
          svEvent = new F.ScoreViewerEvent(null, null, null, null, null, "noteReached", false, C.EventPhase_1, null, null, false, false);
          svEvent.visualNoteGroup = vng;
          svEvent.qNoteTime = vng.get$noteGroup().get$qNoteTime();
          svEvent.contextTime = $.AudioManager_context.currentTime;
          svEvent.tempo = this._lastTimeStamp.get$tempo();
          this._scoreViewer.dispatchEvent$1(0, svEvent);
          ++this._vngIndex;
        }
        mostRecentBeat = null;
        while (true) {
          t1 = this._beatIndex;
          t2 = this._beatList;
          t3 = t2.length;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (!(t1 < t3 && J.$le$n(t2[t1], this._qNoteTime)))
            break;
          t1 = this._beatList;
          t2 = this._beatIndex;
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          mostRecentBeat = t1[t2];
          svEvent = new F.ScoreViewerEvent(null, null, null, null, null, "beatReached", false, C.EventPhase_1, null, null, false, false);
          svEvent.qNoteTime = mostRecentBeat;
          svEvent.contextTime = $.AudioManager_context.currentTime;
          svEvent.tempo = this._lastTimeStamp.get$tempo();
          this._scoreViewer.dispatchEvent$1(0, svEvent);
          t2 = this._beatIndex;
          if (typeof t2 !== "number")
            return t2.$add();
          this._beatIndex = t2 + 1;
        }
        if (mostRecentVNG != null)
          t1 = (mostRecentBeat == null || J.$ge$n(mostRecentVNG.get$noteGroup().get$qNoteTime(), mostRecentBeat)) && !this._isMeasureWholeRest$1(mostRecentVNG.get$noteGroup());
        else
          t1 = false;
        if (t1)
          this._moveCursorToNotePosition$1(mostRecentVNG);
        else if (mostRecentBeat != null) {
          t1 = this._lastReachedVNG;
          prevNG = t1 != null ? t1.get$noteGroup() : null;
          if (prevNG == null)
            return;
          t1 = J.getInterceptor$x(prevNG);
          nextNG = t1.get$next(prevNG);
          if (nextNG != null && J.get$visible$x(nextNG) === false)
            nextNG = null;
          prevNoteXPos = J.get$x$x(this._lastReachedVNG);
          if (nextNG != null) {
            t2 = J.get$measure$x(J.get$voice$x(nextNG));
            t3 = J.get$measure$x(t1.get$voice(prevNG));
            t3 = t2 == null ? t3 == null : t2 === t3;
            t2 = t3;
          } else
            t2 = false;
          if (t2) {
            if (typeof prevNoteXPos !== "number")
              return H.iae(prevNoteXPos);
            startHPos = 0 + prevNoteXPos - 5;
            distance = J.$sub$n(nextNG.get$hPos(), prevNG.get$hPos());
            endQNoteTime = nextNG.get$qNoteTime();
          } else if (this._isMeasureWholeRest$1(prevNG)) {
            stack = J.get$measure$x(t1.get$voice(prevNG))._stack;
            distance = stack._newSystem ? J.$sub$n(stack._data$_width, stack._indentAsSystemLeader) : J.$sub$n(stack._data$_width, stack._data$_indent);
            if (typeof prevNoteXPos !== "number")
              return H.iae(prevNoteXPos);
            t1 = prevNG.get$hPos();
            if (typeof t1 !== "number")
              return H.iae(t1);
            t2 = stack._newSystem ? stack._indentAsSystemLeader : stack._data$_indent;
            if (typeof t2 !== "number")
              return H.iae(t2);
            startHPos = 0 + prevNoteXPos - t1 + t2;
            endQNoteTime = stack._endTime;
          } else {
            stack = J.get$measure$x(t1.get$voice(prevNG))._stack;
            if (typeof prevNoteXPos !== "number")
              return H.iae(prevNoteXPos);
            startHPos = 0 + prevNoteXPos - 5;
            distance = J.$sub$n(stack._data$_width, prevNG.get$hPos());
            endQNoteTime = stack._endTime;
          }
          t1 = this._cursor;
          t2 = this._lastSystem._x;
          t3 = J.$mul$ns(distance, J.$div$n(J.$sub$n(this._qNoteTime, prevNG.get$qNoteTime()), J.$sub$n(endQNoteTime, prevNG.get$qNoteTime())));
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1.set$x(0, t2 + startHPos + t3);
          t3 = this._cursor;
          t2 = this._lastSystem;
          t3.set$y(0, t2._y + t2._pageRef._y - this._vScore._scoreProps._staffLineSpacing);
        }
      },
      _moveCursorToNotePosition$1: function(vng) {
        var t1, t2, t3;
        t1 = this._cursor;
        t2 = vng.get$vSystemRef()._x;
        t3 = J.get$x$x(vng);
        if (typeof t3 !== "number")
          return H.iae(t3);
        t1.set$x(0, t2 + t3 + 0.5 * this._vScore._scoreProps._noteheadWidth);
        t3 = this._cursor;
        t2 = vng.get$vSystemRef();
        t3.set$y(0, t2._y + t2._pageRef._y - this._vScore._scoreProps._staffLineSpacing);
      },
      _displayRepeatPreview$1: function(currentTime) {
        var t1, i, vsys, t2, bd, t3, t4, t5, t6, t7, t8, t9, renderState, tween, tweenProperty, root;
        t1 = this._nextTimeStamp;
        if (t1 != null)
          if (J.$lt$n(t1.get$qNoteTime(), this._qNoteTime))
            if (this._useScrolling === true)
              if (this._vm._systemPreviewBmp == null)
                if (currentTime + 3 >= this._nextTimeStamp.get$msTime() / 1000) {
                  t1 = this._lastSystem._visNoteGroups;
                  if (0 >= t1.length)
                    return H.ioore(t1, 0);
                  t1 = J.$gt$n(t1[0]._bitmap_renderer$_noteGroup.get$qNoteTime(), this._nextTimeStamp.get$qNoteTime()) && J.$ge$n(J.$add$ns(C.JSArray_methods.get$last(this._lastSystem._visNoteGroups)._bitmap_renderer$_noteGroup.get$qNoteTime(), C.JSArray_methods.get$last(this._lastSystem._visNoteGroups)._bitmap_renderer$_noteGroup.get$qNoteDuration()), this._lastTimeStamp.get$qNoteEndTime());
                } else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
        if (t1)
          for (i = 0; t1 = this._vngList, i < t1.length; ++i)
            if (J.$ge$n(t1[i].get$noteGroup().get$qNoteTime(), this._nextTimeStamp.get$qNoteTime())) {
              t1 = this._vngList;
              if (i >= t1.length)
                return H.ioore(t1, i);
              vsys = t1[i].get$vSystemRef();
              t1 = this._vm;
              t1.removeSystemPreview$1(false);
              t2 = vsys.get$bounds().top;
              if (typeof t2 !== "number")
                return H.iae(t2);
              bd = A.BitmapData_BitmapData(J.toInt$0$n(t1._viewerWidth), J.toInt$0$n(t1._viewerHeight), 4294967295, 1);
              t2 = T.Matrix$(1, 0, 0, 1, vsys._x, 0 - t2);
              t3 = bd.renderTextureQuad;
              t4 = t3.renderTexture;
              t5 = t4.get$canvas(t4);
              t6 = T.Matrix$fromIdentity();
              t7 = J.get$context2D$x(t5);
              t8 = [L.RenderContextEvent];
              t9 = t6._data;
              t7.setTransform(t9[0], t9[1], t9[2], t9[3], t9[4], t9[5]);
              t7.globalCompositeOperation = "source-over";
              t7.globalAlpha = 1;
              renderState = L.RenderState$(new L.RenderContextCanvas(t5, t7, t6, C.BlendMode_bZz, 1, new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t8), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t8)), t3.get$drawMatrix(), null, null);
              t3 = renderState._currentContextState.matrix;
              t3.copyFromAndConcat$2(t2, t3);
              vsys.render$1(renderState);
              t4.update$0(0);
              t2 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t2 + 1;
              t2 = new A.Bitmap(bd, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              t1._systemPreviewBmp = t2;
              t2._y = 200;
              t3 = t1._vScore._scaleY;
              t2._scaleY = t3;
              t2._scaleX = t3;
              t1._scoreViewer.addChild$1(t2);
              t1._systemPreviewBmp.set$alpha(0, 0);
              t2 = t1._systemPreviewBmp;
              tween = new K.Tween(t2, K.animation_Transition_easeOutCubic$closure(), H.setRuntimeTypeInfo([], [K.TweenProperty]), null, null, null, 0, 0, 0, false, false);
              if (!J.getInterceptor(t2).$isTweenObject)
                H.throwExpression(P.ArgumentError$("tweenObject"));
              tween._totalTime = Math.max(0.0001, 0.5);
              t2 = tween.get$animate(tween);
              t3 = t2._tween;
              tweenProperty = new K.TweenProperty(t2, 9, 0 / 0, 0 / 0, 0 / 0);
              if (!t3._started)
                t3._tweenPropertyList.push(tweenProperty);
              tweenProperty._targetValue = C.JSInt_methods.toDouble$0(1);
              t1 = t1._scoreViewer;
              root = t1.get$root(t1);
              (root instanceof A.Stage ? root : null).juggler.add$1(0, tween);
              break;
            }
      },
      _stopPlayback$0: function() {
        if (this._stagexl$_isPlaying) {
          this._enterFrameSubscription.cancel$0(0);
          this._stagexl$_isPlaying = false;
          this._vm.enableUserScroll$0();
          var t1 = this._cursor;
          t1._parent.removeChild$1(t1);
        }
      },
      _isMeasureWholeRest$1: function(ng) {
        return ng.get$isRest() && ng.get$durationType() === 4096 && J.get$voice$x(ng).get$noteGroups().length === 1;
      },
      _sortAndRemoveDuplicates$1: function(list) {
        var newList, lastNum, i, newNum;
        C.JSArray_methods.sort$1(list, new F.ScoreViewerPlaybackManager__sortAndRemoveDuplicates_closure());
        newList = [];
        for (lastNum = null, i = 0; i < list.length; ++i, lastNum = newNum) {
          newNum = list[i];
          if (!J.$eq$(newNum, lastNum))
            newList.push(newNum);
        }
        return newList;
      },
      get$qNoteTime: function() {
        return this._qNoteTime;
      },
      get$tempo: function() {
        var t1 = this._lastTimeStamp;
        return t1 == null ? t1 : t1.get$tempo();
      }
    },
    ScoreViewerPlaybackManager__sortAndRemoveDuplicates_closure: {
      "^": "Closure:42;",
      call$2: function(num1, num2) {
        return J.$le$n(num1, num2) ? -1 : 1;
      }
    },
    ScoreViewerViewManager: {
      "^": "Object;_scoreViewer,_vScore,_viewerWidth,_viewerHeight,_vSystems,_systemPreviewBmp,_enabled,_startPos,_scrollOccurred,_mouseDownReceived,_scrollTween,_countoffDisplay,_countoffFadeTween,_lastScrollWheelTime,_mouseDownListener,_touchStartListener,_mouseUpListener,_touchEndListener,_mouseWheelListener,_largestWheelDeltaDist,_lastAppliedDelta",
      setWidthAndHeight$2: function(viewerWidth, viewerHeight) {
        var t1, scale;
        this._viewerWidth = viewerWidth;
        this._viewerHeight = viewerHeight;
        this._scoreViewer._mask = new A._RectangleMask(new U.Rectangle0(0, 0, viewerWidth, viewerHeight, [P.num]), T.Matrix$fromIdentity(), false, false, 4278190080, 1);
        t1 = this._viewerWidth;
        if (t1 != null && this._vScore != null) {
          scale = J.$div$n(J.$sub$n(t1, 4), this._vScore._bitmap_renderer$_score.get$scoreProperties()._pageWidth);
          t1 = this._vScore;
          t1.set$scaleY(scale);
          t1.set$scaleX(scale);
          this._vScore.set$x(0, 2);
          if (this._enabled)
            this._drawViewerBackground$0();
          this._updateVisibleSystems$2(0, true);
        }
      },
      enableUserScroll$0: function() {
        if (!this._enabled) {
          if (this._scoreViewer.get$stage() != null)
            this._enableListeners$1(null);
          else
            this._scoreViewer.on$1(0, "addedToStage")._subscribe$3(this.get$_enableListeners(), false, 0);
          this._drawViewerBackground$0();
          this._enabled = true;
        }
      },
      _enableListeners$1: [function(e) {
        var t1 = this.get$_onMouseDown();
        this._mouseDownListener = this._scoreViewer.on$1(0, "mouseDown").listen$1(t1);
        this._touchStartListener = this._scoreViewer.on$1(0, "touchBegin").listen$1(t1);
        t1 = this.get$_onMouseUp();
        this._mouseUpListener = this._scoreViewer.on$1(0, "mouseUp").listen$1(t1);
        this._touchEndListener = this._scoreViewer.on$1(0, "touchEnd").listen$1(t1);
        this._mouseWheelListener = this._scoreViewer.on$1(0, "mouseWheel").listen$1(this.get$_onMouseWheel());
        this._scoreViewer.on$1(0, "addedToStage")._unsubscribe$2(this.get$_enableListeners(), false);
      }, "call$1", "get$_enableListeners", 2, 0, 11, 0],
      disableUserScroll$0: function() {
        if (this._enabled) {
          var t1 = this._mouseDownListener;
          if (t1 != null)
            t1.cancel$0(0);
          t1 = this._touchStartListener;
          if (t1 != null)
            t1.cancel$0(0);
          t1 = this._mouseUpListener;
          if (t1 != null)
            t1.cancel$0(0);
          t1 = this._touchEndListener;
          if (t1 != null)
            t1.cancel$0(0);
          t1 = this._mouseWheelListener;
          if (t1 != null)
            t1.cancel$0(0);
          this._enabled = false;
          this._scoreViewer.on$1(0, "addedToStage")._unsubscribe$2(this.get$_enableListeners(), false);
          this._scoreViewer.get$graphics().clear$0(0);
        }
      },
      scrollToSystem$2: function(vSystem, seconds) {
        var t1, t2, t3, targetY;
        t1 = this._scrollTween;
        if (t1 != null) {
          t1.complete$0(0);
          this._scrollTween = null;
        }
        t1 = $.BitmapMusicRenderer_firstPageVerticalOffset;
        t2 = vSystem.get$scoreY();
        t3 = this._vScore;
        targetY = (t1 + -1 * t2) * t3._scaleY;
        if (seconds > 0 && t3._y > targetY) {
          this._updateVisibleSystems$1(t3._y - targetY);
          t1 = K.Tween$(this._vScore, seconds, K.animation_Transition_easeOutQuadratic$closure());
          this._scrollTween = t1;
          t1._onComplete = new F.ScoreViewerViewManager_scrollToSystem_closure(this);
          t1 = t1.get$animate(t1);
          t1._tween._createTweenProperty$2(t1, 1)._targetValue = C.JSNumber_methods.toDouble$0(targetY);
          vSystem.get$stage().juggler.add$1(0, this._scrollTween);
        } else {
          t3.set$y(0, targetY);
          this._updateVisibleSystems$1(0);
        }
      },
      isNoteInView$1: function(vng) {
        var vSys, t1, t2, t3, t4, t5;
        vSys = vng.get$vSystemRef();
        if (vSys._parent == null)
          return false;
        else {
          t1 = this._vScore;
          t2 = t1._y;
          t3 = vSys._y + vSys._pageRef._y;
          if (t2 + t3 * t1._scaleY > 0) {
            t1 = vSys.get$boundsTransformed().height;
            if (typeof t1 !== "number")
              return H.iae(t1);
            t4 = this._vScore._scaleY;
            t5 = this._viewerHeight;
            if (typeof t5 !== "number")
              return H.iae(t5);
            t5 = t2 + (t3 + t1) * t4 < t5;
            t1 = t5;
          } else
            t1 = false;
          if (t1)
            return true;
          return false;
        }
      },
      updateVisualCountoff$1: function(countoffBeat) {
        var t1, t2, text, tf;
        t1 = this._countoffFadeTween;
        if (t1 != null && !(t1._currentTime >= t1._totalTime))
          t1.complete$0(0);
        t1 = this._countoffDisplay;
        if (t1 != null && t1._parent === this._scoreViewer)
          this._scoreViewer.removeChild$1(t1);
        t1 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
        t2 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t2 + 1;
        this._countoffDisplay = new A.Sprite(null, null, null, t1, true, true, false, true, "auto", true, 0, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        if (countoffBeat === 2)
          text = "Set";
        else
          text = countoffBeat === 1 ? "Go" : C.JSInt_methods.toString$0(countoffBeat);
        t1 = this._viewerWidth;
        if (typeof t1 !== "number")
          return H.iae(t1);
        tf = Y.TextField$(text, new Y.TextFormat("Arial", 80 * t1 / 600, 65280, 0, 4278190080, null, 400, false, false, false, "left", "top", 0, 0, 0, 0, 0, 0));
        tf._autoSize = "left";
        tf._refreshPending |= 3;
        this._countoffDisplay.addChild$1(tf);
        t1 = this._countoffDisplay;
        t2 = this._viewerWidth;
        tf._refreshTextLineMetrics$0();
        t1.set$x(0, J.$div$n(J.$sub$n(t2, tf._textWidth), 2));
        t2 = this._countoffDisplay;
        t1 = this._viewerHeight;
        tf._refreshTextLineMetrics$0();
        t2.set$y(0, J.$div$n(J.$sub$n(t1, tf._textHeight), 2));
        this._scoreViewer.addChild$1(this._countoffDisplay);
        t1 = K.Tween$(this._countoffDisplay, 1.5, K.animation_Transition_easeOutQuadratic$closure());
        this._countoffFadeTween = t1;
        t1._onComplete = new F.ScoreViewerViewManager_updateVisualCountoff_closure(this);
        t1 = t1.get$animate(t1);
        t1._tween._createTweenProperty$2(t1, 9)._targetValue = C.JSInt_methods.toDouble$0(0);
        this._scoreViewer.get$stage().juggler.add$1(0, this._countoffFadeTween);
      },
      _drawViewerBackground$0: function() {
        var t1, t2, t3, command;
        this._scoreViewer.get$graphics().clear$0(0);
        this._scoreViewer.get$graphics().beginPath$0(0);
        t1 = this._scoreViewer.get$graphics();
        t2 = this._viewerWidth;
        t3 = this._viewerHeight;
        t1.toString;
        command = U.GraphicsCommandRect$(0, 0, t2, t3);
        command._setGraphics$1(t1);
        t1._originalCommands.push(command);
        C.JSArray_methods.set$length(t1._compiledCommands, 0);
        t1._bounds = null;
        this._scoreViewer.get$graphics().fillColor$1(16777215);
        this._scoreViewer.get$graphics().closePath$0(0);
      },
      _stagexl$_init$0: function() {
        this._startPos = new U.Point(0, 0, [null]);
        if ($.ScoreViewerViewManager__numScrollDeltaReadings == null)
          $.ScoreViewerViewManager__numScrollDeltaReadings = 0;
      },
      _onMouseDown$1: [function(e) {
        var t1;
        this._mouseDownReceived = true;
        this._scrollOccurred = false;
        t1 = this._vScore;
        this._startPos = new U.Point(t1._x, t1._y, [null]);
        t1.startDrag$0();
        this._vScore.on$1(0, "enterFrame")._subscribe$3(this.get$_onEnterFrame(), false, 0);
      }, "call$1", "get$_onMouseDown", 2, 0, 4, 0],
      _onMouseUp$1: [function(e) {
        var t1, stage, t2, t3, t4, globalPoint, p, visualSys, visMeas;
        if (!this._mouseDownReceived)
          return;
        t1 = this._vScore;
        stage = t1.get$stage();
        if (stage != null)
          stage._stopDrag$1(t1);
        this._vScore.on$1(0, "enterFrame")._unsubscribe$2(this.get$_onEnterFrame(), false);
        t1 = this._vScore;
        t2 = t1._x;
        t3 = this._startPos;
        t4 = t3.x;
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(Math.abs(t2 - t4) > 5)) {
          t2 = t1._y;
          t3 = t3.y;
          if (typeof t3 !== "number")
            return H.iae(t3);
          t3 = Math.abs(t2 - t3) > 5;
          t2 = t3;
        } else
          t2 = true;
        if (t2)
          this._scrollOccurred = true;
        t1.set$x(0, 2);
        this._fixVerticalPosition$1(0.3);
        this._mouseDownReceived = false;
        if (!this._scrollOccurred) {
          globalPoint = new U.Point(e.get$stageX(), e.get$stageY(), [null]);
          p = this._vScore.globalToLocal$1(globalPoint);
          visualSys = this._vScore.getVisualSystemUnderPoint$1(p);
          if (visualSys != null) {
            visMeas = visualSys.getVisualMeasureUnderPoint$1(visualSys.globalToLocal$1(globalPoint));
            if (visMeas != null) {
              e = new F.ScoreViewerEvent(null, null, null, null, null, "measureClicked", false, C.EventPhase_1, null, null, false, false);
              e.visualMeasure = visMeas;
              this._scoreViewer.dispatchEvent$1(0, e);
            }
          }
        }
      }, "call$1", "get$_onMouseUp", 2, 0, 4, 0],
      _onMouseWheel$1: [function(e) {
        var t1, t2, t3, deltaDist, t4, t5, t6, calculatedDelta;
        t1 = {};
        t2 = J.getInterceptor$x(e);
        t3 = t2.get$deltaY(e);
        t3.toString;
        deltaDist = Math.abs(t3);
        if (deltaDist === 0)
          return;
        t3 = Date.now();
        t4 = this._lastScrollWheelTime;
        this._lastScrollWheelTime = t3;
        if (deltaDist > this._largestWheelDeltaDist)
          this._largestWheelDeltaDist = deltaDist;
        t5 = $.ScoreViewerViewManager__numScrollDeltaReadings;
        if (typeof t5 !== "number")
          return t5.$add();
        $.ScoreViewerViewManager__numScrollDeltaReadings = t5 + 1;
        t1.isWheelMouse = false;
        t5 = $.$get$ScoreViewerViewManager__wheelDeltas();
        if (t5.get$length(t5) < 40) {
          if ($.$get$ScoreViewerViewManager__wheelDeltas().$index(0, deltaDist) == null)
            $.$get$ScoreViewerViewManager__wheelDeltas().$indexSet(0, deltaDist, 1);
          else {
            t5 = $.$get$ScoreViewerViewManager__wheelDeltas();
            t6 = t5.$index(0, deltaDist);
            if (typeof t6 !== "number")
              return t6.$add();
            t5.$indexSet(0, deltaDist, t6 + 1);
          }
          $.$get$ScoreViewerViewManager__wheelDeltas().forEach$1(0, new F.ScoreViewerViewManager__onMouseWheel_closure(t1));
        }
        t5 = $.ScoreViewerViewManager__numScrollDeltaReadings;
        if (typeof t5 !== "number")
          return t5.$lt();
        if (t5 < 5) {
          t1 = t2.get$deltaY(e);
          if (typeof t1 !== "number")
            return t1.$gt();
          calculatedDelta = t1 > 0 ? -10 : 10;
        } else if (t1.isWheelMouse) {
          t1 = t2.get$deltaY(e);
          if (typeof t1 !== "number")
            return t1.$gt();
          calculatedDelta = t1 > 0 ? -60 : 60;
        } else {
          t1 = t2.get$deltaY(e);
          if (typeof t1 !== "number")
            return t1.$gt();
          calculatedDelta = t1 > 0 ? deltaDist * -1 : deltaDist;
          if (t3 - t4 > 200)
            this._lastAppliedDelta = 0;
          calculatedDelta = (this._lastAppliedDelta * 5 + calculatedDelta) / 6;
          this._lastAppliedDelta = calculatedDelta;
        }
        t1 = this._vScore;
        t1.set$y(0, t1._y + calculatedDelta);
        this._updateVisibleSystems$1(0);
        this._fixVerticalPosition$1(0);
      }, "call$1", "get$_onMouseWheel", 2, 0, 12, 0],
      _onEnterFrame$1: [function(e) {
        this._vScore.set$x(0, 2);
        this._updateVisibleSystems$1(0);
      }, "call$1", "get$_onEnterFrame", 2, 0, 11, 0],
      _fixVerticalPosition$1: function(time) {
        var t1, targetY, t2, tween, correctionMade;
        t1 = this._vScore;
        targetY = t1._y;
        t1 = t1.get$boundsTransformed().height;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = J.$sub$n(this._viewerHeight, 100);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (targetY + t1 < t2)
          targetY = J.$sub$n(J.$sub$n(this._viewerHeight, this._vScore.get$boundsTransformed().height), 100);
        if (J.$gt$n(targetY, 0))
          targetY = 0;
        t1 = J.getInterceptor(targetY);
        if (!t1.$eq(targetY, this._vScore._y)) {
          t2 = this._vScore;
          if (time > 0) {
            tween = K.Tween$(t2, 0.3, K.animation_Transition_easeOutCubic$closure());
            tween._onComplete = new F.ScoreViewerViewManager__fixVerticalPosition_closure(this);
            t2 = tween.get$animate(tween);
            t2._tween._createTweenProperty$2(t2, 1)._targetValue = t1.toDouble$0(targetY);
            this._scoreViewer.get$stage().juggler.add$1(0, tween);
          } else {
            t2.set$y(0, targetY);
            this._updateVisibleSystems$1(0);
          }
          correctionMade = true;
        } else
          correctionMade = false;
        return correctionMade;
      },
      _updateVisibleSystems$2: function(nextScrollDelta, cacheAlreadyVisibleSystems) {
        var i, t1, vSys, t2, t3, t4, t5;
        for (i = 0; t1 = this._vSystems, i < t1.length; ++i) {
          vSys = t1[i];
          t1 = this._vScore._y;
          t2 = vSys.get$scoreY();
          t3 = J.getInterceptor$x(vSys);
          t4 = t3.get$height(vSys);
          if (typeof t4 !== "number")
            return H.iae(t4);
          t5 = this._vScore;
          if (t1 + (t2 + t4) * t5._scaleY > 0) {
            t1 = t5._y;
            t2 = vSys.get$scoreY();
            t4 = this._vScore._scaleY;
            t5 = J.$add$ns(this._viewerHeight, nextScrollDelta);
            if (typeof t5 !== "number")
              return H.iae(t5);
            t5 = t1 + t2 * t4 < t5;
            t1 = t5;
          } else
            t1 = false;
          if (t1) {
            if (!J.$eq$(t3.get$parent(vSys), vSys.get$pageRef()) || cacheAlreadyVisibleSystems)
              vSys.cacheSystemGraphics$0();
            if (!J.$eq$(t3.get$parent(vSys), vSys.get$pageRef()))
              vSys.get$pageRef().addChild$1(vSys);
          } else if (J.$eq$(t3.get$parent(vSys), vSys.get$pageRef())) {
            vSys.get$pageRef().removeChild$1(vSys);
            vSys.removeCache$0();
          }
        }
      },
      _updateVisibleSystems$1: function(nextScrollDelta) {
        return this._updateVisibleSystems$2(nextScrollDelta, false);
      },
      removeSystemPreview$1: function(fadeIntoPosition) {
        var t1, tween, t2;
        t1 = this._systemPreviewBmp;
        if (t1 != null && t1._parent != null)
          if (fadeIntoPosition) {
            tween = K.Tween$(t1, 0.5, K.animation_Transition_easeOutCubic$closure());
            t2 = tween.get$animate(tween);
            t2._tween._createTweenProperty$2(t2, 1)._targetValue = C.JSInt_methods.toDouble$0(50);
            tween._onComplete = new F.ScoreViewerViewManager_removeSystemPreview_closure(t1);
            this._scoreViewer.get$stage().juggler.add$1(0, tween);
          } else
            t1._parent.removeChild$1(t1);
        if (this._systemPreviewBmp != null)
          this._systemPreviewBmp = null;
      }
    },
    ScoreViewerViewManager_scrollToSystem_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        this.$this._scrollTween = null;
        return;
      }
    },
    ScoreViewerViewManager_updateVisualCountoff_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, t2, t3, t4;
        t1 = this.$this;
        t2 = t1._countoffDisplay;
        t3 = t2._parent;
        t4 = t1._scoreViewer;
        if (t3 === t4)
          t4.removeChild$1(t2);
        t1._countoffFadeTween = null;
      }
    },
    ScoreViewerViewManager__onMouseWheel_closure: {
      "^": "Closure:3;_box_0",
      call$2: function(delta, freq) {
        if (J.$div$n(freq, $.ScoreViewerViewManager__numScrollDeltaReadings) > 0.3)
          this._box_0.isWheelMouse = true;
      }
    },
    ScoreViewerViewManager__fixVerticalPosition_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        return this.$this._updateVisibleSystems$1(0);
      }
    },
    ScoreViewerViewManager_removeSystemPreview_closure: {
      "^": "Closure:1;tempSys",
      call$0: function() {
        var t1 = this.tempSys;
        return t1._parent.removeChild$1(t1);
      }
    },
    AssessmentType: {
      "^": "Object;index,_stagexl$_name",
      toString$0: function(_) {
        return this._stagexl$_name;
      }
    },
    NoteSplitter: {
      "^": "Object;_prEvents,_pitchHistory,_currentEventIndex,_osMinStablePitches,_osPitchesToConsider,_osMinTotalPitchJump,_osMinPitchStabilityThreshold,_osLastStablePitch,_osStablePitchEventsCount,_osMinAmplPercRise,_osAmplMaxRiseTime,_osLastSplitTime,_minTimeBetweenSplits,_minAmplPerc,_highestAmpl",
      addEvent$1: function(prEvent) {
        var t1, t2, cprEvent, t3, cPitch, t4, t5, firstPitchIndex, t6, t7, i, stableTotal, firstSamePitchIndex, stableCount, pitchStable, t8, newAverage, prevEventIndex;
        this._prEvents.push(prEvent);
        this._pitchHistory.push(prEvent.get$cents());
        t1 = this._prEvents;
        t2 = this._currentEventIndex;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        cprEvent = t1[t2];
        t1 = cprEvent.get$rms();
        t2 = this._highestAmpl;
        if (typeof t1 !== "number")
          return t1.$gt();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 > t2)
          this._highestAmpl = cprEvent.get$rms();
        else {
          t1 = cprEvent.get$rms();
          t2 = this._minAmplPerc;
          t3 = this._highestAmpl;
          if (typeof t2 !== "number")
            return t2.$mul();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (typeof t1 !== "number")
            return t1.$lt();
          if (t1 < t2 * t3) {
            ++this._currentEventIndex;
            return;
          }
        }
        cPitch = prEvent.get$cents();
        t1 = this._osLastStablePitch;
        if (typeof cPitch !== "number")
          return cPitch.$sub();
        t2 = cPitch - t1;
        t3 = this._osMinTotalPitchJump;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t2 >= t3 || t1 - cPitch >= t3) {
          t4 = this._currentEventIndex;
          t5 = this._osPitchesToConsider;
          if (typeof t5 !== "number")
            return H.iae(t5);
          t5 = t4 - t5 + 1 >= 0;
          t4 = t5;
        } else
          t4 = false;
        if (t4) {
          t2 = this._currentEventIndex;
          t4 = this._osPitchesToConsider;
          if (typeof t4 !== "number")
            return H.iae(t4);
          firstPitchIndex = t2 - t4 + 1;
          for (t4 = this._pitchHistory, t5 = t4.length, t6 = this._osMinPitchStabilityThreshold, t7 = this._osMinStablePitches, i = firstPitchIndex, stableTotal = cPitch, firstSamePitchIndex = -1, stableCount = 1, pitchStable = false; i < t2; ++i) {
            if (i < 0 || i >= t5)
              return H.ioore(t4, i);
            t8 = t4[i];
            if (typeof t8 !== "number")
              return t8.$sub();
            if (typeof t6 !== "number")
              return H.iae(t6);
            if (t8 - cPitch < t6 && cPitch - t8 < t6) {
              ++stableCount;
              stableTotal += t8;
              if (firstSamePitchIndex === -1)
                firstSamePitchIndex = i;
              if (typeof t7 !== "number")
                return H.iae(t7);
              if (stableCount >= t7)
                pitchStable = true;
            }
          }
          if (pitchStable) {
            newAverage = C.JSInt_methods.$tdiv(stableTotal, stableCount);
            if (newAverage - t1 >= t3 || t1 - newAverage >= t3) {
              this._osLastStablePitch = newAverage;
              this._osStablePitchEventsCount = stableCount;
              t1 = this._prEvents;
              if (firstPitchIndex < 0 || firstPitchIndex >= t1.length)
                return H.ioore(t1, firstPitchIndex);
              this._osLastSplitTime = J.get$time$x(t1[firstPitchIndex]);
              t1 = this._prEvents;
              if (firstSamePitchIndex < 0 || firstSamePitchIndex >= t1.length)
                return H.ioore(t1, firstSamePitchIndex);
              t1[firstSamePitchIndex].set$pitchSplit(true);
              t1 = this._prEvents;
              if (firstSamePitchIndex >= t1.length)
                return H.ioore(t1, firstSamePitchIndex);
              t1[firstSamePitchIndex].set$splitCents(this._osLastStablePitch);
            }
          }
        } else {
          t3 = this._osMinPitchStabilityThreshold;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t2 < t3 && t1 - cPitch < t3) {
            t2 = ++this._osStablePitchEventsCount;
            if (t2 < 2) {
              this._osStablePitchEventsCount = 2;
              t2 = 2;
            }
            this._osLastStablePitch = C.JSInt_methods.$tdiv((t2 - 1) * t1 + cPitch, t2);
          }
        }
        t1 = J.getInterceptor$x(cprEvent);
        if (J.$le$n(J.$sub$n(t1.get$time(cprEvent), this._minTimeBetweenSplits), this._osLastSplitTime)) {
          ++this._currentEventIndex;
          return;
        }
        prevEventIndex = this._currentEventIndex - 1;
        while (true) {
          if (prevEventIndex >= 0) {
            t2 = this._prEvents;
            if (prevEventIndex >= t2.length)
              return H.ioore(t2, prevEventIndex);
            t2 = J.$ge$n(J.get$time$x(t2[prevEventIndex]), J.$sub$n(t1.get$time(cprEvent), this._osAmplMaxRiseTime));
          } else
            t2 = false;
          if (!t2)
            break;
          t2 = this._prEvents;
          if (prevEventIndex < 0 || prevEventIndex >= t2.length)
            return H.ioore(t2, prevEventIndex);
          t2 = t2[prevEventIndex].get$rms();
          t3 = this._osMinAmplPercRise;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (typeof t2 !== "number")
            return t2.$mul();
          t4 = cprEvent.get$rms();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (t2 * (1 + t3) <= t4) {
            cprEvent.set$amplSplit(true);
            this._osLastSplitTime = t1.get$time(cprEvent);
            break;
          }
          --prevEventIndex;
        }
        ++this._currentEventIndex;
      }
    },
    PitchAssessor: {
      "^": "Assessor;_pitchRecognizer,_noteSplitter,_inst,_prEvents,_pitchHistory,_prEventWindowStartIndex,_maxAmplitudeEncountered,_notationNotesQue,_lastNotationPitch,_assess_Delay,_hitMissHistory,_pitchRecSubscription,_enterFrameSubscription,_debugPRecString,_debugNotesString,_debugNREvents,_debugPREvents,_debugMatchedNotes,_debug,_visualizer,_scoreViewer,_noteList,_totalCorrect,_totalIncorrect,_totalExtra",
      _stagexl$_init$0: function() {
        var t1, t2;
        this.super$Assessor$_init();
        if ($.MicManager__ref == null)
          K.MicManager$(null);
        t1 = $.MicManager__ref;
        t2 = new Q.PitchRecognizer(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [null]));
        t2._assessment$_micManager = t1;
        t2._assessment$_init$0();
        this._pitchRecognizer = t2;
        this._noteSplitter = new F.NoteSplitter([], [], 0, 6, 9, 60, 40, 0, 0, 1, 0.1, 0, 0.1, 0, 0);
      },
      start$0: [function(_) {
        var t1, t2;
        this._hitMissHistory = [];
        this._prEvents = [];
        this._pitchHistory = [];
        this._prEventWindowStartIndex = 0;
        this._lastNotationPitch = 0;
        this._maxAmplitudeEncountered = 0;
        t1 = this._noteSplitter;
        t1._prEvents = [];
        t1._pitchHistory = [];
        t1._currentEventIndex = 0;
        t1._osLastStablePitch = 0;
        t1._osStablePitchEventsCount = 0;
        t1._osLastSplitTime = 0;
        t1._highestAmpl = 0;
        this._notationNotesQue = [];
        this._scoreViewer.on$1(0, "noteReached")._subscribe$3(this.get$_onNoteReached(), false, 0);
        this._enterFrameSubscription = this._scoreViewer.on$1(0, "enterFrame").listen$1(this.get$_onEnterFrame());
        this._pitchRecognizer.setInstrument$1(this._inst);
        t1 = this._pitchRecognizer._pitchRecEventController;
        this._pitchRecSubscription = new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(this.get$_onPitchRec());
        t1 = this._pitchRecognizer;
        t1._assessment$_prEvents = [];
        t1._leftOverMicData = [];
        t1._recordDelay = -1;
        t2 = t1._assessment$_micManager;
        t1._recordTimeStamp = t2._mic$_context.currentTime;
        t2 = t2._micDataController;
        t1._micSub = new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(t1.get$_onMicData());
        t1._assessment$_micManager.startCapture$0();
        this._debugNotesString = "tuning window: " + H.S(this._inst.get$tuningWindow()) + "\n";
        this._debugPRecString = "";
      }, "call$0", "get$start", 0, 0, 2],
      stop$0: function(_) {
        var t1, t2;
        if (this._pitchRecSubscription != null) {
          t1 = this._pitchRecognizer;
          t2 = t1._micSub;
          if (t2 != null) {
            t2.cancel$0(0);
            t1._micSub = null;
          }
          t1 = t1._assessment$_micManager;
          t1._spNode.disconnect(0);
          t1._inputNode.disconnect(0);
          t1._audioProcessingEventSubscription.cancel$0(0);
          this._enterFrameSubscription.cancel$0(0);
          this._enterFrameSubscription = null;
          this._pitchRecSubscription.cancel$0(0);
          this._pitchRecSubscription = null;
          this._scoreViewer.on$1(0, "noteReached")._unsubscribe$2(this.get$_onNoteReached(), false);
        }
      },
      _onNoteReached$1: [function(e) {
        this._notationNotesQue.push(e);
      }, "call$1", "get$_onNoteReached", 2, 0, 7, 0],
      _onPitchRec$1: [function(e) {
        this._prEvents.push(e);
        this._pitchHistory.push(e.get$cents());
        if (this._inst.get$checkNoteStartTimes() === true)
          this._noteSplitter.addEvent$1(e);
      }, "call$1", "get$_onPitchRec", 2, 0, 47, 0],
      _onEnterFrame$1: [function(e) {
        var cTime, t1, t2, nrEvent, ng;
        cTime = $.AudioManager_context.currentTime;
        t1 = this._assess_Delay;
        while (true) {
          t2 = this._notationNotesQue;
          if (t2.length > 0) {
            if (typeof cTime !== "number")
              return cTime.$sub();
            t2 = t2[0].get$contextTime();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = cTime - t1 >= t2;
          } else
            t2 = false;
          if (!t2)
            break;
          t2 = this._notationNotesQue;
          nrEvent = (t2 && C.JSArray_methods).removeAt$1(t2, 0);
          ng = nrEvent.get$visualNoteGroup().get$noteGroup();
          if (!ng.get$isRest()) {
            t2 = ng.get$notes();
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            t2 = t2[0]._tieState;
            t2 = !(t2 === "continue" || t2 === "stop");
          } else
            t2 = false;
          if (t2)
            if (this._inst.get$checkNoteStartTimes() !== true)
              this.assessNote$2(nrEvent, cTime);
            else
              this.assessNote4$2(nrEvent, cTime);
          else
            this._lastNotationPitch = 0;
        }
      }, "call$1", "get$_onEnterFrame", 2, 0, 26, 0],
      assessNote$2: function(noteReachedEvent, cTime) {
        var noteStartTime, assessNote, noteGroup, t1, note, t2, durationInSeconds, requiredMatches, notationCents, timeWindow, $length, matchedPitches, i, pitchRecEvent, t3, t4, pRecCents, pitchMatch, difference, guesses, numGuesses, j;
        noteStartTime = noteReachedEvent.get$contextTime();
        assessNote = this.getAssessNoteFromVNG$1(noteReachedEvent.get$visualNoteGroup());
        noteGroup = assessNote.get$vng().get$noteGroup();
        t1 = noteGroup.get$notes();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        note = t1[0];
        t1 = noteGroup.get$qNoteDuration();
        t2 = noteReachedEvent.get$tempo();
        if (typeof t2 !== "number")
          return H.iae(t2);
        durationInSeconds = t1 * (60 / t2);
        t2 = this._inst.get$requiredPitchesPerSecond();
        if (typeof t2 !== "number")
          return H.iae(t2);
        requiredMatches = C.JSNumber_methods.ceil$0(durationInSeconds * t2);
        t2 = note._displayCents;
        t1 = this._inst.get$transposition();
        if (typeof t1 !== "number")
          return t1.$mul();
        notationCents = t2 - t1 * 100;
        t1 = this._inst.get$timeBucketRight();
        t2 = Math.pow(durationInSeconds, 0.3);
        if (typeof t1 !== "number")
          return t1.$mul();
        timeWindow = t1 * t2;
        t2 = this._pitchRecognizer._pitchRecMethod;
        $length = this._prEvents.length;
        for (t1 = t2 !== 4, matchedPitches = 0, i = 0; i < $length; ++i) {
          t2 = this._prEvents;
          if (i < 0 || i >= t2.length)
            return H.ioore(t2, i);
          pitchRecEvent = t2[i];
          pitchRecEvent.set$correlationScore(-5);
          t2 = J.getInterceptor$x(pitchRecEvent);
          t3 = t2.get$time(pitchRecEvent);
          if (typeof noteStartTime !== "number")
            return noteStartTime.$sub();
          t4 = noteStartTime - timeWindow;
          if (J.$ge$n(t3, t4) && J.$le$n(t2.get$time(pitchRecEvent), noteStartTime + timeWindow)) {
            if (t1) {
              pRecCents = pitchRecEvent.get$cents();
              if (this._inst.get$ignoreOctave() !== true) {
                if (typeof pRecCents !== "number")
                  return H.iae(pRecCents);
                t2 = this._inst.get$tuningWindow();
                if (typeof t2 !== "number")
                  return H.iae(t2);
                if (notationCents - pRecCents < t2) {
                  t2 = this._inst.get$tuningWindow();
                  if (typeof t2 !== "number")
                    return H.iae(t2);
                  pitchMatch = pRecCents - notationCents < t2;
                } else
                  pitchMatch = false;
              } else {
                if (typeof pRecCents !== "number")
                  return H.iae(pRecCents);
                difference = notationCents >= pRecCents ? C.JSNumber_methods.$mod(notationCents - pRecCents, 1200) : C.JSNumber_methods.$mod(pRecCents - notationCents, 1200);
                t2 = this._inst.get$tuningWindow();
                if (typeof t2 !== "number")
                  return H.iae(t2);
                if (!(difference < t2)) {
                  t2 = this._inst.get$tuningWindow();
                  if (typeof t2 !== "number")
                    return H.iae(t2);
                  pitchMatch = difference > 1200 - t2;
                } else
                  pitchMatch = true;
              }
            } else {
              guesses = pitchRecEvent.get$centsGuessList();
              numGuesses = C.JSNull_methods.get$length(guesses);
              if (numGuesses.$gt(0, 3))
                numGuesses = 3;
              j = 0;
              while (true) {
                if (!(j < numGuesses)) {
                  pitchMatch = false;
                  break;
                }
                pRecCents = C.JSNull_methods.$index(guesses, j);
                if (this._inst.get$ignoreOctave() === true) {
                  t2 = C.JSNumber_methods.$sub(notationCents, pRecCents);
                  t3 = this._inst.get$tuningWindow();
                  if (typeof t3 !== "number")
                    return H.iae(t3);
                  if (t2 < t3) {
                    t2 = pRecCents.$sub(0, notationCents);
                    t3 = this._inst.get$tuningWindow();
                    if (typeof t3 !== "number")
                      return H.iae(t3);
                    t3 = t2 < t3;
                    t2 = t3;
                  } else
                    t2 = false;
                  if (t2) {
                    pitchMatch = true;
                    break;
                  }
                } else {
                  difference = C.JSNumber_methods.$ge(notationCents, pRecCents) ? C.JSNumber_methods.$mod(C.JSNumber_methods.$sub(notationCents, pRecCents), 1200) : C.JSNumber_methods.$mod(pRecCents.$sub(0, notationCents), 1200);
                  t2 = this._inst.get$tuningWindow();
                  if (typeof t2 !== "number")
                    return H.iae(t2);
                  if (!(difference < t2)) {
                    t2 = this._inst.get$tuningWindow();
                    if (typeof t2 !== "number")
                      return H.iae(t2);
                    t2 = difference > 1200 - t2;
                  } else
                    t2 = true;
                  if (t2) {
                    pitchMatch = true;
                    break;
                  }
                }
                ++j;
              }
            }
            if (pitchMatch) {
              ++matchedPitches;
              if (matchedPitches >= requiredMatches) {
                assessNote.set$matched(true);
                ++this._totalCorrect;
                this._visualizer.toString;
                assessNote.get$vng().setColor$1(65280);
                t1 = assessNote.get$vng().get$vSystemRef()._cache;
                if (t1 != null)
                  t1.update$0(0);
                this._hitMissHistory.push(1);
                return;
              }
            }
          } else if (J.$lt$n(t2.get$time(pitchRecEvent), t4)) {
            t2 = this._prEvents;
            (t2 && C.JSArray_methods).removeAt$1(t2, i);
            --i;
            --$length;
          } else if (J.$gt$n(t2.get$time(pitchRecEvent), noteStartTime + timeWindow))
            break;
        }
        assessNote.set$matched(false);
        ++this._totalIncorrect;
        this._visualizer.toString;
        assessNote.get$vng().setColor$1(16711680);
        t1 = assessNote.get$vng().get$vSystemRef()._cache;
        if (t1 != null)
          t1.update$0(0);
        this._hitMissHistory.push(0);
      },
      assessNote4$2: function(noteReachedEvent, cTime) {
        var noteStartTime, assessNote, noteGroup, t1, note, t2, durationInSeconds, requiredMatches, notationCents, twLeft, twRight, $length, i, matchedPitches, haveSplitPointInTimeWindow, pitchRecEvent, prEventTime, pRecCents, t3, prEventInTimeWindow, rms, t4, t5, pitchMatch, difference, guesses, numGuesses, j;
        noteStartTime = noteReachedEvent.get$contextTime();
        assessNote = this.getAssessNoteFromVNG$1(noteReachedEvent.get$visualNoteGroup());
        noteGroup = assessNote.get$vng().get$noteGroup();
        t1 = noteGroup.get$notes();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        note = t1[0];
        t1 = noteGroup.get$qNoteDuration();
        t2 = noteReachedEvent.get$tempo();
        if (typeof t2 !== "number")
          return H.iae(t2);
        durationInSeconds = t1 * (60 / t2);
        t1 = this._inst;
        if (durationInSeconds < 1) {
          t1 = t1.get$requiredPitchesPerSecond();
          if (typeof t1 !== "number")
            return H.iae(t1);
          requiredMatches = C.JSNumber_methods.ceil$0(durationInSeconds * t1);
        } else
          requiredMatches = t1.get$requiredPitchesPerSecond();
        t1 = note._displayCents;
        t2 = this._inst.get$transposition();
        if (typeof t2 !== "number")
          return t2.$mul();
        notationCents = t1 - t2 * 100;
        t1 = this._inst;
        if (durationInSeconds >= 1) {
          twLeft = t1.get$timeBucketLeft();
          twRight = this._inst.get$timeBucketRight();
        } else {
          t1 = t1.get$timeBucketLeft();
          t2 = Math.pow(durationInSeconds, 0.4);
          if (typeof t1 !== "number")
            return t1.$mul();
          twLeft = t1 * t2;
          t2 = this._inst.get$timeBucketRight();
          t1 = Math.pow(durationInSeconds, 0.4);
          if (typeof t2 !== "number")
            return t2.$mul();
          twRight = t2 * t1;
        }
        t1 = this._pitchRecognizer._pitchRecMethod;
        $length = this._prEvents.length;
        i = this._prEventWindowStartIndex;
        t1 = t1 !== 4;
        matchedPitches = 0;
        haveSplitPointInTimeWindow = false;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (!(i < $length))
            break;
          t2 = this._prEvents;
          if (i >= t2.length)
            return H.ioore(t2, i);
          pitchRecEvent = t2[i];
          pitchRecEvent.set$correlationScore(-5);
          prEventTime = J.get$time$x(pitchRecEvent);
          pRecCents = pitchRecEvent.get$cents();
          if (typeof noteStartTime !== "number")
            return noteStartTime.$sub();
          if (typeof twLeft !== "number")
            return H.iae(twLeft);
          t2 = noteStartTime - twLeft;
          t3 = J.getInterceptor$n(prEventTime);
          if (t3.$ge(prEventTime, t2)) {
            if (typeof twRight !== "number")
              return H.iae(twRight);
            prEventInTimeWindow = t3.$le(prEventTime, noteStartTime + twRight);
          } else
            prEventInTimeWindow = false;
          if (pitchRecEvent.get$pitchSplit() || pitchRecEvent.get$amplSplit())
            haveSplitPointInTimeWindow = prEventInTimeWindow;
          rms = pitchRecEvent.get$rms();
          t4 = this._maxAmplitudeEncountered;
          if (typeof rms !== "number")
            return rms.$gt();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (rms > t4) {
            this._maxAmplitudeEncountered = rms;
            t4 = rms;
          }
          t5 = this._inst.get$minAmplPerc();
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(rms < t4 * t5)) {
            if (haveSplitPointInTimeWindow) {
              if (typeof twRight !== "number")
                return H.iae(twRight);
              t4 = t3.$le(prEventTime, noteStartTime + 2 * twRight);
            } else
              t4 = false;
            if (!t4) {
              if (t3.$ge(prEventTime, noteStartTime)) {
                if (typeof twRight !== "number")
                  return H.iae(twRight);
                t4 = t3.$le(prEventTime, noteStartTime + twRight);
              } else
                t4 = false;
              t4 = t4 && this._lastNotationPitch === notationCents;
            } else
              t4 = true;
            if (t4) {
              if (t1)
                if (this._inst.get$ignoreOctave() !== true) {
                  if (typeof pRecCents !== "number")
                    return H.iae(pRecCents);
                  t4 = this._inst.get$tuningWindow();
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  if (notationCents - pRecCents < t4) {
                    t4 = this._inst.get$tuningWindow();
                    if (typeof t4 !== "number")
                      return H.iae(t4);
                    pitchMatch = pRecCents - notationCents < t4;
                  } else
                    pitchMatch = false;
                } else {
                  if (typeof pRecCents !== "number")
                    return H.iae(pRecCents);
                  difference = notationCents >= pRecCents ? C.JSNumber_methods.$mod(notationCents - pRecCents, 1200) : C.JSNumber_methods.$mod(pRecCents - notationCents, 1200);
                  t4 = this._inst.get$tuningWindow();
                  if (typeof t4 !== "number")
                    return H.iae(t4);
                  if (!(difference < t4)) {
                    t4 = this._inst.get$tuningWindow();
                    if (typeof t4 !== "number")
                      return H.iae(t4);
                    pitchMatch = difference > 1200 - t4;
                  } else
                    pitchMatch = true;
                }
              else {
                guesses = pitchRecEvent.get$centsGuessList();
                numGuesses = C.JSNull_methods.get$length(guesses);
                if (numGuesses.$gt(0, 3))
                  numGuesses = 3;
                j = 0;
                while (true) {
                  if (!(j < numGuesses)) {
                    pitchMatch = false;
                    break;
                  }
                  pRecCents = C.JSNull_methods.$index(guesses, j);
                  if (this._inst.get$ignoreOctave() !== true) {
                    t4 = C.JSNumber_methods.$sub(notationCents, pRecCents);
                    t5 = this._inst.get$tuningWindow();
                    if (typeof t5 !== "number")
                      return H.iae(t5);
                    if (t4 < t5) {
                      t4 = pRecCents.$sub(0, notationCents);
                      t5 = this._inst.get$tuningWindow();
                      if (typeof t5 !== "number")
                        return H.iae(t5);
                      t5 = t4 < t5;
                      t4 = t5;
                    } else
                      t4 = false;
                    if (t4) {
                      pitchMatch = true;
                      break;
                    }
                  } else {
                    difference = C.JSNumber_methods.$ge(notationCents, pRecCents) ? C.JSNumber_methods.$mod(C.JSNumber_methods.$sub(notationCents, pRecCents), 1200) : C.JSNumber_methods.$mod(pRecCents.$sub(0, notationCents), 1200);
                    t4 = this._inst.get$tuningWindow();
                    if (typeof t4 !== "number")
                      return H.iae(t4);
                    if (!(difference < t4)) {
                      t4 = this._inst.get$tuningWindow();
                      if (typeof t4 !== "number")
                        return H.iae(t4);
                      t4 = difference > 1200 - t4;
                    } else
                      t4 = true;
                    if (t4) {
                      pitchMatch = true;
                      break;
                    }
                  }
                  ++j;
                }
              }
              if (pitchMatch) {
                ++matchedPitches;
                if (typeof requiredMatches !== "number")
                  return H.iae(requiredMatches);
                if (matchedPitches >= requiredMatches) {
                  this._lastNotationPitch = notationCents;
                  assessNote.set$matched(true);
                  ++this._totalCorrect;
                  this._visualizer.toString;
                  assessNote.get$vng().setColor$1(65280);
                  t1 = assessNote.get$vng().get$vSystemRef()._cache;
                  if (t1 != null)
                    t1.update$0(0);
                  this._hitMissHistory.push(1);
                  return;
                }
              }
            }
          }
          if (t3.$lt(prEventTime, t2)) {
            t2 = this._prEventWindowStartIndex;
            if (typeof t2 !== "number")
              return t2.$add();
            this._prEventWindowStartIndex = t2 + 1;
          } else {
            if (typeof twRight !== "number")
              return H.iae(twRight);
            if (t3.$gt(prEventTime, noteStartTime + twRight) && !haveSplitPointInTimeWindow)
              break;
          }
          ++i;
        }
        this._lastNotationPitch = notationCents;
        assessNote.set$matched(false);
        ++this._totalIncorrect;
        this._visualizer.toString;
        assessNote.get$vng().setColor$1(16711680);
        t1 = assessNote.get$vng().get$vSystemRef()._cache;
        if (t1 != null)
          t1.update$0(0);
        this._hitMissHistory.push(0);
      }
    },
    RhythmAssessor: {
      "^": "Assessor;_hitRecognizer,_sfPlayer,_noteIndex,_sfLoader,_hitSubscription,_firstNotePlayed,_notesReachedQue,_beatsReachedQue,_rhythmHits,_beatHits,_defaultWindowSize,_visualizer,_scoreViewer,_noteList,_totalCorrect,_totalIncorrect,_totalExtra",
      start$0: [function(_) {
        var t1 = this._hitRecognizer._hitEventController;
        this._hitSubscription = new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(this.get$_onHit());
        this._scoreViewer.on$1(0, "noteReached")._subscribe$3(this.get$_onNoteReached(), false, 0);
        this._scoreViewer.on$1(0, "beatReached")._subscribe$3(this.get$_onBeatReached(), false, 0);
        this._rhythmHits = [];
        this._beatHits = [];
        this._notesReachedQue = [];
        this._beatsReachedQue = [];
        this._firstNotePlayed = false;
        this._noteIndex = 0;
        t1 = this._hitRecognizer;
        if (t1._keyboardSub == null)
          t1._keyboardSub = W._EventStreamSubscription$(document, "keydown", t1.get$_onKeyDown(), false, W.KeyboardEvent);
      }, "call$0", "get$start", 0, 0, 2],
      stop$0: function(_) {
        var t1;
        if (this._hitSubscription != null) {
          t1 = this._hitRecognizer;
          t1._keyboardSub.cancel$0(0);
          t1._keyboardSub = null;
          this._hitSubscription.cancel$0(0);
          this._hitSubscription = null;
          this._scoreViewer.on$1(0, "noteReached")._unsubscribe$2(this.get$_onNoteReached(), false);
          this._scoreViewer.on$1(0, "beatReached")._unsubscribe$2(this.get$_onBeatReached(), false);
        }
      },
      _stagexl$_init$0: function() {
        var t1, t2;
        this.super$Assessor$_init();
        t1 = $.AudioManager_context;
        t2 = $.KeyHitRecognizer__ref;
        if (t2 == null) {
          t1 = new Q.KeyHitRecognizer(t1, false, 32, null, new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [null]));
          $.KeyHitRecognizer__ref = t1;
        } else
          t1 = t2;
        this._hitRecognizer = t1;
        t1._sendBeatEvents = true;
      },
      _onHit$1: [function(e) {
        var t1, note, t2;
        t1 = J.getInterceptor$x(e);
        t1.set$time(e, this._scoreViewer._stagexl$_pm._qNoteTime);
        if (e.get$hitType() === C.HitType_0) {
          this._rhythmHits.push(e);
          note = this._findNoteMatchForHit$1(e);
          if (note != null) {
            this._markNoteCorrect$1(note);
            t1 = note.vng.get$noteGroup().get$notes();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            this._playNote$1(t1[0]);
          } else {
            t2 = this._findClosestNoteForHit$1(e).vng.get$noteGroup().get$notes();
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            this._playNote$1(t2[0]);
            t1 = t1.get$time(e);
            ++this._totalExtra;
            this._visualizer.addExtraNote$2(this._scoreViewer, t1);
          }
        } else
          this._beatHits.push(e);
      }, "call$1", "get$_onHit", 2, 0, 48, 0],
      _onNoteReached$1: [function(e) {
        if (this._firstNotePlayed !== true)
          this._firstNotePlayed = true;
        this._notesReachedQue.push(e);
      }, "call$1", "get$_onNoteReached", 2, 0, 7, 0],
      _onBeatReached$1: [function(e) {
        if (this._firstNotePlayed === true)
          this._beatsReachedQue.push(e);
      }, "call$1", "get$_onBeatReached", 2, 0, 7, 0],
      _findNoteMatchForHit$1: function(e) {
        var tempo, windowSize, i, t1, t2, t3, cng, noteTime;
        tempo = this._scoreViewer._stagexl$_pm._lastTimeStamp;
        windowSize = this._defaultWindowSize * J.$div$n(tempo == null ? tempo : tempo.get$tempo(), 90);
        i = this._noteIndex;
        t1 = J.getInterceptor$x(e);
        while (true) {
          t2 = this._noteList;
          t3 = t2.length;
          if (typeof i !== "number")
            return i.$lt();
          if (!(i < t3))
            break;
          c$0: {
            cng = t2[i].vng.get$noteGroup();
            if (!cng.get$isRest()) {
              t2 = cng.get$notes();
              if (0 >= t2.length)
                return H.ioore(t2, 0);
              if (t2[0]._tieState !== "continue") {
                t2 = cng.get$notes();
                if (0 >= t2.length)
                  return H.ioore(t2, 0);
                t2 = t2[0]._tieState === "stop";
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              break c$0;
            noteTime = cng.get$qNoteTime();
            t2 = J.getInterceptor$n(noteTime);
            if (J.$gt$n(t1.get$time(e), t2.$sub(noteTime, windowSize)) && J.$lt$n(t1.get$time(e), t2.$add(noteTime, windowSize))) {
              this._noteIndex = i + 1;
              t1 = this._noteList;
              if (i >= t1.length)
                return H.ioore(t1, i);
              return t1[i];
            } else if (J.$le$n(t1.get$time(e), J.$sub$n(cng.get$qNoteTime(), windowSize)))
              break;
          }
          ++i;
        }
        return;
      },
      _findClosestNoteForHit$1: function(e) {
        var t1, t2, t3, i, closestNote, closestDistance, increment, distance;
        t1 = this._noteIndex;
        t2 = this._noteList;
        t3 = t2.length;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (t1 < t3)
          i = t1;
        else
          i = t3 - 1;
        if (i < 0 || i >= t3)
          return H.ioore(t2, i);
        closestNote = t2[i];
        t1 = J.getInterceptor$x(e);
        closestDistance = J.abs$0$n(J.$sub$n(closestNote.vng.get$noteGroup().get$qNoteTime(), t1.get$time(e)));
        increment = J.$gt$n(closestNote.vng.get$noteGroup().get$qNoteTime(), t1.get$time(e)) ? -1 : 1;
        while (true) {
          if (!(i >= 0 && i < this._noteList.length))
            break;
          t2 = this._noteList;
          if (i < 0 || i >= t2.length)
            return H.ioore(t2, i);
          distance = J.abs$0$n(J.$sub$n(t2[i].vng.get$noteGroup().get$qNoteTime(), t1.get$time(e)));
          if (J.$le$n(distance, closestDistance)) {
            t2 = this._noteList;
            if (i >= t2.length)
              return H.ioore(t2, i);
            closestNote = t2[i];
          } else
            break;
          i += increment;
          closestDistance = distance;
        }
        return closestNote;
      },
      _playNote$1: function(note) {
        var part, t1, t2, t3, t4, pNote, duration, bs, gainNode, t5, finalGainNode;
        part = note._noteGroup._voice._measure._staff._partRef;
        t1 = C.JSNumber_methods._tdivFast$1(note._displayCents, 100);
        t2 = part._chromaticTransposition;
        t3 = $.AudioManager_context.currentTime;
        t4 = this._sfPlayer.SAMPLE_RATE;
        if (typeof t3 !== "number")
          return t3.$mul();
        pNote = L.PerformanceNoteDO_createPerformanceNote(t1 - t2, C.JSDouble_methods.round$0(t3 * t4), C.JSDouble_methods.round$0(0.5 * t4), 0.5, 0.5, this._sfLoader.getPreset$2(0, 0));
        t4 = this._sfPlayer;
        t4.toString;
        t3 = pNote.sampleStartTime;
        t2 = t4.SAMPLE_RATE;
        t1 = t3 / t2;
        duration = (pNote.sampleEndTime - t3) / 44100;
        bs = $.SFPlayer__context.createBufferSource();
        bs.buffer = pNote.audioBuffer;
        gainNode = J.createGain$0$x($.SFPlayer__context);
        gainNode.gain.setValueAtTime(1, t1);
        gainNode.gain.setValueAtTime(1, t1 + J.$div$n(pNote.decayStartTime, 44100));
        t3 = gainNode.gain;
        t5 = pNote.sustainVolReduction;
        if (typeof t5 !== "number")
          return H.iae(t5);
        t3.linearRampToValueAtTime(1 - t5, t1 + J.$div$n(pNote.decayEndTime, 44100));
        t5 = t1 + duration;
        gainNode.gain.linearRampToValueAtTime(0, t5);
        finalGainNode = J.createGain$0$x($.SFPlayer__context);
        finalGainNode.gain.value = pNote.amplitude;
        finalGainNode.connect($.SFPlayer__context.destination, 0, 0);
        gainNode.connect(finalGainNode, 0, 0);
        bs.connect(gainNode, 0, 0);
        t3 = pNote.sampleRate;
        bs.playbackRate.value = t3 / 44100;
        if (pNote.loop === true) {
          bs.loopStart = J.$div$n(J.$mul$ns(pNote.loopStartPos, t2), pNote.sampleRate) / 44100;
          bs.loopEnd = J.$div$n(J.$mul$ns(pNote.loopEndPos, t2), pNote.sampleRate) / 44100;
          bs.loop = true;
        }
        C.AudioBufferSourceNode_methods.start$3(bs, t1, 0, duration);
        C.AudioBufferSourceNode_methods.stop$1(bs, t5);
        t4._noteNodes.push(new L.NoteNodes(t5, bs, gainNode, finalGainNode));
      }
    },
    Assessor: {
      "^": "Object;",
      _stagexl$_init$0: ["super$Assessor$_init", function() {
        this._visualizer = new F.AssessmentVisualizer();
        this._createAssessmentNotes$0();
      }],
      getAssessNoteFromVNG$1: function(vng) {
        var t1, t2, _i, assessNote;
        for (t1 = this._noteList, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          assessNote = t1[_i];
          if (J.$eq$(assessNote.vng, vng))
            return assessNote;
        }
        return;
      },
      _createAssessmentNotes$0: function() {
        var t1, t2, _i, vng, ng, t3, note;
        this._noteList = [];
        for (t1 = this._scoreViewer._vngList, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          vng = t1[_i];
          ng = vng.get$noteGroup();
          if (!ng.get$isRest()) {
            t3 = ng.get$notes();
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            if (t3[0]._tieState !== "none") {
              t3 = ng.get$notes();
              if (0 >= t3.length)
                return H.ioore(t3, 0);
              t3 = t3[0]._tieState === "start";
            } else
              t3 = true;
          } else
            t3 = false;
          if (t3) {
            note = new F.AssessmentNote(null, false);
            note.vng = vng;
            this._noteList.push(note);
          }
        }
      },
      _markNoteCorrect$1: function(note) {
        var t1;
        note.set$matched(true);
        ++this._totalCorrect;
        this._visualizer.toString;
        note.get$vng().setColor$1(65280);
        t1 = note.get$vng().get$vSystemRef()._cache;
        if (t1 != null)
          t1.update$0(0);
      }
    },
    AssessmentVisualizer: {
      "^": "Object;",
      addExtraNote$2: function(scoreViewer, time) {
        var vngList, numNotes, i, xVal, targetSystem, i0, t1, noteBefore, t2, noteAfter, posRatio, bd, bmp;
        vngList = scoreViewer._vngList;
        numNotes = vngList.length;
        if (0 >= numNotes)
          return H.ioore(vngList, 0);
        if (J.$gt$n(vngList[0].get$noteGroup().get$qNoteTime(), time)) {
          if (0 >= vngList.length)
            return H.ioore(vngList, 0);
          J.$sub$n(vngList[0].get$originalPosition().x, 30);
          if (0 >= vngList.length)
            return H.ioore(vngList, 0);
          vngList[0].get$vSystemRef();
        } else if (J.$lt$n((vngList && C.JSArray_methods).get$last(vngList).get$noteGroup().get$qNoteTime(), time)) {
          J.$add$ns(C.JSArray_methods.get$last(vngList).get$originalPosition().x, 30);
          C.JSArray_methods.get$last(vngList).get$vSystemRef();
        } else {
          i = numNotes - 1;
          i0 = i;
          while (true) {
            if (!(i0 >= 0)) {
              xVal = 0;
              targetSystem = null;
              break;
            }
            if (i0 >= vngList.length)
              return H.ioore(vngList, i0);
            if (J.$le$n(vngList[i0].get$noteGroup().get$qNoteTime(), time)) {
              t1 = vngList.length;
              if (i0 >= t1)
                return H.ioore(vngList, i0);
              noteBefore = vngList[i0];
              if (i0 < i) {
                t2 = i0 + 1;
                if (t2 >= t1)
                  return H.ioore(vngList, t2);
                noteAfter = vngList[t2];
              } else
                noteAfter = noteBefore;
              if (J.$ge$n(noteAfter.get$originalPosition().x, noteBefore.get$originalPosition().x)) {
                posRatio = J.$div$n(J.$sub$n(time, noteBefore.get$noteGroup().get$qNoteTime()), J.$sub$n(noteAfter.get$noteGroup().get$qNoteTime(), noteBefore.get$noteGroup().get$qNoteTime()));
                t1 = noteBefore.get$originalPosition().x;
                t2 = J.$sub$n(noteAfter.get$originalPosition().x, noteBefore.get$originalPosition().x);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                xVal = J.$add$ns(t1, posRatio * t2);
              } else
                xVal = J.$add$ns(noteBefore.get$originalPosition().x, 30);
              targetSystem = noteBefore.get$vSystemRef();
              break;
            }
            --i0;
          }
          if (targetSystem._extraNoteheads == null)
            targetSystem._extraNoteheads = [];
          bd = G.MusicTextures_getColoredNoteheadBD(C.NoteheadType_0, 16711680);
          t1 = $.DisplayObject__nextID;
          $.DisplayObject__nextID = t1 + 1;
          bmp = new A.Bitmap(bd, t1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
          bmp.set$x(0, xVal);
          bmp.set$y(0, 0);
          targetSystem._extraNoteheads.push(bmp);
          targetSystem.addChild$1(bmp);
          t1 = targetSystem._cache;
          if (t1 != null)
            t1.update$0(0);
        }
      },
      clearAssessmentVisuals$1: function(scoreViewer) {
        var t1, t2, _i, systems, sys;
        for (t1 = scoreViewer._vngList, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          J.clearColor$0$x(t1[_i]);
        systems = scoreViewer._vScore.getVisualSystems$0();
        for (t1 = systems.length, _i = 0; _i < systems.length; systems.length === t1 || (0, H.throwConcurrentModificationError)(systems), ++_i) {
          sys = systems[_i];
          sys.removeExtraNoteheads$0();
          sys.refreshCache$0();
        }
      }
    },
    AssessmentNote: {
      "^": "Object;vng<,matched?"
    }
  }], ["score_player", "package:score_player/score_player.dart",, M, {
    "^": "",
    AbstractControls: {
      "^": "Sprite;",
      init$0: function() {
        var gbd, t1, t2, t3, upBmp, downBmp;
        gbd = H.interceptedTypeCast(this.pm._resourceManager._getResourceValue$2("TextureAtlas", "controls"), "$isTextureAtlas").get$getBitmapData();
        t1 = gbd.call$1("playBtn");
        t2 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t2 + 1;
        t3 = [A.BitmapFilter];
        this._playBtnBmp = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        t2 = gbd.call$1("stopBtn");
        t1 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t1 + 1;
        this._stopBtnBmp = new A.Bitmap(t2, t1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        t1 = this._playBtnBmp;
        this._playBtn = A.SimpleButton$(t1, t1, t1, t1);
        t1 = gbd.call$1("upBtn");
        t2 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t2 + 1;
        upBmp = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        this._upTempoBtn = A.SimpleButton$(upBmp, upBmp, upBmp, upBmp);
        t2 = gbd.call$1("downBtn");
        t1 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t1 + 1;
        downBmp = new A.Bitmap(t2, t1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        this._downTempoBtn = A.SimpleButton$(downBmp, downBmp, downBmp, downBmp);
        t3 = Y.TextField$("", new Y.TextFormat("Arial", 24, 5394804, 0, 4278190080, null, 400, false, false, false, "left", "top", 0, 0, 0, 0, 0, 0));
        this._tempoTF = t3;
        t3.set$scaleY(0.5);
        t3.set$scaleX(0.5);
        t3 = this._tempoTF;
        t3._autoSize = "left";
        t3._refreshPending |= 3;
        t3.mouseEnabled = false;
        this._playBtn.set$x(0, 0);
        this._playBtn.set$y(0, 0);
        this._downTempoBtn.set$x(0, 50);
        this._downTempoBtn.set$y(0, 3);
        this._upTempoBtn.set$x(0, 100);
        this._upTempoBtn.set$y(0, 3);
        this._tempoTF.set$x(0, 95);
        this._tempoTF.set$y(0, 23);
        this._updateTempoDisplay$0();
        this.addChild$1(this._playBtn);
        this.addChild$1(this._upTempoBtn);
        this.addChild$1(this._downTempoBtn);
        this.addChild$1(this._tempoTF);
        this.pm.on$1(0, "playerInit")._subscribe$3(this.get$onPlayerInit(), false, 0);
        this.pm.on$1(0, "songRendered")._subscribe$3(this.get$onSongRendered(), false, 0);
        this.pm.on$1(0, "playbackStarted")._subscribe$3(this.get$onPlaybackStarted(), false, 0);
        this.pm.on$1(0, "playbackFinished")._subscribe$3(this.get$onPlaybackFinished(), false, 0);
        this.pm.on$1(0, "songClosing")._subscribe$3(this.get$onSongClosing(), false, 0);
        t3 = this.get$_onTempoUpBtnClick();
        this._upTempoBtn.on$1(0, "click").listen$1(t3);
        this._upTempoBtn.on$1(0, "touchTap").listen$1(t3);
        t3 = this.get$_onTempoDownBtnClick();
        this._downTempoBtn.on$1(0, "click").listen$1(t3);
        this._downTempoBtn.on$1(0, "touchTap").listen$1(t3);
        t3 = this.get$_onPlayBtnClick();
        this._playBtn.on$1(0, "click").listen$1(t3);
        this._playBtn.on$1(0, "touchTap").listen$1(t3);
      },
      onPlayerInit$1: [function(e) {
        this.setMode$1(0);
      }, "call$1", "get$onPlayerInit", 2, 0, 5],
      onSongRendered$1: [function(e) {
        this.setMode$1(1);
      }, "call$1", "get$onSongRendered", 2, 0, 5],
      onPlaybackStarted$1: [function(e) {
        this.setMode$1(2);
      }, "call$1", "get$onPlaybackStarted", 2, 0, 5],
      onPlaybackFinished$1: [function(e) {
        this.setMode$1(1);
      }, "call$1", "get$onPlaybackFinished", 2, 0, 5],
      onSongClosing$1: [function(e) {
        this.setMode$1(0);
      }, "call$1", "get$onSongClosing", 2, 0, 5]
    },
    AbstractPlayer: {
      "^": "Sprite;",
      init$1: ["super$AbstractPlayer$init", function(config) {
        var t1, root, t2, key, t3, sourceUrl, t4, options, pixelRatioMatch, maxPixelRatio, t5, originPixelRatio, loaderPixelRatio, pixelRatio, t6, sourceUrl0;
        this._config = config;
        this.scoreManager = new K.ScoreManager(null, null, null, null);
        P.print("Loading graphics...");
        t1 = this._config;
        root = t1.resourceRoot;
        $.MusicTextures_pathPrefix = root;
        this._resourceManager = new O.ResourceManager(new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.String, O.ResourceManagerResource]), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [P.num]));
        for (t1 = t1.atlases, t1 = t1.get$keys(t1), t1 = t1.get$iterator(t1), t2 = J.getInterceptor$ns(root); t1.moveNext$0();) {
          key = t1.get$current();
          t3 = this._resourceManager;
          sourceUrl = t2.$add(root, this._config.atlases.$index(0, key));
          t3.toString;
          t4 = new O._TextureAtlasLoaderFile("", false, false, 1);
          options = $.$get$BitmapData_defaultLoadOptions();
          pixelRatioMatch = P.RegExp_RegExp("@(\\d)x", true, false).firstMatch$1(sourceUrl);
          if (pixelRatioMatch != null) {
            maxPixelRatio = options.maxPixelRatio;
            t5 = pixelRatioMatch._match;
            if (1 >= t5.length)
              return H.ioore(t5, 1);
            originPixelRatio = H.Primitives_parseInt(t5[1], null, null);
            loaderPixelRatio = J.round$0$n(V.minNum($.$get$devicePixelRatio(), maxPixelRatio));
            if (typeof originPixelRatio !== "number")
              return H.iae(originPixelRatio);
            pixelRatio = loaderPixelRatio / originPixelRatio;
            t6 = t5.index;
            sourceUrl0 = J.replaceRange$3$asx(sourceUrl, t6, t6 + t5[0].length, "@" + loaderPixelRatio + "x");
          } else {
            sourceUrl0 = sourceUrl;
            pixelRatio = 1;
          }
          t4._sourceUrl = sourceUrl0;
          options.webp;
          t4._pixelRatio = pixelRatio;
          t3._addResource$4("TextureAtlas", key, sourceUrl, C.C__TextureAtlasFormatJson.load$1(0, t4));
        }
        this._resourceManager.load$0(0).then$1(new M.AbstractPlayer_init_closure(this));
      }],
      resizeDisplay$2: function(setWidth, setHeight) {
        this._lm.resizeDisplay$2(setWidth, setHeight);
      },
      loadSong$2$partIndex: function(musicXMLString, partIndex) {
        var t1;
        P.print("Rendering music...");
        this._driver.parseScore$3(musicXMLString, true, true).then$1(new M.AbstractPlayer_loadSong_closure(this, partIndex)).catchError$1(new M.AbstractPlayer_loadSong_closure0(this));
        t1 = new P._Future(0, $.Zone__current, null, [null]);
        this._songLoadCompleter = new P._AsyncCompleter(t1, [null]);
        return t1;
      },
      loadSong$1: function(musicXMLString) {
        return this.loadSong$2$partIndex(musicXMLString, 0);
      },
      setPartPlaybackPresets$0: function() {
        var t1, t2, _i, part;
        for (t1 = this.score.get$parts(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          part = t1[_i];
          if (!J.$eq$(part.get$midiChannel(), 10))
            part.set$midiPreset(0);
        }
      },
      setPartVolumesAndPan$0: function() {
        var numParts, t1, t2, t3, i, t4, part;
        numParts = this.score.get$parts().length;
        for (t1 = numParts > 1, t2 = 0.2 / numParts, t3 = numParts - 1, i = 0; i < numParts; ++i) {
          t4 = this.score.get$parts();
          if (i >= t4.length)
            return H.ioore(t4, i);
          part = t4[i];
          t4 = J.getInterceptor(part);
          t4.set$volume(part, (t4.$eq(part, this._lm._currentPart) ? 0.4 : 0.3) + t2);
          t4.set$pan(part, t1 ? 0.3 + 0.4 * (i / t3) : 0.5);
        }
      }
    },
    AbstractPlayer_init_closure: {
      "^": "Closure:0;$this",
      call$1: [function(_) {
        var t1, t2, t3, t4;
        t1 = this.$this;
        t2 = new M._LayoutManager(null, null, null, null, null, null, null);
        t2._pm = t1;
        t2._init$0();
        t1._lm = t2;
        t2 = new M._PlaybackManager(null, null, null, null);
        t2._pm = t1;
        t2._init$0();
        t1._pbm = t2;
        t2.on$1(0, "playbackManagerReady")._subscribe$3(new M.AbstractPlayer_init__closure(t1), false, 0);
        t2 = t1._lm;
        t3 = t1._config;
        t2._width = t3.playerWidth;
        t2._height = t3.playerHeight;
        t1.instrument = t3.instrument;
        t3 = t2._fingeringDM;
        t4 = t3._showFingerings;
        t3.setInstrument$2(t2._pm.instrument, t4);
        t4 = t1._lm;
        t1._config.showFingerings;
        t4._fingeringDM.setInstrument$2(t4._pm.instrument, true);
        t1._lm.set$showNoteNames(t1._config.showNoteNames);
        t4 = t1._lm;
        t1 = t1._config.notationVOffset;
        t4.toString;
        $.BitmapMusicRenderer_firstPageVerticalOffset = t1;
      }, null, null, 2, 0, null, 4, "call"]
    },
    AbstractPlayer_init__closure: {
      "^": "Closure:0;$this",
      call$1: function(_) {
        this.$this.dispatchEvent$1(0, new M.PlayerEvent(null, "playerInit", false, C.EventPhase_1, null, null, false, false));
      }
    },
    AbstractPlayer_loadSong_closure: {
      "^": "Closure:20;$this,partIndex",
      call$1: [function(score) {
        var t1 = this.$this;
        t1.score = score;
        P.Timer_Timer(C.Duration_0, new M.AbstractPlayer_loadSong__closure(t1, this.partIndex, score));
      }, null, null, 2, 0, null, 17, "call"]
    },
    AbstractPlayer_loadSong__closure: {
      "^": "Closure:1;$this,partIndex,score",
      call$0: function() {
        var t1, t2, t3, t4;
        t1 = this.$this;
        t2 = t1.scoreManager;
        t3 = this.score;
        t2._score = t3;
        t4 = new K.NoteManager(null);
        t4._score = t3;
        t2._noteManager = t4;
        t2._transpositionManager = new K.TranspositionManager(t3, t4, null, []);
        t2._pitchNameManager = new K.PitchNameManager(t3);
        t2 = this.partIndex;
        if (t2 < t3.get$parts().length) {
          t3 = t3.get$parts();
          if (t2 >= t3.length)
            return H.ioore(t3, t2);
          t2 = t3[t2];
        } else {
          t2 = t3.get$parts();
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t2 = t2[0];
        }
        t3 = t1._lm;
        t3._currentPart = t2;
        t3.set$showNoteNames(t3._showNoteNames);
        t1.setPartVolumesAndPan$0();
        t1.setPartPlaybackPresets$0();
        P.Timer_Timer(C.Duration_0, new M.AbstractPlayer_loadSong___closure(t1));
      }
    },
    AbstractPlayer_loadSong___closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, t2, t3, sv, parts, viewerRect, t4, t5, t6;
        t1 = this.$this;
        t2 = t1._lm;
        t3 = t2._pm;
        sv = t3._score_player$_scoreViewer;
        if (sv != null && sv._parent === t3)
          t3.removeChild$1(sv);
        t3 = t2._currentPart;
        parts = t3 != null ? [J.get$name$x(t3)] : null;
        viewerRect = t2._calculatePositions$0();
        t3 = t2._pm;
        t4 = t3._driver;
        t3 = t3.score;
        t5 = viewerRect.width;
        t6 = viewerRect.height;
        t4._stagexl$_score = t3;
        t4 = t4._drawManager;
        t4._clearSystemIndents$0();
        t4._scoreFormatter = null;
        t4._renderMusic$4(t5, t6, 0, parts);
        sv = t4._stagexl$_driver._scoreViewer;
        t2._pm._score_player$_scoreViewer = sv;
        sv.set$x(0, viewerRect.left);
        sv.set$y(0, viewerRect.top);
        t2._pm.addChild$1(sv);
        t3 = t2._fingeringDM;
        t3._score_player$_removeListeners$0();
        t3._score_player$_scoreViewer = sv;
        t3._addListeners$0();
        t2._notifySongRendered$0();
        P.Timer_Timer(C.Duration_0, new M.AbstractPlayer_loadSong____closure(t1));
      }
    },
    AbstractPlayer_loadSong____closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1 = this.$this;
        t1.dispatchEvent$1(0, new M.PlayerEvent(null, "songLoaded", false, C.EventPhase_1, null, null, false, false));
        t1._songLoadCompleter.complete$0(0);
      }
    },
    AbstractPlayer_loadSong_closure0: {
      "^": "Closure:0;$this",
      call$1: [function(e) {
        this.$this._songLoadCompleter.completeError$1(e);
      }, null, null, 2, 0, null, 0, "call"]
    },
    _PlaybackManager: {
      "^": "EventDispatcher;_pm,_sfLoadProgressListener,_playbackDO,_eventStreams",
      _init$0: function() {
        var t1, root, t2, t3, t4;
        P.print("Initializing sound engine...");
        t1 = this._pm;
        root = t1._config.resourceRoot;
        t2 = H.S(root) + "sf/sf2.wav";
        t3 = H.S(root) + "sf/sf2_v2.json";
        t4 = new F.SFScoreDriver(null, null, null, null, null, null, null, null, null, false, null, null, null, 0, null);
        t4._initDriverCallback = new M._PlaybackManager__init_closure(this);
        t4._stagexl$_init$3(t2, t3, null);
        t1._driver = t4;
        t4 = this._pm._driver._sfLoader._progressController;
        this._sfLoadProgressListener = new P._ControllerStream(t4, [H.getTypeArgumentByIndex(t4, 0)]).listen$1(this.get$_onSFLoadProgress());
      },
      _onSFLoadProgress$1: [function(message) {
        P.print("Initializing sound engine... " + H.S(message));
      }, "call$1", "get$_onSFLoadProgress", 2, 0, 27, 53],
      _play$6: function(loop, tempo, tempoIncrement, startNG, endNG, assessmentType) {
        var t1, t2;
        t1 = this._pm.score;
        if (t1 == null)
          return;
        t2 = new M._PlaybackDO(null, null, null, 2, null, 0, 0, false);
        this._playbackDO = t2;
        t2.loop = loop;
        if (startNG == null) {
          t1 = t1.get$parts();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = t1[0].getFirstNote$0();
        } else
          t1 = startNG;
        t2.startNG = t1;
        t1 = this._playbackDO;
        t1.endNG = endNG;
        t1.assessmentType = assessmentType;
        t1.tempo = tempo > 0 ? tempo : this._pm.controls._tempoPercentage / 100;
        t1.tempoIncrement = tempoIncrement;
        this._startPlayback$0();
        this._pm.dispatchEvent$1(0, new M.PlayerEvent(null, "playbackStarted", false, C.EventPhase_1, null, null, false, false));
      },
      _startPlayback$0: function() {
        var pdo, t1, t2, endQNoteTime, t3, t4, t5;
        pdo = this._playbackDO;
        if (pdo.playbackFinished)
          return;
        t1 = pdo.loop;
        t2 = pdo.endNG;
        if (t2 != null) {
          endQNoteTime = J.$add$ns(t2.get$qNoteTime(), pdo.endNG.get$qNoteDuration());
          if (J.get$next$x(pdo.endNG) != null)
            endQNoteTime = J.$add$ns(endQNoteTime, Math.min(J.get$next$x(pdo.endNG).get$qNoteDuration(), 0.1));
        } else
          endQNoteTime = null;
        t2 = this._pm._driver._assessor;
        if (t2 != null)
          t2._visualizer.clearAssessmentVisuals$1(t2._scoreViewer);
        t2 = this._pm._driver;
        t3 = pdo.tempo;
        t4 = pdo.startNG;
        t5 = pdo.countoffSeconds;
        t2.play$9$assessmentType$countoffSeconds$endQNoteTime$metronomeVolume$playRepeats$playSoundFontNotes$startNG$tempoRatio(0, this.get$_onPlaybackComplete(), pdo.assessmentType, t5, endQNoteTime, 0, t1 === false, true, t4, t3);
      },
      _onPlaybackComplete$0: [function() {
        var t1, t2, sv, system, msPerBeat, pauseDuration;
        t1 = this._playbackDO;
        if (t1.loop === true) {
          t2 = t1.tempoIncrement;
          if (t2 > 0) {
            t2 = t1.tempo += t2;
            if (t2 > 1)
              t1.tempo = 1;
          }
          t2 = this._pm._lm;
          t1 = t1.startNG;
          t2 = t2._pm;
          sv = t2._score_player$_scoreViewer;
          if (sv != null) {
            if (t1 == null) {
              t1 = t2.score.get$pages();
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              t1 = t1[0]._systems;
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              system = t1[0];
            } else
              system = J.get$measure$x(J.get$voice$x(t1))._stack._systemRef;
            sv.scrollToSystem$2(system, 0);
          }
          t1 = this._playbackDO.startNG.get$playbackTempo();
          if (typeof t1 !== "number")
            return H.iae(t1);
          msPerBeat = C.JSNumber_methods.toInt$0(1000 * (60 / t1));
          this._playbackDO.countoffSeconds = 0.9;
          pauseDuration = msPerBeat - 600;
          P.Timer_Timer(P.Duration$(0, 0, 0, pauseDuration < 0 ? 0 : pauseDuration, 0, 0), new M._PlaybackManager__onPlaybackComplete_closure(this));
        } else
          this._finishPlayback$0();
      }, "call$0", "get$_onPlaybackComplete", 0, 0, 2],
      _finishPlayback$0: function() {
        this._playbackDO.playbackFinished = true;
        this._pm.dispatchEvent$1(0, new M.PlayerEvent(null, "playbackFinished", false, C.EventPhase_1, null, null, false, false));
      }
    },
    _PlaybackManager__init_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1 = this.$this;
        t1._sfLoadProgressListener.cancel$0(0);
        t1.dispatchEventRaw$3(new R.Event("playbackManagerReady", false, C.EventPhase_1, null, null, false, false), t1, C.EventPhase_1);
      }
    },
    _PlaybackManager__onPlaybackComplete_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        return this.$this._startPlayback$0();
      }
    },
    _PlaybackDO: {
      "^": "Object;loop>,startNG,endNG,countoffSeconds,assessmentType,tempoIncrement,tempo<,playbackFinished"
    },
    _LayoutManager: {
      "^": "EventDispatcher;_pm,_currentPart,_width,_height,_fingeringDM,_showNoteNames,_eventStreams",
      _init$0: function() {
        var t1, t2, t3;
        t1 = this._pm;
        t2 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
        t3 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t3 + 1;
        t3 = new L.BasicControls(null, null, null, null, null, null, 100, 380, false, null, null, null, null, t2, true, true, false, true, "auto", true, 0, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        t3.pm = t1;
        t3.init$0();
        t1.controls = t3;
        t3 = this._pm;
        t3.addChild$1(t3.controls);
        t3 = this._pm;
        t3._barPlayControls = null;
        $.FingeringDisplay_resourceManager = t3._resourceManager;
        this._fingeringDM = new M.FingeringDisplayManager(t3, null, null, null, null, 0, null, null, false, true, null);
      },
      resizeDisplay$2: function(width, height) {
        var t1, t2, parts, viewerRect;
        this._width = width;
        this._height = height;
        t1 = this._pm;
        t2 = t1._score_player$_scoreViewer;
        if (t2 != null && t2._parent === t1) {
          t1 = this._currentPart;
          parts = t1 != null ? [J.get$name$x(t1)] : null;
          viewerRect = this._calculatePositions$0();
          t1 = this._pm._driver;
          width = viewerRect.width;
          height = viewerRect.height;
          t1 = t1._drawManager;
          t1.toString;
          if (J.$eq$(width, 0))
            width = t1._scoreViewerWidth;
          if (J.$eq$(height, 0))
            height = t1._scoreViewerHeight;
          t2 = t1._stagexl$_driver._scoreViewer;
          if (t2 != null)
            t2._vScore.toString;
          t1._renderMusic$4(width, height, 0, parts == null ? t1._displayedParts : parts);
          this._pm._score_player$_scoreViewer.set$x(0, viewerRect.left);
          this._pm._score_player$_scoreViewer.set$y(0, viewerRect.top);
          t1 = this._fingeringDM;
          t2 = this._pm._score_player$_scoreViewer;
          t1._score_player$_removeListeners$0();
          t1._score_player$_scoreViewer = t2;
          t1._addListeners$0();
          this._notifySongRendered$0();
        }
      },
      _calculatePositions$0: function() {
        var t1, t2, t3, controlsHeight, notationHPos;
        t1 = this._pm.controls;
        t2 = this.get$width(this);
        t3 = t1._unscaledWidth;
        if (typeof t2 !== "number")
          return t2.$div();
        t3 = Math.min(1.75, t2 / t3);
        t1.set$scaleY(t3);
        t1.set$scaleX(t3);
        t3 = this._pm.controls;
        controlsHeight = J.$add$ns(t3.get$boundsTransformed().height, 5 * t3._scaleY);
        t3 = this._fingeringDM;
        t1 = this.get$height(this);
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof controlsHeight !== "number")
          return H.iae(controlsHeight);
        t2 = this.get$width(this);
        t3._xPos = 0;
        t3._yPos = controlsHeight;
        t1 = Math.min((t1 - controlsHeight) / 312, 2);
        t3._scale = t1;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = 0.1 * t2;
        if (t1 * 46 > t2)
          t3._scale = t2 / 46;
        t1 = t3._recorderBackground;
        if (t1 != null && t1._parent === t3._container) {
          t1.set$x(0, 0);
          t3._recorderBackground.set$y(0, t3._yPos);
          t1 = t3._recorderBackground;
          t3 = t3._scale;
          t1.set$scaleY(t3);
          t1.set$scaleX(t3);
        }
        t1 = this._fingeringDM;
        t2 = t1._displayWidth;
        t1 = t1._scale;
        if (typeof t1 !== "number")
          return H.iae(t1);
        notationHPos = 10 + t2 * t1;
        t1 = this.get$width(this);
        if (typeof t1 !== "number")
          return t1.$sub();
        t2 = this.get$height(this);
        if (typeof t2 !== "number")
          return t2.$sub();
        return new U.Rectangle0(notationHPos, controlsHeight, t1 - notationHPos, t2 - controlsHeight, [null]);
      },
      _notifySongRendered$0: function() {
        var e, t1;
        e = new M.PlayerEvent(null, "songRendered", false, C.EventPhase_1, null, null, false, false);
        t1 = this._pm;
        e.scoreViewer = t1._score_player$_scoreViewer;
        t1.dispatchEvent$1(0, e);
      },
      set$showNoteNames: function(value) {
        var t1, t2;
        this._showNoteNames = value;
        t1 = this._currentPart;
        if (t1 != null) {
          t2 = this._pm.scoreManager;
          if (value === true) {
            t1 = t1.get$staves();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            t1 = t1[0];
            t2._pitchNameManager.showNoteNames$1(t1);
          } else
            t2._pitchNameManager.showLyrics$0();
        }
      },
      get$width: function(_) {
        var t1 = this._width;
        if (t1 != null)
          return t1;
        return this._pm.get$stage() != null ? this._pm.get$stage()._stageWidth : 400;
      },
      get$height: function(_) {
        var t1 = this._height;
        if (t1 != null)
          return t1;
        return this._pm.get$stage() != null ? this._pm.get$stage()._stageHeight : 300;
      }
    },
    PlayerEvent: {
      "^": "Event;scoreViewer,_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped"
    },
    PlayerInitConfig: {
      "^": "Object;showFingerings,showNoteNames,instrument,notationVOffset,useArranger,playerWidth,playerHeight,resourceRoot,atlases"
    },
    StandalonePlayerLoader: {
      "^": "Object;_options,_playerInitFunction,_player,_stage,_renderLoop,_container,_resizeTimer",
      _init$0: function() {
        var t1, canvas, options, t2, t3, t4;
        t1 = "#" + this._options.canvasID;
        canvas = document.querySelector(t1);
        options = new A.StageOptions(C.RenderEngine_0, C.InputEventMode_0, C.StageRenderMode_0, C.StageScaleMode_3, C.StageAlign_4, 4294967295, false, false, 5, true, true, false, false);
        options.inputEventMode = C.InputEventMode_2;
        options.renderEngine = C.RenderEngine_1;
        t1 = A.Stage$(canvas, null, options, null);
        this._stage = t1;
        t1._stageScaleMode = C.StageScaleMode_2;
        t1._updateCanvasSize$0();
        t1 = this._stage;
        t1._stageAlign = C.StageAlign_0;
        t1._updateCanvasSize$0();
        t1 = new K.Juggler(null, null, 0, new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [P.num]));
        t2 = new K._AnimatableLink(null, null);
        t1._firstAnimatableLink = t2;
        t1._lastAnimatableLink = t2;
        t2 = H.setRuntimeTypeInfo([], [A.Stage]);
        t1 = new A.RenderLoop(t1, t2, new R.EnterFrameEvent(0, "enterFrame", false, C.EventPhase_1, null, null, false, false), new R.ExitFrameEvent("exitFrame", false, C.EventPhase_1, null, null, false, false), 0, false);
        t1.start$0(0);
        this._renderLoop = t1;
        t3 = this._stage;
        t4 = t3._display$_renderLoop;
        if (!(t4 == null))
          if (C.JSArray_methods.remove$1(t4._stages, t3))
            t3._display$_renderLoop = null;
        t3._display$_renderLoop = t1;
        t2.push(t3);
        t1 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
        t2 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t2 + 1;
        t2 = new A.Sprite(null, null, null, t1, true, true, false, true, "auto", true, 0, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        this._container = t2;
        t2.set$x(0, 0);
        this._container.set$y(0, 0);
        this._stage.addChild$1(this._container);
        t2 = this._playerInitFunction.call$0();
        this._player = t2;
        this._container.addChild$1(t2);
        J.addEventListener$2$x(this._player, "playerInit", this.get$_onPlayerReady());
      },
      _onPlayerReady$1: [function(e) {
        var $async$goto = 0, $async$completer = P.Completer_Completer$sync(), $async$self = this, t1, t2;
        var $async$_onPlayerReady$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                J.set$x$x($async$self._player, 5);
                J.set$y$x($async$self._player, 5);
                t1 = $async$self._player;
                t2 = $async$self._stage;
                t1.resizeDisplay$2(t2._stageWidth - 10, t2._stageHeight - 5);
                $async$self._stage.on$1(0, "resize").listen$1($async$self.get$_onWindowResize());
                $async$self._loadSong$0();
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStart($async$_onPlayerReady$1, $async$completer);
      }, "call$1", "get$_onPlayerReady", 2, 0, 51, 0],
      _loadSong$0: function() {
        var $async$goto = 0, $async$completer = P.Completer_Completer$sync(), $async$self = this, t1, url, musicXmlString;
        var $async$_loadSong$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._options;
                url = P.Uri_base().get$queryParameters().$index(0, t1.songUrlParam);
                if (url == null)
                  url = $async$self._options.defaultSongUrl;
                if (url != null)
                  url = J.$add$ns($async$self._options.resourceRoot, url);
                $async$goto = 2;
                return P._asyncAwait(S.MusicXmlUtils_getMusicXmlStringFromUrl(url), $async$_loadSong$0);
              case 2:
                // returning from await.
                musicXmlString = $async$result;
                if (musicXmlString != null)
                  $async$self._player.loadSong$1(musicXmlString);
                else
                  P.print("problem loading file, url: " + H.S(url == null ? "null" : url));
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStart($async$_loadSong$0, $async$completer);
      },
      _onWindowResize$1: [function(e) {
        var t1 = this._resizeTimer;
        if (t1 != null && t1._handle != null)
          t1.cancel$0(0);
        this._resizeTimer = P.Timer_Timer(P.Duration$(0, 0, 0, 500, 0, 0), new M.StandalonePlayerLoader__onWindowResize_closure(this));
      }, "call$1", "get$_onWindowResize", 2, 0, 11, 0]
    },
    StandalonePlayerLoader__onWindowResize_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._player;
        t1 = t1._stage;
        t2.resizeDisplay$2(t1._stageWidth - 10, t1._stageHeight - 5);
      }
    },
    PlayerLoaderOptions: {
      "^": "Object;canvasID,songUrlParam,defaultSongUrl,resourceRoot"
    },
    FingeringDisplay: {
      "^": "Sprite;_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      static: {
        FingeringDisplay_createFingeringDisplays: function() {
          var t1, gbd, t2, t3, t4, t5, _i, fingering, t6, t7, display, i, hole, rectangle;
          t1 = $.FingeringDisplay__fingerMode;
          if (t1 === 0)
            $.FingeringDisplay__fingerings = $.$get$FingeringDisplay__baroqueFingerings();
          else if (t1 === 1)
            $.FingeringDisplay__fingerings = $.$get$FingeringDisplay__germanFingerings();
          else if (t1 === 2)
            $.FingeringDisplay__fingerings = $.$get$FingeringDisplay__altoUntransposedFingerings();
          else
            P.print("Unrecognized fingering mode!");
          $.FingeringDisplay_displays = [];
          gbd = H.interceptedTypeCast($.FingeringDisplay_resourceManager._getResourceValue$2("TextureAtlas", "recorder"), "$isTextureAtlas").get$getBitmapData();
          for (t1 = $.FingeringDisplay__fingerings, t2 = t1.length, t3 = [A.BitmapFilter], t4 = [P.int], t5 = [A.DisplayObject], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            fingering = t1[_i];
            t6 = H.setRuntimeTypeInfo([], t5);
            t7 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t7 + 1;
            display = new M.FingeringDisplay(null, null, null, t6, true, true, false, true, "auto", true, 0, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            for (i = 0; i < 8; ++i) {
              if (i >= fingering.length)
                return H.ioore(fingering, i);
              switch (fingering[i]) {
                case 0:
                  if (i < 6) {
                    t6 = gbd.call$1("closedHole");
                    t7 = $.DisplayObject__nextID;
                    $.DisplayObject__nextID = t7 + 1;
                    hole = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                    t7 = new Y.DropShadowFilter(null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4));
                    t7._distance = 3;
                    t7._angle = 45;
                    t7._color = 16777215;
                    t7._blurX = 1;
                    t7._blurY = 5;
                    t7.set$quality(1);
                    t7.knockout = false;
                    t7.hideObject = false;
                    hole._filters = [t7];
                  } else {
                    t6 = gbd.call$1("closedDoubleHole");
                    t7 = $.DisplayObject__nextID;
                    $.DisplayObject__nextID = t7 + 1;
                    hole = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                    t7 = new Y.DropShadowFilter(null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4));
                    t7._distance = 1;
                    t7._angle = 45;
                    t7._color = 16777215;
                    t7._blurX = 1;
                    t7._blurY = 5;
                    t7.set$quality(1);
                    t7.knockout = false;
                    t7.hideObject = false;
                    hole._filters = [t7];
                  }
                  break;
                case 1:
                  t6 = gbd.call$1("halfClosedDoubleHole");
                  t7 = $.DisplayObject__nextID;
                  $.DisplayObject__nextID = t7 + 1;
                  hole = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                  t7 = new Y.DropShadowFilter(null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4));
                  t7._distance = 3;
                  t7._angle = 45;
                  t7._color = 0;
                  t7._blurX = 1;
                  t7._blurY = 5;
                  t7.set$quality(1);
                  t7.knockout = false;
                  t7.hideObject = false;
                  hole._filters = [t7];
                  break;
                case 2:
                  if (i < 6) {
                    t6 = gbd.call$1("openHole");
                    t7 = $.DisplayObject__nextID;
                    $.DisplayObject__nextID = t7 + 1;
                    hole = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                    t7 = new Y.DropShadowFilter(null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4));
                    t7._distance = 5;
                    t7._angle = 45;
                    t7._color = 0;
                    t7._blurX = 1;
                    t7._blurY = 5;
                    t7.set$quality(1);
                    t7.knockout = false;
                    t7.hideObject = false;
                    hole._filters = [t7];
                  } else {
                    t6 = gbd.call$1("openDoubleHole");
                    t7 = $.DisplayObject__nextID;
                    $.DisplayObject__nextID = t7 + 1;
                    hole = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                    t7 = new Y.DropShadowFilter(null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4));
                    t7._distance = 2;
                    t7._angle = 45;
                    t7._color = 0;
                    t7._blurX = 1;
                    t7._blurY = 5;
                    t7.set$quality(1);
                    t7.knockout = false;
                    t7.hideObject = false;
                    hole._filters = [t7];
                  }
                  break;
                case 3:
                  t6 = gbd.call$1("halfClosedHole");
                  t7 = $.DisplayObject__nextID;
                  $.DisplayObject__nextID = t7 + 1;
                  hole = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                  t7 = new Y.DropShadowFilter(null, null, null, null, null, null, null, null, H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4));
                  t7._distance = 3;
                  t7._angle = 45;
                  t7._color = 0;
                  t7._blurX = 1;
                  t7._blurY = 5;
                  t7.set$quality(1);
                  t7.knockout = false;
                  t7.hideObject = false;
                  hole._filters = [t7];
                  break;
                default:
                  hole = null;
              }
              hole._scaleY = 0.5;
              hole._transformationMatrixRefresh = true;
              hole._scaleX = 0.5;
              hole._x = 7;
              t6 = $.$get$FingeringDisplay_positions()[i];
              rectangle = hole.get$bounds();
              t7 = hole.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height;
              if (typeof t7 !== "number")
                return H.iae(t7);
              hole._y = t6 + (26 - t7) / 2;
              hole._transformationMatrixRefresh = true;
              display.addChild$1(hole);
            }
            $.FingeringDisplay_displays.push(display);
          }
        },
        FingeringDisplay_getFingeringDisplay: function(cents) {
          var index, t1;
          index = C.JSNumber_methods._tdivFast$1(cents, 100) - 60;
          if (index < 0 || index >= $.FingeringDisplay__fingerings.length)
            return;
          else {
            t1 = $.FingeringDisplay_displays;
            if (index >>> 0 !== index || index >= t1.length)
              return H.ioore(t1, index);
            return t1[index];
          }
        },
        FingeringDisplay_fingerMode: function(value) {
          if (typeof value !== "number")
            return value.$lt();
          if (value > 2)
            return;
          $.FingeringDisplay__fingerMode = value;
          M.FingeringDisplay_createFingeringDisplays();
        }
      }
    },
    FingeringDisplayManager: {
      "^": "Object;_container,_xPos,_yPos,_scale,_score_player$_scoreViewer,_displayWidth,_recorderBackground,_fingeringDisplay,_instrumentSupportsFingerings,_showFingerings,_listeners",
      setInstrument$2: function(ido, showFingeringsIfAvailable) {
        var lastInstSupportedFingerings, t1, t2, t3, t4, t5, t6, t7;
        lastInstSupportedFingerings = this._instrumentSupportsFingerings;
        t1 = ido.fingeringMode;
        if (t1 != null && showFingeringsIfAvailable) {
          M.FingeringDisplay_fingerMode(t1);
          this._displayWidth = 46;
          if (this._recorderBackground == null) {
            t1 = H.interceptedTypeCast($.FingeringDisplay_resourceManager._getResourceValue$2("TextureAtlas", "recorder"), "$isTextureAtlas").getBitmapData$1("background");
            t2 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t2 + 1;
            t3 = [A.BitmapFilter];
            t4 = H.setRuntimeTypeInfo([], t3);
            t5 = T.Matrix$fromIdentity();
            t6 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
            t7 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t7 + 1;
            t3 = new A.Sprite(null, null, null, t6, true, true, false, true, "auto", true, 0, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            this._recorderBackground = t3;
            t3.addChild$1(new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, t4, null, "", null, t5, true, null, null));
          }
          t1 = this._recorderBackground;
          t2 = this._scale;
          t1.set$scaleY(t2);
          t1.set$scaleX(t2);
          this._recorderBackground.set$x(0, this._xPos);
          this._recorderBackground.set$y(0, this._yPos);
          t1 = this._recorderBackground;
          t2 = t1._parent;
          t3 = this._container;
          if (t2 !== t3)
            t3.addChild$1(t1);
          this._instrumentSupportsFingerings = true;
          this._showFingerings = true;
          t1 = true;
        } else {
          if ($.FingeringDisplay_displays != null)
            $.FingeringDisplay_displays = null;
          this._displayWidth = 0;
          t1 = this._recorderBackground;
          if (t1 != null && t1._parent === this._container) {
            this._container.removeChild$1(t1);
            this._recorderBackground = null;
          }
          this._instrumentSupportsFingerings = false;
          this._showFingerings = false;
          t1 = false;
        }
        return t1 !== lastInstSupportedFingerings;
      },
      _onVngClick$1: [function(e) {
        this._displayFingering$1(H.interceptedTypeCast(J.get$currentTarget$x(e), "$isVisualNoteGroup"));
      }, "call$1", "get$_onVngClick", 2, 0, 4, 0],
      _score_player$_onNoteReached$1: [function(e) {
        if (J.get$visible$x(e.get$visualNoteGroup().get$noteGroup()) === true)
          this._displayFingering$1(e.get$visualNoteGroup());
      }, "call$1", "get$_score_player$_onNoteReached", 2, 0, 7, 0],
      _displayFingering$1: function(vng) {
        var t1, t2, t3;
        if (vng.get$noteGroup().get$isRest())
          return;
        t1 = this._fingeringDisplay;
        if (t1 != null) {
          t2 = t1._parent;
          t3 = this._recorderBackground;
          t3 = t2 == null ? t3 == null : t2 === t3;
          t2 = t3;
        } else
          t2 = false;
        if (t2)
          this._recorderBackground.removeChild$1(t1);
        t1 = vng.get$noteGroup().get$visibleNotes();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = M.FingeringDisplay_getFingeringDisplay(t1[0].get$displayCents());
        this._fingeringDisplay = t1;
        if (t1 != null) {
          t1.set$x(0, 4);
          this._fingeringDisplay.set$y(0, 3);
          this._recorderBackground.addChild$1(this._fingeringDisplay);
        }
      },
      _addListeners$0: function() {
        var t1, vngList, t2, _i, vng;
        t1 = this._score_player$_scoreViewer;
        if (t1 != null && this._instrumentSupportsFingerings) {
          vngList = t1._vScore.getVisualNoteGroups$0();
          this._listeners = [];
          for (t1 = vngList.length, t2 = this.get$_onVngClick(), _i = 0; _i < vngList.length; vngList.length === t1 || (0, H.throwConcurrentModificationError)(vngList), ++_i) {
            vng = vngList[_i];
            if (vng.get$noteGroup().get$isRest())
              continue;
            vng.set$mouseCursor("pointer");
            this._listeners.push(vng.get$onMouseClick().listen$1(t2));
            this._listeners.push(vng.get$onTouchTap().listen$1(t2));
          }
          this._score_player$_scoreViewer.on$1(0, "noteReached")._subscribe$3(this.get$_score_player$_onNoteReached(), false, 0);
        }
      },
      _score_player$_removeListeners$0: function() {
        var t1, vngList, _i, vng, t2;
        t1 = this._score_player$_scoreViewer;
        if (t1 != null) {
          if (this._listeners != null) {
            vngList = t1._vScore.getVisualNoteGroups$0();
            for (t1 = vngList.length, _i = 0; _i < vngList.length; vngList.length === t1 || (0, H.throwConcurrentModificationError)(vngList), ++_i) {
              vng = vngList[_i];
              if (vng.get$noteGroup().get$isRest())
                continue;
              vng.set$mouseCursor("default");
            }
            for (t1 = this._listeners, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
              t1[_i].cancel$0(0);
            this._listeners = null;
          }
          this._score_player$_scoreViewer.on$1(0, "noteReached")._unsubscribe$2(this.get$_score_player$_onNoteReached(), false);
        }
      }
    }
  }], ["score_render.stagexl.bitmap_renderer", "package:score_render/src/stagexl/bitmap_renderer.dart",, D, {
    "^": "",
    BitmapMusicRenderer: {
      "^": "Object;_bitmap_renderer$_score,_visualScore,_systemRenderer,_parts,_addedObjects,_removedObjects,_rendererReadyCallback",
      renderScore$2: function(score, partNames) {
        var t1, t2, t3, t4, _i, part, index, systems, vPages, cVPage, system, vSystem, t5, t6, i, rectangle, lastPage, command;
        if (partNames != null)
          partNames = C.JSArray_methods.sublist$1(partNames, 0);
        this._bitmap_renderer$_score = score;
        t1 = [A.DisplayObject];
        t2 = H.setRuntimeTypeInfo([], t1);
        t3 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t3 + 1;
        t4 = [A.BitmapFilter];
        t3 = new D.VisualScore(null, null, null, null, null, null, t2, true, true, false, true, "auto", true, 0, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        t3._bitmap_renderer$_score = score;
        t3._scoreProps = score.get$scoreProperties();
        t3.init$0();
        this._visualScore = t3;
        this._addedObjects = [];
        this._removedObjects = [];
        if (partNames == null)
          this._parts = score.get$parts();
        else {
          this._parts = [];
          for (t2 = score.get$parts(), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
            part = t2[_i];
            index = C.JSArray_methods.indexOf$1(partNames, J.get$name$x(part));
            if (index !== -1) {
              this._parts.push(part);
              C.JSArray_methods.removeAt$1(partNames, index);
            }
          }
        }
        systems = score.getSystems$0();
        t2 = new D.SystemRenderer(score.get$scoreProperties(), null, null);
        t2._legacyVNGIndex = 0;
        if ($.SystemRenderer_TC_FLAT_POSITIONS == null) {
          $.SystemRenderer_TC_FLAT_POSITIONS = [4, 1, 5, 2, 6, 3, 7];
          $.SystemRenderer_BC_FLAT_POSITIONS = [6, 3, 7, 4, 8, 5, 9];
          $.SystemRenderer_TC_SHARP_POSITIONS = [0, 3, -1, 2, 5, 1, 4];
          $.SystemRenderer_BC_SHARP_POSITIONS = [2, 5, 1, 4, 7, 3, 6];
          $.SystemRenderer_TENOR_FLAT_POSITIONS = [3, 0, 4, 1, 5, 2, 6];
          $.SystemRenderer_TENOR_SHARP_POSITIONS = [6, 2, 5, 1, 4, 0, 3];
          $.SystemRenderer_ALTO_FLAT_POSITIONS = [5, 2, 6, 3, 7, 4, 8];
          $.SystemRenderer_ALTO_SHARP_POSITIONS = [1, 4, 0, 3, 6, 2, 5];
        }
        this._systemRenderer = t2;
        vPages = [];
        for (t2 = systems.length, cVPage = null, _i = 0; _i < systems.length; systems.length === t2 || (0, H.throwConcurrentModificationError)(systems), ++_i) {
          system = systems[_i];
          vSystem = this._systemRenderer.renderSystem$4(system, this._parts, this._addedObjects, this._removedObjects);
          if (system.get$newPage()) {
            t3 = score.get$scoreProperties();
            t5 = H.setRuntimeTypeInfo([], t1);
            t6 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t6 + 1;
            cVPage = new D.VisualPage(null, null, null, null, null, null, t5, true, true, false, true, "auto", true, 0, t6, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            cVPage._scoreProps = t3;
            cVPage._currentVSystemPos = 0;
            cVPage._visualSystems = [];
            vPages.push(cVPage);
          }
          if (cVPage != null)
            cVPage.addSystem$1(vSystem);
          system.set$needsRendering(false);
        }
        for (i = 0; t1 = vPages.length, i < t1; ++i) {
          t1 = vPages[i];
          if (i > 0) {
            t2 = vPages[i - 1];
            t3 = t2._y;
            rectangle = t2.get$bounds();
            t2 = t2.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t3 + t2 + 50;
          } else
            t2 = $.BitmapMusicRenderer_firstPageVerticalOffset;
          t1._y = t2;
          t1._transformationMatrixRefresh = true;
          t1 = this._visualScore;
          if (i >= vPages.length)
            return H.ioore(vPages, i);
          t1.addChild$1(vPages[i]);
        }
        t2 = this._visualScore;
        t2._visualPages = vPages;
        t2._mouseChildren = false;
        if (t1 > 0) {
          lastPage = vPages[t1 - 1];
          t1 = t2.get$graphics();
          t2 = lastPage._y;
          t3 = lastPage.get$boundsTransformed().height;
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1.toString;
          command = U.GraphicsCommandCircle$(0, t2 + t3 + 100, 1, false);
          command._setGraphics$1(t1);
          t1._originalCommands.push(command);
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
        return this._visualScore;
      }
    },
    SystemRenderer: {
      "^": "Object;_scoreProps,_legacyVNoteGroups,_legacyVNGIndex",
      renderSystem$4: function(system, parts, addedObjects, removedObjects) {
        var t1, t2, t3, visualSystem, staffVPosOffsets, numStaves, staffGroupings, stacks, numStacks, systemIndent, systemWidth, staffSpacing, vStaffPos, i, vngLists, horizMeasPos, j, cStack, t4, cMeasure, j0, t5, clefOffset, vMeasure;
        t1 = [];
        t2 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
        t3 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t3 + 1;
        visualSystem = new D.VisualSystem(null, null, null, t1, null, null, null, null, t2, true, true, false, true, "auto", true, 0, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        visualSystem._bitmap_renderer$_systemRef = system;
        visualSystem._visNoteGroups = [];
        system.set$visibleParts(parts);
        staffVPosOffsets = system.get$staffVPosOffsets();
        numStaves = staffVPosOffsets.length;
        staffGroupings = system.get$staffGroupings();
        stacks = system.get$measureStacks();
        numStacks = stacks.length;
        systemIndent = system.get$indent();
        systemWidth = system.get$systemWidth();
        t3 = system.get$staffLineSpacing();
        if (typeof t3 !== "number")
          return t3.$mul();
        t2 = system.get$staffSpacing();
        if (typeof t2 !== "number")
          return H.iae(t2);
        staffSpacing = t3 * 4 + t2;
        for (t2 = parts && C.JSArray_methods, vStaffPos = 0, i = 0; i < numStaves; ++i) {
          if (0 >= stacks.length)
            return H.ioore(stacks, 0);
          t3 = stacks[0].get$measures();
          if (i >= t3.length)
            return H.ioore(t3, i);
          if (t2.indexOf$1(parts, t3[i].get$staff()._partRef) !== -1) {
            if (0 >= stacks.length)
              return H.ioore(stacks, 0);
            t3 = stacks[0].get$measures();
            if (i >= t3.length)
              return H.ioore(t3, i);
            t3 = !t3[i].get$staff()._visible;
          } else
            t3 = true;
          if (t3)
            continue;
          if (i >= staffVPosOffsets.length)
            return H.ioore(staffVPosOffsets, i);
          vStaffPos += staffVPosOffsets[i];
          this.drawStaff$4(systemWidth, visualSystem, systemIndent, vStaffPos);
          vngLists = [];
          for (t3 = i === 0, horizMeasPos = systemIndent, j = 0; j < numStacks; j = j0) {
            if (j >= stacks.length)
              return H.ioore(stacks, j);
            cStack = stacks[j];
            t4 = cStack.get$measures();
            if (i >= t4.length)
              return H.ioore(t4, i);
            cMeasure = t4[i];
            this.drawNotes$7(cMeasure, systemIndent, vngLists, visualSystem, vStaffPos, addedObjects, removedObjects);
            this.addClefKeyTime$5(cMeasure, systemIndent, vStaffPos, visualSystem, vngLists);
            this.addAttachments$4(cMeasure, systemIndent, vStaffPos, visualSystem);
            if (t3)
              cStack.set$needsRendering(false);
            j0 = j + 1;
            if (j0 < numStacks) {
              if (j0 >= stacks.length)
                return H.ioore(stacks, j0);
              t4 = stacks[j0].get$newClef();
            } else
              t4 = false;
            if (t4) {
              t4 = this._scoreProps;
              t5 = t4._clefWidth;
              t4 = t4._clefDistanceFromBarline;
              if (typeof t5 !== "number")
                return t5.$add();
              clefOffset = t5 + t4;
            } else if (cStack.get$newClef() && j > 0) {
              t4 = this._scoreProps;
              t5 = t4._clefWidth;
              t4 = t4._clefDistanceFromBarline;
              if (typeof t5 !== "number")
                return t5.$add();
              clefOffset = -1 * (t5 + t4);
            } else
              clefOffset = 0;
            t4 = J.getInterceptor$x(cStack);
            vMeasure = new D.VisualMeasure(horizMeasPos, vStaffPos, J.$add$ns(t4.get$width(cStack), clefOffset), 4 * this._scoreProps._staffLineSpacing, cMeasure, null);
            vMeasure.vSystemRef = visualSystem;
            t1.push(vMeasure);
            horizMeasPos = J.$add$ns(horizMeasPos, J.$add$ns(t4.get$width(cStack), clefOffset));
          }
          this.drawBeams$4(vngLists, systemIndent, vStaffPos, visualSystem);
          this.drawTuplets$3(vngLists, vStaffPos, visualSystem);
          this.drawTies$3(vngLists, vStaffPos, visualSystem);
          vStaffPos += staffSpacing;
        }
        t1 = vStaffPos - staffSpacing;
        this.renderVerticalBarlines$6(staffGroupings, systemIndent, visualSystem, t1, stacks, systemWidth);
        this._drawRepeats$5(staffGroupings, systemIndent, visualSystem, t1, stacks);
        this.drawSlurs$3(system, visualSystem, parts);
        return visualSystem;
      },
      drawStaff$4: function(systemWidth, vSystem, systemIndent, vStaffPos) {
        var t1, command, t2, t3, i, t4, t5;
        t1 = vSystem._graphics;
        if (!(t1 != null)) {
          t1 = [U.GraphicsCommand];
          t1 = new U.Graphics(H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), null);
          vSystem._graphics = t1;
        }
        command = new U.GraphicsCommandBeginPath(null);
        command._drawing$_graphics = t1;
        t1._originalCommands.push(command);
        C.JSArray_methods.set$length(t1._compiledCommands, 0);
        t1._bounds = null;
        for (t1 = J.getInterceptor$n(systemWidth), t2 = [U.GraphicsCommand], t3 = J.getInterceptor$n(systemIndent), i = 0; i < 5; ++i) {
          t4 = vSystem._graphics;
          if (!(t4 != null)) {
            t4 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
            vSystem._graphics = t4;
          }
          t5 = this._scoreProps._staffLineSpacing;
          command = new U.GraphicsCommandMoveTo(t3.toDouble$0(systemIndent), C.JSNumber_methods.toDouble$0(i * t5 + vStaffPos), null);
          command._drawing$_graphics = t4;
          t4._originalCommands.push(command);
          C.JSArray_methods.set$length(t4._compiledCommands, 0);
          t4._bounds = null;
          t4 = vSystem._graphics;
          if (!(t4 != null)) {
            t4 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
            vSystem._graphics = t4;
          }
          t5 = this._scoreProps._staffLineSpacing;
          command = new U.GraphicsCommandLineTo(t1.toDouble$0(systemWidth), C.JSNumber_methods.toDouble$0(i * t5 + vStaffPos), null);
          command._drawing$_graphics = t4;
          t4._originalCommands.push(command);
          C.JSArray_methods.set$length(t4._compiledCommands, 0);
          t4._bounds = null;
        }
        t1 = vSystem._graphics;
        if (!(t1 != null)) {
          t1 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
          vSystem._graphics = t1;
        }
        command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(this._scoreProps._staffLineWidth), C.JointStyle_0, C.CapsStyle_0, null);
        command._drawing$_graphics = t1;
        t1._originalCommands.push(command);
        C.JSArray_methods.set$length(t1._compiledCommands, 0);
        t1._bounds = null;
        t1 = vSystem._graphics;
        if (!(t1 != null)) {
          t1 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
          vSystem._graphics = t1;
        }
        command = new U.GraphicsCommandClosePath(null);
        command._drawing$_graphics = t1;
        t1._originalCommands.push(command);
        C.JSArray_methods.set$length(t1._compiledCommands, 0);
        t1._bounds = null;
      },
      drawNotes$7: function(measure, systemIndent, vngLists, vSystem, vStaffPos, addedObjects, removedObjects) {
        var t1, numLegacyVNGs, t2, t3, visNoteGroup, i, i0, t4, t5, _i, noteGroup, loopedOnce, t6, attachments, t7, t8, t9, t10;
        if (!measure.get$notesNeedRendering()) {
          t1 = this._legacyVNoteGroups;
          numLegacyVNGs = C.JSNull_methods.get$length(t1);
          for (t2 = J.getInterceptor$ns(systemIndent), t3 = [D.VisualNoteGroup], visNoteGroup = null, i = 0; i < measure.get$voices().length; i = i0) {
            i0 = i + 1;
            if (vngLists.length < i0)
              vngLists.push(H.setRuntimeTypeInfo([], t3));
            t4 = measure.get$voices();
            if (i >= t4.length)
              return H.ioore(t4, i);
            t4 = t4[i].get$noteGroups();
            t5 = t4.length;
            _i = 0;
            for (; _i < t4.length; t4.length === t5 || (0, H.throwConcurrentModificationError)(t4), ++_i) {
              noteGroup = t4[_i];
              loopedOnce = false;
              while (true) {
                if (C.JSInt_methods.$lt(this._legacyVNGIndex, numLegacyVNGs)) {
                  C.JSNull_methods.$index(t1, this._legacyVNGIndex).get$noteGroup();
                  t6 = true;
                } else
                  t6 = false;
                if (!t6)
                  break;
                if (C.JSInt_methods.$ge(++this._legacyVNGIndex, numLegacyVNGs))
                  if (!loopedOnce) {
                    this._legacyVNGIndex = 0;
                    loopedOnce = true;
                  }
              }
              if (C.JSInt_methods.$ge(this._legacyVNGIndex, numLegacyVNGs))
                throw H.wrapException("Looking for a VisualNoteGroup that is not available for re-render! This probably means a Measure with a new note was not marked for re-rendering.");
              visNoteGroup = C.JSNull_methods.$index(t1, this._legacyVNGIndex);
              attachments = [];
              for (t6 = visNoteGroup.get$visualAttachments(), t6 = t6.get$iterator(t6); t6.moveNext$0();)
                attachments.push(t6.get$current());
              visNoteGroup.set$visualAttachments(attachments);
              visNoteGroup.set$x(0, J.$add$ns(t2.$add(systemIndent, measure.get$stack()._startPosition), noteGroup.get$hPos()));
              visNoteGroup.set$y(0, vStaffPos);
              visNoteGroup.get$originalPosition().set$x(0, visNoteGroup.get$x(visNoteGroup));
              visNoteGroup.get$originalPosition().set$y(0, visNoteGroup.get$y(visNoteGroup));
              vSystem.addChild$1(visNoteGroup);
              visNoteGroup.set$vSystemRef(vSystem);
              vSystem._visNoteGroups.push(visNoteGroup);
              if (i >= vngLists.length)
                return H.ioore(vngLists, i);
              vngLists[i].push(visNoteGroup);
            }
          }
        } else {
          for (t1 = [null], t2 = J.getInterceptor$ns(systemIndent), t3 = [A.DisplayObject], t4 = [A.BitmapFilter], t5 = [D.VisualNoteGroup], visNoteGroup = null, i = 0; i < measure.get$voices().length; i = i0) {
            i0 = i + 1;
            if (vngLists.length < i0)
              vngLists.push(H.setRuntimeTypeInfo([], t5));
            t6 = measure.get$voices();
            if (i >= t6.length)
              return H.ioore(t6, i);
            t6 = t6[i].get$noteGroups();
            t7 = t6.length;
            _i = 0;
            for (; _i < t6.length; t6.length === t7 || (0, H.throwConcurrentModificationError)(t6), ++_i) {
              noteGroup = t6[_i];
              t8 = this._scoreProps;
              t9 = H.setRuntimeTypeInfo([], t3);
              t10 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t10 + 1;
              visNoteGroup = new D.VisualNoteGroup(null, null, null, null, null, null, null, null, null, null, null, t9, true, true, false, true, "auto", true, 0, t10, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              visNoteGroup._bitmap_renderer$_noteGroup = noteGroup;
              if (noteGroup == null)
                H.printString("NoteGroup null - VisualNoteGroup()");
              visNoteGroup._scoreProps = t8;
              visNoteGroup._vSystemRef = vSystem;
              visNoteGroup._bitmap_renderer$_init$0();
              t8 = J.$add$ns(t2.$add(systemIndent, measure.get$stack()._startPosition), noteGroup.get$hPos());
              if (typeof t8 === "number")
                visNoteGroup._x = t8;
              visNoteGroup._transformationMatrixRefresh = true;
              t8 = visNoteGroup._y + vStaffPos;
              visNoteGroup._y = t8;
              visNoteGroup._originalPosition = new U.Point(visNoteGroup._x, t8, t1);
              vSystem.addChild$1(visNoteGroup);
              vSystem._visNoteGroups.push(visNoteGroup);
              if (i >= vngLists.length)
                return H.ioore(vngLists, i);
              vngLists[i].push(visNoteGroup);
              addedObjects.push(visNoteGroup);
            }
          }
          measure.set$notesNeedRendering(false);
        }
      },
      drawBeams$4: function(vngLists, systemIndent, vStaffPos, vSystem) {
        var currentBeams, beamWidth, t1, t2, t3, t4, stemEndPos, hPos, vPos, _i, t5, noteGroup, t6, scale, stackPos, i, t7, startingPoint, command, t8, t9;
        currentBeams = P.LinkedHashMap__makeEmpty();
        beamWidth = this._scoreProps._beamWidth;
        for (t1 = vngLists.length, t2 = J.getInterceptor$ns(systemIndent), t3 = [U.GraphicsCommand], t4 = [null], stemEndPos = 0, hPos = 0, vPos = 0, _i = 0; _i < vngLists.length; vngLists.length === t1 || (0, H.throwConcurrentModificationError)(vngLists), ++_i)
          for (t5 = C.JSArray_methods.get$iterator(vngLists[_i]); t5.moveNext$0();) {
            noteGroup = t5.get$current().get$noteGroup();
            t6 = J.getInterceptor$x(noteGroup);
            if (t6.get$visible(noteGroup) !== true) {
              currentBeams = P.LinkedHashMap__makeEmpty();
              continue;
            }
            scale = !noteGroup.get$isGrace() ? 1 : 0.65;
            stackPos = J.get$measure$x(t6.get$voice(noteGroup))._stack._startPosition;
            beamWidth = J.$mul$ns(this._scoreProps._beamWidth, scale);
            for (t6 = J.getInterceptor$ns(beamWidth), i = 0; i < noteGroup.get$beamStates().length; ++i) {
              t7 = noteGroup.get$beamStates();
              if (i >= t7.length)
                return H.ioore(t7, i);
              if (!J.$eq$(t7[i], "continue")) {
                t7 = noteGroup.get$beamStates();
                if (i >= t7.length)
                  return H.ioore(t7, i);
                t7 = !J.$eq$(t7[i], "none");
              } else
                t7 = false;
              if (t7) {
                stemEndPos = noteGroup.get$stemEndPos();
                hPos = J.$add$ns(J.$add$ns(t2.$add(systemIndent, stackPos), noteGroup.get$hPos()), noteGroup.get$stemHPos());
                if (noteGroup.get$stemDirection() === "up") {
                  t7 = J.$mul$ns(t6.$mul(beamWidth, 2), i);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  vPos = stemEndPos + t7;
                } else {
                  t7 = J.$mul$ns(t6.$mul(beamWidth, 2), i);
                  if (typeof t7 !== "number")
                    return H.iae(t7);
                  vPos = stemEndPos - t7;
                }
                vPos += vStaffPos;
              }
              t7 = noteGroup.get$beamStates();
              if (i >= t7.length)
                return H.ioore(t7, i);
              switch (t7[i]) {
                case "begin":
                  currentBeams.$indexSet(0, i, new U.Point(hPos, vPos, t4));
                  break;
                case "end":
                  startingPoint = currentBeams.$index(0, i);
                  if (startingPoint != null) {
                    t7 = vSystem._graphics;
                    if (!(t7 != null)) {
                      t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                      vSystem._graphics = t7;
                    }
                    command = new U.GraphicsCommandBeginPath(null);
                    command._drawing$_graphics = t7;
                    t7._originalCommands.push(command);
                    C.JSArray_methods.set$length(t7._compiledCommands, 0);
                    t7._bounds = null;
                    t7 = vSystem._graphics;
                    if (!(t7 != null)) {
                      t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                      vSystem._graphics = t7;
                    }
                    t8 = startingPoint.x;
                    t9 = startingPoint.y;
                    command = new U.GraphicsCommandMoveTo(J.toDouble$0$n(t8), J.toDouble$0$n(t9), null);
                    command._drawing$_graphics = t7;
                    t7._originalCommands.push(command);
                    C.JSArray_methods.set$length(t7._compiledCommands, 0);
                    t7._bounds = null;
                    t7 = vSystem._graphics;
                    if (!(t7 != null)) {
                      t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                      vSystem._graphics = t7;
                    }
                    command = new U.GraphicsCommandLineTo(J.toDouble$0$n(hPos), C.JSNumber_methods.toDouble$0(vPos), null);
                    command._drawing$_graphics = t7;
                    t7._originalCommands.push(command);
                    C.JSArray_methods.set$length(t7._compiledCommands, 0);
                    t7._bounds = null;
                    t7 = vSystem._graphics;
                    if (!(t7 != null)) {
                      t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                      vSystem._graphics = t7;
                    }
                    command = new U.GraphicsCommandStrokeColor(4278190080, t6.toDouble$0(beamWidth), C.JointStyle_1, C.CapsStyle_0, null);
                    command._drawing$_graphics = t7;
                    t7._originalCommands.push(command);
                    C.JSArray_methods.set$length(t7._compiledCommands, 0);
                    t7._bounds = null;
                    t7 = vSystem._graphics;
                    if (!(t7 != null)) {
                      t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                      vSystem._graphics = t7;
                    }
                    command = new U.GraphicsCommandClosePath(null);
                    command._drawing$_graphics = t7;
                    t7._originalCommands.push(command);
                    C.JSArray_methods.set$length(t7._compiledCommands, 0);
                    t7._bounds = null;
                  }
                  break;
                case "continue":
                  break;
                case "forward hook":
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandBeginPath(null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  t8 = J.getInterceptor$n(hPos);
                  command = new U.GraphicsCommandMoveTo(t8.toDouble$0(hPos), C.JSNumber_methods.toDouble$0(vPos), null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandLineTo(J.toDouble$0$n(t8.$add(hPos, this._scoreProps._noteheadWidth / 1.5)), C.JSNumber_methods.toDouble$0(vPos), null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandStrokeColor(4278190080, t6.toDouble$0(beamWidth), C.JointStyle_1, C.CapsStyle_0, null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandClosePath(null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  break;
                case "backward hook":
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandBeginPath(null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  t8 = J.getInterceptor$n(hPos);
                  command = new U.GraphicsCommandMoveTo(t8.toDouble$0(hPos), C.JSNumber_methods.toDouble$0(vPos), null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandLineTo(J.toDouble$0$n(t8.$sub(hPos, this._scoreProps._noteheadWidth / 1.5)), C.JSNumber_methods.toDouble$0(vPos), null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandStrokeColor(4278190080, t6.toDouble$0(beamWidth), C.JointStyle_1, C.CapsStyle_0, null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  t7 = vSystem._graphics;
                  if (!(t7 != null)) {
                    t7 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
                    vSystem._graphics = t7;
                  }
                  command = new U.GraphicsCommandClosePath(null);
                  command._drawing$_graphics = t7;
                  t7._originalCommands.push(command);
                  C.JSArray_methods.set$length(t7._compiledCommands, 0);
                  t7._bounds = null;
                  break;
                case "none":
                  break;
                default:
                  t7 = noteGroup.get$beamStates();
                  if (i >= t7.length)
                    return H.ioore(t7, i);
                  H.printString("Unrecognized Beam Stage! VisualSystem.drawBeams() " + H.S(t7[i]));
              }
            }
          }
      },
      drawTuplets$3: function(vngLists, vStaffPos, vSystem) {
        var tupletTF, t1, t2, t3, t4, drawTupletBrackets, _i, t5, vng, noteGroup, t6, t7, t8, _i0, tuplet, t9, bd, t10, t11, t12, t13, t14, renderState, bitmap, centerX, vPos, rectangle, command, startX, endX, hookEndVPos;
        tupletTF = Y.TextField$(null, null);
        for (t1 = vngLists.length, t2 = [A.BitmapFilter], t3 = [L.RenderContextEvent], t4 = [U.GraphicsCommand], drawTupletBrackets = false, _i = 0; _i < vngLists.length; vngLists.length === t1 || (0, H.throwConcurrentModificationError)(vngLists), ++_i)
          for (t5 = C.JSArray_methods.get$iterator(vngLists[_i]); t5.moveNext$0();) {
            vng = t5.get$current();
            if (vng.get$noteGroup().get$tuplets() == null)
              continue;
            noteGroup = vng.get$noteGroup();
            for (t6 = noteGroup.get$tuplets(), t7 = t6.length, t8 = J.getInterceptor$x(vng), _i0 = 0; _i0 < t6.length; t6.length === t7 || (0, H.throwConcurrentModificationError)(t6), ++_i0) {
              tuplet = t6[_i0];
              if (!tuplet.get$firstNote()._visible || !tuplet.get$endNote()._visible)
                continue;
              t9 = tuplet.get$firstNote();
              if (t9 == null ? noteGroup == null : t9 === noteGroup) {
                t9 = J.toString$0$(tuplet.get$numerator());
                tupletTF._text$_text = t9;
                tupletTF._caretIndex = J.get$length$asx(t9);
                tupletTF._refreshPending |= 3;
                bd = A.BitmapData_BitmapData(20, 20, 0, 1);
                t9 = bd.renderTextureQuad;
                t10 = t9.renderTexture;
                t11 = t10.get$canvas(t10);
                t12 = T.Matrix$fromIdentity();
                t13 = J.get$context2D$x(t11);
                t14 = t12._data;
                t13.setTransform(t14[0], t14[1], t14[2], t14[3], t14[4], t14[5]);
                t13.globalCompositeOperation = "source-over";
                t13.globalAlpha = 1;
                renderState = L.RenderState$(new L.RenderContextCanvas(t11, t13, t12, C.BlendMode_bZz, 1, new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t3), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t3)), t9.get$drawMatrix(), null, null);
                tupletTF.render$1(renderState);
                t10.update$0(0);
                t9 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t9 + 1;
                bitmap = new A.Bitmap(bd, t9, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t2), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                centerX = J.$add$ns(J.$add$ns(t8.get$x(vng), J.$div$n(J.$sub$n(tuplet.get$endNote()._hPos, vng.get$noteGroup().get$hPos()), 2)), tuplet.get$firstNote()._stemHPos / 2);
                if (typeof centerX === "number")
                  bitmap._x = centerX;
                vPos = J.$add$ns(tuplet.get$vPos(), vStaffPos);
                rectangle = bitmap.get$bounds();
                t9 = J.getInterceptor$n(vPos);
                t10 = t9.$sub(vPos, J.$div$n(bitmap.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height, 2));
                if (typeof t10 === "number")
                  bitmap._y = t10;
                bitmap._transformationMatrixRefresh = true;
                if (tuplet.get$showBracket()) {
                  if (!drawTupletBrackets) {
                    t10 = vSystem._graphics;
                    if (!(t10 != null)) {
                      t10 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
                      vSystem._graphics = t10;
                    }
                    command = new U.GraphicsCommandBeginPath(null);
                    command._drawing$_graphics = t10;
                    t10._originalCommands.push(command);
                    C.JSArray_methods.set$length(t10._compiledCommands, 0);
                    t10._bounds = null;
                    drawTupletBrackets = true;
                  }
                  startX = t8.get$x(vng);
                  endX = J.$add$ns(J.$add$ns(t8.get$x(vng), J.$sub$n(tuplet.get$endNote()._hPos, vng.get$noteGroup().get$hPos())), this._scoreProps._noteheadWidth);
                  t10 = tuplet.get$above();
                  t11 = this._scoreProps;
                  hookEndVPos = t10 === true ? t9.$add(vPos, t11._staffLineSpacing / 2) : t9.$sub(vPos, t11._staffLineSpacing / 2);
                  t10 = vSystem._graphics;
                  if (!(t10 != null)) {
                    t10 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
                    vSystem._graphics = t10;
                  }
                  t11 = J.getInterceptor$n(startX);
                  t12 = J.getInterceptor$n(hookEndVPos);
                  command = new U.GraphicsCommandMoveTo(t11.toDouble$0(startX), t12.toDouble$0(hookEndVPos), null);
                  command._drawing$_graphics = t10;
                  t10._originalCommands.push(command);
                  C.JSArray_methods.set$length(t10._compiledCommands, 0);
                  t10._bounds = null;
                  t10 = vSystem._graphics;
                  if (!(t10 != null)) {
                    t10 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
                    vSystem._graphics = t10;
                  }
                  command = new U.GraphicsCommandLineTo(t11.toDouble$0(startX), t9.toDouble$0(vPos), null);
                  command._drawing$_graphics = t10;
                  t10._originalCommands.push(command);
                  C.JSArray_methods.set$length(t10._compiledCommands, 0);
                  t10._bounds = null;
                  t10 = vSystem._graphics;
                  if (!(t10 != null)) {
                    t10 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
                    vSystem._graphics = t10;
                  }
                  t11 = J.getInterceptor$n(centerX);
                  command = new U.GraphicsCommandLineTo(J.toDouble$0$n(t11.$sub(centerX, 0.3 * this._scoreProps._staffLineSpacing)), t9.toDouble$0(vPos), null);
                  command._drawing$_graphics = t10;
                  t10._originalCommands.push(command);
                  C.JSArray_methods.set$length(t10._compiledCommands, 0);
                  t10._bounds = null;
                  t10 = vSystem._graphics;
                  if (!(t10 != null)) {
                    t10 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
                    vSystem._graphics = t10;
                  }
                  command = new U.GraphicsCommandMoveTo(J.toDouble$0$n(t11.$add(centerX, 1.2 * this._scoreProps._staffLineSpacing)), t9.toDouble$0(vPos), null);
                  command._drawing$_graphics = t10;
                  t10._originalCommands.push(command);
                  C.JSArray_methods.set$length(t10._compiledCommands, 0);
                  t10._bounds = null;
                  t10 = vSystem._graphics;
                  if (!(t10 != null)) {
                    t10 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
                    vSystem._graphics = t10;
                  }
                  t11 = J.getInterceptor$n(endX);
                  command = new U.GraphicsCommandLineTo(t11.toDouble$0(endX), t9.toDouble$0(vPos), null);
                  command._drawing$_graphics = t10;
                  t10._originalCommands.push(command);
                  C.JSArray_methods.set$length(t10._compiledCommands, 0);
                  t10._bounds = null;
                  t9 = vSystem._graphics;
                  if (!(t9 != null)) {
                    t9 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
                    vSystem._graphics = t9;
                  }
                  command = new U.GraphicsCommandLineTo(t11.toDouble$0(endX), t12.toDouble$0(hookEndVPos), null);
                  command._drawing$_graphics = t9;
                  t9._originalCommands.push(command);
                  C.JSArray_methods.set$length(t9._compiledCommands, 0);
                  t9._bounds = null;
                }
                vSystem.addChild$1(bitmap);
              }
            }
          }
        if (drawTupletBrackets) {
          t1 = vSystem._graphics;
          if (!(t1 != null)) {
            t1 = new U.Graphics(H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([], t4), null);
            vSystem._graphics = t1;
          }
          command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(this._scoreProps._tupletBracketWidth), C.JointStyle_1, C.CapsStyle_0, null);
          command._drawing$_graphics = t1;
          t1._originalCommands.push(command);
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      addClefKeyTime$5: function(measure, systemIndent, vStaffPos, vSystem, vngLists) {
        var hInsertPos, clefList, t1, clefType, t2, i, clef, breakMiddle, _i, vngList, numVNGs, j, t3, displayKey, outgoingKey, sharpPositions, flatPositions, accidentalList, numAccidentals, timeTF, tFormat, timeBitmap, rectangle;
        hInsertPos = J.$add$ns(measure.get$stack()._startPosition, systemIndent);
        clefList = measure.get$clefs();
        if (0 >= clefList.length)
          return H.ioore(clefList, 0);
        t1 = clefList[0];
        clefType = t1._data$_type;
        if (t1._show) {
          hInsertPos = J.$add$ns(hInsertPos, this._scoreProps._clefDistanceFromBarline);
          if (0 >= clefList.length)
            return H.ioore(clefList, 0);
          this.drawClef$5(clefType, clefList[0]._smallSize, hInsertPos, vStaffPos, vSystem);
          hInsertPos = J.$add$ns(hInsertPos, this._scoreProps._clefWidth);
        } else if (measure.get$stack()._newClef) {
          t1 = this._scoreProps;
          t2 = t1._clefDistanceFromBarline;
          t1 = t1._clefWidth;
          if (typeof t1 !== "number")
            return H.iae(t1);
          hInsertPos = J.$add$ns(hInsertPos, t2 + t1);
        }
        for (i = 1; i < clefList.length;) {
          clef = clefList[i];
          for (t1 = vngLists.length, breakMiddle = false, _i = 0; _i < vngLists.length; vngLists.length === t1 || (0, H.throwConcurrentModificationError)(vngLists), ++_i) {
            vngList = vngLists[_i];
            numVNGs = vngList.length;
            for (j = 0; j < numVNGs; ++j) {
              if (j >= vngList.length)
                return H.ioore(vngList, j);
              if (vngList[j].get$noteGroup().get$clef() === clef) {
                t2 = clef._data$_type;
                t3 = clef._smallSize;
                if (j >= vngList.length)
                  return H.ioore(vngList, j);
                this.drawClef$5(t2, t3, J.$sub$n(J.$sub$n(J.get$x$x(vngList[j]), this._scoreProps._clefWidth), this._scoreProps._clefDistanceFromBarline), vStaffPos, vSystem);
                breakMiddle = true;
                break;
              }
            }
            if (breakMiddle)
              break;
          }
          ++i;
        }
        if (measure.get$showKey()) {
          hInsertPos = J.$add$ns(hInsertPos, this._scoreProps._clefDistanceFromBarline);
          displayKey = measure.get$displayKey();
          outgoingKey = measure.get$outgoingKey();
          sharpPositions = $.SystemRenderer_TC_SHARP_POSITIONS;
          flatPositions = $.SystemRenderer_TC_FLAT_POSITIONS;
          switch (clefType) {
            case "treble":
              break;
            case "bass":
              sharpPositions = $.SystemRenderer_BC_SHARP_POSITIONS;
              flatPositions = $.SystemRenderer_BC_FLAT_POSITIONS;
              break;
            case "tenor":
              sharpPositions = $.SystemRenderer_TENOR_SHARP_POSITIONS;
              flatPositions = $.SystemRenderer_TENOR_FLAT_POSITIONS;
              break;
            case "alto":
              sharpPositions = $.SystemRenderer_ALTO_SHARP_POSITIONS;
              flatPositions = $.SystemRenderer_ALTO_FLAT_POSITIONS;
              break;
            default:
              H.printString("unrecognized clef type! " + H.S(clefType) + " VisualSystem.addClefKeyTime()");
          }
          accidentalList = S.PitchUtils_getAccidentalsForNewKeySignature(displayKey, outgoingKey);
          for (t1 = J.getInterceptor$ns(hInsertPos), numAccidentals = 0, i = 0; i < 7; ++i)
            if (accidentalList[i] === 1) {
              t2 = $.MusicTextures_natural;
              t3 = this._scoreProps._keySigWidth;
              if (typeof t3 !== "number")
                return H.iae(t3);
              this.drawAccidental$6(t2, 0.6, J.round$0$n(t1.$add(hInsertPos, numAccidentals * t3)), flatPositions[i], vStaffPos, vSystem);
              ++numAccidentals;
            }
          for (i = 7; i < 14; ++i)
            if (accidentalList[i] === 1) {
              t2 = $.MusicTextures_natural;
              t3 = this._scoreProps._keySigWidth;
              if (typeof t3 !== "number")
                return H.iae(t3);
              this.drawAccidental$6(t2, 0.6, J.round$0$n(t1.$add(hInsertPos, numAccidentals * t3)), sharpPositions[i - 7], vStaffPos, vSystem);
              ++numAccidentals;
            }
          for (i = 14; i < 21; ++i) {
            t2 = accidentalList[i];
            if (t2 === 1) {
              t2 = $.MusicTextures_flat;
              t3 = this._scoreProps._keySigWidth;
              if (typeof t3 !== "number")
                return H.iae(t3);
              this.drawAccidental$7(t2, 0.6, J.round$0$n(t1.$add(hInsertPos, numAccidentals * t3)), flatPositions[i - 14], vStaffPos, vSystem, -0.5 * this._scoreProps._staffLineSpacing);
              ++numAccidentals;
            } else if (t2 === 2) {
              t2 = $.MusicTextures_doubleFlat;
              t3 = this._scoreProps._keySigWidth;
              if (typeof t3 !== "number")
                return H.iae(t3);
              this.drawAccidental$7(t2, 1, J.round$0$n(t1.$add(hInsertPos, numAccidentals * t3)), flatPositions[i - 14], vStaffPos, vSystem, -0.5 * this._scoreProps._staffLineSpacing);
              ++numAccidentals;
            }
          }
          for (i = 21; i < 28; ++i) {
            t2 = accidentalList[i];
            if (t2 === 1) {
              t2 = $.MusicTextures_sharp;
              t3 = this._scoreProps._keySigWidth;
              if (typeof t3 !== "number")
                return H.iae(t3);
              this.drawAccidental$6(t2, 0.75, J.round$0$n(t1.$add(hInsertPos, numAccidentals * t3)), sharpPositions[i - 21], vStaffPos, vSystem);
              ++numAccidentals;
            } else if (t2 === 2) {
              t2 = $.MusicTextures_doubleSharp;
              t3 = this._scoreProps._keySigWidth;
              if (typeof t3 !== "number")
                return H.iae(t3);
              this.drawAccidental$6(t2, 0.8, J.round$0$n(t1.$add(hInsertPos, numAccidentals * t3)), sharpPositions[i - 21], vStaffPos, vSystem);
              ++numAccidentals;
            }
          }
          t2 = this._scoreProps._keySigWidth;
          t3 = measure.get$stack()._maxKeySize;
          if (typeof t2 !== "number")
            return t2.$mul();
          if (typeof t3 !== "number")
            return H.iae(t3);
          hInsertPos = t1.$add(hInsertPos, t2 * t3);
        }
        if (measure.get$showTime()) {
          hInsertPos = J.$add$ns(hInsertPos, this._scoreProps._clefDistanceFromBarline);
          timeTF = Y.TextField$(null, null);
          t1 = this._scoreProps;
          tFormat = new Y.TextFormat("Arial", 12 * t1._staffLineSpacing, 4278190080, 0, 4278190080, null, 400, false, false, false, "center", "top", 0, 0, 0, 0, 0, 0);
          tFormat.leading = -5.2 * t1._noteheadWidth;
          timeTF._defaultTextFormat = tFormat.clone$0(0);
          timeTF._refreshPending |= 3;
          t1 = measure.get$displayNumBeats() == null ? J.$add$ns(J.$add$ns(J.toString$0$(measure.get$numBeats()), "\n"), J.toString$0$(measure.get$beatType())) : J.$add$ns(J.$add$ns(J.toString$0$(measure.get$displayNumBeats()), "\n"), J.toString$0$(measure.get$displayBeatType()));
          timeTF._text$_text = t1;
          timeTF._caretIndex = J.get$length$asx(t1);
          t1 = timeTF._refreshPending |= 3;
          timeTF._autoSize = "center";
          timeTF._refreshPending = t1 | 3;
          timeTF._refreshTextLineMetrics$0();
          t1 = C.JSNumber_methods.round$0(timeTF._textWidth);
          timeTF._refreshTextLineMetrics$0();
          t1 = A.BitmapData_BitmapData(t1 + 2, C.JSNumber_methods.round$0(timeTF._textHeight), 16777215, 1);
          t2 = $.DisplayObject__nextID;
          $.DisplayObject__nextID = t2 + 1;
          timeBitmap = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
          t1.draw$1(timeTF);
          if (typeof hInsertPos === "number")
            timeBitmap._x = hInsertPos;
          rectangle = timeBitmap.get$bounds();
          timeBitmap._y = vStaffPos - J.$div$n(timeBitmap.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height, 28);
          timeBitmap._transformationMatrixRefresh = true;
          timeBitmap._scaleY = 0.25;
          timeBitmap._scaleX = 0.25;
          vSystem.addChild$1(timeBitmap);
        }
      },
      drawClef$5: function(clefType, smallSize, xPos, vStaffPos, vSystem) {
        var t1, t2, clefShape;
        switch (clefType) {
          case "treble":
            t1 = $.MusicTextures_trebleClef;
            t2 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t2 + 1;
            clefShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            t1 = this._scoreProps;
            clefShape._y = smallSize ? vStaffPos - t1._staffLineSpacing : vStaffPos - 2 * t1._staffLineSpacing;
            break;
          case "bass":
            t1 = $.MusicTextures_bassClef;
            t2 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t2 + 1;
            clefShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            clefShape._y = smallSize ? vStaffPos + this._scoreProps._staffLineSpacing / 6 : vStaffPos;
            break;
          case "tenor":
            t1 = $.MusicTextures_tenorClef;
            t2 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t2 + 1;
            clefShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            clefShape._y = smallSize ? vStaffPos + this._scoreProps._staffLineSpacing / 6 : vStaffPos;
            break;
          case "alto":
            t1 = $.MusicTextures_altoClef;
            t2 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t2 + 1;
            clefShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            clefShape._y = smallSize ? vStaffPos + this._scoreProps._staffLineSpacing / 6 : vStaffPos;
            break;
          default:
            H.printString("unrecognized clef type! " + H.S(clefType) + " VisualSystem.addClefKeyTime()");
            t1 = $.MusicTextures_trebleClef;
            t2 = $.DisplayObject__nextID;
            $.DisplayObject__nextID = t2 + 1;
            clefShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        }
        if (typeof xPos === "number")
          clefShape._x = xPos;
        clefShape._transformationMatrixRefresh = true;
        if (smallSize) {
          t1 = clefShape._scaleY * 0.75;
          clefShape._scaleY = t1;
          clefShape._scaleX = t1;
        }
        vSystem.addChild$1(clefShape);
      },
      drawAccidental$7: function(accidentalBD, scaling, hInsertPos, stepsFromTopStaffLine, vStaffPos, vSystem, vertOffset) {
        var t1, accidentalShape, rectangle;
        t1 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t1 + 1;
        accidentalShape = new A.Bitmap(accidentalBD, t1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        accidentalShape._x = hInsertPos;
        t1 = this._scoreProps._staffLineSpacing;
        rectangle = accidentalShape.get$bounds();
        accidentalShape._y = vStaffPos + stepsFromTopStaffLine * (t1 / 2) - J.$div$n(accidentalShape.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height, 2) + vertOffset;
        accidentalShape._transformationMatrixRefresh = true;
        vSystem.addChild$1(accidentalShape);
      },
      drawAccidental$6: function(accidentalBD, scaling, hInsertPos, stepsFromTopStaffLine, vStaffPos, vSystem) {
        return this.drawAccidental$7(accidentalBD, scaling, hInsertPos, stepsFromTopStaffLine, vStaffPos, vSystem, 0);
      },
      addAttachments$4: function(cMeasure, systemIndent, vStaffPos, visualSystem) {
        var hOffset, attachments, numAttachments, t1, i, attachment, t2, t3, visualAttachment;
        hOffset = J.$add$ns(systemIndent, cMeasure.get$stack()._startPosition);
        attachments = cMeasure.get$attachments();
        numAttachments = attachments.length;
        for (t1 = [A.BitmapFilter], i = 0; i < numAttachments; ++i) {
          if (i >= attachments.length)
            return H.ioore(attachments, i);
          attachment = attachments[i];
          switch (attachment._data$_type) {
            case "f":
              t2 = $.MusicTextures_f;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "ff":
              t2 = $.MusicTextures_ff;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "fff":
              t2 = $.MusicTextures_fff;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "ffff":
              t2 = $.MusicTextures_fff;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "p":
              t2 = $.MusicTextures_p;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "pp":
              t2 = $.MusicTextures_pp;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "ppp":
              t2 = $.MusicTextures_ppp;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "pppp":
              t2 = $.MusicTextures_ppp;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "mf":
              t2 = $.MusicTextures_mf;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            case "mp":
              t2 = $.MusicTextures_mp;
              t3 = $.DisplayObject__nextID;
              $.DisplayObject__nextID = t3 + 1;
              visualAttachment = new A.Bitmap(t2, t3, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t1), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              break;
            default:
              visualAttachment = null;
          }
          if (visualAttachment != null) {
            t2 = J.$add$ns(attachment._hPos, hOffset);
            if (typeof t2 === "number")
              visualAttachment._x = t2;
            visualAttachment._transformationMatrixRefresh = true;
            t2 = J.$add$ns(attachment._vPos, vStaffPos);
            if (typeof t2 === "number")
              visualAttachment._y = t2;
            visualAttachment._transformationMatrixRefresh = true;
            visualSystem.addChild$1(visualAttachment);
          }
        }
      },
      renderVerticalBarlines$6: function(staffGroupings, systemIndent, vSystem, vStaffPos, stacks, systemWidth) {
        var t1, t2, command, vertStartPos, _i, stavesInGroup, t3, t4, vertEndPos, horizPos, i, clefOffset;
        vSystem.get$graphics().beginPath$0(0);
        t1 = staffGroupings.length;
        if (t1 <= 1)
          t1 = t1 > 0 && staffGroupings[0] > 1;
        else
          t1 = true;
        if (t1) {
          vSystem.get$graphics().moveTo$2(0, systemIndent, 0);
          vSystem.get$graphics().lineTo$2(0, systemIndent, vStaffPos + 4 * this._scoreProps._staffLineSpacing);
        }
        if (J.get$next$x(C.JSArray_methods.get$last(stacks)) == null) {
          t1 = vSystem.get$graphics();
          t2 = this._scoreProps._lightBarlineWidth;
          t1.toString;
          command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(t2), C.JointStyle_0, C.CapsStyle_0, null);
          command._setGraphics$1(t1);
          t1._originalCommands.push(command);
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
          vSystem.get$graphics().closePath$0(0);
          vSystem.get$graphics().beginPath$0(0);
          vSystem.get$graphics().moveTo$2(0, systemWidth, 0);
          vSystem.get$graphics().lineTo$2(0, systemWidth, vStaffPos + 4 * this._scoreProps._staffLineSpacing);
          t1 = vSystem.get$graphics();
          t2 = this._scoreProps._heavyBarlineWidth;
          t1.toString;
          command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(t2), C.JointStyle_1, C.CapsStyle_0, null);
          command._setGraphics$1(t1);
          t1._originalCommands.push(command);
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
          t1 = J.getInterceptor$n(systemWidth);
          vSystem.get$graphics().moveTo$2(0, t1.$sub(systemWidth, this._scoreProps._staffLineSpacing), 0);
          vSystem.get$graphics().lineTo$2(0, t1.$sub(systemWidth, this._scoreProps._staffLineSpacing), vStaffPos + 4 * this._scoreProps._staffLineSpacing);
        } else {
          vSystem.get$graphics().moveTo$2(0, systemWidth, 0);
          vSystem.get$graphics().lineTo$2(0, systemWidth, vStaffPos + 4 * this._scoreProps._staffLineSpacing);
        }
        for (t1 = staffGroupings.length, t2 = [U.GraphicsCommand], vertStartPos = 0, _i = 0; _i < staffGroupings.length; staffGroupings.length === t1 || (0, H.throwConcurrentModificationError)(staffGroupings), ++_i) {
          stavesInGroup = staffGroupings[_i];
          t3 = this._scoreProps;
          t4 = 4 * t3._staffLineSpacing;
          t3 = t3._staffSpacing;
          if (typeof t3 !== "number")
            return H.iae(t3);
          vertEndPos = vertStartPos + (stavesInGroup - 1) * (t4 + t3) + t4;
          for (horizPos = systemIndent, i = 0; i < stacks.length - 1;) {
            horizPos = J.$add$ns(horizPos, J.get$width$x(stacks[i]));
            ++i;
            if (i >= stacks.length)
              return H.ioore(stacks, i);
            if (stacks[i].get$newClef()) {
              t3 = this._scoreProps;
              t4 = t3._clefWidth;
              t3 = t3._clefDistanceFromBarline;
              if (typeof t4 !== "number")
                return t4.$add();
              clefOffset = t4 + t3;
            } else
              clefOffset = 0;
            t3 = vSystem._graphics;
            if (!(t3 != null)) {
              t3 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
              vSystem._graphics = t3;
            }
            t4 = J.getInterceptor$ns(horizPos);
            command = new U.GraphicsCommandMoveTo(J.toDouble$0$n(t4.$add(horizPos, clefOffset)), C.JSNumber_methods.toDouble$0(vertStartPos), null);
            command._drawing$_graphics = t3;
            t3._originalCommands.push(command);
            C.JSArray_methods.set$length(t3._compiledCommands, 0);
            t3._bounds = null;
            t3 = vSystem._graphics;
            if (!(t3 != null)) {
              t3 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
              vSystem._graphics = t3;
            }
            command = new U.GraphicsCommandLineTo(J.toDouble$0$n(t4.$add(horizPos, clefOffset)), C.JSNumber_methods.toDouble$0(vertEndPos), null);
            command._drawing$_graphics = t3;
            t3._originalCommands.push(command);
            C.JSArray_methods.set$length(t3._compiledCommands, 0);
            t3._bounds = null;
          }
          t3 = this._scoreProps;
          t4 = t3._staffLineSpacing;
          t3 = t3._staffSpacing;
          if (typeof t3 !== "number")
            return H.iae(t3);
          vertStartPos += stavesInGroup * (4 * t4 + t3);
        }
        t1 = vSystem.get$graphics();
        t2 = this._scoreProps._lightBarlineWidth;
        t1.toString;
        command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(t2), C.JointStyle_0, C.CapsStyle_0, null);
        command._setGraphics$1(t1);
        t1._originalCommands.push(command);
        C.JSArray_methods.set$length(t1._compiledCommands, 0);
        t1._bounds = null;
        vSystem.get$graphics().closePath$0(0);
      },
      _drawRepeats$5: function(staffGroupings, systemIndent, vSystem, vStaffPos, stacks) {
        var space, t1, t2, t3, t4, t5, t6, t7, t8, t9, vertStartPos, _i, stavesInGroup, t10, vertEndPos, horizPos, i, stack, t11, t12, t13, t14, _i0, rdo, t15, heavyPos, lightPos, dotsPos, leftPos, rightPos, vPos, command, t16, t17, t18, textPos, tf, j;
        space = this._scoreProps._staffLineSpacing;
        for (t1 = staffGroupings.length, t2 = [U.GraphicsCommand], t3 = 1.5 * space, t4 = space / 4, t5 = 12 * space / 12, t6 = 0.5 * space, t7 = 2.5 * space, t8 = space / 5, t9 = 4 * space, vertStartPos = 0, _i = 0; _i < staffGroupings.length; staffGroupings.length === t1 || (0, H.throwConcurrentModificationError)(staffGroupings), ++_i) {
          stavesInGroup = staffGroupings[_i];
          t10 = this._scoreProps._staffSpacing;
          if (typeof t10 !== "number")
            return H.iae(t10);
          vertEndPos = vertStartPos + (stavesInGroup - 1) * (t9 + t10) + t9;
          for (horizPos = systemIndent, i = 0; i < stacks.length; ++i) {
            stack = stacks[i];
            if (stack.get$repeatDOs() != null)
              for (t10 = stack.get$repeatDOs(), t11 = t10.length, t12 = J.getInterceptor$x(stack), t13 = J.getInterceptor$ns(horizPos), t14 = i === 0, _i0 = 0; _i0 < t10.length; t10.length === t11 || (0, H.throwConcurrentModificationError)(t10), ++_i0) {
                rdo = t10[_i0];
                t15 = rdo.repeatDirection;
                if (t15 === 0) {
                  t15 = this._scoreProps._measureLeadIn;
                  if (typeof t15 !== "number")
                    return H.iae(t15);
                  t15 = t13.$sub(horizPos, 2 * t15);
                  heavyPos = J.$add$ns(t15, t14 ? stack.get$indentAsSystemLeader() : stack.get$indent());
                  t15 = J.getInterceptor$n(heavyPos);
                  if (t15.$gt(heavyPos, horizPos))
                    heavyPos = t15.$add(heavyPos, space);
                  lightPos = J.$add$ns(heavyPos, space);
                  dotsPos = J.$add$ns(lightPos, t6);
                } else if (t15 === 1) {
                  heavyPos = t13.$add(horizPos, t12.get$width(stack));
                  lightPos = J.$sub$n(heavyPos, space);
                  dotsPos = J.$sub$n(lightPos, t6);
                } else {
                  if (rdo.endingType != null) {
                    t15 = t13.$sub(horizPos, this._scoreProps._measureLeadIn);
                    leftPos = J.$add$ns(t15, t14 ? stack.get$indentAsSystemLeader() : stack.get$indent());
                    rightPos = t13.$add(horizPos, t12.get$width(stack));
                    vPos = rdo.endingVPos;
                    t15 = vSystem._graphics;
                    if (!(t15 != null)) {
                      t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                      vSystem._graphics = t15;
                    }
                    command = new U.GraphicsCommandBeginPath(null);
                    command._drawing$_graphics = t15;
                    t15._originalCommands.push(command);
                    C.JSArray_methods.set$length(t15._compiledCommands, 0);
                    t15._bounds = null;
                    t15 = vSystem._graphics;
                    if (!(t15 != null)) {
                      t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                      vSystem._graphics = t15;
                    }
                    t16 = J.getInterceptor$n(leftPos);
                    t17 = J.getInterceptor$n(vPos);
                    command = new U.GraphicsCommandMoveTo(t16.toDouble$0(leftPos), t17.toDouble$0(vPos), null);
                    command._drawing$_graphics = t15;
                    t15._originalCommands.push(command);
                    C.JSArray_methods.set$length(t15._compiledCommands, 0);
                    t15._bounds = null;
                    t15 = vSystem._graphics;
                    if (!(t15 != null)) {
                      t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                      vSystem._graphics = t15;
                    }
                    t18 = J.getInterceptor$n(rightPos);
                    command = new U.GraphicsCommandLineTo(t18.toDouble$0(rightPos), t17.toDouble$0(vPos), null);
                    command._drawing$_graphics = t15;
                    t15._originalCommands.push(command);
                    C.JSArray_methods.set$length(t15._compiledCommands, 0);
                    t15._bounds = null;
                    t15 = rdo.endingType;
                    if (t15 === 0) {
                      t15 = vSystem._graphics;
                      if (!(t15 != null)) {
                        t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                        vSystem._graphics = t15;
                      }
                      command = new U.GraphicsCommandMoveTo(t16.toDouble$0(leftPos), t17.toDouble$0(vPos), null);
                      command._drawing$_graphics = t15;
                      t15._originalCommands.push(command);
                      C.JSArray_methods.set$length(t15._compiledCommands, 0);
                      t15._bounds = null;
                      t15 = vSystem._graphics;
                      if (!(t15 != null)) {
                        t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                        vSystem._graphics = t15;
                      }
                      t18 = t17.$add(vPos, t3);
                      command = new U.GraphicsCommandLineTo(t16.toDouble$0(leftPos), J.toDouble$0$n(t18), null);
                      command._drawing$_graphics = t15;
                      t15._originalCommands.push(command);
                      C.JSArray_methods.set$length(t15._compiledCommands, 0);
                      t15._bounds = null;
                      if (rdo.endingNumber != null) {
                        textPos = t16.$add(leftPos, space);
                        tf = Y.TextField$(rdo.endingNumber, new Y.TextFormat("arial", t5, 0, 0, 4278190080, null, 400, false, false, false, "left", "top", 0, 0, 0, 0, 0, 0));
                        if (typeof textPos === "number")
                          tf._x = textPos;
                        tf._transformationMatrixRefresh = true;
                        t15 = t17.$add(vPos, t4);
                        if (typeof t15 === "number")
                          tf._y = t15;
                        tf._transformationMatrixRefresh = true;
                        vSystem.addChild$1(tf);
                      }
                    } else if (t15 === 1) {
                      t15 = vSystem._graphics;
                      if (!(t15 != null)) {
                        t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                        vSystem._graphics = t15;
                      }
                      command = new U.GraphicsCommandMoveTo(t18.toDouble$0(rightPos), t17.toDouble$0(vPos), null);
                      command._drawing$_graphics = t15;
                      t15._originalCommands.push(command);
                      C.JSArray_methods.set$length(t15._compiledCommands, 0);
                      t15._bounds = null;
                      t15 = vSystem._graphics;
                      if (!(t15 != null)) {
                        t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                        vSystem._graphics = t15;
                      }
                      t17 = t17.$add(vPos, t3);
                      command = new U.GraphicsCommandLineTo(t18.toDouble$0(rightPos), J.toDouble$0$n(t17), null);
                      command._drawing$_graphics = t15;
                      t15._originalCommands.push(command);
                      C.JSArray_methods.set$length(t15._compiledCommands, 0);
                      t15._bounds = null;
                    }
                    t15 = vSystem._graphics;
                    if (!(t15 != null)) {
                      t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                      vSystem._graphics = t15;
                    }
                    command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(this._scoreProps._lightBarlineWidth), C.JointStyle_0, C.CapsStyle_0, null);
                    command._drawing$_graphics = t15;
                    t15._originalCommands.push(command);
                    C.JSArray_methods.set$length(t15._compiledCommands, 0);
                    t15._bounds = null;
                  }
                  heavyPos = null;
                  lightPos = null;
                  dotsPos = null;
                }
                if (heavyPos != null) {
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandBeginPath(null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  t16 = J.getInterceptor$n(heavyPos);
                  command = new U.GraphicsCommandMoveTo(t16.toDouble$0(heavyPos), C.JSNumber_methods.toDouble$0(vertStartPos), null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandLineTo(t16.toDouble$0(heavyPos), C.JSNumber_methods.toDouble$0(vertEndPos), null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(this._scoreProps._heavyBarlineWidth), C.JointStyle_1, C.CapsStyle_0, null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandClosePath(null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandBeginPath(null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  t16 = J.getInterceptor$n(lightPos);
                  command = new U.GraphicsCommandMoveTo(t16.toDouble$0(lightPos), C.JSNumber_methods.toDouble$0(vertStartPos), null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandLineTo(t16.toDouble$0(lightPos), C.JSNumber_methods.toDouble$0(vertEndPos), null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(this._scoreProps._lightBarlineWidth), C.JointStyle_0, C.CapsStyle_0, null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandClosePath(null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandBeginPath(null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                  for (t15 = J.getInterceptor$n(dotsPos), j = 0; j < stavesInGroup; ++j) {
                    t16 = this._scoreProps._staffSpacing;
                    if (typeof t16 !== "number")
                      return H.iae(t16);
                    vPos = vertStartPos + j * (t9 + t16);
                    t16 = vSystem._graphics;
                    if (!(t16 != null)) {
                      t16 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                      vSystem._graphics = t16;
                    }
                    command = new U.GraphicsCommandCircle(t15.toDouble$0(dotsPos), C.JSNumber_methods.toDouble$0(vPos + t3), t8, false, null);
                    command._drawing$_graphics = t16;
                    t16._originalCommands.push(command);
                    C.JSArray_methods.set$length(t16._compiledCommands, 0);
                    t16._bounds = null;
                    t16 = vSystem._graphics;
                    if (!(t16 != null)) {
                      t16 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                      vSystem._graphics = t16;
                    }
                    command = new U.GraphicsCommandCircle(t15.toDouble$0(dotsPos), C.JSNumber_methods.toDouble$0(vPos + t7), t8, false, null);
                    command._drawing$_graphics = t16;
                    t16._originalCommands.push(command);
                    C.JSArray_methods.set$length(t16._compiledCommands, 0);
                    t16._bounds = null;
                    t16 = vSystem._graphics;
                    if (!(t16 != null)) {
                      t16 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                      vSystem._graphics = t16;
                    }
                    command = new U.GraphicsCommandFillColor(4278190080, null);
                    command._drawing$_graphics = t16;
                    t16._originalCommands.push(command);
                    C.JSArray_methods.set$length(t16._compiledCommands, 0);
                    t16._bounds = null;
                  }
                  t15 = vSystem._graphics;
                  if (!(t15 != null)) {
                    t15 = new U.Graphics(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), null);
                    vSystem._graphics = t15;
                  }
                  command = new U.GraphicsCommandClosePath(null);
                  command._drawing$_graphics = t15;
                  t15._originalCommands.push(command);
                  C.JSArray_methods.set$length(t15._compiledCommands, 0);
                  t15._bounds = null;
                }
              }
            if (i >= stacks.length)
              return H.ioore(stacks, i);
            horizPos = J.$add$ns(horizPos, J.get$width$x(stacks[i]));
          }
          t10 = this._scoreProps;
          t11 = t10._staffLineSpacing;
          t10 = t10._staffSpacing;
          if (typeof t10 !== "number")
            return H.iae(t10);
          vertStartPos += stavesInGroup * (4 * t11 + t10);
        }
      },
      drawTies$3: function(vngLists, vStaffPos, vSystem) {
        var noteheadWidth, tieStartOffset, tieEndOffset, nextVNG, i, vngList, numNotes, t1, j, cVNG, t2, t3, t4, t5, t6, t7, _i, note, t8, nextNote, it;
        noteheadWidth = this._scoreProps._noteheadWidth;
        tieStartOffset = 0.8 * noteheadWidth;
        tieEndOffset = 0.3 * noteheadWidth;
        for (nextVNG = null, i = 0; i < vngLists.length; ++i) {
          vngList = vngLists[i];
          numNotes = vngList.length;
          for (t1 = numNotes - 1, j = 0; j < numNotes; ++j) {
            if (j >= vngList.length)
              return H.ioore(vngList, j);
            cVNG = vngList[j];
            if (J.get$visible$x(cVNG.get$noteGroup()) === false)
              continue;
            for (t2 = cVNG.get$noteGroup().get$notes(), t3 = t2.length, t4 = j === 0, t5 = J.getInterceptor$x(cVNG), t6 = j < t1, t7 = j + 1, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
              note = t2[_i];
              if (!note.get$visible(note))
                continue;
              switch (note.get$tieState()) {
                case "start":
                  if (t6) {
                    if (t7 >= vngList.length)
                      return H.ioore(vngList, t7);
                    nextVNG = vngList[t7];
                    t8 = nextVNG.get$noteGroup().get$notes();
                    nextNote = new H.WhereIterable(t8, new D.SystemRenderer_drawTies_closure(note), [H.getTypeArgumentByIndex(t8, 0)]);
                    if (J.get$visible$x(nextVNG.get$noteGroup()) === true)
                      if (nextNote.get$length(nextNote) > 0) {
                        it = nextNote.get$iterator(nextNote);
                        if (!it.moveNext$0())
                          H.throwExpression(H.IterableElementError_noElement());
                        t8 = J.get$visible$x(it.get$current()) === true;
                      } else
                        t8 = false;
                    else
                      t8 = false;
                    if (t8)
                      this.drawTie$6(J.$add$ns(J.$add$ns(t5.get$x(cVNG), note.get$hPos()), tieStartOffset), J.$add$ns(J.get$x$x(nextVNG), tieEndOffset), J.$add$ns(note.get$vPos(), vStaffPos), vSystem, cVNG, note.get$vPos());
                  } else
                    this.drawTie$6(J.$add$ns(J.$add$ns(t5.get$x(cVNG), note.get$hPos()), tieStartOffset), vSystem._bitmap_renderer$_systemRef.get$systemWidth(), J.$add$ns(note.get$vPos(), vStaffPos), vSystem, cVNG, note.get$vPos());
                  break;
                case "continue":
                  if (t6) {
                    if (t7 >= vngList.length)
                      return H.ioore(vngList, t7);
                    nextVNG = vngList[t7];
                    t8 = nextVNG.get$noteGroup().get$notes();
                    nextNote = new H.WhereIterable(t8, new D.SystemRenderer_drawTies_closure0(note), [H.getTypeArgumentByIndex(t8, 0)]);
                    if (J.get$visible$x(nextVNG.get$noteGroup()) === true)
                      if (nextNote.get$length(nextNote) > 0) {
                        it = nextNote.get$iterator(nextNote);
                        if (!it.moveNext$0())
                          H.throwExpression(H.IterableElementError_noElement());
                        t8 = J.get$visible$x(it.get$current()) === true;
                      } else
                        t8 = false;
                    else
                      t8 = false;
                    if (t8)
                      this.drawTie$6(J.$add$ns(J.$add$ns(t5.get$x(cVNG), note.get$hPos()), tieStartOffset), J.$add$ns(J.get$x$x(nextVNG), tieEndOffset), J.$add$ns(note.get$vPos(), vStaffPos), vSystem, cVNG, note.get$vPos());
                    if (t4)
                      this.drawTie$6(J.$sub$n(t5.get$x(cVNG), 20), J.$add$ns(t5.get$x(cVNG), tieEndOffset), J.$add$ns(note.get$vPos(), vStaffPos), vSystem, cVNG, note.get$vPos());
                  } else
                    this.drawTie$6(J.$add$ns(t5.get$x(cVNG), tieStartOffset), vSystem._bitmap_renderer$_systemRef.get$systemWidth(), J.$add$ns(note.get$vPos(), vStaffPos), vSystem, cVNG, note.get$vPos());
                  break;
                case "stop":
                  if (t4)
                    this.drawTie$6(J.$sub$n(t5.get$x(cVNG), 20), J.$add$ns(t5.get$x(cVNG), tieEndOffset), J.$add$ns(note.get$vPos(), vStaffPos), vSystem, cVNG, note.get$vPos());
                  break;
              }
            }
          }
        }
      },
      drawTie$6: function(x1Val, x2Val, yVal, vSystem, vng, vPosInStaff) {
        var t1, curveDown, t2, t3, t4, tieShape, command, yControl, $length, t5, t6;
        if (vng.get$noteGroup().get$stemDirection() !== "up")
          t1 = vng.get$noteGroup().get$stemDirection() === "noStem" && J.$gt$n(vPosInStaff, this._scoreProps._staffLineSpacing * 3);
        else
          t1 = true;
        curveDown = t1 && true;
        t1 = [U.GraphicsCommand];
        t2 = H.setRuntimeTypeInfo([], t1);
        t1 = H.setRuntimeTypeInfo([], t1);
        t3 = new U.Graphics(t2, t1, null);
        t4 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t4 + 1;
        tieShape = new A.Shape(t3, t4, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        command = new U.GraphicsCommandBeginPath(null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        yControl = curveDown ? 7 : -7;
        $length = J.$sub$n(x2Val, x1Val);
        command = new U.GraphicsCommandMoveTo(C.JSInt_methods.toDouble$0(0), C.JSInt_methods.toDouble$0(0), null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        t4 = J.$div$n($length, 3);
        if (typeof $length !== "number")
          return H.iae($length);
        t5 = 2 * $length / 3;
        command = new U.GraphicsCommandBezierCurveTo(C.JSNumber_methods.toDouble$0(t4), C.JSInt_methods.toDouble$0(yControl), C.JSDouble_methods.toDouble$0(t5), C.JSInt_methods.toDouble$0(yControl), C.JSNumber_methods.toDouble$0($length), C.JSInt_methods.toDouble$0(0), null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        command = new U.GraphicsCommandMoveTo(C.JSInt_methods.toDouble$0(0), C.JSInt_methods.toDouble$0(0), null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        t4 = $length / 3;
        t6 = yControl - 1;
        command = new U.GraphicsCommandBezierCurveTo(C.JSDouble_methods.toDouble$0(t4), C.JSInt_methods.toDouble$0(t6), C.JSDouble_methods.toDouble$0(t5), C.JSInt_methods.toDouble$0(t6), C.JSNumber_methods.toDouble$0($length), C.JSInt_methods.toDouble$0(0), null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        command = new U.GraphicsCommandMoveTo(C.JSInt_methods.toDouble$0(0), C.JSInt_methods.toDouble$0(0), null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        t6 = yControl - 2;
        command = new U.GraphicsCommandBezierCurveTo(C.JSDouble_methods.toDouble$0(t4), C.JSInt_methods.toDouble$0(t6), C.JSDouble_methods.toDouble$0(t5), C.JSInt_methods.toDouble$0(t6), C.JSNumber_methods.toDouble$0($length), C.JSInt_methods.toDouble$0(0), null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        command = new U.GraphicsCommandStrokeColor(4278190080, C.JSInt_methods.toDouble$0(1), C.JointStyle_0, C.CapsStyle_0, null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        command = new U.GraphicsCommandClosePath(null);
        command._drawing$_graphics = t3;
        t2.push(command);
        C.JSArray_methods.set$length(t1, 0);
        t3._bounds = null;
        t1 = J.getInterceptor$n(x1Val);
        t1 = curveDown ? t1.$sub(x1Val, 1) : t1.$sub(x1Val, 0);
        if (typeof t1 === "number")
          tieShape._x = t1;
        t1 = J.getInterceptor$ns(yVal);
        t1 = curveDown ? t1.$add(yVal, 6) : t1.$sub(yVal, 6);
        if (typeof t1 === "number")
          tieShape._y = t1;
        vSystem.addChild$1(tieShape);
        vng.get$visualAttachments().push(tieShape);
      },
      drawSlurs$3: function(system, vSystem, parts) {
        var t1, t2, t3, t4, _i, segment, points, t5, t6, t7, command, t8, t9, t10, t11;
        if (system.get$slurSegments() == null)
          return;
        vSystem.get$graphics().beginPath$0(0);
        for (t1 = system.get$slurSegments(), t2 = t1.length, t3 = [U.GraphicsCommand], t4 = parts && C.JSArray_methods, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          segment = t1[_i];
          if (t4.indexOf$1(parts, segment.get$slur()._firstNote._voice._measure._staff._partRef) === -1)
            continue;
          if (!segment.get$slur()._firstNote._visible || !segment.get$slur()._endNote._visible)
            continue;
          points = segment.get$points(segment);
          t5 = vSystem._graphics;
          if (!(t5 != null)) {
            t5 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
            vSystem._graphics = t5;
          }
          t6 = points[0];
          t7 = t6.x;
          t6 = t6.y;
          command = new U.GraphicsCommandMoveTo(J.toDouble$0$n(t7), J.toDouble$0$n(t6), null);
          command._drawing$_graphics = t5;
          t5._originalCommands.push(command);
          C.JSArray_methods.set$length(t5._compiledCommands, 0);
          t5._bounds = null;
          t5 = vSystem._graphics;
          if (!(t5 != null)) {
            t5 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
            vSystem._graphics = t5;
          }
          t6 = points[1];
          t7 = t6.x;
          t6 = t6.y;
          t8 = points[2];
          t9 = t8.x;
          t8 = t8.y;
          t10 = points[3];
          t11 = t10.x;
          t10 = t10.y;
          command = new U.GraphicsCommandBezierCurveTo(J.toDouble$0$n(t7), J.toDouble$0$n(t6), J.toDouble$0$n(t9), J.toDouble$0$n(t8), J.toDouble$0$n(t11), J.toDouble$0$n(t10), null);
          command._drawing$_graphics = t5;
          t5._originalCommands.push(command);
          C.JSArray_methods.set$length(t5._compiledCommands, 0);
          t5._bounds = null;
          t5 = vSystem._graphics;
          if (!(t5 != null)) {
            t5 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
            vSystem._graphics = t5;
          }
          t6 = points[0];
          t7 = t6.x;
          t6 = t6.y;
          command = new U.GraphicsCommandMoveTo(J.toDouble$0$n(t7), J.toDouble$0$n(t6), null);
          command._drawing$_graphics = t5;
          t5._originalCommands.push(command);
          C.JSArray_methods.set$length(t5._compiledCommands, 0);
          t5._bounds = null;
          t5 = vSystem._graphics;
          if (!(t5 != null)) {
            t5 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
            vSystem._graphics = t5;
          }
          t6 = points[1];
          t7 = t6.x;
          t6 = J.$sub$n(t6.y, 1);
          t8 = points[2];
          t9 = t8.x;
          t8 = J.$sub$n(t8.y, 1);
          t10 = points[3];
          t11 = t10.x;
          t10 = t10.y;
          command = new U.GraphicsCommandBezierCurveTo(J.toDouble$0$n(t7), J.toDouble$0$n(t6), J.toDouble$0$n(t9), J.toDouble$0$n(t8), J.toDouble$0$n(t11), J.toDouble$0$n(t10), null);
          command._drawing$_graphics = t5;
          t5._originalCommands.push(command);
          C.JSArray_methods.set$length(t5._compiledCommands, 0);
          t5._bounds = null;
          t5 = vSystem._graphics;
          if (!(t5 != null)) {
            t5 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
            vSystem._graphics = t5;
          }
          t6 = points[0];
          t7 = t6.x;
          t6 = t6.y;
          command = new U.GraphicsCommandMoveTo(J.toDouble$0$n(t7), J.toDouble$0$n(t6), null);
          command._drawing$_graphics = t5;
          t5._originalCommands.push(command);
          C.JSArray_methods.set$length(t5._compiledCommands, 0);
          t5._bounds = null;
          t5 = vSystem._graphics;
          if (!(t5 != null)) {
            t5 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
            vSystem._graphics = t5;
          }
          t6 = points[1];
          t7 = t6.x;
          t6 = J.$sub$n(t6.y, 2);
          t8 = points[2];
          t9 = t8.x;
          t8 = J.$sub$n(t8.y, 2);
          t10 = points[3];
          t11 = t10.x;
          t10 = t10.y;
          command = new U.GraphicsCommandBezierCurveTo(J.toDouble$0$n(t7), J.toDouble$0$n(t6), J.toDouble$0$n(t9), J.toDouble$0$n(t8), J.toDouble$0$n(t11), J.toDouble$0$n(t10), null);
          command._drawing$_graphics = t5;
          t5._originalCommands.push(command);
          C.JSArray_methods.set$length(t5._compiledCommands, 0);
          t5._bounds = null;
        }
        t1 = vSystem.get$graphics();
        t1.toString;
        command = new U.GraphicsCommandStrokeColor(4278190080, C.JSInt_methods.toDouble$0(1), C.JointStyle_0, C.CapsStyle_0, null);
        command._setGraphics$1(t1);
        t1._originalCommands.push(command);
        C.JSArray_methods.set$length(t1._compiledCommands, 0);
        t1._bounds = null;
        vSystem.get$graphics().closePath$0(0);
      }
    },
    SystemRenderer_drawTies_closure: {
      "^": "Closure:0;note",
      call$1: function(e) {
        return e.get$displayCents() === this.note.get$displayCents();
      }
    },
    SystemRenderer_drawTies_closure0: {
      "^": "Closure:0;note",
      call$1: function(e) {
        var t1, t2;
        t1 = e.get$pitchName();
        t2 = this.note.get$pitchName();
        return t1 == null ? t2 == null : t1 === t2;
      }
    },
    VisualMeasure: {
      "^": "Object;x*,y*,width*,height>,measureRef,vSystemRef<"
    },
    VisualNoteGroup: {
      "^": "Sprite;_bitmap_renderer$_noteGroup,_scoreProps,_vSystemRef,_visualAttachments,_originalPosition,_colorOverlay,_noteheadList,_noteheadType,_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      setColor$1: function(color) {
        var t1, t2, _i;
        t1 = this._noteheadList;
        if (t1 == null)
          return;
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].set$bitmapData(G.MusicTextures_getColoredNoteheadBD(this._noteheadType, color));
      },
      clearColor$0: function(_) {
        var t1, t2, _i;
        t1 = this._noteheadList;
        if (t1 == null)
          return;
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].set$bitmapData(G.MusicTextures_getColoredNoteheadBD(this._noteheadType, 0));
      },
      _bitmap_renderer$_init$0: function() {
        this._visualAttachments = [];
        if (J.get$visible$x(this._bitmap_renderer$_noteGroup) === false)
          return;
        if (this._bitmap_renderer$_noteGroup.get$isRest())
          this._drawRest$0();
        else {
          this._drawNotes$0();
          this._drawStem$0();
        }
        this._addAttachments$0();
      },
      _drawRest$0: function() {
        var t1, t2, t3, t4, restShape, verticalOffset, i, command, rectangle, t5, t6, t7;
        t1 = this._bitmap_renderer$_noteGroup.get$durationType();
        t2 = $.DisplayObject__nextID;
        t3 = t2 + 1;
        t4 = [A.BitmapFilter];
        switch (t1) {
          case 4096:
            t1 = $.MusicTextures_wholeRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            verticalOffset = -0.75 * this._scoreProps._staffLineSpacing;
            break;
          case 2048:
            t1 = $.MusicTextures_halfRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            verticalOffset = -0.25 * this._scoreProps._staffLineSpacing;
            t4 = restShape.get$boundsTransformed().width;
            if (typeof t4 !== "number")
              return H.iae(t4);
            restShape.set$x(0, -0.35 * t4);
            break;
          case 1024:
            t1 = $.MusicTextures_quarterRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            verticalOffset = 0;
            break;
          case 512:
            t1 = $.MusicTextures_eighthRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            verticalOffset = 0;
            break;
          case 256:
            t1 = $.MusicTextures_sixteenthRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            verticalOffset = 0;
            break;
          case 128:
            t1 = $.MusicTextures_thirtySecondRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            verticalOffset = 0;
            break;
          case 64:
            t1 = $.MusicTextures_sixtyFourthRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            verticalOffset = 0;
            break;
          default:
            t1 = $.MusicTextures_quarterRest;
            $.DisplayObject__nextID = t3;
            restShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
            P.print("Unsupported rest duration! " + H.S(this._bitmap_renderer$_noteGroup) + ".durationType VisualNoteGroup.drawRest()");
            verticalOffset = 0;
        }
        restShape.set$y(0, this._bitmap_renderer$_noteGroup.get$restVPos() - J.$div$n(restShape.get$boundsTransformed().height, 2) + verticalOffset);
        if (this._bitmap_renderer$_noteGroup.get$durationType() === 4096)
          if (this._bitmap_renderer$_noteGroup.get$qNoteDuration() === J.get$measure$x(J.get$voice$x(this._bitmap_renderer$_noteGroup))._stack._dpqLength) {
            t1 = restShape.get$boundsTransformed().width;
            if (typeof t1 !== "number")
              return H.iae(t1);
            restShape.set$x(0, -0.5 * t1);
          }
        this.addChild$1(restShape);
        for (t1 = [U.GraphicsCommand], i = 0; i < this._bitmap_renderer$_noteGroup.get$numDots(); ++i) {
          t2 = this._graphics;
          if (!(t2 != null)) {
            t2 = new U.Graphics(H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), null);
            this._graphics = t2;
          }
          command = new U.GraphicsCommandBeginPath(null);
          command._drawing$_graphics = t2;
          t2._originalCommands.push(command);
          C.JSArray_methods.set$length(t2._compiledCommands, 0);
          t2._bounds = null;
          t2 = this._graphics;
          if (!(t2 != null)) {
            t2 = new U.Graphics(H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), null);
            this._graphics = t2;
          }
          t3 = restShape._x;
          rectangle = restShape.get$bounds();
          t4 = restShape.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).width;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t5 = restShape._y;
          rectangle = restShape.get$bounds();
          t6 = restShape.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height;
          if (typeof t6 !== "number")
            return H.iae(t6);
          t7 = this._scoreProps._noteheadWidth;
          command = new U.GraphicsCommandCircle(C.JSNumber_methods.toDouble$0(t3 + t4 + 3 + 8 * i), C.JSNumber_methods.toDouble$0(t5 + 0.3 * t6), t7 / 5, false, null);
          command._drawing$_graphics = t2;
          t2._originalCommands.push(command);
          C.JSArray_methods.set$length(t2._compiledCommands, 0);
          t2._bounds = null;
          t2 = this._graphics;
          if (!(t2 != null)) {
            t2 = new U.Graphics(H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), null);
            this._graphics = t2;
          }
          command = new U.GraphicsCommandFillColor(4278190080, null);
          command._drawing$_graphics = t2;
          t2._originalCommands.push(command);
          C.JSArray_methods.set$length(t2._compiledCommands, 0);
          t2._bounds = null;
          t2 = this._graphics;
          if (!(t2 != null)) {
            t2 = new U.Graphics(H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), null);
            this._graphics = t2;
          }
          command = new U.GraphicsCommandClosePath(null);
          command._drawing$_graphics = t2;
          t2._originalCommands.push(command);
          C.JSArray_methods.set$length(t2._compiledCommands, 0);
          t2._bounds = null;
        }
      },
      _drawNotes$0: function() {
        var t1, t2, t3, t4, t5, bottomNote, topNote, _i, note, t6, t7, t8, noteShape, rectangle, i, command, t9, accidental, vertOffset, sharp, doubSharp, flat;
        this._noteheadList = [];
        for (t1 = this._bitmap_renderer$_noteGroup.get$notes(), t2 = t1.length, t3 = [U.GraphicsCommand], t4 = [A.BitmapFilter], t5 = [A.DisplayObject], bottomNote = null, topNote = null, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          note = t1[_i];
          if (!note.get$visible(note))
            continue;
          if (bottomNote == null)
            bottomNote = note;
          t6 = this._bitmap_renderer$_noteGroup.get$durationType();
          t7 = $.DisplayObject__nextID;
          t8 = t7 + 1;
          switch (t6) {
            case 4096:
              t6 = $.MusicTextures_wholeNoteHead;
              $.DisplayObject__nextID = t8;
              noteShape = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              this._noteheadType = C.NoteheadType_2;
              break;
            case 2048:
              t6 = $.MusicTextures_halfNoteHead;
              $.DisplayObject__nextID = t8;
              noteShape = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              this._noteheadType = C.NoteheadType_1;
              break;
            default:
              t6 = $.MusicTextures_quarterNoteHead;
              $.DisplayObject__nextID = t8;
              noteShape = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              this._noteheadType = C.NoteheadType_0;
          }
          this._noteheadList.push(noteShape);
          if (this._bitmap_renderer$_noteGroup.get$isGrace()) {
            noteShape._scaleX = noteShape._scaleX * 0.65;
            noteShape._transformationMatrixRefresh = true;
            noteShape._scaleY = noteShape._scaleY * 0.65;
          }
          t6 = this._bitmap_renderer$_noteGroup.get$stemDirection() === "down" ? J.$sub$n(note.get$hPos(), 1) : note.get$hPos();
          if (typeof t6 === "number")
            noteShape._x = t6;
          noteShape._transformationMatrixRefresh = true;
          t6 = note.get$vPos();
          rectangle = noteShape.get$bounds();
          t6 = J.$sub$n(t6, J.$div$n(noteShape.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height, 2));
          if (typeof t6 === "number")
            noteShape._y = t6;
          noteShape._transformationMatrixRefresh = true;
          this.addChild$1(noteShape);
          for (i = 0; i < this._bitmap_renderer$_noteGroup.get$numDots(); ++i) {
            t6 = this._graphics;
            if (!(t6 != null)) {
              t6 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t6;
            }
            command = new U.GraphicsCommandBeginPath(null);
            command._drawing$_graphics = t6;
            t6._originalCommands.push(command);
            C.JSArray_methods.set$length(t6._compiledCommands, 0);
            t6._bounds = null;
            t6 = this._graphics;
            if (!(t6 != null)) {
              t6 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t6;
            }
            t7 = J.$add$ns(J.$add$ns(note.get$hPos(), 1.6 * this._scoreProps._noteheadWidth), i * 8);
            t8 = J.$sub$n(note.get$vPos(), 0.5 * this._scoreProps._staffLineSpacing * C.JSNumber_methods.$mod(Math.abs(note.get$stepsFromTopStaffLine()) + 1, 2));
            t9 = this._scoreProps._noteheadWidth;
            command = new U.GraphicsCommandCircle(J.toDouble$0$n(t7), J.toDouble$0$n(t8), t9 / 5, false, null);
            command._drawing$_graphics = t6;
            t6._originalCommands.push(command);
            C.JSArray_methods.set$length(t6._compiledCommands, 0);
            t6._bounds = null;
            t6 = this._graphics;
            if (!(t6 != null)) {
              t6 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t6;
            }
            command = new U.GraphicsCommandFillColor(4278190080, null);
            command._drawing$_graphics = t6;
            t6._originalCommands.push(command);
            C.JSArray_methods.set$length(t6._compiledCommands, 0);
            t6._bounds = null;
            t6 = this._graphics;
            if (!(t6 != null)) {
              t6 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t6;
            }
            command = new U.GraphicsCommandClosePath(null);
            command._drawing$_graphics = t6;
            t6._originalCommands.push(command);
            C.JSArray_methods.set$length(t6._compiledCommands, 0);
            t6._bounds = null;
          }
          if (note.get$showAccidental())
            switch (note.get$accidental()) {
              case 100:
                accidental = null;
                vertOffset = 0;
                break;
              case 1:
                t6 = $.MusicTextures_sharp;
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                accidental = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                vertOffset = -0.1 * this._scoreProps._staffLineSpacing;
                break;
              case -1:
                t6 = $.MusicTextures_flat;
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                accidental = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                vertOffset = -0.5 * this._scoreProps._staffLineSpacing;
                break;
              case 0:
                t6 = $.MusicTextures_natural;
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                accidental = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                vertOffset = -0.1 * this._scoreProps._staffLineSpacing;
                break;
              case 2:
                t6 = $.MusicTextures_doubleSharp;
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                accidental = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                vertOffset = 0.2 * this._scoreProps._staffLineSpacing;
                break;
              case -2:
                t6 = $.MusicTextures_doubleFlat;
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                accidental = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                vertOffset = -0.5 * this._scoreProps._staffLineSpacing;
                break;
              case 3:
                t6 = H.setRuntimeTypeInfo([], t5);
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                accidental = new A.Sprite(null, null, null, t6, true, true, false, true, "auto", true, 0, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                t7 = $.MusicTextures_sharp;
                t6 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t6 + 1;
                sharp = new A.Bitmap(t7, t6, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                sharp._x = -2.5 * this._scoreProps._staffLineSpacing;
                t6 = $.MusicTextures_doubleSharp;
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                doubSharp = new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                doubSharp._y = 1.3 * this._scoreProps._staffLineSpacing;
                accidental.addChild$1(sharp);
                accidental.addChild$1(doubSharp);
                vertOffset = 0;
                break;
              case -3:
                t6 = H.setRuntimeTypeInfo([], t5);
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                accidental = new A.Sprite(null, null, null, t6, true, true, false, true, "auto", true, 0, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                t7 = $.MusicTextures_flat;
                t6 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t6 + 1;
                flat = new A.Bitmap(t7, t6, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                flat._x = -1 * this._scoreProps._staffLineSpacing;
                t6 = $.MusicTextures_doubleFlat;
                t7 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t7 + 1;
                t8 = H.setRuntimeTypeInfo([], t4);
                t9 = T.Matrix$fromIdentity();
                accidental.addChild$1(flat);
                accidental.addChild$1(new A.Bitmap(t6, t7, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, t8, null, "", null, t9, true, null, null));
                vertOffset = -0.5 * this._scoreProps._staffLineSpacing;
                break;
              default:
                H.printString("Unrecognized accidental! " + note.toString$0(0) + ".accidental VisualNoteGroup.drawNotes()");
                accidental = null;
                vertOffset = 0;
            }
          else {
            accidental = null;
            vertOffset = 0;
          }
          if (accidental != null) {
            accidental._scaleX = noteShape._scaleX;
            accidental._transformationMatrixRefresh = true;
            accidental._scaleY = noteShape._scaleY;
            t6 = noteShape._y;
            rectangle = accidental.get$bounds();
            accidental._y = t6 - J.$div$n(accidental.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height, 4) + vertOffset;
            accidental._transformationMatrixRefresh = true;
            t6 = note.get$accidentalPos();
            if (typeof t6 === "number")
              accidental._x = t6;
            accidental._transformationMatrixRefresh = true;
            this.addChild$1(accidental);
          }
          topNote = note;
        }
        if (bottomNote == null)
          return;
        if (bottomNote.get$legerLines() > 0) {
          this.get$graphics().beginPath$0(0);
          for (i = 0; i < bottomNote.get$legerLines(); ++i) {
            t1 = this._graphics;
            if (!(t1 != null)) {
              t1 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t1;
            }
            t2 = this._scoreProps;
            t4 = t2._noteheadWidth;
            t2 = t2._staffLineSpacing;
            t5 = 5 + i;
            command = new U.GraphicsCommandMoveTo(C.JSDouble_methods.toDouble$0(-0.2 * t4), C.JSInt_methods.toDouble$0(t2 * t5), null);
            command._drawing$_graphics = t1;
            t1._originalCommands.push(command);
            C.JSArray_methods.set$length(t1._compiledCommands, 0);
            t1._bounds = null;
            t1 = this._graphics;
            if (!(t1 != null)) {
              t1 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t1;
            }
            t2 = this._scoreProps._noteheadWidth;
            t4 = bottomNote.get$hPos();
            if (typeof t4 !== "number")
              return H.iae(t4);
            t6 = this._scoreProps._staffLineSpacing;
            command = new U.GraphicsCommandLineTo(C.JSDouble_methods.toDouble$0(1.2 * t2 + t4), C.JSInt_methods.toDouble$0(t6 * t5), null);
            command._drawing$_graphics = t1;
            t1._originalCommands.push(command);
            C.JSArray_methods.set$length(t1._compiledCommands, 0);
            t1._bounds = null;
          }
          t1 = this.get$graphics();
          t2 = this._scoreProps._legerLineWidth;
          t1.toString;
          command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(t2), C.JointStyle_0, C.CapsStyle_0, null);
          command._setGraphics$1(t1);
          t1._originalCommands.push(command);
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
          this.get$graphics().closePath$0(0);
        }
        if (topNote.get$legerLines() < 0) {
          this.get$graphics().beginPath$0(0);
          for (i = 0; i > topNote.get$legerLines();) {
            t1 = this._graphics;
            if (!(t1 != null)) {
              t1 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t1;
            }
            t2 = this._scoreProps;
            t4 = t2._noteheadWidth;
            t2 = t2._staffLineSpacing;
            t5 = -1 + i;
            command = new U.GraphicsCommandMoveTo(C.JSDouble_methods.toDouble$0(-0.2 * t4), C.JSInt_methods.toDouble$0(t2 * t5), null);
            command._drawing$_graphics = t1;
            t1._originalCommands.push(command);
            C.JSArray_methods.set$length(t1._compiledCommands, 0);
            t1._bounds = null;
            t1 = this._graphics;
            if (!(t1 != null)) {
              t1 = new U.Graphics(H.setRuntimeTypeInfo([], t3), H.setRuntimeTypeInfo([], t3), null);
              this._graphics = t1;
            }
            t2 = this._scoreProps._noteheadWidth;
            t4 = topNote.get$hPos();
            if (typeof t4 !== "number")
              return H.iae(t4);
            t6 = this._scoreProps._staffLineSpacing;
            command = new U.GraphicsCommandLineTo(C.JSDouble_methods.toDouble$0(1.2 * t2 + t4), C.JSInt_methods.toDouble$0(t6 * t5), null);
            command._drawing$_graphics = t1;
            t1._originalCommands.push(command);
            C.JSArray_methods.set$length(t1._compiledCommands, 0);
            t1._bounds = null;
            --i;
          }
          t1 = this.get$graphics();
          t2 = this._scoreProps._legerLineWidth;
          t1.toString;
          command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(t2), C.JointStyle_0, C.CapsStyle_0, null);
          command._setGraphics$1(t1);
          t1._originalCommands.push(command);
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
          this.get$graphics().closePath$0(0);
        }
      },
      _drawStem$0: function() {
        var t1, t2, command, t3, t4, flagShape;
        if (this._bitmap_renderer$_noteGroup.get$stemDirection() === "noStem")
          return;
        this.get$graphics().beginPath$0(0);
        this.get$graphics().moveTo$2(0, this._bitmap_renderer$_noteGroup.get$stemHPos(), this._bitmap_renderer$_noteGroup.get$stemStartPos());
        this.get$graphics().lineTo$2(0, this._bitmap_renderer$_noteGroup.get$stemHPos(), this._bitmap_renderer$_noteGroup.get$stemEndPos());
        t1 = this.get$graphics();
        t2 = this._scoreProps._stemWidth;
        t1.toString;
        command = new U.GraphicsCommandStrokeColor(4278190080, J.toDouble$0$n(t2), C.JointStyle_0, C.CapsStyle_0, null);
        command._setGraphics$1(t1);
        t1._originalCommands.push(command);
        C.JSArray_methods.set$length(t1._compiledCommands, 0);
        t1._bounds = null;
        this.get$graphics().closePath$0(0);
        if (this._bitmap_renderer$_noteGroup.get$beamStates().length !== 0) {
          t1 = this._bitmap_renderer$_noteGroup.get$beamStates();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = J.$eq$(t1[0], "none");
        } else
          t1 = true;
        if (t1) {
          switch (this._bitmap_renderer$_noteGroup.get$durationType()) {
            case 512:
              t1 = this._bitmap_renderer$_noteGroup.get$stemDirection();
              t2 = $.DisplayObject__nextID;
              t3 = t2 + 1;
              t4 = [A.BitmapFilter];
              if (t1 === "up") {
                t1 = $.MusicTextures_eighthFlagUp;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              } else {
                t1 = $.MusicTextures_eighthFlagDown;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              }
              break;
            case 256:
              t1 = this._bitmap_renderer$_noteGroup.get$stemDirection();
              t2 = $.DisplayObject__nextID;
              t3 = t2 + 1;
              t4 = [A.BitmapFilter];
              if (t1 === "up") {
                t1 = $.MusicTextures_sixteenthFlagUp;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              } else {
                t1 = $.MusicTextures_sixteenthFlagDown;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              }
              break;
            case 128:
              t1 = this._bitmap_renderer$_noteGroup.get$stemDirection();
              t2 = $.DisplayObject__nextID;
              t3 = t2 + 1;
              t4 = [A.BitmapFilter];
              if (t1 === "up") {
                t1 = $.MusicTextures_thirtySecondFlagUp;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              } else {
                t1 = $.MusicTextures_thirtySecondFlagDown;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              }
              break;
            case 64:
              t1 = this._bitmap_renderer$_noteGroup.get$stemDirection();
              t2 = $.DisplayObject__nextID;
              t3 = t2 + 1;
              t4 = [A.BitmapFilter];
              if (t1 === "up") {
                t1 = $.MusicTextures_sixteenthFlagUp;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              } else {
                t1 = $.MusicTextures_sixteenthFlagDown;
                $.DisplayObject__nextID = t3;
                flagShape = new A.Bitmap(t1, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t4), null, "", null, T.Matrix$fromIdentity(), true, null, null);
              }
              break;
            case 1024:
              flagShape = null;
              break;
            case 2048:
              flagShape = null;
              break;
            case 4096:
              flagShape = null;
              break;
            default:
              P.print("Unknown duration! " + H.S(this._bitmap_renderer$_noteGroup) + ".durationType VisualNoteGroup.drawStem()");
              flagShape = null;
          }
          if (flagShape != null) {
            if (this._bitmap_renderer$_noteGroup.get$isGrace()) {
              flagShape.set$scaleX(0.6);
              flagShape.set$scaleY(0.6);
            }
            flagShape.set$x(0, this._bitmap_renderer$_noteGroup.get$stemHPos());
            t1 = this._bitmap_renderer$_noteGroup.get$stemDirection();
            t2 = this._bitmap_renderer$_noteGroup;
            if (t1 === "up")
              t1 = t2.get$stemEndPos();
            else {
              t1 = t2.get$stemEndPos();
              t2 = flagShape.get$boundsTransformed().height;
              if (typeof t2 !== "number")
                return H.iae(t2);
              t2 = t1 - t2;
              t1 = t2;
            }
            flagShape.set$y(0, t1);
            this.addChild$1(flagShape);
          }
        }
      },
      _addAttachments$0: function() {
        var lyric, t1, lyricTF, t2, t3, _i, artic, t4, t5, articBmp, rectangle;
        if (this._bitmap_renderer$_noteGroup.get$lyric() != null) {
          lyric = this._bitmap_renderer$_noteGroup.get$lyric();
          t1 = lyric._text;
          if (t1 != null && t1 !== "") {
            lyricTF = Y.TextField$(null, null);
            lyricTF._autoSize = "left";
            lyricTF._refreshPending |= 3;
            lyricTF._defaultTextFormat = new Y.TextFormat("arial", this._scoreProps._staffLineSpacing * 2, 0, 0, 4278190080, null, 400, false, false, false, "left", "top", 0, 0, 0, 0, 0, 0).clone$0(0);
            lyricTF._refreshPending |= 3;
            lyricTF.set$text(0, lyric._text);
            t1 = lyric._vPos;
            if (typeof t1 !== "number")
              return H.iae(t1);
            lyricTF._refreshTextLineMetrics$0();
            lyricTF.set$y(0, -1 * t1 - lyricTF._text$_height + 4);
            lyricTF._refreshTextLineMetrics$0();
            lyricTF.set$x(0, lyricTF._textWidth / -2 + this._scoreProps._noteheadWidth / 2);
            this.addChild$1(lyricTF);
            this._visualAttachments.push(lyricTF);
          }
        }
        if (this._bitmap_renderer$_noteGroup.get$articulations() != null)
          for (t1 = this._bitmap_renderer$_noteGroup.get$articulations(), t2 = t1.length, t3 = [A.BitmapFilter], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            artic = t1[_i];
            switch (artic.get$type(artic)) {
              case 0:
                t4 = $.MusicTextures_staccato;
                t5 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t5 + 1;
                articBmp = new A.Bitmap(t4, t5, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                break;
              case 1:
                t4 = $.MusicTextures_accent;
                t5 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t5 + 1;
                articBmp = new A.Bitmap(t4, t5, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                break;
              case 2:
                t4 = $.MusicTextures_legato;
                t5 = $.DisplayObject__nextID;
                $.DisplayObject__nextID = t5 + 1;
                articBmp = new A.Bitmap(t4, t5, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], t3), null, "", null, T.Matrix$fromIdentity(), true, null, null);
                break;
              default:
                continue;
            }
            t4 = artic.get$hPos();
            if (typeof t4 === "number")
              articBmp._x = t4;
            articBmp._transformationMatrixRefresh = true;
            if (artic.get$isAbove()) {
              t4 = artic.get$vPos();
              rectangle = articBmp.get$bounds();
              t4 = J.$sub$n(t4, articBmp.get$transformationMatrix().transformRectangle$2(rectangle, rectangle).height);
            } else
              t4 = artic.get$vPos();
            if (typeof t4 === "number")
              articBmp._y = t4;
            articBmp._transformationMatrixRefresh = true;
            this.addChild$1(articBmp);
            this._visualAttachments.push(articBmp);
          }
      },
      get$noteGroup: function() {
        return this._bitmap_renderer$_noteGroup;
      },
      get$vSystemRef: function() {
        return this._vSystemRef;
      },
      get$visualAttachments: function() {
        return this._visualAttachments;
      },
      get$scoreX: function() {
        var t1 = this._vSystemRef;
        return t1._x + t1._pageRef._x + this._x;
      },
      get$scoreY: function() {
        var t1 = this._vSystemRef;
        return t1._y + t1._pageRef._y + this._y;
      },
      get$originalPosition: function() {
        return this._originalPosition;
      }
    },
    VisualPage: {
      "^": "Sprite;_currentVSystemPos,_scoreProps,_visualSystems,_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      addSystem$1: function(visualSystem) {
        var t1, t2;
        visualSystem.set$x(0, this._scoreProps._leftPageMargin);
        visualSystem.set$y(0, this._currentVSystemPos);
        this.addChild$1(visualSystem);
        visualSystem.set$pageRef(this);
        t1 = this._currentVSystemPos;
        t2 = visualSystem.get$height(visualSystem);
        if (typeof t2 !== "number")
          return H.iae(t2);
        this._currentVSystemPos = t1 + (50 + t2);
        this._visualSystems.push(visualSystem);
      },
      get$visualSystems: function() {
        return this._visualSystems;
      }
    },
    VisualScore: {
      "^": "Sprite;_bitmap_renderer$_score,_scoreProps,_visualPages,_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      init$0: function() {
        this.set$scaleX(J.$div$n(this._scoreProps._mmHeight, 7.1967));
        this.set$scaleY(J.$div$n(this._scoreProps._mmHeight, 7.1967));
      },
      getVisualSystems$0: function() {
        var vSystems, t1, t2, _i, systems, t3, _i0;
        vSystems = [];
        for (t1 = this._visualPages, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          systems = t1[_i].get$visualSystems();
          for (t3 = systems.length, _i0 = 0; _i0 < systems.length; systems.length === t3 || (0, H.throwConcurrentModificationError)(systems), ++_i0)
            vSystems.push(systems[_i0]);
        }
        return vSystems;
      },
      getVisualNoteGroups$0: function() {
        var vNoteGroups, t1, t2, _i, systems, t3, _i0, noteGroups, t4, _i1;
        vNoteGroups = H.setRuntimeTypeInfo([], [D.VisualNoteGroup]);
        for (t1 = this._visualPages, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          systems = t1[_i].get$visualSystems();
          for (t3 = systems.length, _i0 = 0; _i0 < systems.length; systems.length === t3 || (0, H.throwConcurrentModificationError)(systems), ++_i0) {
            noteGroups = systems[_i0].get$visNoteGroups();
            for (t4 = noteGroups.length, _i1 = 0; _i1 < noteGroups.length; noteGroups.length === t4 || (0, H.throwConcurrentModificationError)(noteGroups), ++_i1)
              vNoteGroups.push(noteGroups[_i1]);
          }
        }
        return vNoteGroups;
      },
      getVisualSystemUnderPoint$1: function(point) {
        var vSystems, numSystems, i, visSystem, t1, t2, t3, t4;
        vSystems = this.getVisualSystems$0();
        numSystems = vSystems.length;
        for (i = 0; i < numSystems; ++i) {
          if (i >= vSystems.length)
            return H.ioore(vSystems, i);
          visSystem = vSystems[i];
          t1 = visSystem.get$scoreX();
          t2 = point.x;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (t1 <= t2) {
            t1 = visSystem.get$scoreX();
            t2 = J.getInterceptor$x(visSystem);
            t3 = t2.get$width(visSystem);
            if (typeof t3 !== "number")
              return H.iae(t3);
            t4 = point.x;
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (t1 + t3 > t4) {
              t1 = visSystem.get$scoreY();
              t3 = point.y;
              if (typeof t3 !== "number")
                return H.iae(t3);
              if (t1 <= t3) {
                t1 = visSystem.get$scoreY();
                t2 = t2.get$height(visSystem);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                t3 = point.y;
                if (typeof t3 !== "number")
                  return H.iae(t3);
                t3 = t1 + t2 > t3;
                t1 = t3;
              } else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
          if (t1)
            return visSystem;
        }
        return;
      }
    },
    VisualSystem: {
      "^": "Sprite;_visNoteGroups,_pageRef,_bitmap_renderer$_systemRef,_visualMeasures,_extraNoteheads,_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      getVisualMeasureUnderPoint$1: function(point) {
        var t1, numMeasures, i, visMeas, t2, t3;
        t1 = this._visualMeasures;
        numMeasures = t1.length;
        for (i = 0; i < numMeasures; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          visMeas = t1[i];
          if (J.$le$n(visMeas.x, point.x))
            if (J.$gt$n(J.$add$ns(visMeas.x, visMeas.width), point.x)) {
              t2 = visMeas.y;
              t3 = point.y;
              if (typeof t3 !== "number")
                return H.iae(t3);
              t2 = t2 <= t3 && t2 + visMeas.height > t3;
            } else
              t2 = false;
          else
            t2 = false;
          if (t2)
            return visMeas;
        }
        return;
      },
      cacheSystemGraphics$0: function() {
        var bounds, t1, t2, t3, t4, t5, t6;
        bounds = this.get$bounds();
        t1 = J.floor$0$n(bounds.left);
        t2 = J.floor$0$n(bounds.top);
        t3 = J.ceil$0$n(bounds.width);
        t4 = C.JSInt_methods.$mod($.VisualSystem__cacheWidthAddition, 100);
        t5 = J.ceil$0$n(bounds.height);
        t6 = this._cache;
        t6 = t6 != null ? t6 : new A._DisplayObjectCache(this, 1, true, new U.Rectangle0(0, 0, 256, 256, [P.num]), null, null);
        this._cache = t6;
        t6.debugBorder = false;
        t6.pixelRatio = 1;
        t6.bounds = new U.Rectangle0(t1, t2, t3 + t4, t5, [P.num]);
        t6.update$0(0);
        $.VisualSystem__cacheWidthAddition = $.VisualSystem__cacheWidthAddition + 1;
      },
      removeExtraNoteheads$0: function() {
        var t1, t2, _i, bmp;
        t1 = this._extraNoteheads;
        if (t1 == null)
          return false;
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          bmp = t1[_i];
          if (bmp.get$parent(bmp) === this)
            this.removeChild$1(bmp);
        }
        this._extraNoteheads = null;
        return true;
      },
      get$visNoteGroups: function() {
        return this._visNoteGroups;
      },
      get$pageRef: function() {
        return this._pageRef;
      },
      set$pageRef: function(value) {
        this._pageRef = value;
      },
      get$scoreX: function() {
        return this._x + this._pageRef._x;
      },
      get$scoreY: function() {
        return this._y + this._pageRef._y;
      },
      get$systemRef: function() {
        return this._bitmap_renderer$_systemRef;
      }
    }
  }], ["score_render.stagexl.textures", "package:score_render/src/stagexl/textures.dart",, G, {
    "^": "",
    MusicTextures_createTextures: function() {
      var resourceManager, t1;
      if ($.MusicTextures__texturesCreated)
        return;
      resourceManager = new O.ResourceManager(new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.String, O.ResourceManagerResource]), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [P.num]));
      resourceManager.addTextFile$2("infoString", H.S($.MusicTextures_pathPrefix) + "images/gonvilleSymbolsInfo.xml");
      t1 = H.S($.MusicTextures_pathPrefix) + "images/gonvilleconsol.svg";
      resourceManager._addResource$4("BitmapData", "symbolsBD", t1, A.BitmapData_load(t1, null));
      resourceManager.load$0(0).then$1(new G.MusicTextures_createTextures_closure(resourceManager));
    },
    MusicTextures_getBitmapData: function(id, infoXML, symbolsBD) {
      var t1, x, y, width, height, iXML, t2, bd, updateBatch, sourceQuad, renderState;
      for (t1 = new W._FrozenElementList(infoXML.querySelectorAll("symbol"), [null]), t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null), x = 0, y = 0, width = 0, height = 0; t1.moveNext$0();) {
        iXML = t1.__internal$_current;
        t2 = J.getInterceptor$x(iXML);
        if (t2.getAttribute$1(iXML, "id") === id) {
          x = J.floor$0$n(J.$mul$ns(P.num_parse(t2.getAttribute$1(iXML, "x"), null), $.MusicTextures__svgScale));
          y = J.floor$0$n(J.$mul$ns(P.num_parse(t2.getAttribute$1(iXML, "y"), null), $.MusicTextures__svgScale));
          width = J.ceil$0$n(J.$mul$ns(P.num_parse(t2.getAttribute$1(iXML, "width"), null), $.MusicTextures__svgScale));
          height = J.ceil$0$n(J.$mul$ns(P.num_parse(t2.getAttribute$1(iXML, "height"), null), $.MusicTextures__svgScale));
        }
      }
      bd = A.BitmapData_BitmapData(C.JSInt_methods.ceil$0(width), C.JSInt_methods.ceil$0(height), 0, 1);
      t1 = new U.Rectangle0(C.JSInt_methods.floor$0(x), C.JSInt_methods.floor$0(y), C.JSInt_methods.ceil$0(width), C.JSInt_methods.ceil$0(height), [P.int]);
      updateBatch = A.BitmapDataUpdateBatch$(bd);
      sourceQuad = symbolsBD.renderTextureQuad.cut$1(t1);
      t2 = updateBatch._renderContext;
      renderState = L.RenderState$(t2, updateBatch._drawMatrix, null, null);
      renderState._currentContextState.matrix.prependTranslation$2(0, 0);
      t2.setTransform$1(0, renderState._currentContextState.matrix);
      t2._renderingContext.clearRect(0, 0, t1.width, t1.height);
      t2.renderTextureQuad$2(renderState, sourceQuad);
      updateBatch.bitmapData.renderTextureQuad.renderTexture.update$0(0);
      return bd;
    },
    MusicTextures_getColoredNoteheadBD: function(noteheadType, color) {
      var t1, t2, _i, t3, cndo, t4, bd, value, t5, t6, t7, t8, t9;
      if (color === 0)
        switch (noteheadType) {
          case C.NoteheadType_2:
            return $.MusicTextures_wholeNoteHead;
          case C.NoteheadType_1:
            return $.MusicTextures_halfNoteHead;
          default:
            return $.MusicTextures_quarterNoteHead;
        }
      for (t1 = $.$get$MusicTextures__coloredNoteheadDOs(), t2 = t1.length, _i = 0; t3 = t1.length, _i < t3; t3 === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        cndo = t1[_i];
        t4 = cndo.type;
        if (t4 == null ? noteheadType == null : t4 === noteheadType)
          if (color === cndo.color)
            return cndo.bitmapData;
      }
      cndo = new G.ColoredNoteheadDO(noteheadType, color, null);
      switch (noteheadType) {
        case C.NoteheadType_2:
          bd = $.MusicTextures_wholeNoteHead.clone$0(0);
          break;
        case C.NoteheadType_1:
          bd = $.MusicTextures_halfNoteHead.clone$0(0);
          break;
        default:
          bd = $.MusicTextures_quarterNoteHead.clone$0(0);
      }
      t1 = new Float32Array(4);
      t2 = new Int32Array(4);
      t1[0] = 1;
      t1[1] = 1;
      t1[2] = 1;
      t1[3] = 1;
      t2[0] = 0;
      t2[1] = 0;
      t2[2] = 0;
      t2[3] = 0;
      value = V.ensureInt(color);
      t2[0] = (value & 16711680) >>> 16;
      t2[1] = (value & 65280) >>> 8;
      t2[2] = value & 255;
      t1[0] = 0;
      t1[1] = 0;
      t1[2] = 0;
      t3 = bd.renderTextureQuad;
      t4 = t3.renderTexture;
      t5 = t4.get$canvas(t4);
      t6 = T.Matrix$fromIdentity();
      t7 = J.get$context2D$x(t5);
      t8 = [L.RenderContextEvent];
      t9 = t6._data;
      t7.setTransform(t9[0], t9[1], t9[2], t9[3], t9[4], t9[5]);
      t7.globalCompositeOperation = "source-over";
      t7.globalAlpha = 1;
      new A.BitmapDataUpdateBatch(bd, new L.RenderContextCanvas(t5, t7, t6, C.BlendMode_bZz, 1, new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t8), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t8)), t3.get$drawMatrix()).colorTransform$2(new U.Rectangle0(0, 0, bd.width, bd.height, [P.num]), new A.ColorTransform(t1, t2));
      t4.update$0(0);
      cndo.bitmapData = bd;
      $.$get$MusicTextures__coloredNoteheadDOs().push(cndo);
      return bd;
    },
    MusicTextures_createTextures_closure: {
      "^": "Closure:0;resourceManager",
      call$1: [function(result) {
        var t1, infoString, value, infoXML;
        t1 = this.resourceManager;
        infoString = H.stringTypeCast(t1._getResourceValue$2("TextFile", "infoString"));
        value = t1._getResourceValue$2("BitmapData", "symbolsBD");
        if (!(value instanceof A.BitmapData))
          H.throwExpression("dart2js_hint");
        infoXML = new DOMParser().parseFromString(infoString, "text/xml").querySelector("symbols");
        $.MusicTextures__svgScale = P.num_parse(infoXML.getAttribute("scale"), null);
        $.MusicTextures_wholeRest = G.MusicTextures_getBitmapData("WholeRest", infoXML, value);
        $.MusicTextures_halfRest = G.MusicTextures_getBitmapData("HalfRest", infoXML, value);
        $.MusicTextures_quarterRest = G.MusicTextures_getBitmapData("QuarterRest", infoXML, value);
        $.MusicTextures_eighthRest = G.MusicTextures_getBitmapData("EighthRest", infoXML, value);
        $.MusicTextures_sixteenthRest = G.MusicTextures_getBitmapData("SixteenthRest", infoXML, value);
        $.MusicTextures_thirtySecondRest = G.MusicTextures_getBitmapData("ThirtySecondRest", infoXML, value);
        $.MusicTextures_sixtyFourthRest = G.MusicTextures_getBitmapData("SixtyFourthRest", infoXML, value);
        $.MusicTextures_wholeNoteHead = G.MusicTextures_getBitmapData("WholeNoteHead", infoXML, value);
        $.MusicTextures_halfNoteHead = G.MusicTextures_getBitmapData("HalfNoteHead", infoXML, value);
        $.MusicTextures_quarterNoteHead = G.MusicTextures_getBitmapData("QuarterNoteHead", infoXML, value);
        $.MusicTextures_sharp = G.MusicTextures_getBitmapData("Sharp", infoXML, value);
        $.MusicTextures_flat = G.MusicTextures_getBitmapData("Flat", infoXML, value);
        $.MusicTextures_natural = G.MusicTextures_getBitmapData("Natural", infoXML, value);
        $.MusicTextures_doubleSharp = G.MusicTextures_getBitmapData("DoubleSharp", infoXML, value);
        $.MusicTextures_doubleFlat = G.MusicTextures_getBitmapData("DoubleFlat", infoXML, value);
        $.MusicTextures_eighthFlagUp = G.MusicTextures_getBitmapData("EighthFlagUp", infoXML, value);
        $.MusicTextures_eighthFlagDown = G.MusicTextures_getBitmapData("EighthFlagDown", infoXML, value);
        $.MusicTextures_sixteenthFlagUp = G.MusicTextures_getBitmapData("SixteenthFlagUp", infoXML, value);
        $.MusicTextures_sixteenthFlagDown = G.MusicTextures_getBitmapData("SixteenthFlagDown", infoXML, value);
        $.MusicTextures_thirtySecondFlagUp = G.MusicTextures_getBitmapData("ThirtySecondFlagUp", infoXML, value);
        $.MusicTextures_thirtySecondFlagDown = G.MusicTextures_getBitmapData("ThirtySecondFlagDown", infoXML, value);
        $.MusicTextures_sixtyFourthFlagUp = G.MusicTextures_getBitmapData("SixtyFourthFlagUp", infoXML, value);
        $.MusicTextures_sixtyFourthFlagDown = G.MusicTextures_getBitmapData("SixtyFourthFlagDown", infoXML, value);
        $.MusicTextures_trebleClef = G.MusicTextures_getBitmapData("TrebleClef", infoXML, value);
        $.MusicTextures_bassClef = G.MusicTextures_getBitmapData("BassClef", infoXML, value);
        $.MusicTextures_altoClef = G.MusicTextures_getBitmapData("AltoClef", infoXML, value);
        $.MusicTextures_tenorClef = G.MusicTextures_getBitmapData("TenorClef", infoXML, value);
        $.MusicTextures_f = G.MusicTextures_getBitmapData("F", infoXML, value);
        $.MusicTextures_ff = G.MusicTextures_getBitmapData("FF", infoXML, value);
        $.MusicTextures_fff = G.MusicTextures_getBitmapData("FFF", infoXML, value);
        $.MusicTextures_p = G.MusicTextures_getBitmapData("P", infoXML, value);
        $.MusicTextures_pp = G.MusicTextures_getBitmapData("PP", infoXML, value);
        $.MusicTextures_ppp = G.MusicTextures_getBitmapData("PPP", infoXML, value);
        $.MusicTextures_mf = G.MusicTextures_getBitmapData("MF", infoXML, value);
        $.MusicTextures_mp = G.MusicTextures_getBitmapData("MP", infoXML, value);
        $.MusicTextures_augmentationDot = G.MusicTextures_getBitmapData("Staccato", infoXML, value);
        $.MusicTextures_accent = G.MusicTextures_getBitmapData("Accent", infoXML, value);
        $.MusicTextures_staccato = G.MusicTextures_getBitmapData("Staccato", infoXML, value);
        $.MusicTextures_legato = G.MusicTextures_getBitmapData("Legato", infoXML, value);
        $.MusicTextures__texturesCreated = true;
        t1 = $.MusicTextures_onCompleteFunction;
        if (t1 != null)
          t1.call$0();
      }, null, null, 2, 0, null, 7, "call"]
    },
    NoteheadType: {
      "^": "Object;index,_textures$_name",
      toString$0: function(_) {
        return this._textures$_name;
      }
    },
    ColoredNoteheadDO: {
      "^": "Object;type>,color,bitmapData"
    }
  }], ["sf2.audio", "package:sf2/src/audio.dart",, K, {
    "^": "",
    AudioBufferLoader: {
      "^": "Object;_context,_urlList,_callback,_bufferList,_loadCount,_request,_audioLoadProgressController,_progressListener",
      load$0: function(_) {
        var t1, t2, t3, t4, i, t5, t6;
        for (t1 = W.ProgressEvent, t2 = this.get$_onBufferLoaded(), t3 = this.get$_onProgress(), t4 = this._audioLoadProgressController, i = 0; i < 1; ++i) {
          t5 = this._urlList[i];
          if (!t4.get$_mayAddEvent())
            H.throwExpression(t4._addEventError$0());
          t4._sendData$1("downloading audio...");
          t6 = new XMLHttpRequest();
          this._request = t6;
          C.HttpRequest_methods.open$3$async(t6, "GET", t5, true);
          t5 = this._request;
          t5.responseType = "arraybuffer";
          t5.toString;
          W._EventStreamSubscription$(t5, "load", t2, false, t1);
          t5 = this._request;
          t5.toString;
          this._progressListener = W._EventStreamSubscription$(t5, "progress", t3, false, t1);
          this._request.send();
        }
      },
      _onProgress$1: [function(e) {
        var t1, t2, t3;
        t1 = this._audioLoadProgressController;
        t2 = J.getInterceptor$x(e);
        t3 = t2.get$loaded(e);
        if (typeof t3 !== "number")
          return H.iae(t3);
        t2 = t2.get$total(e);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = "audio download " + C.JSDouble_methods.toStringAsFixed$1(100 * t3 / t2, 1) + "% complete...";
        if (!t1.get$_mayAddEvent())
          H.throwExpression(t1._addEventError$0());
        t1._sendData$1(t2);
      }, "call$1", "get$_onProgress", 2, 0, 79],
      _onBufferLoaded$1: [function(e) {
        var t1;
        this._progressListener.cancel$0(0);
        t1 = this._audioLoadProgressController;
        if (!t1.get$_mayAddEvent())
          H.throwExpression(t1._addEventError$0());
        t1._sendData$1("audio downloaded... extracting...");
        J.decodeAudioData$1$x(this._context, W._convertNativeToDart_XHR_Response(this._request.response)).then$1(new K.AudioBufferLoader__onBufferLoaded_closure(this)).catchError$1(new K.AudioBufferLoader__onBufferLoaded_closure0());
      }, "call$1", "get$_onBufferLoaded", 2, 0, 14]
    },
    AudioBufferLoader__onBufferLoaded_closure: {
      "^": "Closure:54;$this",
      call$1: [function(buffer) {
        var t1, t2;
        t1 = this.$this;
        t1._bufferList.push(buffer);
        if (++t1._loadCount === 1) {
          t2 = t1._bufferList;
          t1._callback.call$1(t2);
          t1._bufferList = null;
        }
      }, null, null, 2, 0, null, 40, "call"]
    },
    AudioBufferLoader__onBufferLoaded_closure0: {
      "^": "Closure:0;",
      call$1: [function(e) {
        P.print(e);
      }, null, null, 2, 0, null, 0, "call"]
    }
  }], ["sf2.sf", "package:sf2/src/sf.dart",, L, {
    "^": "",
    Instrument: {
      "^": "Object;name>,zones"
    },
    PerformanceNoteDO: {
      "^": "Object;sampleStartTime<,sampleEndTime<,audioBuffer<,sfAudioStartPos,sfAudioEndPos,position,sampleRate>,sampleDebt,loopStartPos<,loopEndPos<,leftVolume,rightVolume,fadeInSamples,fadeOutSamples,loop>,totalTimePlayed,attackStartTime,holdStartTime,decayStartTime<,decayEndTime<,sustainVolReduction<,preReleaseVol,releaseStartTime,amplitude<,pan*",
      static: {
        PerformanceNoteDO_createPerformanceNote: function(midiNote, startTime, duration, amplitude, pan, preset) {
          var zoneFound, t1, t2, presetZone, _i, instZone, sample, pNoteDO, t3, sampleRootPitch;
          t1 = preset.zones;
          t2 = t1.length;
          presetZone = null;
          _i = 0;
          while (true) {
            if (!(_i < t1.length)) {
              zoneFound = false;
              break;
            }
            presetZone = t1[_i];
            if (J.$le$n(presetZone.bottomNote, midiNote) && J.$ge$n(presetZone.topNote, midiNote) && presetZone.instrument != null) {
              zoneFound = true;
              break;
            }
            t1.length === t2 || (0, H.throwConcurrentModificationError)(t1);
            ++_i;
          }
          if (!zoneFound)
            return;
          t1 = presetZone.instrument.zones;
          t2 = t1.length;
          instZone = null;
          _i = 0;
          while (true) {
            if (!(_i < t1.length)) {
              zoneFound = false;
              break;
            }
            instZone = t1[_i];
            if (J.$le$n(instZone.bottomNote, midiNote) && J.$ge$n(instZone.topNote, midiNote) && instZone.sample != null) {
              zoneFound = true;
              break;
            }
            t1.length === t2 || (0, H.throwConcurrentModificationError)(t1);
            ++_i;
          }
          if (!zoneFound)
            return;
          sample = instZone.sample;
          pNoteDO = new L.PerformanceNoteDO(0, 0, null, 0, 0, 0, 44100, 0, 0, 0, 0, 0, 0, 0, false, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.5);
          pNoteDO.sampleStartTime = startTime;
          t1 = startTime + duration;
          pNoteDO.sampleEndTime = t1;
          pNoteDO.audioBuffer = sample.get$audioBuffer();
          t2 = J.getInterceptor$x(sample);
          t3 = t2.get$start(sample);
          pNoteDO.sfAudioStartPos = t3;
          pNoteDO.sfAudioEndPos = t2.get$end(sample);
          pNoteDO.position = t3;
          sampleRootPitch = sample.get$originalPitch();
          if (J.$gt$n(presetZone.overridingRootKey, 0))
            sampleRootPitch = presetZone.overridingRootKey;
          else if (J.$gt$n(instZone.overridingRootKey, 0))
            sampleRootPitch = instZone.overridingRootKey;
          pNoteDO.sampleRate = J.toInt$0$n(J.$mul$ns(t2.get$sampleRate(sample), Math.pow(2, J.$div$n(J.$sub$n(J.$add$ns(J.$add$ns(J.$add$ns(J.$add$ns(midiNote, instZone.fineTune), presetZone.fineTune), instZone.courseTune), presetZone.courseTune), sampleRootPitch), 12))));
          if (instZone.loop) {
            pNoteDO.loopStartPos = J.$add$ns(J.$add$ns(instZone.startLoopAddrsOffset, presetZone.startLoopAddrsOffset), t2.get$loopStart(sample));
            pNoteDO.loopEndPos = J.$add$ns(J.$add$ns(instZone.endLoopAddrsOffset, presetZone.endLoopAddrsOffset), t2.get$loopEnd(sample));
          }
          pNoteDO.loop = instZone.loop;
          t2 = J.$add$ns(instZone.delayVolEnvTime, presetZone.delayVolEnvTime);
          pNoteDO.attackStartTime = t2;
          t2 = J.$add$ns(J.$add$ns(t2, instZone.attackVolEnvTime), presetZone.attackVolEnvTime);
          pNoteDO.holdStartTime = t2;
          t2 = J.$add$ns(J.$add$ns(t2, instZone.holdVolEnvTime), presetZone.holdVolEnvTime);
          pNoteDO.decayStartTime = t2;
          pNoteDO.decayEndTime = J.$add$ns(J.$add$ns(t2, instZone.decayVolEnvTime), presetZone.decayVolEnvTime);
          pNoteDO.sustainVolReduction = J.$add$ns(instZone.sustainVolReduction, presetZone.sustainVolReduction);
          pNoteDO.releaseStartTime = duration;
          t2 = J.$add$ns(instZone.releaseVolEnvTime, presetZone.releaseVolEnvTime);
          if (typeof t2 !== "number")
            return H.iae(t2);
          pNoteDO.sampleEndTime = t1 + t2;
          t2 = 2 * amplitude;
          if (typeof pan !== "number")
            return H.iae(pan);
          t1 = t2 * (1 - pan);
          pNoteDO.leftVolume = t1;
          t2 *= pan;
          pNoteDO.rightVolume = t2;
          if (t1 > 1)
            pNoteDO.leftVolume = 1;
          if (t2 > 1)
            pNoteDO.rightVolume = 1;
          pNoteDO.amplitude = amplitude;
          pNoteDO.pan = pan;
          return pNoteDO;
        }
      }
    },
    Preset: {
      "^": "Object;name>,presetNumber,bankNumber,zones"
    },
    SFLoader: {
      "^": "Object;_sfReadyCallback,_numLoadedFiles,_sfJson,_sfBuffer,_bufferLoader,_samples,_presets,_audioLoadProgressListener,_progressController",
      getPreset$2: function(preset, bank) {
        var numPresets, i, t1;
        numPresets = this._presets.length;
        for (i = 0; i < numPresets; ++i) {
          t1 = this._presets;
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (J.$eq$(t1[i].presetNumber, preset)) {
            t1 = this._presets;
            if (i >= t1.length)
              return H.ioore(t1, i);
            if (J.$eq$(t1[i].bankNumber, bank)) {
              t1 = this._presets;
              if (i >= t1.length)
                return H.ioore(t1, i);
              return t1[i];
            }
          }
        }
        return;
      },
      _loadJsonFile$1: function(jsonFileUrl) {
        W.HttpRequest_getString(jsonFileUrl, null, null).then$1(new L.SFLoader__loadJsonFile_closure(this));
      },
      _onAudioLoadProgress$1: [function(text) {
        var t1 = this._progressController;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(0, text);
      }, "call$1", "get$_onAudioLoadProgress", 2, 0, 27, 18],
      _onSFLoaded$1: [function(bufferList) {
        var t1;
        if (0 >= bufferList.length)
          return H.ioore(bufferList, 0);
        this._sfBuffer = bufferList[0];
        this._audioLoadProgressListener.cancel$0(0);
        t1 = this._numLoadedFiles;
        if (typeof t1 !== "number")
          return t1.$add();
        ++t1;
        this._numLoadedFiles = t1;
        if (t1 === 2)
          this._processFiles$0();
      }, "call$1", "get$_onSFLoaded", 2, 0, 55],
      _processFiles$0: function() {
        var t1 = this._progressController;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(0, "Creating audio samples...");
        this._createSampleObjects$0();
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(0, "Creating instrument presets...");
        this._createPresets$0();
        this._sfBuffer = null;
        this._sfJson = null;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(0, "SoundFont Ready");
        this._sfReadyCallback.call$0();
      },
      _createSampleObjects$0: function() {
        var sfAudioData, t1, sampleRateConv, sampleMap, sample, t2, sampleStartIndex, t3, buffer, bufferAudioData, i;
        this._samples = [];
        sfAudioData = J.getChannelData$1$x(this._sfBuffer, 0);
        t1 = $.SFPlayer__context.sampleRate;
        if (typeof t1 !== "number")
          return t1.$div();
        sampleRateConv = t1 / 44100;
        P.print("sampleRateConv: " + C.JSDouble_methods.toString$0(sampleRateConv));
        for (t1 = J.get$iterator$ax(J.$index$asx(J.$index$asx(J.$index$asx(this._sfJson, "sfData"), "samples"), "sample")); t1.moveNext$0();) {
          sampleMap = t1.get$current();
          sample = new L.Sample(null, null, null, null, null, null, null, null, null, null, null, null);
          t2 = J.getInterceptor$asx(sampleMap);
          sample.id = H.Primitives_parseInt(t2.$index(sampleMap, "id"), null, null);
          sample.name = t2.$index(sampleMap, "name");
          sampleStartIndex = J.toInt$0$n(J.$mul$ns(H.Primitives_parseInt(t2.$index(sampleMap, "start"), null, null), sampleRateConv));
          sample.start = sampleStartIndex;
          t3 = J.toInt$0$n(J.$mul$ns(H.Primitives_parseInt(t2.$index(sampleMap, "end"), null, null), sampleRateConv));
          sample.end = t3;
          sample.loopStart = J.toInt$0$n(J.$mul$ns(H.Primitives_parseInt(t2.$index(sampleMap, "loopStart"), null, null), sampleRateConv));
          sample.loopEnd = J.toInt$0$n(J.$mul$ns(H.Primitives_parseInt(t2.$index(sampleMap, "loopEnd"), null, null), sampleRateConv));
          sample.sampleRate = H.Primitives_parseInt(t2.$index(sampleMap, "sampleRate"), null, null);
          sample.originalPitch = H.Primitives_parseInt(t2.$index(sampleMap, "originalPitch"), null, null);
          sample.pitchCorrection = H.Primitives_parseInt(t2.$index(sampleMap, "pitchCorrection"), null, null);
          sample.sampleLink = H.Primitives_parseInt(t2.$index(sampleMap, "sampleLink"), null, null);
          sample.sampleType = H.Primitives_parseInt(t2.$index(sampleMap, "sampleType"), null, null);
          t2 = $.SFPlayer__context;
          buffer = t2.createBuffer(1, t3 - sampleStartIndex, t2.sampleRate);
          bufferAudioData = buffer.getChannelData(0);
          for (t2 = bufferAudioData.length, i = 0; i < t2; ++i) {
            t3 = i + sampleStartIndex;
            if (t3 < 0 || t3 >= sfAudioData.length)
              return H.ioore(sfAudioData, t3);
            bufferAudioData[i] = sfAudioData[t3];
          }
          sample.audioBuffer = buffer;
          if (J.$eq$(sample.id, 47))
            H.printString(C.JSString_methods.$add("start: " + J.toString$0$(sample.start) + " end: " + J.toString$0$(sample.end) + " loopStart: " + J.toString$0$(sample.loopStart) + " loopEnd: " + J.toString$0$(sample.loopEnd) + " sRate: ", J.toString$0$(sample.sampleRate)));
          t2 = sample.loopEnd;
          t3 = sample.start;
          if (typeof t2 !== "number")
            return t2.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          sample.loopEnd = t2 - t3;
          t2 = sample.loopStart;
          if (typeof t2 !== "number")
            return t2.$sub();
          sample.loopStart = t2 - t3;
          t2 = sample.end;
          if (typeof t2 !== "number")
            return t2.$sub();
          sample.end = t2 - t3;
          sample.start = 0;
          this._samples.push(sample);
        }
      },
      _createPresets$0: function() {
        var t1, t2, pMap, t3, preset, t4, t5, pzMap, pzone, iMap, inst, t6, t7, izMap, izone, t8, it;
        this._presets = [];
        for (t1 = J.get$iterator$ax(J.$index$asx(J.$index$asx(J.$index$asx(this._sfJson, "sfData"), "presets"), "preset")), t2 = [P.Map]; t1.moveNext$0();) {
          pMap = t1.get$current();
          t3 = [];
          preset = new L.Preset(null, null, null, t3);
          this._presets.push(preset);
          t4 = J.getInterceptor$asx(pMap);
          preset.name = t4.$index(pMap, "name");
          preset.presetNumber = H.Primitives_parseInt(t4.$index(pMap, "presetNumber"), null, null);
          preset.bankNumber = H.Primitives_parseInt(t4.$index(pMap, "bankNumber"), null, null);
          if (J.$eq$(preset.presetNumber, 0) && J.$eq$(preset.bankNumber, 0))
            H.printString("preset 0 bank 0");
          t5 = J.$index$asx(t4.$index(pMap, "zones"), "zone");
          for (t4 = J.get$iterator$ax(H.checkSubtype(t5, "$isList", t2, "$asList") ? J.$index$asx(t4.$index(pMap, "zones"), "zone") : [J.$index$asx(t4.$index(pMap, "zones"), "zone")]); t4.moveNext$0();) {
            pzMap = t4.get$current();
            pzone = new L.Zone(null, 0, 0, 0, 127, null, 0, 0, -1, false, 43, 43, 43, 43, 0, 43, false);
            t3.push(pzone);
            t5 = J.getInterceptor$asx(pzMap);
            pzone.startLoopAddrsOffset = H.Primitives_parseInt(t5.$index(pzMap, "startLoopAddrsOffset"), null, null);
            pzone.endLoopAddrsOffset = H.Primitives_parseInt(t5.$index(pzMap, "endLoopAddrsOffset"), null, null);
            pzone.bottomNote = H.Primitives_parseInt(t5.$index(pzMap, "bottomNote"), null, null);
            pzone.topNote = H.Primitives_parseInt(t5.$index(pzMap, "topNote"), null, null);
            pzone.fineTune = P.num_parse(t5.$index(pzMap, "fineTune"), null);
            pzone.courseTune = H.Primitives_parseInt(t5.$index(pzMap, "courseTune"), null, null);
            pzone.overridingRootKey = H.Primitives_parseInt(t5.$index(pzMap, "overridingRootKey"), null, null);
            pzone.loop = J.$eq$(t5.$index(pzMap, "loop"), "true");
            pzone.delayVolEnvTime = H.Primitives_parseInt(t5.$index(pzMap, "delayVolEnvTime"), null, null);
            pzone.attackVolEnvTime = H.Primitives_parseInt(t5.$index(pzMap, "attackVolEnvTime"), null, null);
            pzone.holdVolEnvTime = H.Primitives_parseInt(t5.$index(pzMap, "holdVolEnvTime"), null, null);
            pzone.decayVolEnvTime = H.Primitives_parseInt(t5.$index(pzMap, "decayVolEnvTime"), null, null);
            pzone.sustainVolReduction = P.num_parse(t5.$index(pzMap, "sustainVolReduction"), null);
            pzone.releaseVolEnvTime = H.Primitives_parseInt(t5.$index(pzMap, "releaseVolEnvTime"), null, null);
            pzone.isGlobal = J.$eq$(t5.$index(pzMap, "isGlobal"), "true");
            if (t5.$index(pzMap, "instrument") != null && J.$index$asx(t5.$index(pzMap, "instrument"), "name") != null) {
              iMap = t5.$index(pzMap, "instrument");
              t5 = [];
              inst = new L.Instrument("", t5);
              pzone.instrument = inst;
              t6 = J.getInterceptor$asx(iMap);
              inst.name = t6.$index(iMap, "name");
              t7 = J.$index$asx(t6.$index(iMap, "zones"), "zone");
              for (t6 = J.get$iterator$ax(H.checkSubtype(t7, "$isList", t2, "$asList") ? J.$index$asx(t6.$index(iMap, "zones"), "zone") : [J.$index$asx(t6.$index(iMap, "zones"), "zone")]); t6.moveNext$0();) {
                izMap = t6.get$current();
                izone = new L.Zone(null, 0, 0, 0, 127, null, 0, 0, -1, false, 43, 43, 43, 43, 0, 43, false);
                t5.push(izone);
                t7 = J.getInterceptor$asx(izMap);
                izone.startLoopAddrsOffset = H.Primitives_parseInt(t7.$index(izMap, "startLoopAddrsOffset"), null, null);
                izone.endLoopAddrsOffset = H.Primitives_parseInt(t7.$index(izMap, "endLoopAddrsOffset"), null, null);
                izone.bottomNote = H.Primitives_parseInt(t7.$index(izMap, "bottomNote"), null, null);
                izone.topNote = H.Primitives_parseInt(t7.$index(izMap, "topNote"), null, null);
                if (t7.$index(izMap, "sample") != null) {
                  t8 = this._samples;
                  t8.toString;
                  t8 = new H.WhereIterable(t8, new L.SFLoader__createPresets_closure(izMap), [H.getTypeArgumentByIndex(t8, 0)]);
                  it = t8.get$iterator(t8);
                  if (!it.moveNext$0())
                    H.throwExpression(H.IterableElementError_noElement());
                  izone.sample = it.get$current();
                }
                izone.fineTune = P.num_parse(t7.$index(izMap, "fineTune"), null);
                izone.courseTune = H.Primitives_parseInt(t7.$index(izMap, "courseTune"), null, null);
                izone.overridingRootKey = H.Primitives_parseInt(t7.$index(izMap, "overridingRootKey"), null, null);
                izone.loop = J.$eq$(t7.$index(izMap, "loop"), "true");
                izone.delayVolEnvTime = H.Primitives_parseInt(t7.$index(izMap, "delayVolEnvTime"), null, null);
                izone.attackVolEnvTime = H.Primitives_parseInt(t7.$index(izMap, "attackVolEnvTime"), null, null);
                izone.holdVolEnvTime = H.Primitives_parseInt(t7.$index(izMap, "holdVolEnvTime"), null, null);
                izone.decayVolEnvTime = H.Primitives_parseInt(t7.$index(izMap, "decayVolEnvTime"), null, null);
                izone.sustainVolReduction = P.num_parse(t7.$index(izMap, "sustainVolReduction"), null);
                izone.releaseVolEnvTime = H.Primitives_parseInt(t7.$index(izMap, "releaseVolEnvTime"), null, null);
                izone.isGlobal = J.$eq$(t7.$index(izMap, "isGlobal"), "true");
              }
            }
          }
        }
      }
    },
    SFLoader__loadJsonFile_closure: {
      "^": "Closure:0;$this",
      call$1: [function(jsonString) {
        var t1, t2;
        t1 = this.$this;
        t1._sfJson = C.JsonCodec_null_null.decode$1(jsonString);
        t2 = t1._numLoadedFiles;
        if (typeof t2 !== "number")
          return t2.$add();
        ++t2;
        t1._numLoadedFiles = t2;
        if (t2 === 2)
          t1._processFiles$0();
      }, null, null, 2, 0, null, 42, "call"]
    },
    SFLoader__createPresets_closure: {
      "^": "Closure:0;izMap",
      call$1: function(s) {
        return J.$eq$(J.get$id$x(s), H.Primitives_parseInt(J.$index$asx(this.izMap, "sample"), null, null));
      }
    },
    SFPlayer: {
      "^": "Object;_pNoteDOs,_unplayedNotes,_firstProcessTime,_processTimer,_playbackCompleteTimer,_isPlaying,_sf$_playbackCompleteCallback,SAMPLE_RATE,_noteNodes",
      play$1: function(_, playbackCompleteCallback) {
        var t1, bs;
        if (this._isPlaying)
          return;
        t1 = this._pNoteDOs;
        this._unplayedNotes = (t1 && C.JSArray_methods).sublist$1(t1, 0);
        this._sf$_playbackCompleteCallback = playbackCompleteCallback;
        this._firstProcessTime = -1;
        this._isPlaying = true;
        this._processTimer = P.Timer_Timer$periodic(C.Duration_500000, this.get$_onAudioProcess());
        this._onAudioProcess$1(null);
        bs = $.SFPlayer__context.createBufferSource();
        t1 = $.SFPlayer__context;
        bs.buffer = t1.createBuffer(1, 1024, t1.sampleRate);
        (bs && C.AudioBufferSourceNode_methods).start$1(bs, $.SFPlayer__context.currentTime);
      },
      stop$0: function(_) {
        var t1, t2, _i;
        if (this._isPlaying) {
          t1 = this._processTimer;
          if (t1 != null) {
            if (t1._handle != null)
              t1.cancel$0(0);
            this._processTimer = null;
          }
          t1 = this._playbackCompleteTimer;
          if (t1 != null) {
            if (t1._handle != null)
              t1.cancel$0(0);
            this._playbackCompleteTimer = null;
          }
          this._isPlaying = false;
          for (t1 = this._noteNodes, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
            t1[_i].disconnectNodes$0();
          this._noteNodes = [];
        }
      },
      _onAudioProcess$1: [function(timer) {
        var currentTime, t1, currentSamplePos, t2, activePNotes, _i, note, t3, t4, noteContextTime, duration, bs, gainNode, finalGainNode, sampleRateFac;
        currentTime = $.SFPlayer__context.currentTime;
        t1 = this._firstProcessTime;
        if (t1 === -1) {
          this._firstProcessTime = currentTime;
          t1 = currentTime;
        }
        if (typeof currentTime !== "number")
          return currentTime.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        currentSamplePos = (currentTime - t1) * 44100;
        while (true) {
          t1 = this._noteNodes;
          t2 = t1.length;
          if (!(t2 > 0 && t1[0].endContextTime < currentTime))
            break;
          if (0 >= t2)
            return H.ioore(t1, 0);
          t1 = t1[0];
          t1.bufferSourceNode.disconnect(0);
          t1.gainNode.disconnect(0);
          t1.finalGainNode.disconnect(0);
          C.JSArray_methods.removeAt$1(this._noteNodes, 0);
        }
        activePNotes = [];
        t1 = currentSamplePos + 44100;
        while (true) {
          t2 = this._unplayedNotes;
          if (!(t2.length > 0 && t2[0].get$sampleStartTime() <= t1))
            break;
          t2 = this._unplayedNotes;
          activePNotes.push((t2 && C.JSArray_methods).removeAt$1(t2, 0));
        }
        t1 = activePNotes.length;
        if (t1 === 0) {
          if (this._unplayedNotes.length === 0) {
            this._processTimer.cancel$0(0);
            t1 = this._pNoteDOs;
            this._playbackCompleteTimer = P.Timer_Timer(P.Duration$(0, 0, 0, C.JSNumber_methods.$tdiv((t1 && C.JSArray_methods).get$last(t1).sampleEndTime - currentSamplePos, 44.1), 0, 0), new L.SFPlayer__onAudioProcess_closure(this));
          }
          return;
        }
        for (t2 = this.SAMPLE_RATE, _i = 0; _i < activePNotes.length; activePNotes.length === t1 || (0, H.throwConcurrentModificationError)(activePNotes), ++_i) {
          note = activePNotes[_i];
          t3 = note.get$sampleStartTime();
          t4 = this._firstProcessTime;
          if (typeof t4 !== "number")
            return H.iae(t4);
          noteContextTime = t3 / t2 - (currentTime - t4) + currentTime;
          duration = (note.get$sampleEndTime() - note.get$sampleStartTime()) / 44100;
          bs = $.SFPlayer__context.createBufferSource();
          bs.buffer = note.get$audioBuffer();
          gainNode = J.createGain$0$x($.SFPlayer__context);
          gainNode.gain.setValueAtTime(1, noteContextTime);
          gainNode.gain.setValueAtTime(1, noteContextTime + J.$div$n(note.get$decayStartTime(), 44100));
          t4 = gainNode.gain;
          t3 = note.get$sustainVolReduction();
          if (typeof t3 !== "number")
            return H.iae(t3);
          t4.linearRampToValueAtTime(1 - t3, noteContextTime + J.$div$n(note.get$decayEndTime(), 44100));
          t3 = noteContextTime + duration;
          gainNode.gain.linearRampToValueAtTime(0, t3);
          finalGainNode = J.createGain$0$x($.SFPlayer__context);
          finalGainNode.gain.value = note.get$amplitude();
          finalGainNode.connect($.SFPlayer__context.destination, 0, 0);
          gainNode.connect(finalGainNode, 0, 0);
          bs.connect(gainNode, 0, 0);
          t4 = J.getInterceptor$x(note);
          sampleRateFac = J.$div$n(t4.get$sampleRate(note), 44100);
          bs.playbackRate.value = sampleRateFac;
          if (t4.get$loop(note) === true) {
            bs.loopStart = J.$div$n(note.get$loopStartPos(), $.SFPlayer__context.sampleRate);
            bs.loopEnd = J.$div$n(note.get$loopEndPos(), $.SFPlayer__context.sampleRate);
            bs.loop = true;
          }
          C.AudioBufferSourceNode_methods.start$3(bs, noteContextTime, 0, duration);
          if (!!bs.stop)
            bs.stop(t3);
          else
            bs.noteOff(t3);
          this._noteNodes.push(new L.NoteNodes(t3, bs, gainNode, finalGainNode));
        }
      }, "call$1", "get$_onAudioProcess", 2, 0, 56]
    },
    SFPlayer__onAudioProcess_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1 = this.$this;
        t1.stop$0(0);
        t1 = t1._sf$_playbackCompleteCallback;
        if (t1 != null)
          t1.call$0();
      }
    },
    NoteNodes: {
      "^": "Object;endContextTime,bufferSourceNode,gainNode,finalGainNode",
      disconnectNodes$0: function() {
        this.bufferSourceNode.disconnect(0);
        this.gainNode.disconnect(0);
        this.finalGainNode.disconnect(0);
      }
    },
    Sample: {
      "^": "Object;id>,name>,start>,end>,loopStart>,loopEnd>,sampleRate>,originalPitch<,pitchCorrection,sampleLink,sampleType,audioBuffer<"
    },
    SequenceBuilder: {
      "^": "Object;_preset,_sequence",
      get$sequence: function() {
        var t1 = this._sequence;
        (t1 && C.JSArray_methods).sort$1(t1, new L.SequenceBuilder_sequence_closure());
        return this._sequence;
      }
    },
    SequenceBuilder_sequence_closure: {
      "^": "Closure:3;",
      call$2: function(pn1, pn2) {
        return pn1.get$sampleStartTime() <= pn2.get$sampleStartTime() ? -1 : 1;
      }
    },
    Zone: {
      "^": "Object;instrument,startLoopAddrsOffset,endLoopAddrsOffset,bottomNote,topNote,sample,fineTune,courseTune,overridingRootKey,loop>,delayVolEnvTime,attackVolEnvTime,holdVolEnvTime,decayVolEnvTime,sustainVolReduction<,releaseVolEnvTime,isGlobal"
    }
  }], ["stagexl.animation", "package:stagexl/src/animation.dart",, K, {
    "^": "",
    Transition_linear: [function(ratio) {
      return ratio;
    }, "call$1", "animation_Transition_linear$closure", 2, 0, 13],
    Transition_easeOutQuadratic: [function(ratio) {
      ratio = 1 - ratio;
      return 1 - ratio * ratio;
    }, "call$1", "animation_Transition_easeOutQuadratic$closure", 2, 0, 13],
    Transition_easeOutCubic: [function(ratio) {
      ratio = 1 - ratio;
      return 1 - ratio * ratio * ratio;
    }, "call$1", "animation_Transition_easeOutCubic$closure", 2, 0, 13],
    _AnimatableLink: {
      "^": "Object;animatable,nextAnimatableLink"
    },
    Juggler: {
      "^": "Object;_firstAnimatableLink,_lastAnimatableLink,_elapsedTime,_elapsedTimeChangedEvent",
      add$1: function(_, animatable) {
        var animatableLink, t1;
        if (!J.getInterceptor(animatable).$isAnimatable)
          throw H.wrapException(P.ArgumentError$("The supplied animatable does not extend type Animatable."));
        if (!this.contains$1(0, animatable)) {
          animatableLink = new K._AnimatableLink(null, null);
          t1 = this._lastAnimatableLink;
          t1.animatable = animatable;
          t1.nextAnimatableLink = animatableLink;
          this._lastAnimatableLink = animatableLink;
        }
      },
      contains$1: function(_, animatable) {
        var link, t1;
        link = this._firstAnimatableLink;
        for (t1 = this._lastAnimatableLink; link == null ? t1 != null : link !== t1;) {
          if (link.animatable === animatable)
            return true;
          link = link.nextAnimatableLink;
        }
        return false;
      },
      advanceTime$1: function(time) {
        var t1, t2, link, lastLink, animatable, nextLink;
        t1 = this._elapsedTime += time;
        t2 = this._elapsedTimeChangedEvent;
        if (!t2.get$_mayAddEvent())
          H.throwExpression(t2._addEventError$0());
        t2._sendData$1(t1);
        link = this._firstAnimatableLink;
        lastLink = this._lastAnimatableLink;
        for (; link == null ? lastLink != null : link !== lastLink;) {
          animatable = link.animatable;
          if (animatable == null) {
            nextLink = link.nextAnimatableLink;
            link.animatable = nextLink.animatable;
            link.nextAnimatableLink = nextLink.nextAnimatableLink;
            if (nextLink == null ? lastLink == null : nextLink === lastLink)
              lastLink = link;
            t1 = this._lastAnimatableLink;
            if (nextLink == null ? t1 == null : nextLink === t1)
              this._lastAnimatableLink = link;
          } else if (!animatable.advanceTime$1(time))
            link.animatable = null;
          else
            link = link.nextAnimatableLink;
        }
        return true;
      },
      $isAnimatable: 1
    },
    Tween: {
      "^": "Object;_tweenObject,_transition,_tweenPropertyList,_onStart,_onUpdate,_onComplete,_totalTime,_currentTime,_delay,_roundToInt,_started",
      get$animate: function(_) {
        var tweenObject = this._tweenObject;
        if (!!J.getInterceptor(tweenObject).$isTweenObject2D)
          return new K.TweenPropertyAccessor2D(this, tweenObject);
        else
          throw H.wrapException(new P.StateError("Invalid tween object for 2D animation."));
      },
      _createTweenProperty$2: function(accessor, propertyID) {
        var tweenProperty = new K.TweenProperty(accessor, propertyID, 0 / 0, 0 / 0, 0 / 0);
        if (!this._started)
          this._tweenPropertyList.push(tweenProperty);
        return tweenProperty;
      },
      advanceTime$1: function(time) {
        var t1, t2, i, transition, t3, value;
        t1 = this._currentTime;
        t2 = this._totalTime;
        if (t1 < t2 || !this._started) {
          t1 += time;
          this._currentTime = t1;
          if (t1 > t2) {
            this._currentTime = t2;
            t1 = t2;
          }
          if (t1 >= 0) {
            if (!this._started) {
              this._started = true;
              for (t1 = this._tweenPropertyList, i = 0; i < t1.length; ++i) {
                t2 = t1[i];
                t2._startValue = t2._tweenPropertyAccessor._getValue$1(t2._propertyID);
                if (isNaN(t2._deltaValue) && isFinite(t2._targetValue))
                  t2._deltaValue = t2._targetValue - t2._startValue;
                if (isNaN(t2._targetValue) && isFinite(t2._deltaValue))
                  t2._targetValue = t2._startValue + t2._deltaValue;
              }
            }
            transition = J.toDouble$0$n(this._transition.call$1(this._currentTime / this._totalTime));
            for (t1 = this._tweenPropertyList, i = 0; i < t1.length; ++i) {
              t2 = t1[i];
              if (isFinite(t2._startValue) && isFinite(t2._targetValue)) {
                t3 = t2._startValue;
                value = t3 + transition * (t2._targetValue - t3);
                t3 = t2._tweenPropertyAccessor;
                switch (t2._propertyID) {
                  case 0:
                    t2 = t3._tweenObject;
                    t2._x = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 1:
                    t2 = t3._tweenObject;
                    t2._y = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 2:
                    t2 = t3._tweenObject;
                    t2._pivotX = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 3:
                    t2 = t3._tweenObject;
                    t2._pivotY = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 4:
                    t2 = t3._tweenObject;
                    t2._scaleX = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 5:
                    t2 = t3._tweenObject;
                    t2._scaleY = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 6:
                    t2 = t3._tweenObject;
                    t2._skewX = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 7:
                    t2 = t3._tweenObject;
                    t2._skewY = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 8:
                    t2 = t3._tweenObject;
                    t2._rotation = value;
                    t2._transformationMatrixRefresh = true;
                    break;
                  case 9:
                    t3._tweenObject.set$alpha(0, value);
                    break;
                }
              }
            }
            t1 = this._onComplete;
            if (t1 != null && this._currentTime === this._totalTime)
              t1.call$0();
          }
        }
        return this._currentTime < this._totalTime;
      },
      complete$0: [function(_) {
        var t1, t2;
        t1 = this._totalTime;
        t2 = this._currentTime;
        if (t1 >= t2)
          this.advanceTime$1(t1 - t2);
      }, "call$0", "get$complete", 0, 0, 2],
      Tween$3: function(tweenObject, time, transition) {
        if (!J.getInterceptor(this._tweenObject).$isTweenObject)
          throw H.wrapException(P.ArgumentError$("tweenObject"));
        this._totalTime = Math.max(0.0001, time);
      },
      $isAnimatable: 1,
      static: {
        Tween$: function(tweenObject, time, transition) {
          var t1 = new K.Tween(tweenObject, transition, H.setRuntimeTypeInfo([], [K.TweenProperty]), null, null, null, 0, 0, 0, false, false);
          t1.Tween$3(tweenObject, time, transition);
          return t1;
        }
      }
    },
    TweenProperty: {
      "^": "Object;_tweenPropertyAccessor,_propertyID,_startValue,_targetValue,_deltaValue"
    },
    TweenPropertyAccessor2D: {
      "^": "Object;_tween,_tweenObject",
      get$x: function(_) {
        return this._tween._createTweenProperty$2(this, 0);
      },
      get$y: function(_) {
        return this._tween._createTweenProperty$2(this, 1);
      },
      get$rotation: function() {
        return this._tween._createTweenProperty$2(this, 8);
      },
      get$alpha: function(_) {
        return this._tween._createTweenProperty$2(this, 9);
      },
      _getValue$1: function(propertyID) {
        switch (propertyID) {
          case 0:
            return this._tweenObject._x;
          case 1:
            return this._tweenObject._y;
          case 2:
            return this._tweenObject._pivotX;
          case 3:
            return this._tweenObject._pivotY;
          case 4:
            return this._tweenObject._scaleX;
          case 5:
            return this._tweenObject._scaleY;
          case 6:
            return this._tweenObject._skewX;
          case 7:
            return this._tweenObject._skewY;
          case 8:
            return this._tweenObject._rotation;
          case 9:
            return this._tweenObject._alpha;
          default:
            return 0;
        }
      }
    }
  }], ["stagexl.display", "package:stagexl/src/display.dart",, A, {
    "^": "",
    BitmapDataChannel_getCanvasIndex: function(bitmapDataChannel) {
      var isLittleEndianSystem = $.$get$isLittleEndianSystem();
      if ((bitmapDataChannel & 1) !== 0)
        return isLittleEndianSystem === true ? 0 : 3;
      if ((bitmapDataChannel & 2) !== 0)
        return isLittleEndianSystem === true ? 1 : 2;
      if ((bitmapDataChannel & 4) !== 0)
        return isLittleEndianSystem === true ? 2 : 1;
      if ((bitmapDataChannel & 8) !== 0)
        return isLittleEndianSystem === true ? 3 : 0;
      throw H.wrapException(P.ArgumentError$("Invalid bitmapDataChannel"));
    },
    Bitmap: {
      "^": "DisplayObject;_display$_bitmapData,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      set$bitmapData: function(value) {
        this._display$_bitmapData = value;
      },
      get$bounds: function() {
        var t1, t2;
        t1 = this._display$_bitmapData;
        t2 = [P.num];
        return t1 == null ? new U.Rectangle0(0, 0, 0, 0, t2) : new U.Rectangle0(0, 0, J.get$width$x(t1), J.get$height$x(this._display$_bitmapData), t2);
      },
      hitTestInput$2: function(localX, localY) {
        var t1;
        if (this._display$_bitmapData == null)
          return;
        t1 = J.getInterceptor$n(localX);
        if (t1.$lt(localX, 0) || t1.$ge(localX, J.get$width$x(this._display$_bitmapData)))
          return;
        t1 = J.getInterceptor$n(localY);
        if (t1.$lt(localY, 0) || t1.$ge(localY, J.get$height$x(this._display$_bitmapData)))
          return;
        return this;
      },
      render$1: function(renderState) {
        var t1 = this._display$_bitmapData;
        if (t1 != null)
          t1.render$1(renderState);
      },
      renderFiltered$1: function(renderState) {
        var t1 = this._display$_bitmapData;
        if (t1 != null)
          renderState._engine$_renderContext.renderTextureQuadFiltered$3(renderState, t1.get$renderTextureQuad(), this._filters);
      }
    },
    BitmapData: {
      "^": "Object;width>,height>,renderTextureQuad<",
      clone$1: function(_, pixelRatio) {
        var t1, t2, t3, bitmapData, updateBatch, sourceQuad, renderState;
        t1 = this.renderTextureQuad;
        pixelRatio = t1.pixelRatio;
        t2 = this.width;
        t3 = this.height;
        bitmapData = A.BitmapData_BitmapData(t2, t3, 16777215, pixelRatio);
        updateBatch = A.BitmapDataUpdateBatch$(bitmapData);
        sourceQuad = t1.cut$1(new U.Rectangle0(0, 0, t2, t3, [P.num]));
        renderState = L.RenderState$(updateBatch._renderContext, updateBatch._drawMatrix, 1, null);
        renderState._currentContextState.matrix.prependTranslation$2(0, 0);
        renderState._engine$_renderContext.renderTextureQuad$2(renderState, sourceQuad);
        updateBatch.bitmapData.renderTextureQuad.renderTexture.update$0(0);
        return bitmapData;
      },
      clone$0: function($receiver) {
        return this.clone$1($receiver, null);
      },
      get$renderTexture: function() {
        return this.renderTextureQuad.renderTexture;
      },
      draw$2: function(source, matrix) {
        var updateBatch = A.BitmapDataUpdateBatch$(this);
        updateBatch.draw$2(source, matrix);
        updateBatch.bitmapData.renderTextureQuad.renderTexture.update$0(0);
      },
      draw$1: function(source) {
        return this.draw$2(source, null);
      },
      render$1: function(renderState) {
        renderState._engine$_renderContext.renderTextureQuad$2(renderState, this.renderTextureQuad);
      },
      renderTextureQuad$2: function(arg0, arg1) {
        return this.renderTextureQuad.call$2(arg0, arg1);
      },
      static: {
        BitmapData$fromRenderTextureQuad: function(renderTextureQuad) {
          var t1, t2, t3;
          t1 = renderTextureQuad.offsetRectangle;
          t2 = t1.width;
          t3 = renderTextureQuad.pixelRatio;
          return new A.BitmapData(J.$div$n(t2, t3), J.$div$n(t1.height, t3), renderTextureQuad);
        },
        BitmapData_BitmapData: function(width, height, fillColor, pixelRatio) {
          var renderTexture, t1, t2, t3, renderTextureQuad;
          if (typeof pixelRatio !== "number")
            return H.iae(pixelRatio);
          renderTexture = L.RenderTexture$(C.JSNumber_methods.round$0(width * pixelRatio), C.JSNumber_methods.round$0(height * pixelRatio), fillColor);
          t1 = renderTexture._engine$_width;
          t2 = renderTexture._engine$_height;
          t3 = [P.int];
          t3 = L.RenderTextureQuad$(renderTexture, new U.Rectangle0(0, 0, t1, t2, t3), new U.Rectangle0(0, 0, t1, t2, t3), 0, 1);
          renderTextureQuad = L.RenderTextureQuad$(t3.renderTexture, t3.sourceRectangle, t3.offsetRectangle, t3.rotation, pixelRatio);
          t3 = renderTextureQuad.offsetRectangle;
          t2 = renderTextureQuad.pixelRatio;
          return new A.BitmapData(J.$div$n(t3.width, t2), J.$div$n(t3.height, t2), renderTextureQuad);
        },
        BitmapData_load: function(url, bitmapDataLoadOptions) {
          var $async$goto = 0, $async$completer = P.Completer_Completer$sync(), $async$returnValue, pixelRatioMatch, maxPixelRatio, t1, originPixelRatio, loaderPixelRatio, pixelRatio, t2, $async$temp1;
          var $async$BitmapData_load = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
            if ($async$errorCode === 1)
              return P._asyncRethrow($async$result, $async$completer);
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  bitmapDataLoadOptions = $.$get$BitmapData_defaultLoadOptions();
                  pixelRatioMatch = P.RegExp_RegExp("@(\\d)x", true, false).firstMatch$1(url);
                  maxPixelRatio = bitmapDataLoadOptions.maxPixelRatio;
                  if (pixelRatioMatch != null) {
                    t1 = pixelRatioMatch._match;
                    if (1 >= t1.length) {
                      $async$returnValue = H.ioore(t1, 1);
                      // goto return
                      $async$goto = 1;
                      break;
                    }
                    originPixelRatio = H.Primitives_parseInt(t1[1], null, null);
                    loaderPixelRatio = V.minInt(J.round$0$n($.$get$devicePixelRatio()), maxPixelRatio);
                    if (typeof originPixelRatio !== "number") {
                      $async$returnValue = H.iae(originPixelRatio);
                      // goto return
                      $async$goto = 1;
                      break;
                    }
                    pixelRatio = loaderPixelRatio / originPixelRatio;
                    t2 = t1.index;
                    url = C.JSString_methods.replaceRange$3(url, t2, t2 + t1[0].length, "@" + loaderPixelRatio + "x");
                  } else
                    pixelRatio = 1;
                  $async$temp1 = L;
                  $async$goto = 3;
                  return P._asyncAwait(N.ImageLoader$(url, false, false)._completer.future, $async$BitmapData_load);
                case 3:
                  // returning from await.
                  t1 = $async$temp1.RenderTexture$fromImageElement($async$result).get$quad();
                  $async$returnValue = A.BitmapData$fromRenderTextureQuad(L.RenderTextureQuad$(t1.renderTexture, t1.sourceRectangle, t1.offsetRectangle, t1.rotation, pixelRatio));
                  // goto return
                  $async$goto = 1;
                  break;
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
          });
          return P._asyncStart($async$BitmapData_load, $async$completer);
        }
      }
    },
    BitmapDataLoadOptions: {
      "^": "Object;png,jpg,webp,maxPixelRatio,corsEnabled"
    },
    BitmapDataUpdateBatch: {
      "^": "Object;bitmapData,_renderContext,_drawMatrix",
      colorTransform$2: function(rectangle, transform) {
        var isLittleEndianSystem, t1, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset, mulitplier0, mulitplier1, mulitplier2, mulitplier3, offset0, offset1, offset2, offset3, renderTextureQuad, imageData, data, i, c0, t2, c1, t3, c2, t4, c3;
        isLittleEndianSystem = $.$get$isLittleEndianSystem();
        t1 = transform.multipliers;
        redMultiplier = C.JSNumber_methods.toInt$0(1024 * t1[0]);
        greenMultiplier = C.JSNumber_methods.toInt$0(1024 * t1[1]);
        blueMultiplier = C.JSNumber_methods.toInt$0(1024 * t1[2]);
        alphaMultiplier = C.JSNumber_methods.toInt$0(1024 * t1[3]);
        t1 = transform.offsets;
        redOffset = t1[0];
        greenOffset = t1[1];
        blueOffset = t1[2];
        alphaOffset = t1[3];
        t1 = isLittleEndianSystem === true;
        mulitplier0 = t1 ? redMultiplier : alphaMultiplier;
        mulitplier1 = t1 ? greenMultiplier : blueMultiplier;
        mulitplier2 = t1 ? blueMultiplier : greenMultiplier;
        mulitplier3 = t1 ? alphaMultiplier : redMultiplier;
        offset0 = t1 ? redOffset : alphaOffset;
        offset1 = t1 ? greenOffset : blueOffset;
        offset2 = t1 ? blueOffset : greenOffset;
        offset3 = t1 ? alphaOffset : redOffset;
        renderTextureQuad = this.bitmapData.renderTextureQuad.cut$1(rectangle);
        imageData = renderTextureQuad.getImageData$0(0);
        data = J.get$data$x(imageData);
        for (t1 = data.length - 4, i = 0; i <= t1; i += 4) {
          c0 = data[i];
          t2 = i + 1;
          c1 = data[t2];
          t3 = i + 2;
          c2 = data[t3];
          t4 = i + 3;
          c3 = data[t4];
          data[i] = offset0 + ((c0 * mulitplier0 | 0) >>> 10);
          data[t2] = offset1 + ((c1 * mulitplier1 | 0) >>> 10);
          data[t3] = offset2 + ((c2 * mulitplier2 | 0) >>> 10);
          data[t4] = offset3 + ((c3 * mulitplier3 | 0) >>> 10);
        }
        renderTextureQuad.putImageData$1(0, imageData);
      },
      draw$2: function(source, matrix) {
        var renderState, t1;
        renderState = L.RenderState$(this._renderContext, this._drawMatrix, null, null);
        if (matrix != null) {
          t1 = renderState._currentContextState.matrix;
          t1.copyFromAndConcat$2(matrix, t1);
        }
        source.render$1(renderState);
      },
      static: {
        BitmapDataUpdateBatch$: function(bitmapData) {
          var t1, t2, t3, t4, t5;
          t1 = bitmapData.renderTextureQuad;
          t2 = t1.renderTexture;
          t2 = t2.get$canvas(t2);
          t3 = T.Matrix$fromIdentity();
          t4 = J.get$context2D$x(t2);
          t5 = [L.RenderContextEvent];
          t2 = new L.RenderContextCanvas(t2, t4, t3, C.BlendMode_bZz, 1, new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t5), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t5));
          t2.reset$0(0);
          return new A.BitmapDataUpdateBatch(bitmapData, t2, t1.get$drawMatrix());
        }
      }
    },
    BitmapFilter: {
      "^": "RenderFilter;",
      get$renderPassSources: function() {
        return C.List_0;
      },
      get$renderPassTargets: function() {
        return C.List_1;
      },
      apply$2: function(bitmapData, rectangle) {
      },
      apply$1: function(bitmapData) {
        return this.apply$2(bitmapData, null);
      },
      renderFilter$3: function(renderState, renderTextureQuad, pass) {
        renderState._engine$_renderContext.renderTextureQuad$2(renderState, renderTextureQuad);
      }
    },
    ColorTransform: {
      "^": "Object;multipliers,offsets"
    },
    DisplayObject: {
      "^": "EventDispatcher;_parent?",
      get$x: function(_) {
        return this._x;
      },
      set$x: ["super$DisplayObject$x", function(_, value) {
        if (typeof value === "number")
          this._x = value;
        this._transformationMatrixRefresh = true;
      }],
      get$y: function(_) {
        return this._y;
      },
      set$y: function(_, value) {
        if (typeof value === "number")
          this._y = value;
        this._transformationMatrixRefresh = true;
      },
      set$scaleX: function(value) {
        if (typeof value === "number")
          this._scaleX = value;
        this._transformationMatrixRefresh = true;
      },
      set$scaleY: function(value) {
        if (typeof value === "number")
          this._scaleY = value;
        this._transformationMatrixRefresh = true;
      },
      get$rotation: function() {
        return this._rotation;
      },
      get$visible: function(_) {
        return this._display$_visible;
      },
      set$visible: function(_, value) {
        this._display$_visible = value;
      },
      get$off: function() {
        return false;
      },
      get$alpha: function(_) {
        return this._alpha;
      },
      set$alpha: function(_, value) {
        if (value <= 0)
          value = 0;
        this._alpha = value >= 1 ? 1 : value;
      },
      get$mask: function(_) {
        return this._mask;
      },
      get$filters: function() {
        return this._filters;
      },
      get$blendMode: function() {
        return this._blendMode;
      },
      get$name: function(_) {
        return this._display$_name;
      },
      get$cache: function() {
        var t1 = this._cache;
        return t1 != null ? t1.renderTextureQuad : null;
      },
      get$parent: function(_) {
        return this._parent;
      },
      get$root: function(_) {
        var obj, obj0;
        for (obj = this; obj0 = obj._parent, obj0 != null; obj = obj0)
          ;
        return obj;
      },
      get$stage: function() {
        var root = this.get$root(this);
        return root instanceof A.Stage ? root : null;
      },
      get$width: function(_) {
        return this.get$boundsTransformed().width;
      },
      set$width: function(_, value) {
        var bounds, matrix, scale, ma, mc, t1;
        bounds = this.get$bounds();
        matrix = this.get$transformationMatrix();
        scale = J.$div$n(value, matrix.transformRectangle$2(bounds, bounds).width);
        ma = isFinite(scale) ? matrix._data[0] * scale : 1;
        mc = isFinite(scale) ? matrix._data[2] * scale : 0;
        t1 = matrix._data;
        this._reverseMatrix$4(ma, t1[1], mc, t1[3]);
      },
      get$height: function(_) {
        return this.get$boundsTransformed().height;
      },
      get$transformationMatrix: function() {
        var matrix, rotation, scaleX, scaleY, skewX, skewY, t1, ma, mb, mc, md, t2, t3, cr, sr;
        if (this._transformationMatrixRefresh) {
          this._transformationMatrixRefresh = false;
          matrix = this._transformationMatrix;
          rotation = this._rotation;
          scaleX = this._scaleX;
          scaleY = this._scaleY;
          skewX = this._skewX;
          skewY = this._skewY;
          if (scaleX > -0.0001 && scaleX < 0.0001)
            scaleX = scaleX >= 0 ? 0.0001 : -0.0001;
          if (scaleY > -0.0001 && scaleY < 0.0001)
            scaleY = scaleY >= 0 ? 0.0001 : -0.0001;
          if (skewX !== 0 || skewY !== 0) {
            t1 = skewY + rotation;
            ma = scaleX * Math.cos(t1);
            mb = scaleX * Math.sin(t1);
            t1 = skewX + rotation;
            mc = -scaleY * Math.sin(t1);
            md = scaleY * Math.cos(t1);
            t1 = this._x;
            t2 = this._pivotX;
            t3 = this._pivotY;
            matrix.setTo$6(ma, mb, mc, md, t1 - t2 * ma - t3 * mc, this._y - t2 * mb - t3 * md);
          } else if (rotation !== 0) {
            cr = Math.cos(rotation);
            sr = Math.sin(rotation);
            ma = scaleX * cr;
            mb = scaleX * sr;
            mc = -scaleY * sr;
            md = scaleY * cr;
            t1 = this._x;
            t2 = this._pivotX;
            t3 = this._pivotY;
            matrix.setTo$6(ma, mb, mc, md, t1 - t2 * ma - t3 * mc, this._y - t2 * mb - t3 * md);
          } else
            matrix.setTo$6(scaleX, 0, 0, scaleY, this._x - this._pivotX * scaleX, this._y - this._pivotY * scaleY);
        }
        return this._transformationMatrix;
      },
      removeFromParent$0: function() {
        var t1 = this._parent;
        if (t1 != null)
          t1.removeChild$1(this);
      },
      get$bounds: function() {
        return new U.Rectangle0(0, 0, 0, 0, [P.num]);
      },
      get$boundsTransformed: function() {
        var rectangle = this.get$bounds();
        return this.get$transformationMatrix().transformRectangle$2(rectangle, rectangle);
      },
      hitTestInput$2: function(localX, localY) {
        return this.get$bounds().contains$2(0, localX, localY) ? this : null;
      },
      localToParent$2: function(localPoint, returnPoint) {
        var x, y, t1;
        x = J.toDouble$0$n(localPoint.x);
        y = J.toDouble$0$n(localPoint.y);
        t1 = this.get$transformationMatrix()._data;
        returnPoint.x = x * t1[0] + y * t1[2] + t1[4];
        returnPoint.y = x * t1[1] + y * t1[3] + t1[5];
        return returnPoint;
      },
      parentToLocal$2: function(parentPoint, returnPoint) {
        var x, y, t1, t2, t3, t4, t5, t6, t7;
        x = J.toDouble$0$n(parentPoint.x);
        y = J.toDouble$0$n(parentPoint.y);
        t1 = this.get$transformationMatrix()._data;
        t2 = t1[3];
        t3 = x - t1[4];
        t4 = t1[2];
        t5 = y - t1[5];
        t6 = t1[0];
        t1 = t1[1];
        t7 = t6 * t2 - t1 * t4;
        returnPoint.x = (t2 * t3 - t4 * t5) / t7;
        returnPoint.y = (t6 * t5 - t1 * t3) / t7;
        return returnPoint;
      },
      globalToLocal$2: function(globalPoint, returnPoint) {
        var p = returnPoint instanceof U.Point ? returnPoint : new U.Point(0, 0, [P.num]);
        p.x = J.toDouble$0$n(globalPoint.x);
        p.y = J.toDouble$0$n(globalPoint.y);
        this._globalToLocalRecursion$1(p);
        return p;
      },
      globalToLocal$1: function(globalPoint) {
        return this.globalToLocal$2(globalPoint, null);
      },
      _globalToLocalRecursion$1: function(point) {
        var t1 = this._parent;
        if (t1 != null)
          t1._globalToLocalRecursion$1(point);
        this.parentToLocal$2(point, point);
      },
      refreshCache$0: function() {
        var t1 = this._cache;
        if (t1 != null)
          t1.update$0(0);
      },
      removeCache$0: function() {
        var t1, t2;
        t1 = this._cache;
        if (t1 != null) {
          t2 = t1.renderTexture;
          if (t2 != null)
            t2.dispose$0();
          t1.renderTexture = null;
          t1.renderTextureQuad = null;
        }
      },
      dispatchEvent$1: function(_, $event) {
        var ancestors, p, i, t1, t2;
        ancestors = H.setRuntimeTypeInfo([], [R.EventDispatcher]);
        for (p = this._parent; p != null; p = p._parent)
          ancestors.push(p);
        i = ancestors.length - 1;
        while (true) {
          if (!(i >= 0 && $event.get$captures()))
            break;
          if (i < 0 || i >= ancestors.length)
            return H.ioore(ancestors, i);
          ancestors[i].dispatchEventRaw$3($event, this, C.EventPhase_0);
          if ($event._isPropagationStopped)
            return;
          --i;
        }
        this.dispatchEventRaw$3($event, this, C.EventPhase_1);
        if ($event._isPropagationStopped)
          return;
        t1 = $event._bubbles;
        i = 0;
        while (true) {
          t2 = ancestors.length;
          if (!(i < t2 && t1))
            break;
          if (i >= t2)
            return H.ioore(ancestors, i);
          ancestors[i].dispatchEventRaw$3($event, this, C.EventPhase_2);
          if ($event._isPropagationStopped)
            return;
          ++i;
        }
      },
      render$1: function(renderState) {
      },
      renderFiltered$1: ["super$DisplayObject$renderFiltered", function(renderState) {
        renderState._engine$_renderContext.renderObjectFiltered$2(renderState, this);
      }],
      _reverseMatrix$4: function(ma, mb, mc, md) {
        var t1, skewX, cosX, sinX, skewY, cosY, sinY;
        t1 = -mc;
        skewX = Math.atan2(t1, md);
        cosX = Math.cos(skewX);
        sinX = Math.sin(skewX);
        skewY = Math.atan2(mb, ma);
        cosY = Math.cos(skewY);
        sinY = Math.sin(skewY);
        this._transformationMatrixRefresh = true;
        this._scaleX = cosY * cosY > sinY * sinY ? ma / cosY : mb / sinY;
        this._scaleY = cosX * cosX > sinX * sinX ? md / cosX : t1 / sinX;
        t1 = this._rotation;
        this._skewX = skewX - t1;
        this._skewY = skewY - t1;
      },
      $isTweenObject2D: 1,
      $isTweenObject: 1
    },
    _DisplayObjectCache: {
      "^": "Object;displayObject,pixelRatio<,debugBorder,bounds,renderTexture<,renderTextureQuad<",
      update$0: function(_) {
        var t1, t2, l, t, r, w, h, pr, sr, or, canvas, matrix, t3, t4, renderContext, renderState, filters, context;
        t1 = this.pixelRatio;
        t2 = this.bounds.left;
        if (typeof t2 !== "number")
          return H.iae(t2);
        l = C.JSNumber_methods.floor$0(t1 * t2);
        t2 = this.pixelRatio;
        t1 = this.bounds.top;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t = C.JSNumber_methods.floor$0(t2 * t1);
        t1 = this.pixelRatio;
        t2 = this.bounds;
        t2 = J.$add$ns(t2.left, t2.width);
        if (typeof t2 !== "number")
          return H.iae(t2);
        r = C.JSNumber_methods.ceil$0(t1 * t2);
        t2 = this.pixelRatio;
        t1 = this.bounds;
        t1 = J.$add$ns(t1.top, t1.height);
        if (typeof t1 !== "number")
          return H.iae(t1);
        w = r - l;
        h = C.JSNumber_methods.ceil$0(t2 * t1) - t;
        pr = this.pixelRatio;
        t1 = [P.int];
        sr = new U.Rectangle0(0, 0, w, h, t1);
        or = new U.Rectangle0(0 - l, 0 - t, w, h, t1);
        t1 = this.renderTexture;
        if (t1 == null) {
          t1 = L.RenderTexture$(w, h, 16777215);
          this.renderTexture = t1;
          this.renderTextureQuad = L.RenderTextureQuad$(t1, sr, or, 0, pr);
        } else {
          t1.resize$2(0, w, h);
          this.renderTextureQuad = L.RenderTextureQuad$(this.renderTexture, sr, or, 0, pr);
        }
        t1 = this.renderTexture;
        canvas = t1.get$canvas(t1);
        matrix = this.renderTextureQuad.get$drawMatrix();
        t1 = T.Matrix$fromIdentity();
        t2 = J.getInterceptor$x(canvas);
        t3 = t2.get$context2D(canvas);
        t4 = [L.RenderContextEvent];
        renderContext = new L.RenderContextCanvas(canvas, t3, t1, C.BlendMode_bZz, 1, new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t4), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t4));
        renderContext.reset$0(0);
        renderState = L.RenderState$(renderContext, matrix, null, null);
        renderContext.clear$1(0, 16777215);
        t1 = this.displayObject;
        t1.render$1(renderState);
        filters = t1._filters;
        t1 = filters.length;
        if (t1 > 0)
          C.JSArray_methods.forEach$1(filters, new A._DisplayObjectCache_update_closure(A.BitmapData$fromRenderTextureQuad(this.renderTextureQuad)));
        if (this.debugBorder) {
          context = t2.get$context2D(canvas);
          context.setTransform(1, 0, 0, 1, 0, 0);
          context.lineWidth = 1;
          context.lineJoin = "miter";
          context.lineCap = "butt";
          context.strokeStyle = "#FF00FF";
          context.strokeRect(0.5, 0.5, J.$sub$n(t2.get$width(canvas), 1), J.$sub$n(t2.get$height(canvas), 1));
        }
        this.renderTexture.update$0(0);
      },
      renderTextureQuad$2: function(arg0, arg1) {
        return this.renderTextureQuad.call$2(arg0, arg1);
      }
    },
    _DisplayObjectCache_update_closure: {
      "^": "Closure:0;bitmapData",
      call$1: function(filter) {
        return filter.apply$1(this.bitmapData);
      }
    },
    DisplayObjectContainer: {
      "^": "InteractiveObject;",
      addChild$1: function(child) {
        var t1, root;
        t1 = J.getInterceptor(child);
        if (t1.$eq(child, this))
          throw H.wrapException(P.ArgumentError$("An object cannot be added as a child of itself."));
        else if (J.$eq$(t1.get$parent(child), this))
          this._addLocalChild$1(child);
        else {
          child.removeFromParent$0();
          this._throwIfAncestors$1(child);
          this._children.push(child);
          child.set$_parent(this);
          t1.dispatchEvent$1(child, new R.Event("added", true, C.EventPhase_1, null, null, false, false));
          root = this.get$root(this);
          if ((root instanceof A.Stage ? root : null) != null)
            this._dispatchStageEvents$2(child, "addedToStage");
        }
      },
      removeChild$1: function(child) {
        var t1, t2, index, root;
        t1 = J.getInterceptor$x(child);
        if (!J.$eq$(t1.get$parent(child), this))
          throw H.wrapException(P.ArgumentError$("The supplied DisplayObject must be a child of the caller."));
        else {
          t2 = this._children;
          index = C.JSArray_methods.indexOf$1(t2, child);
          t1.dispatchEvent$1(child, new R.Event("removed", true, C.EventPhase_1, null, null, false, false));
          root = this.get$root(this);
          if ((root instanceof A.Stage ? root : null) != null)
            this._dispatchStageEvents$2(child, "removedFromStage");
          child.set$_parent(null);
          C.JSArray_methods.removeAt$1(t2, index);
        }
      },
      get$bounds: function() {
        var t1, left, $top, right, bottom, i, rectangle;
        t1 = this._children;
        if (t1.length === 0)
          return A.DisplayObject.prototype.get$bounds.call(this);
        for (left = 1 / 0, $top = 1 / 0, right = -1 / 0, bottom = -1 / 0, i = 0; i < t1.length; ++i) {
          rectangle = t1[i].get$boundsTransformed();
          if (J.$lt$n(rectangle.left, left))
            left = rectangle.left;
          if (J.$lt$n(rectangle.top, $top))
            $top = rectangle.top;
          if (J.$gt$n(J.$add$ns(rectangle.left, rectangle.width), right))
            right = J.$add$ns(rectangle.left, rectangle.width);
          if (J.$gt$n(J.$add$ns(rectangle.top, rectangle.height), bottom))
            bottom = J.$add$ns(rectangle.top, rectangle.height);
        }
        return new U.Rectangle0(left, $top, J.$sub$n(right, left), J.$sub$n(bottom, $top), [P.num]);
      },
      hitTestInput$2: ["super$DisplayObjectContainer$hitTestInput", function(localX, localY) {
        var t1, i, hit, child, t2, mask, matrix, deltaX, deltaY, t3, t4, t5, t6, childX, childY, displayObject;
        localX = J.toDouble$0$n(localX);
        localY = J.toDouble$0$n(localY);
        for (t1 = this._children, i = t1.length - 1, hit = null; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          child = t1[i];
          t2 = J.getInterceptor$x(child);
          mask = t2.get$mask(child);
          matrix = child.get$transformationMatrix();
          if (t2.get$visible(child) === true) {
            child.get$off();
            t2 = true;
          } else
            t2 = false;
          if (t2) {
            t2 = matrix._data;
            deltaX = localX - t2[4];
            deltaY = localY - t2[5];
            t3 = t2[3];
            t4 = t2[2];
            t5 = t2[0];
            t2 = t2[1];
            t6 = t5 * t3 - t2 * t4;
            childX = (t3 * deltaX - t4 * deltaY) / t6;
            childY = (t5 * deltaY - t2 * deltaX) / t6;
            if (mask != null) {
              mask.get$relativeToParent();
              mask.get$relativeToParent();
              if (!mask.hitTest$2(childX, childY))
                continue;
            }
            displayObject = child.hitTestInput$2(childX, childY);
            if (displayObject == null)
              continue;
            if (!!displayObject.$isInteractiveObject && displayObject.mouseEnabled)
              return this._mouseChildren ? displayObject : this;
            hit = this;
          }
        }
        return hit;
      }],
      render$1: ["super$DisplayObjectContainer$render", function(renderState) {
        var t1, i, child, t2;
        for (t1 = this._children, i = 0; i < t1.length; ++i) {
          child = t1[i];
          if (J.get$visible$x(child) === true) {
            child.get$off();
            t2 = true;
          } else
            t2 = false;
          if (t2)
            renderState.renderObject$1(child);
        }
      }],
      _throwIfAncestors$1: function(child) {
        var a;
        for (a = this; a != null; a = a._parent)
          if (a === child)
            throw H.wrapException(P.ArgumentError$("An object cannot be added as a child to one of it's children (or children's children, etc.)."));
      },
      _addLocalChild$1: function(child) {
        var children, i, t1, newChild, oldChild;
        children = this._children;
        for (i = children.length - 1, t1 = J.getInterceptor(child), newChild = child; i >= 0; --i, newChild = oldChild) {
          if (i >= children.length)
            return H.ioore(children, i);
          oldChild = children[i];
          children[i] = newChild;
          if (t1.$eq(child, oldChild))
            break;
        }
      },
      _dispatchStageEvents$2: function(child, eventType) {
        var captured, obj;
        captured = false;
        obj = this;
        while (true) {
          if (!(obj != null && !captured))
            break;
          if (obj.hasEventListener$2$useCapture(eventType, true))
            captured = true;
          obj = obj._parent;
        }
        this._dispatchStageEventsRecursion$3(child, new R.Event(eventType, false, C.EventPhase_1, null, null, false, false), captured);
      },
      _dispatchStageEventsRecursion$3: function(displayObject, $event, captured) {
        var t1, children, i;
        t1 = !captured;
        if (!t1 || displayObject.hasEventListener$1($event._type))
          J.dispatchEvent$1$x(displayObject, $event);
        if (displayObject instanceof A.DisplayObjectContainer) {
          captured = !t1 || displayObject.hasEventListener$2$useCapture($event._type, true);
          children = displayObject._children;
          for (i = 0; i < children.length; ++i)
            this._dispatchStageEventsRecursion$3(children[i], $event, captured);
        }
      },
      $isTweenObject2D: 1,
      $isTweenObject: 1
    },
    InteractiveObject: {
      "^": "DisplayObject;mouseCursor?",
      get$onMouseClick: function() {
        return this.on$1(0, "click");
      },
      get$onTouchTap: function() {
        return this.on$1(0, "touchTap");
      }
    },
    Mask: {
      "^": "Object;transformationMatrix<,relativeToParent<,border>"
    },
    _TransformedMask: {
      "^": "Mask;",
      hitTest$2: function(x, y) {
        var t1, deltaX, deltaY, t2, t3, t4, t5;
        t1 = this.transformationMatrix._data;
        deltaX = x - t1[4];
        deltaY = y - t1[5];
        t2 = t1[3];
        t3 = t1[2];
        t4 = t1[0];
        t1 = t1[1];
        t5 = t4 * t2 - t1 * t3;
        return this.rectangle.contains$2(0, (t2 * deltaX - t3 * deltaY) / t5, (t4 * deltaY - t1 * deltaX) / t5);
      },
      renderMask$1: function(renderState) {
        var renderContext, t1, t2, l, t, r, b;
        renderState.push$3(this.transformationMatrix, 1, null);
        renderContext = renderState._engine$_renderContext;
        t1 = J.getInterceptor(renderContext);
        t2 = this.rectangle;
        if (!!t1.$isRenderContextCanvas) {
          t1.setTransform$1(renderContext, renderState._currentContextState.matrix);
          renderContext._renderingContext.rect(t2.left, t2.top, t2.width, t2.height);
        } else {
          l = t2.left;
          t = t2.top;
          r = J.$add$ns(l, t2.width);
          b = J.$add$ns(t2.top, t2.height);
          renderContext.renderTriangle$8(renderState, l, t, r, t, r, b, 4294902015);
          renderContext.renderTriangle$8(renderState, l, t, r, b, l, b, 4294902015);
        }
        renderState._currentContextState = renderState._currentContextState.previousContextState;
      }
    },
    _RectangleMask: {
      "^": "_TransformedMask;rectangle,transformationMatrix,relativeToParent,border,borderColor,borderWidth",
      $isScissorRenderMask: 1
    },
    RenderLoop: {
      "^": "RenderLoopBase;_juggler,_stages,_enterFrameEvent,_exitFrameEvent,_display$_currentTime,_running",
      get$juggler: function() {
        return this._juggler;
      },
      advanceTime$1: function(deltaTime) {
        var t1;
        this._display$_currentTime += deltaTime;
        t1 = this._enterFrameEvent;
        t1.passedTime = deltaTime;
        R._dispatchBroadcastEvent(t1, $.$get$_enterFrameSubscriptions());
        this._juggler.advanceTime$1(deltaTime);
        t1 = this._stages;
        C.JSArray_methods.forEach$1(t1, new A.RenderLoop_advanceTime_closure(deltaTime));
        C.JSArray_methods.forEach$1(t1, new A.RenderLoop_advanceTime_closure0(this, deltaTime));
        R._dispatchBroadcastEvent(this._exitFrameEvent, $.$get$_exitFrameSubscriptions());
      }
    },
    RenderLoop_advanceTime_closure: {
      "^": "Closure:0;deltaTime",
      call$1: function(s) {
        s.get$juggler().advanceTime$1(this.deltaTime);
        return true;
      }
    },
    RenderLoop_advanceTime_closure0: {
      "^": "Closure:0;$this,deltaTime",
      call$1: function(s) {
        return s.materialize$2(this.$this._display$_currentTime, this.deltaTime);
      }
    },
    Shape: {
      "^": "DisplayObject;graphics,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      get$bounds: function() {
        var t1 = this.graphics.get$bounds();
        return t1;
      },
      hitTestInput$2: function(localX, localY) {
        if (this.graphics.hitTest$2(localX, localY))
          return this;
        return;
      },
      render$1: function(renderState) {
        this.graphics.render$1(renderState);
      }
    },
    SimpleButtonState: {
      "^": "Object;index,_display$_name",
      toString$0: function(_) {
        return this._display$_name;
      }
    },
    SimpleButton: {
      "^": "InteractiveObject;upState,overState,downState,hitTestState,_display$_enabled,_display$_state,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      get$bounds: function() {
        var displayObject = this._getDisplayObject$0();
        return displayObject != null ? displayObject.get$boundsTransformed() : A.DisplayObject.prototype.get$bounds.call(this);
      },
      hitTestInput$2: function(localX, localY) {
        var t1, deltaX, deltaY, t2, t3, t4, t5;
        t1 = this.hitTestState;
        if (t1 == null)
          return;
        t1 = t1.get$transformationMatrix()._data;
        deltaX = J.$sub$n(localX, t1[4]);
        deltaY = J.$sub$n(localY, t1[5]);
        t2 = t1[3];
        if (typeof deltaX !== "number")
          return H.iae(deltaX);
        t3 = t1[2];
        if (typeof deltaY !== "number")
          return H.iae(deltaY);
        t4 = t1[0];
        t1 = t1[1];
        t5 = t4 * t2 - t1 * t3;
        return this.hitTestState.hitTestInput$2((t2 * deltaX - t3 * deltaY) / t5, (t4 * deltaY - t1 * deltaX) / t5) != null ? this : null;
      },
      render$1: function(renderState) {
        var displayObject = this._getDisplayObject$0();
        if (displayObject != null)
          renderState.renderObject$1(displayObject);
      },
      _getDisplayObject$0: function() {
        switch (this._display$_state) {
          case C.SimpleButtonState_0:
            return this.upState;
          case C.SimpleButtonState_1:
            return this.overState;
          case C.SimpleButtonState_2:
            return this.downState;
          default:
            return;
        }
      },
      _onMouseEvent$1: [function(mouseEvent) {
        if (J.get$type$x(mouseEvent) === "mouseOut")
          this._display$_state = C.SimpleButtonState_0;
        else if (mouseEvent.get$buttonDown())
          this._display$_state = C.SimpleButtonState_2;
        else
          this._display$_state = C.SimpleButtonState_1;
      }, "call$1", "get$_onMouseEvent", 2, 0, 12, 19],
      _onTouchEvent$1: [function(touchEvent) {
        var t1;
        if (!!touchEvent.get$isPrimaryTouchPoint()) {
          t1 = J.getInterceptor$x(touchEvent);
          if (t1.get$type(touchEvent) === "touchOver")
            this._display$_state = C.SimpleButtonState_2;
          else if (t1.get$type(touchEvent) === "touchOut")
            this._display$_state = C.SimpleButtonState_0;
          else if (t1.get$type(touchEvent) === "touchBegin")
            this._display$_state = C.SimpleButtonState_2;
          else if (t1.get$type(touchEvent) === "touchEnd")
            this._display$_state = C.SimpleButtonState_0;
        }
      }, "call$1", "get$_onTouchEvent", 2, 0, 57, 44],
      SimpleButton$4: function(upState, overState, downState, hitTestState) {
        var t1;
        this.mouseCursor = "pointer";
        t1 = this.get$_onMouseEvent();
        this.on$1(0, "mouseOver").listen$1(t1);
        this.on$1(0, "mouseOut").listen$1(t1);
        this.on$1(0, "mouseDown").listen$1(t1);
        this.on$1(0, "mouseUp").listen$1(t1);
        t1 = this.get$_onTouchEvent();
        this.on$1(0, "touchOver").listen$1(t1);
        this.on$1(0, "touchOut").listen$1(t1);
        this.on$1(0, "touchBegin").listen$1(t1);
        this.on$1(0, "touchEnd").listen$1(t1);
      },
      static: {
        SimpleButton$: function(upState, overState, downState, hitTestState) {
          var t1 = $.DisplayObject__nextID;
          $.DisplayObject__nextID = t1 + 1;
          t1 = new A.SimpleButton(upState, overState, downState, hitTestState, true, C.SimpleButtonState_0, false, true, "auto", true, 0, t1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
          t1.SimpleButton$4(upState, overState, downState, hitTestState);
          return t1;
        }
      }
    },
    Sprite: {
      "^": "DisplayObjectContainer;_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      get$graphics: function() {
        var t1 = this._graphics;
        if (!(t1 != null)) {
          t1 = [U.GraphicsCommand];
          t1 = new U.Graphics(H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), null);
          this._graphics = t1;
        }
        return t1;
      },
      startDrag$2: function(lockCenter, bounds) {
        var stage, inputEvent, t1, globalPoint, anchorPoint, touchPointID, t2;
        stage = this.get$stage();
        inputEvent = $.InputEvent_current;
        t1 = [P.num];
        globalPoint = new U.Point(0, 0, t1);
        anchorPoint = new U.Point(0, 0, t1);
        if (inputEvent == null && stage != null) {
          t1 = stage._mousePosition;
          globalPoint.x = t1.x;
          globalPoint.y = t1.y;
          touchPointID = 0;
        } else {
          t1 = J.getInterceptor(inputEvent);
          if (!!t1.$isMouseEvent) {
            t1 = inputEvent.stageX;
            t2 = inputEvent.stageY;
            globalPoint.x = t1;
            globalPoint.y = t2;
            touchPointID = 0;
          } else if (!!t1.$isTouchEvent) {
            t1 = inputEvent.stageX;
            t2 = inputEvent.stageY;
            globalPoint.x = t1;
            globalPoint.y = t2;
            touchPointID = inputEvent.touchPointID;
          } else
            return;
        }
        this.globalToLocal$2(globalPoint, anchorPoint);
        stage._startDrag$5(this, globalPoint, anchorPoint, bounds, touchPointID);
      },
      startDrag$0: function() {
        return this.startDrag$2(false, null);
      },
      get$bounds: function() {
        var t1 = this._graphics;
        if (t1 == null)
          return A.DisplayObjectContainer.prototype.get$bounds.call(this);
        else if (this._children.length === 0)
          return t1.get$bounds();
        else
          return t1.get$bounds().boundingBox$1(0, A.DisplayObjectContainer.prototype.get$bounds.call(this));
      },
      hitTestInput$2: function(localX, localY) {
        var graphics, target;
        graphics = this._graphics;
        target = this.super$DisplayObjectContainer$hitTestInput(localX, localY);
        if (target == null && graphics != null)
          target = graphics.hitTest$2(localX, localY) ? this : null;
        return target;
      },
      render$1: function(renderState) {
        var t1 = this._graphics;
        if (t1 != null)
          t1.render$1(renderState);
        this.super$DisplayObjectContainer$render(renderState);
      }
    },
    StageRenderMode: {
      "^": "Object;index,_display$_name",
      toString$0: function(_) {
        return this._display$_name;
      }
    },
    StageScaleMode: {
      "^": "Object;index,_display$_name",
      toString$0: function(_) {
        return this._display$_name;
      }
    },
    StageAlign: {
      "^": "Object;index,_display$_name",
      toString$0: function(_) {
        return this._display$_name;
      }
    },
    Stage: {
      "^": "DisplayObjectContainer;_display$_canvas,_renderContext,_display$_renderLoop,_console,_sourceWidth,_sourceHeight,_stageWidth,_stageHeight,_display$_pixelRatio,_invalid,_avgFrameTime,_avgDrawCalls,_avgVertexCount,_avgIdexCount,_contentRectangle,_clientTransformation,_stageTransformation,_consoleTransformation,_renderEvent,_renderState,_inputEventMode,_stageRenderMode,_stageScaleMode,_stageAlign,_mouseCursor,_mousePosition,_mouseTarget,_drags,_touchPoints,_mouseButtons,juggler<,focus,backgroundColor,preventDefaultOnTouch,preventDefaultOnMouse,preventDefaultOnWheel,preventDefaultOnKeyboard,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      get$pixelRatio: function() {
        return this._display$_pixelRatio;
      },
      _throwStageException$0: function() {
        throw H.wrapException(new P.UnsupportedError("The Stage class does not implement this property or method."));
      },
      set$x: function(_, value) {
        this._throwStageException$0();
      },
      set$y: function(_, value) {
        this._throwStageException$0();
      },
      set$width: function(_, value) {
        this._throwStageException$0();
      },
      hitTestInput$2: function(localX, localY) {
        var target = this.super$DisplayObjectContainer$hitTestInput(localX, localY);
        return target != null ? target : this;
      },
      materialize$2: function(currentTime, deltaTime) {
        var t1, stopwatch, t2, stats, frameTime;
        t1 = this._stageRenderMode;
        if (t1 !== C.StageRenderMode_0)
          t1 = t1 === C.StageRenderMode_2;
        else
          t1 = true;
        if (t1) {
          stopwatch = new P.Stopwatch(0, 0);
          if ($.Stopwatch__frequency == null) {
            H.Primitives_initTicker();
            $.Stopwatch__frequency = $.Primitives_timerFrequency;
          }
          stopwatch.start$0(0);
          this._updateCanvasSize$0();
          R._dispatchBroadcastEvent(this._renderEvent, $.$get$_renderSubscriptions());
          this._renderContext.reset$0(0);
          t1 = this._renderContext;
          t2 = t1.renderStatistics;
          t2.drawCount = 0;
          t2.vertexCount = 0;
          t2.indexCount = 0;
          t1.clear$1(0, this.backgroundColor);
          this._renderState.reset$1(0, this._stageTransformation);
          this._renderState.currentTime = V.ensureNum(currentTime);
          this._renderState.deltaTime = V.ensureNum(deltaTime);
          this._renderState.renderObject$1(this);
          this._renderState._engine$_renderContext.flush$0(0);
          this._invalid = false;
          stats = this._renderContext.renderStatistics;
          t1 = stopwatch._stop;
          if (t1 == null)
            t1 = $.Primitives_timerTicks.call$0();
          frameTime = J.$tdiv$n(J.$mul$ns(J.$sub$n(t1, stopwatch._core$_start), 1000), $.Stopwatch__frequency);
          this._avgDrawCalls = this._avgDrawCalls * 0.75 + stats.drawCount * 0.25;
          this._avgVertexCount = this._avgVertexCount * 0.75 + stats.vertexCount * 0.25;
          this._avgIdexCount = this._avgIdexCount * 0.75 + stats.indexCount * 0.25;
          t1 = this._avgFrameTime;
          t2 = J.$mul$ns(frameTime, 0.05);
          if (typeof t2 !== "number")
            return H.iae(t2);
          this._avgFrameTime = t1 * 0.95 + t2;
          t1 = this._console;
          if (t1._display$_visible) {
            t1._off;
            t2 = true;
          } else
            t2 = false;
          if (t2) {
            t1.clear$0(0);
            this._console.print$1(0, "FRAMETIME" + C.JSString_methods.padLeft$1(C.JSInt_methods.toString$0(C.JSNumber_methods.round$0(this._avgFrameTime)), 6));
            this._console.print$1(0, "DRAWCALLS" + C.JSString_methods.padLeft$1(C.JSInt_methods.toString$0(C.JSNumber_methods.round$0(this._avgDrawCalls)), 6));
            this._console.print$1(0, "VERTICES" + C.JSString_methods.padLeft$1(C.JSInt_methods.toString$0(C.JSNumber_methods.round$0(this._avgVertexCount)), 7));
            this._console.print$1(0, "INDICES" + C.JSString_methods.padLeft$1(C.JSInt_methods.toString$0(C.JSNumber_methods.round$0(this._avgIdexCount)), 8));
            this._renderState.reset$1(0, this._consoleTransformation);
            this._renderState.renderObject$1(this._console);
            this._renderState._engine$_renderContext.flush$0(0);
          }
        }
        if (this._stageRenderMode === C.StageRenderMode_2)
          this._stageRenderMode = C.StageRenderMode_3;
      },
      _createRenderContext$2: function(canvas, options) {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, renderingContext, exception;
        t1 = options.renderEngine;
        if (t1 === C.RenderEngine_0)
          try {
            options.antialias;
            t1 = new T.Matrix3D(new Float32Array(H._checkLength(16)));
            t1.setIdentity$0();
            t2 = H.setRuntimeTypeInfo([], [L._MaskState]);
            t3 = P.String;
            t4 = [t3, P.int];
            t5 = [t3, P.UniformLocation];
            t6 = new L.RenderProgramSimple(-1, null, null, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t4), new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t5), new L.RenderBufferIndex(new Int16Array(H._checkLength(0)), 35048, 0, 0, -1, null, null, null), new L.RenderBufferVertex(new Float32Array(H._checkLength(0)), 35048, 0, 0, -1, null, null, null), new L.RenderStatistics(0, 0, 0));
            t7 = new Int16Array(H._checkLength(0));
            t8 = new Float32Array(H._checkLength(0));
            t9 = new Int16Array(H._checkLength(0));
            t10 = new Float32Array(H._checkLength(0));
            t11 = new Int16Array(H._checkLength(16384));
            t12 = new Float32Array(H._checkLength(32768));
            t13 = H.setRuntimeTypeInfo(new Array(8), [L.RenderTexture]);
            t14 = H.setRuntimeTypeInfo([], [L.RenderFrameBuffer]);
            t15 = [L.RenderContextEvent];
            t1 = new L.RenderContextWebGL(canvas, null, t1, t2, null, null, null, null, true, 0, t6, new L.RenderProgramTinted(-1, null, null, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t4), new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t5), new L.RenderBufferIndex(t7, 35048, 0, 0, -1, null, null, null), new L.RenderBufferVertex(t8, 35048, 0, 0, -1, null, null, null), new L.RenderStatistics(0, 0, 0)), new L.RenderProgramTriangle(-1, null, null, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t4), new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t5), new L.RenderBufferIndex(t9, 35048, 0, 0, -1, null, null, null), new L.RenderBufferVertex(t10, 35048, 0, 0, -1, null, null, null), new L.RenderStatistics(0, 0, 0)), new L.RenderBufferIndex(t11, 35048, 0, 0, -1, null, null, null), new L.RenderBufferVertex(t12, 35048, 0, 0, -1, null, null, null), t13, t14, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, L.RenderProgram]), new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t15), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t15));
            t2 = P.ContextEvent;
            W._EventStreamSubscription$(canvas, "webglcontextlost", t1.get$_onContextLost(), false, t2);
            W._EventStreamSubscription$(canvas, "webglcontextrestored", t1.get$_onContextRestored(), false, t2);
            renderingContext = C.CanvasElement_methods.getContext3d$6$alpha$antialias$depth$premultipliedAlpha$preserveDrawingBuffer$stencil(canvas, false, false, false, true, false, true);
            if (!J.getInterceptor(renderingContext).$isRenderingContext)
              H.throwExpression(new P.StateError("Failed to get WebGL context."));
            t1._renderingContext = renderingContext;
            renderingContext.enable(3042);
            t1._renderingContext.disable(2960);
            t1._renderingContext.disable(2929);
            t1._renderingContext.disable(2884);
            t1._renderingContext.pixelStorei(37441, 1);
            t1._renderingContext.blendFunc(1, 771);
            t1._activeRenderProgram = t6;
            t6.activate$1(0, t1);
            t1._contextValid = true;
            t2 = $.RenderContextWebGL__globalContextIdentifier + 1;
            $.RenderContextWebGL__globalContextIdentifier = t2;
            t1._contextIdentifier = t2;
            t1.reset$0(0);
            return t1;
          } catch (exception) {
            H.unwrapException(exception);
            t1 = T.Matrix$fromIdentity();
            t2 = C.CanvasElement_methods.get$context2D(canvas);
            t3 = [L.RenderContextEvent];
            t1 = new L.RenderContextCanvas(canvas, t2, t1, C.BlendMode_bZz, 1, new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t3), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t3));
            t1.reset$0(0);
            return t1;
          }
        else if (t1 === C.RenderEngine_1) {
          t1 = T.Matrix$fromIdentity();
          t2 = C.CanvasElement_methods.get$context2D(canvas);
          t3 = [L.RenderContextEvent];
          t1 = new L.RenderContextCanvas(canvas, t2, t1, C.BlendMode_bZz, 1, new L.RenderStatistics(0, 0, 0), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t3), new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, t3));
          t1.reset$0(0);
          return t1;
        } else
          throw H.wrapException(new P.StateError("Unknown RenderEngine"));
      },
      _startDrag$5: function(sprite, globalPoint, anchorPoint, bounds, touchPointID) {
        var drag, t1;
        drag = new A._Drag(this, sprite, anchorPoint, bounds, touchPointID);
        drag.update$2(0, touchPointID, globalPoint);
        t1 = this._drags;
        C.JSArray_methods.checkGrowable$1(t1, "removeWhere");
        C.JSArray_methods._removeWhere$2(t1, new A.Stage__startDrag_closure(sprite, touchPointID), true);
        t1.push(drag);
      },
      _stopDrag$1: function(sprite) {
        var t1 = this._drags;
        C.JSArray_methods.checkGrowable$1(t1, "removeWhere");
        C.JSArray_methods._removeWhere$2(t1, new A.Stage__stopDrag_closure(sprite), true);
      },
      _updateCanvasSize$0: function() {
        var sourceWidth, sourceHeight, clientRectangle, t1, t2, t3, t4, t5, clientWidth, clientHeight, ratioWidth, ratioHeight, scaleY, scaleX, pivotX, pivotY, t6;
        sourceWidth = this._sourceWidth;
        sourceHeight = this._sourceHeight;
        clientRectangle = this._display$_canvas.getBoundingClientRect();
        t1 = this._display$_canvas;
        t2 = t1.clientLeft;
        t3 = J.round$0$n(clientRectangle.left);
        if (typeof t2 !== "number")
          return t2.$add();
        t4 = t1.clientTop;
        t5 = J.round$0$n(clientRectangle.top);
        if (typeof t4 !== "number")
          return t4.$add();
        clientWidth = t1.clientWidth;
        clientHeight = t1.clientHeight;
        if (typeof clientWidth !== "number")
          throw H.wrapException("dart2js_hint");
        if (typeof clientHeight !== "number")
          throw H.wrapException("dart2js_hint");
        if (clientWidth === 0 || clientHeight === 0)
          return;
        ratioWidth = clientWidth / sourceWidth;
        ratioHeight = clientHeight / sourceHeight;
        switch (this._stageScaleMode) {
          case C.StageScaleMode_0:
            scaleY = ratioHeight;
            scaleX = ratioWidth;
            break;
          case C.StageScaleMode_1:
            scaleY = ratioWidth > ratioHeight ? ratioWidth : ratioHeight;
            scaleX = scaleY;
            break;
          case C.StageScaleMode_2:
            scaleX = 1;
            scaleY = 1;
            break;
          case C.StageScaleMode_3:
            scaleY = ratioWidth < ratioHeight ? ratioWidth : ratioHeight;
            scaleX = scaleY;
            break;
          default:
            scaleX = 1;
            scaleY = 1;
        }
        t1 = this._stageAlign;
        switch (t1) {
          case C.StageAlign_3:
          case C.StageAlign_6:
          case C.StageAlign_0:
            pivotX = 0;
            break;
          case C.StageAlign_1:
          case C.StageAlign_4:
          case C.StageAlign_7:
            pivotX = (clientWidth - sourceWidth * scaleX) / 2;
            break;
          case C.StageAlign_2:
          case C.StageAlign_5:
          case C.StageAlign_8:
            pivotX = clientWidth - sourceWidth * scaleX;
            break;
          default:
            pivotX = 0;
        }
        switch (t1) {
          case C.StageAlign_0:
          case C.StageAlign_1:
          case C.StageAlign_2:
            pivotY = 0;
            break;
          case C.StageAlign_3:
          case C.StageAlign_4:
          case C.StageAlign_5:
            pivotY = (clientHeight - sourceHeight * scaleY) / 2;
            break;
          case C.StageAlign_6:
          case C.StageAlign_7:
          case C.StageAlign_8:
            pivotY = clientHeight - sourceHeight * scaleY;
            break;
          default:
            pivotY = 0;
        }
        t1 = this._contentRectangle;
        t1.left = -pivotX / scaleX;
        t1.top = -pivotY / scaleY;
        t1.width = clientWidth / scaleX;
        t1.height = clientHeight / scaleY;
        t1 = this._stageTransformation;
        t1.setTo$6(scaleX, 0, 0, scaleY, pivotX, pivotY);
        t6 = this._display$_pixelRatio;
        t1.scale$2(0, t6, t6);
        t6 = this._clientTransformation;
        t6.setTo$6(1, 0, 0, 1, -(t2 + t3) - pivotX, -(t4 + t5) - pivotY);
        t6.scale$2(0, 1 / scaleX, 1 / scaleY);
        t6 = this._consoleTransformation;
        t6.identity$0();
        t5 = this._display$_pixelRatio;
        t6.scale$2(0, t5, t5);
        if (this._stageWidth !== clientWidth || this._stageHeight !== clientHeight) {
          this._stageWidth = clientWidth;
          this._stageHeight = clientHeight;
          t1 = this._display$_canvas;
          t2 = this._display$_pixelRatio;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1.width = C.JSNumber_methods.round$0(clientWidth * t2);
          t1.height = C.JSNumber_methods.round$0(clientHeight * t2);
          if (t1.clientWidth !== clientWidth || t1.clientHeight !== clientHeight) {
            t1 = t1.style;
            t2 = H.S(clientWidth) + "px";
            t1.width = t2;
            t1 = this._display$_canvas.style;
            t2 = H.S(clientHeight) + "px";
            t1.height = t2;
          }
          this.dispatchEvent$1(0, new R.Event("resize", false, C.EventPhase_1, null, null, false, false));
        }
      },
      _updateMouseCursor$0: function() {
        var mouseTarget, mouseCursor, mc, t1, cursorData, cursorDataUrl, t2, cursorDataX, cursorDataY, style;
        mouseTarget = this._mouseTarget;
        mouseCursor = $.Mouse__cursorName;
        if (mouseTarget != null && mouseCursor === "auto") {
          mc = mouseTarget.mouseCursor;
          if (mc != null && mc !== "auto")
            mouseCursor = mc;
        }
        if (mouseCursor === "auto")
          mouseCursor = "default";
        t1 = this._mouseCursor;
        if (t1 == null ? mouseCursor != null : t1 !== mouseCursor) {
          this._mouseCursor = mouseCursor;
          t1 = this._display$_canvas.style;
          if ($.$get$Mouse__cursorDatas().containsKey$1(0, mouseCursor)) {
            cursorData = $.$get$Mouse__cursorDatas().$index(0, mouseCursor);
            cursorDataUrl = J.get$url$x(cursorData);
            t2 = cursorData.get$hotSpot();
            cursorDataX = t2.get$x(t2);
            t2 = cursorData.get$hotSpot();
            cursorDataY = t2.get$y(t2);
            style = "url('" + H.S(cursorDataUrl) + "') " + H.S(cursorDataX) + " " + H.S(cursorDataY) + ", " + H.S(mouseCursor);
          } else
            style = mouseCursor;
          t2 = $.Mouse__cursorHidden ? "none" : style;
          t1.toString;
          t1.cursor = t2 == null ? "" : t2;
        }
      },
      _onMouseEvent$1: [function($event) {
        var t1, t2, button, stagePoint, localPoint, t3, mouseButton, target, p, oldTargetList, newTargetList, p0, t4, commonCount, t5, ot, t6, t7, t8, t9, i, target0, mouseEventType, isClick;
        t1 = J.getInterceptor$x($event);
        t1.preventDefault$0($event);
        t2 = Date.now();
        button = t1.get$button($event);
        stagePoint = this._clientTransformation.transformPoint$1(t1.get$client($event));
        localPoint = new U.Point(0, 0, [P.num]);
        if (typeof button !== "number")
          return button.$lt();
        if (button < 0 || button > 2)
          return;
        if (t1.get$type($event) === "mousemove" && this._mousePosition.$eq(0, stagePoint))
          return;
        t3 = this._mouseButtons;
        if (button < 0 || button >= 3)
          return H.ioore(t3, button);
        mouseButton = t3[button];
        this._mousePosition = stagePoint;
        C.JSArray_methods.forEach$1(this._drags, new A.Stage__onMouseEvent_closure(stagePoint));
        if (t1.get$type($event) !== "mouseout")
          target = this.hitTestInput$2(stagePoint.x, stagePoint.y);
        else {
          this.dispatchEvent$1(0, new R.Event("mouseLeave", false, C.EventPhase_1, null, null, false, false));
          target = null;
        }
        p = this._mouseTarget;
        if (p == null ? target != null : p !== target) {
          t3 = [A.DisplayObject];
          oldTargetList = H.setRuntimeTypeInfo([], t3);
          newTargetList = H.setRuntimeTypeInfo([], t3);
          for (p0 = p; p0 != null; p0 = p0._parent)
            oldTargetList.push(p0);
          for (p0 = target; p0 != null; p0 = p0._parent)
            newTargetList.push(p0);
          for (t3 = oldTargetList.length, t4 = newTargetList.length, commonCount = 0; true; ++commonCount) {
            if (commonCount === t3)
              break;
            if (commonCount === t4)
              break;
            t5 = t3 - commonCount - 1;
            if (t5 < 0)
              return H.ioore(oldTargetList, t5);
            ot = oldTargetList[t5];
            t5 = t4 - commonCount - 1;
            if (t5 < 0)
              return H.ioore(newTargetList, t5);
            if (ot !== newTargetList[t5])
              break;
          }
          if (p != null) {
            p.globalToLocal$2(stagePoint, localPoint);
            t3 = localPoint.x;
            t4 = localPoint.y;
            t5 = stagePoint.x;
            t6 = stagePoint.y;
            t7 = t1.get$altKey($event);
            t8 = t1.get$ctrlKey($event);
            t9 = t1.get$shiftKey($event);
            p.dispatchEvent$1(0, new R.MouseEvent(0, 0, mouseButton.buttonDown, 0, t3, t4, t5, t6, t7, t8, t9, false, "mouseOut", true, C.EventPhase_1, null, null, false, false));
          }
          for (i = 0; i < oldTargetList.length - commonCount; ++i) {
            target0 = oldTargetList[i];
            target0.globalToLocal$2(stagePoint, localPoint);
            t3 = localPoint.x;
            t4 = localPoint.y;
            t5 = stagePoint.x;
            t6 = stagePoint.y;
            t7 = t1.get$altKey($event);
            t8 = t1.get$ctrlKey($event);
            t9 = t1.get$shiftKey($event);
            target0.dispatchEvent$1(0, new R.MouseEvent(0, 0, mouseButton.buttonDown, 0, t3, t4, t5, t6, t7, t8, t9, false, "rollOut", false, C.EventPhase_1, null, null, false, false));
          }
          for (i = newTargetList.length - commonCount - 1; i >= 0; --i) {
            if (i >= newTargetList.length)
              return H.ioore(newTargetList, i);
            target0 = newTargetList[i];
            target0.globalToLocal$2(stagePoint, localPoint);
            t3 = localPoint.x;
            t4 = localPoint.y;
            t5 = stagePoint.x;
            t6 = stagePoint.y;
            t7 = t1.get$altKey($event);
            t8 = t1.get$ctrlKey($event);
            t9 = t1.get$shiftKey($event);
            target0.dispatchEvent$1(0, new R.MouseEvent(0, 0, mouseButton.buttonDown, 0, t3, t4, t5, t6, t7, t8, t9, false, "rollOver", false, C.EventPhase_1, null, null, false, false));
          }
          if (target != null) {
            target.globalToLocal$2(stagePoint, localPoint);
            t3 = localPoint.x;
            t4 = localPoint.y;
            t5 = stagePoint.x;
            t6 = stagePoint.y;
            t7 = t1.get$altKey($event);
            t8 = t1.get$ctrlKey($event);
            t9 = t1.get$shiftKey($event);
            target.dispatchEvent$1(0, new R.MouseEvent(0, 0, mouseButton.buttonDown, 0, t3, t4, t5, t6, t7, t8, t9, false, "mouseOver", true, C.EventPhase_1, null, null, false, false));
          }
          this._mouseTarget = target;
        }
        this._updateMouseCursor$0();
        if (t1.get$type($event) === "mousedown") {
          this._display$_canvas.focus();
          mouseEventType = mouseButton.mouseDownEventType;
          t3 = mouseButton.target;
          if ((target == null ? t3 != null : target !== t3) || t2 > mouseButton.clickTime + 500)
            mouseButton.clickCount = 0;
          mouseButton.buttonDown = true;
          mouseButton.target = target;
          mouseButton.clickTime = t2;
          ++mouseButton.clickCount;
        } else
          mouseEventType = null;
        if (t1.get$type($event) === "mouseup") {
          mouseEventType = mouseButton.mouseUpEventType;
          mouseButton.buttonDown = false;
          t2 = mouseButton.target;
          isClick = t2 == null ? target == null : t2 === target;
          isClick;
        } else
          isClick = false;
        if (t1.get$type($event) === "mousemove")
          mouseEventType = "mouseMove";
        if (t1.get$type($event) === "contextmenu")
          mouseEventType = "contextMenu";
        if (mouseEventType != null && target != null) {
          target.globalToLocal$2(stagePoint, localPoint);
          t2 = localPoint.x;
          t3 = localPoint.y;
          t4 = stagePoint.x;
          t5 = stagePoint.y;
          t6 = t1.get$altKey($event);
          t7 = t1.get$ctrlKey($event);
          t8 = t1.get$shiftKey($event);
          target.dispatchEvent$1(0, new R.MouseEvent(0, 0, mouseButton.buttonDown, mouseButton.clickCount, t2, t3, t4, t5, t6, t7, t8, false, mouseEventType, true, C.EventPhase_1, null, null, false, false));
          if (isClick) {
            t2 = localPoint.x;
            t3 = localPoint.y;
            t4 = stagePoint.x;
            t5 = stagePoint.y;
            t6 = t1.get$altKey($event);
            t7 = t1.get$ctrlKey($event);
            t1 = t1.get$shiftKey($event);
            target.dispatchEvent$1(0, new R.MouseEvent(0, 0, mouseButton.buttonDown, 0, t2, t3, t4, t5, t6, t7, t1, false, mouseButton.mouseClickEventType, true, C.EventPhase_1, null, null, false, false));
          }
        }
      }, "call$1", "get$_onMouseEvent", 2, 0, 58],
      _onMouseWheelEvent$1: [function($event) {
        var t1, stagePoint, localPoint, target, t2, t3, t4, t5, t6, t7, t8, mouseEvent;
        t1 = J.getInterceptor$x($event);
        stagePoint = this._clientTransformation.transformPoint$1(t1.get$client($event));
        localPoint = new U.Point(0, 0, [P.num]);
        target = this.hitTestInput$2(stagePoint.x, stagePoint.y);
        target.globalToLocal$2(stagePoint, localPoint);
        t2 = localPoint.x;
        t3 = localPoint.y;
        t4 = stagePoint.x;
        t5 = stagePoint.y;
        t6 = t1.get$altKey($event);
        t7 = t1.get$ctrlKey($event);
        t8 = t1.get$shiftKey($event);
        mouseEvent = new R.MouseEvent(t1.get$deltaX($event), t1.get$deltaY($event), false, 0, t2, t3, t4, t5, t6, t7, t8, false, "mouseWheel", true, C.EventPhase_1, null, null, false, false);
        target.dispatchEvent$1(0, mouseEvent);
        if (mouseEvent._isImmediatePropagationStopped)
          t1.stopImmediatePropagation$0($event);
        if (mouseEvent._isPropagationStopped)
          t1.stopPropagation$0($event);
        if (mouseEvent._isDefaultPrevented)
          t1.preventDefault$0($event);
      }, "call$1", "get$_onMouseWheelEvent", 2, 0, 59],
      _onTouchEvent$1: [function($event) {
        var t1, eventType, altKey, ctrlKey, shiftKey, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, _i, changedTouch, identifier, stagePoint, localPoint, target, touchPoint, touchPointID, primaryTouchPoint, t12, oldTarget, oldTargetList, newTargetList, p, commonCount, t13, t14, t15, ot, i, target0, touchEventType, isTap;
        t1 = J.getInterceptor$x($event);
        t1.preventDefault$0($event);
        eventType = t1.get$type($event);
        altKey = t1.get$altKey($event);
        ctrlKey = t1.get$ctrlKey($event);
        shiftKey = t1.get$shiftKey($event);
        for (t1 = t1.get$changedTouches($event), t2 = t1.length, t3 = eventType === "touchmove", t4 = eventType === "touchcancel", t5 = eventType === "touchend", t6 = eventType === "touchstart", t7 = this._touchPoints, t8 = this._drags, t9 = this._clientTransformation, t10 = [P.num], t11 = [A.DisplayObject], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          changedTouch = t1[_i];
          identifier = changedTouch.identifier;
          stagePoint = t9.transformPoint$1(C.Touch_methods.get$client(changedTouch));
          localPoint = new U.Point(0, 0, t10);
          target = this.super$DisplayObjectContainer$hitTestInput(stagePoint.x, stagePoint.y);
          target = target != null ? target : this;
          touchPoint = t7.putIfAbsent$2(0, identifier, new A.Stage__onTouchEvent_closure(this, target));
          touchPointID = touchPoint.get$touchPointID();
          primaryTouchPoint = touchPoint.get$primaryTouchPoint();
          C.JSArray_methods.forEach$1(t8, new A.Stage__onTouchEvent_closure0(stagePoint, touchPointID));
          t12 = J.getInterceptor$x(touchPoint);
          if (!J.$eq$(t12.get$currentTarget(touchPoint), target)) {
            oldTarget = t12.get$currentTarget(touchPoint);
            oldTargetList = H.setRuntimeTypeInfo([], t11);
            newTargetList = H.setRuntimeTypeInfo([], t11);
            for (p = oldTarget; p != null; p = J.get$parent$x(p))
              oldTargetList.push(p);
            for (p = target; p != null; p = p._parent)
              newTargetList.push(p);
            for (commonCount = 0; true; ++commonCount) {
              t13 = oldTargetList.length;
              if (commonCount === t13)
                break;
              t14 = newTargetList.length;
              if (commonCount === t14)
                break;
              t15 = t13 - commonCount - 1;
              if (t15 < 0)
                return H.ioore(oldTargetList, t15);
              ot = oldTargetList[t15];
              t15 = t14 - commonCount - 1;
              if (t15 < 0)
                return H.ioore(newTargetList, t15);
              if (!J.$eq$(ot, newTargetList[t15]))
                break;
            }
            if (oldTarget != null) {
              oldTarget.globalToLocal$2(stagePoint, localPoint);
              J.dispatchEvent$1$x(oldTarget, new R.TouchEvent(touchPointID, primaryTouchPoint, localPoint.x, localPoint.y, stagePoint.x, stagePoint.y, altKey, ctrlKey, shiftKey, false, "touchOut", true, C.EventPhase_1, null, null, false, false));
            }
            for (i = 0; i < oldTargetList.length - commonCount; ++i) {
              target0 = oldTargetList[i];
              target0.globalToLocal$2(stagePoint, localPoint);
              J.dispatchEvent$1$x(target0, new R.TouchEvent(touchPointID, primaryTouchPoint, localPoint.x, localPoint.y, stagePoint.x, stagePoint.y, altKey, ctrlKey, shiftKey, false, "touchRollOut", false, C.EventPhase_1, null, null, false, false));
            }
            for (i = newTargetList.length - commonCount - 1; i >= 0; --i) {
              if (i >= newTargetList.length)
                return H.ioore(newTargetList, i);
              target0 = newTargetList[i];
              target0.globalToLocal$2(stagePoint, localPoint);
              target0.dispatchEvent$1(0, new R.TouchEvent(touchPointID, primaryTouchPoint, localPoint.x, localPoint.y, stagePoint.x, stagePoint.y, altKey, ctrlKey, shiftKey, false, "touchRollOver", false, C.EventPhase_1, null, null, false, false));
            }
            target.globalToLocal$2(stagePoint, localPoint);
            target.dispatchEvent$1(0, new R.TouchEvent(touchPointID, primaryTouchPoint, localPoint.x, localPoint.y, stagePoint.x, stagePoint.y, altKey, ctrlKey, shiftKey, false, "touchOver", true, C.EventPhase_1, null, null, false, false));
            t12.set$currentTarget(touchPoint, target);
          }
          if (t6) {
            this._display$_canvas.focus();
            t7.$indexSet(0, identifier, touchPoint);
            touchEventType = "touchBegin";
          } else
            touchEventType = null;
          if (t5) {
            t7.remove$1(0, identifier);
            isTap = J.$eq$(t12.get$target(touchPoint), target);
            touchEventType = "touchEnd";
          } else
            isTap = false;
          if (t4) {
            t7.remove$1(0, identifier);
            touchEventType = "touchCancel";
          }
          if (t3)
            touchEventType = "touchMove";
          if (touchEventType != null && true) {
            target.globalToLocal$2(stagePoint, localPoint);
            target.dispatchEvent$1(0, new R.TouchEvent(touchPointID, primaryTouchPoint, localPoint.x, localPoint.y, stagePoint.x, stagePoint.y, altKey, ctrlKey, shiftKey, false, touchEventType, true, C.EventPhase_1, null, null, false, false));
            if (isTap)
              target.dispatchEvent$1(0, new R.TouchEvent(touchPointID, primaryTouchPoint, localPoint.x, localPoint.y, stagePoint.x, stagePoint.y, altKey, ctrlKey, shiftKey, false, "touchTap", true, C.EventPhase_1, null, null, false, false));
          }
        }
      }, "call$1", "get$_onTouchEvent", 2, 0, 60],
      _onKeyEvent$1: [function($event) {
        return;
      }, "call$1", "get$_onKeyEvent", 2, 0, 25],
      Stage$4$height$options$width: function(canvas, height, options, width) {
        var t1, t2, t3, t4;
        if (!J.getInterceptor(canvas).$isCanvasElement)
          throw H.wrapException(P.ArgumentError$("canvas"));
        t1 = canvas.tabIndex;
        if (typeof t1 !== "number")
          return t1.$le();
        if (t1 <= 0)
          canvas.tabIndex = 1;
        t1 = canvas.style;
        if (t1.outline === "")
          t1.outline = "none";
        width = canvas.width;
        height = canvas.height;
        this.backgroundColor = options.backgroundColor;
        this.preventDefaultOnTouch = true;
        this.preventDefaultOnMouse = true;
        this.preventDefaultOnWheel = false;
        this.preventDefaultOnKeyboard = false;
        this._display$_canvas = canvas;
        this._stageAlign = options.stageAlign;
        this._stageScaleMode = options.stageScaleMode;
        this._stageRenderMode = options.stageRenderMode;
        this._inputEventMode = options.inputEventMode;
        this._sourceWidth = V.ensureInt(width);
        this._sourceHeight = V.ensureInt(height);
        this._display$_pixelRatio = V.minNum(options.maxPixelRatio, $.$get$devicePixelRatio());
        t1 = this._createRenderContext$2(canvas, options);
        this._renderContext = t1;
        this._renderState = L.RenderState$(t1, null, null, null);
        t1 = H.setRuntimeTypeInfo([], [L.RenderTextureQuad]);
        t2 = T.Matrix$fromIdentity();
        t3 = H.setRuntimeTypeInfo([], [P.String]);
        t4 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t4 + 1;
        t4 = new A.StageConsole("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcAAAAAOAQAAAACQy/GuAAABsElEQVR4Aa3OMWsTUQDA8f97eV6fEpvT6YZgX4qDYwoOAdE+IQ5OfoXzG7S46KA8HZSC1PQLaNCln8ElFxyaQWg3XZQLBAyi5BqjJDHeE7whoE7i7xP8+He1Wq38WGkLIFmyphryV2JQAQnIhwE6tQCR6Sc3dq80tsBmQVTrHlSeVZvT8flwr3p7u3/Q27va3MnMWKEA2e0oRAjI8uWN1f3rZ9YjhNNU392Ud7bPckGuf9LB62sblQ874E3OqbEEefRyrsNRywFs5sL5FOIuizSqQ0IO2JMApMAA4DQS/77+dZEBgMIhVor/Wi6nkAIgHAvAw0zTCz3fkCDOubJD3IorDgifH+8yydrNvleQsLIaNPDuB1zkMIH+8MjACAknnr564vCf28dOg4n5QrnFAoFu1JmNF70i3MPGQIT1DiTp91h0gAQAbGkfBeRrcjrYwgAImAOMYf7rDUhAKchC7rsgRDyYxYCLO33FoAUWBaTkFD5WgQQkhnzzkqMweTtq+7tMhnin9YTDF4/chDftUsKcoW97B2RQEIC24GDJWsNvDAWRVrjHUgmWhOMPEf/DT5NSmGlKVHTvAAAAAElFTkSuQmCC", t1, t2, t3, 0, 0, t4, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        A.BitmapData_load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcAAAAAOAQAAAACQy/GuAAABsElEQVR4Aa3OMWsTUQDA8f97eV6fEpvT6YZgX4qDYwoOAdE+IQ5OfoXzG7S46KA8HZSC1PQLaNCln8ElFxyaQWg3XZQLBAyi5BqjJDHeE7whoE7i7xP8+He1Wq38WGkLIFmyphryV2JQAQnIhwE6tQCR6Sc3dq80tsBmQVTrHlSeVZvT8flwr3p7u3/Q27va3MnMWKEA2e0oRAjI8uWN1f3rZ9YjhNNU392Ud7bPckGuf9LB62sblQ874E3OqbEEefRyrsNRywFs5sL5FOIuizSqQ0IO2JMApMAA4DQS/77+dZEBgMIhVor/Wi6nkAIgHAvAw0zTCz3fkCDOubJD3IorDgifH+8yydrNvleQsLIaNPDuB1zkMIH+8MjACAknnr564vCf28dOg4n5QrnFAoFu1JmNF70i3MPGQIT1DiTp91h0gAQAbGkfBeRrcjrYwgAImAOMYf7rDUhAKchC7rsgRDyYxYCLO33FoAUWBaTkFD5WgQQkhnzzkqMweTtq+7tMhnin9YTDF4/chDftUsKcoW97B2RQEIC24GDJWsNvDAWRVrjHUgmWhOMPEf/DT5NSmGlKVHTvAAAAAElFTkSuQmCC", null).then$1(t4.get$_calculateGlyphs());
        t4._display$_visible = false;
        this._console = t4;
        P.print("StageXL render engine : " + this._renderContext.get$renderEngine()._engine$_name);
        t1 = W.KeyboardEvent;
        t2 = this.get$_onKeyEvent();
        W._EventStreamSubscription$(canvas, "keydown", t2, false, t1);
        W._EventStreamSubscription$(canvas, "keyup", t2, false, t1);
        W._EventStreamSubscription$(canvas, "keypress", t2, false, t1);
        t1 = this._inputEventMode;
        if (t1 === C.InputEventMode_0 || t1 === C.InputEventMode_2) {
          t1 = W.MouseEvent0;
          t2 = this.get$_onMouseEvent();
          W._EventStreamSubscription$(canvas, "mousedown", t2, false, t1);
          W._EventStreamSubscription$(canvas, "mouseup", t2, false, t1);
          W._EventStreamSubscription$(canvas, "mousemove", t2, false, t1);
          W._EventStreamSubscription$(canvas, "mouseout", t2, false, t1);
          W._EventStreamSubscription$(canvas, "contextmenu", t2, false, t1);
          W._EventStreamSubscription$(canvas, W.html_Element__determineMouseWheelEventType$closure().call$1(canvas), this.get$_onMouseWheelEvent(), false, W.WheelEvent);
        }
        t1 = this._inputEventMode;
        if ((t1 === C.InputEventMode_1 || t1 === C.InputEventMode_2) && $.$get$isTouchEventSupported() === true) {
          t1 = W.TouchEvent0;
          t2 = this.get$_onTouchEvent();
          W._EventStreamSubscription$(canvas, "touchstart", t2, false, t1);
          W._EventStreamSubscription$(canvas, "touchend", t2, false, t1);
          W._EventStreamSubscription$(canvas, "touchmove", t2, false, t1);
          W._EventStreamSubscription$(canvas, "touchenter", t2, false, t1);
          W._EventStreamSubscription$(canvas, "touchleave", t2, false, t1);
          W._EventStreamSubscription$(canvas, "touchcancel", t2, false, t1);
        }
        $.$get$Mouse_onCursorChanged().listen$1(new A.Stage_closure(this));
        this._updateMouseCursor$0();
        this._updateCanvasSize$0();
        this._renderContext.clear$1(0, this.backgroundColor);
      },
      static: {
        Stage$: function(canvas, height, options, width) {
          var t1, t2, t3, t4, t5, t6, t7, t8;
          t1 = P.num;
          t2 = T.Matrix$fromIdentity();
          t3 = T.Matrix$fromIdentity();
          t4 = T.Matrix$fromIdentity();
          t5 = H.setRuntimeTypeInfo([], [A._Drag]);
          t6 = new K.Juggler(null, null, 0, new P._AsyncBroadcastStreamController(null, null, 0, null, null, null, null, [t1]));
          t7 = new K._AnimatableLink(null, null);
          t6._firstAnimatableLink = t7;
          t6._lastAnimatableLink = t7;
          t7 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
          t8 = $.DisplayObject__nextID;
          $.DisplayObject__nextID = t8 + 1;
          t8 = new A.Stage(null, null, null, null, 0, 0, 0, 0, 1, false, 0, 0, 0, 0, new U.Rectangle0(0, 0, 0, 0, [t1]), t2, t3, t4, new R.RenderEvent("render", false, C.EventPhase_1, null, null, false, false), null, C.InputEventMode_0, C.StageRenderMode_0, C.StageScaleMode_3, C.StageAlign_4, "default", new U.Point(0, 0, [t1]), null, t5, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.int, A._TouchPoint]), [new A._MouseButton("mouseDown", "mouseUp", "click", "doubleClick", null, false, 0, 0), new A._MouseButton("middleMouseDown", "middleMouseUp", "middleClick", "middleClick", null, false, 0, 0), new A._MouseButton("rightMouseDown", "rightMouseUp", "rightClick", "rightClick", null, false, 0, 0)], t6, null, 4294967295, true, true, false, false, t7, true, true, false, true, "auto", true, 0, t8, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
          t8.Stage$4$height$options$width(canvas, height, options, width);
          return t8;
        }
      }
    },
    Stage_closure: {
      "^": "Closure:0;$this",
      call$1: [function(cursorName) {
        return this.$this._updateMouseCursor$0();
      }, null, null, 2, 0, null, 45, "call"]
    },
    Stage__startDrag_closure: {
      "^": "Closure:0;sprite,touchPointID",
      call$1: function(d) {
        return d.get$touchPointID() === this.touchPointID || d.get$sprite() === this.sprite;
      }
    },
    Stage__stopDrag_closure: {
      "^": "Closure:0;sprite",
      call$1: function(d) {
        return d.get$sprite() === this.sprite;
      }
    },
    Stage__onMouseEvent_closure: {
      "^": "Closure:0;stagePoint",
      call$1: function(d) {
        return J.update$2$x(d, 0, this.stagePoint);
      }
    },
    Stage__onTouchEvent_closure: {
      "^": "Closure:1;$this,target",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.target;
        t2 = this.$this._touchPoints;
        t2 = t2.get$isEmpty(t2);
        t3 = $._TouchPoint__globalTouchPointID;
        $._TouchPoint__globalTouchPointID = t3 + 1;
        return new A._TouchPoint(t3, t2, t1, t1);
      }
    },
    Stage__onTouchEvent_closure0: {
      "^": "Closure:0;stagePoint,touchPointID",
      call$1: function(d) {
        return J.update$2$x(d, this.touchPointID, this.stagePoint);
      }
    },
    StageConsole: {
      "^": "DisplayObject;_fontImage,_glyphs,_matrix,_lines,_consoleWidth,_consoleHeight,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      clear$0: function(_) {
        C.JSArray_methods.set$length(this._lines, 0);
        this._consoleWidth = 0;
        this._consoleHeight = 0;
      },
      print$1: function(_, line) {
        var t1, t2;
        this._lines.push(line);
        t1 = line.length;
        t2 = this._consoleWidth;
        this._consoleWidth = t1 > t2 ? t1 : t2;
        ++this._consoleHeight;
      },
      render$1: function(renderState) {
        var t1, t2, t3, t4, y, t5, x, t6, index;
        this.dispatchEvent$1(0, new R.Event("Update", false, C.EventPhase_1, null, null, false, false));
        for (t1 = this._matrix, t2 = this._glyphs, t3 = renderState._engine$_renderContext, t4 = this._lines, y = 0; y < this._consoleHeight; ++y)
          for (t5 = y * 14, x = 0; x < this._consoleWidth; ++x) {
            if (y >= t4.length)
              return H.ioore(t4, y);
            t6 = t4[y];
            index = x < t6.length ? C.JSString_methods._codeUnitAt$1(t6, x) - 32 : 0;
            if (index < 0 || index >= 64)
              index = 0;
            t1.setTo$6(1, 0, 0, 1, x * 7, t5);
            renderState.push$3(t1, 1, C.BlendMode_bZz);
            if (index < 0 || index >= t2.length)
              return H.ioore(t2, index);
            t3.renderTextureQuad$2(renderState, t2[index]);
            renderState._currentContextState = renderState._currentContextState.previousContextState;
          }
      },
      _calculateGlyphs$1: [function(fontBitmapData) {
        var t1, t2, i;
        fontBitmapData.get$renderTexture().set$filtering(C.RenderTextureFiltering_9728);
        for (t1 = [P.int], t2 = this._glyphs, i = 0; i < 64; ++i)
          t2.push(fontBitmapData.get$renderTextureQuad().cut$1(new U.Rectangle0(i * 7, 0, 7, 14, t1)));
      }, "call$1", "get$_calculateGlyphs", 2, 0, 61]
    },
    StageOptions: {
      "^": "Object;renderEngine,inputEventMode,stageRenderMode,stageScaleMode,stageAlign,backgroundColor,transparent,antialias,maxPixelRatio,preventDefaultOnTouch,preventDefaultOnMouse,preventDefaultOnWheel,preventDefaultOnKeyboard"
    },
    _MouseButton: {
      "^": "Object;mouseDownEventType,mouseUpEventType,mouseClickEventType,mouseDoubleClickEventType,target>,buttonDown<,clickTime,clickCount"
    },
    _TouchPoint: {
      "^": "Object;touchPointID<,primaryTouchPoint<,target>,currentTarget*"
    },
    _Drag: {
      "^": "Object;stage<,sprite<,anchor,bounds,touchPointID<",
      update$2: function(_, touchPointID, stagePoint) {
        var t1, localPoint, parentPoint, visible, t2;
        if (touchPointID !== this.touchPointID)
          return;
        t1 = [P.num];
        localPoint = new U.Point(0, 0, t1);
        parentPoint = new U.Point(0, 0, t1);
        t1 = this.sprite;
        visible = t1._display$_visible;
        t1.globalToLocal$2(stagePoint, localPoint);
        t2 = this.anchor;
        localPoint.x = J.$sub$n(J.$add$ns(localPoint.x, t1._pivotX), t2.x);
        localPoint.y = J.$sub$n(J.$add$ns(localPoint.y, t1._pivotY), t2.y);
        t1.localToParent$2(localPoint, parentPoint);
        t1._display$_visible = false;
        t1.dropTarget = this.stage.hitTestInput$2(stagePoint.x, stagePoint.y);
        t1.set$x(0, parentPoint.x);
        t1.set$y(0, parentPoint.y);
        t1._display$_visible = visible;
      }
    }
  }], ["stagexl.drawing", "package:stagexl/src/drawing.dart",, U, {
    "^": "",
    GraphicsCommandBeginPath: {
      "^": "GraphicsCommand;_drawing$_graphics",
      updateContext$1: function(context) {
        context.beginPath$0(0);
      }
    },
    GraphicsCommandBezierCurveTo: {
      "^": "GraphicsCommand;_controlX1,_controlY1,_controlX2,_controlY2,_endX,_endY,_drawing$_graphics",
      updateContext$1: function(context) {
        context.bezierCurveTo$6(0, this._controlX1, this._controlY1, this._controlX2, this._controlY2, this._endX, this._endY);
      }
    },
    GraphicsCommandCircle: {
      "^": "GraphicsCommand;_drawing$_x,_drawing$_y,_radius,_antiClockwise,_drawing$_graphics",
      get$x: function(_) {
        return this._drawing$_x;
      },
      set$x: function(_, value) {
        var t1;
        this._drawing$_x = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      get$y: function(_) {
        return this._drawing$_y;
      },
      set$y: function(_, value) {
        var t1;
        this._drawing$_y = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      updateContext$1: function(context) {
        var t1 = this._radius;
        context.moveTo$2(0, this._drawing$_x + t1, this._drawing$_y);
        context.arc$6(0, this._drawing$_x, this._drawing$_y, t1, 0, 6.283185307179586, false);
        context.closePath$0(0);
      },
      static: {
        GraphicsCommandCircle$: function(x, y, radius, antiClockwise) {
          return new U.GraphicsCommandCircle(J.toDouble$0$n(x), J.toDouble$0$n(y), radius, false, null);
        }
      }
    },
    GraphicsCommandClosePath: {
      "^": "GraphicsCommand;_drawing$_graphics",
      updateContext$1: function(context) {
        context.closePath$0(0);
      }
    },
    GraphicsCommandFill: {
      "^": "GraphicsCommand;"
    },
    GraphicsCommandFillColor: {
      "^": "GraphicsCommandFill;_drawing$_color,_drawing$_graphics",
      updateContext$1: function(context) {
        context.fillColor$1(this._drawing$_color);
      }
    },
    GraphicsCommandLineTo: {
      "^": "GraphicsCommand;_drawing$_x,_drawing$_y,_drawing$_graphics",
      get$x: function(_) {
        return this._drawing$_x;
      },
      set$x: function(_, value) {
        var t1;
        this._drawing$_x = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      get$y: function(_) {
        return this._drawing$_y;
      },
      set$y: function(_, value) {
        var t1;
        this._drawing$_y = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      updateContext$1: function(context) {
        context.lineTo$2(0, this._drawing$_x, this._drawing$_y);
      }
    },
    GraphicsCommandMoveTo: {
      "^": "GraphicsCommand;_drawing$_x,_drawing$_y,_drawing$_graphics",
      get$x: function(_) {
        return this._drawing$_x;
      },
      set$x: function(_, value) {
        var t1;
        this._drawing$_x = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      get$y: function(_) {
        return this._drawing$_y;
      },
      set$y: function(_, value) {
        var t1;
        this._drawing$_y = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      updateContext$1: function(context) {
        context.moveTo$2(0, this._drawing$_x, this._drawing$_y);
      }
    },
    GraphicsCommandRect: {
      "^": "GraphicsCommand;_drawing$_x,_drawing$_y,_drawing$_width,_drawing$_height,_drawing$_graphics",
      get$x: function(_) {
        return this._drawing$_x;
      },
      set$x: function(_, value) {
        var t1;
        this._drawing$_x = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      get$y: function(_) {
        return this._drawing$_y;
      },
      set$y: function(_, value) {
        var t1;
        this._drawing$_y = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      get$width: function(_) {
        return this._drawing$_width;
      },
      set$width: function(_, value) {
        var t1;
        this._drawing$_width = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      },
      get$height: function(_) {
        return this._drawing$_height;
      },
      updateContext$1: function(context) {
        var t1, t2;
        context.moveTo$2(0, this._drawing$_x, this._drawing$_y);
        t1 = this._drawing$_x;
        t2 = this._drawing$_width;
        if (typeof t2 !== "number")
          return H.iae(t2);
        context.lineTo$2(0, t1 + t2, this._drawing$_y);
        t2 = this._drawing$_x;
        t1 = this._drawing$_width;
        if (typeof t1 !== "number")
          return H.iae(t1);
        context.lineTo$2(0, t2 + t1, this._drawing$_y + this._drawing$_height);
        context.lineTo$2(0, this._drawing$_x, this._drawing$_y + this._drawing$_height);
        context.closePath$0(0);
      },
      static: {
        GraphicsCommandRect$: function(x, y, width, height) {
          return new U.GraphicsCommandRect(x, y, J.toDouble$0$n(width), J.toDouble$0$n(height), null);
        }
      }
    },
    GraphicsCommandStroke: {
      "^": "GraphicsCommand;",
      get$width: function(_) {
        return this._drawing$_width;
      },
      set$width: function(_, value) {
        var t1;
        this._drawing$_width = value;
        t1 = this._drawing$_graphics;
        if (!(t1 == null)) {
          C.JSArray_methods.set$length(t1._compiledCommands, 0);
          t1._bounds = null;
        }
      }
    },
    GraphicsCommandStrokeColor: {
      "^": "GraphicsCommandStroke;_drawing$_color,_drawing$_width,_jointStyle,_capsStyle,_drawing$_graphics",
      updateContext$1: function(context) {
        context.strokeColor$4(this._drawing$_color, this._drawing$_width, this._jointStyle, this._capsStyle);
      }
    },
    Graphics: {
      "^": "Object;_originalCommands,_compiledCommands,_bounds",
      clear$0: function(_) {
        var t1, t2, _i;
        for (t1 = this._originalCommands, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i]._setGraphics$1(null);
        C.JSArray_methods.set$length(t1, 0);
        C.JSArray_methods.set$length(this._compiledCommands, 0);
        this._bounds = null;
      },
      beginPath$0: function(_) {
        var command = new U.GraphicsCommandBeginPath(null);
        command._setGraphics$1(this);
        this._originalCommands.push(command);
        C.JSArray_methods.set$length(this._compiledCommands, 0);
        this._bounds = null;
        return command;
      },
      closePath$0: function(_) {
        var command = new U.GraphicsCommandClosePath(null);
        command._setGraphics$1(this);
        this._originalCommands.push(command);
        C.JSArray_methods.set$length(this._compiledCommands, 0);
        this._bounds = null;
        return command;
      },
      moveTo$2: function(_, x, y) {
        var command = new U.GraphicsCommandMoveTo(J.toDouble$0$n(x), J.toDouble$0$n(y), null);
        command._setGraphics$1(this);
        this._originalCommands.push(command);
        C.JSArray_methods.set$length(this._compiledCommands, 0);
        this._bounds = null;
        return command;
      },
      lineTo$2: function(_, x, y) {
        var command = new U.GraphicsCommandLineTo(J.toDouble$0$n(x), J.toDouble$0$n(y), null);
        command._setGraphics$1(this);
        this._originalCommands.push(command);
        C.JSArray_methods.set$length(this._compiledCommands, 0);
        this._bounds = null;
        return command;
      },
      fillColor$1: function(color) {
        var command = new U.GraphicsCommandFillColor(color, null);
        command._setGraphics$1(this);
        this._originalCommands.push(command);
        C.JSArray_methods.set$length(this._compiledCommands, 0);
        this._bounds = null;
        return command;
      },
      get$bounds: function() {
        var t1, commands, context;
        t1 = this._bounds;
        if (t1 == null) {
          commands = this._getCommands$1(true);
          context = new U._GraphicsContextBounds(17976931348623157e292, 17976931348623157e292, -17976931348623157e292, -17976931348623157e292, new U._GraphicsPath(null, H.setRuntimeTypeInfo([], [U._GraphicsPathSegment])));
          this._updateContext$2(context, commands);
          t1 = context.get$bounds();
          this._bounds = t1;
        }
        return new U.Rectangle0(t1.left, t1.top, t1.width, t1.height, [H.getTypeArgumentByIndex(t1, 0)]);
      },
      hitTest$2: function(localX, localY) {
        var commands, context;
        if (this.get$bounds().contains$2(0, localX, localY)) {
          commands = this._getCommands$1(true);
          context = new U._GraphicsContextHitTest(false, J.toDouble$0$n(localX), J.toDouble$0$n(localY), new U._GraphicsPath(null, H.setRuntimeTypeInfo([], [U._GraphicsPathSegment])));
          this._updateContext$2(context, commands);
          return context._hit;
        } else
          return false;
      },
      render$1: function(renderState) {
        var commands;
        if (renderState._engine$_renderContext instanceof L.RenderContextCanvas) {
          commands = this._getCommands$1(false);
          this._updateContext$2(U._GraphicsContextCanvas$(renderState), commands);
        } else {
          commands = this._getCommands$1(true);
          this._updateContext$2(new U._GraphicsContextRender(renderState, new U._GraphicsPath(null, H.setRuntimeTypeInfo([], [U._GraphicsPathSegment]))), commands);
        }
      },
      _getCommands$1: function(useCompiled) {
        var context, t1, t2, _i;
        if (useCompiled && this._compiledCommands.length === 0) {
          context = new U._GraphicsContextCompiler(this._compiledCommands, new U._GraphicsPath(null, H.setRuntimeTypeInfo([], [U._GraphicsPathSegment])));
          for (t1 = this._originalCommands, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
            t1[_i].updateContext$1(context);
        }
        return useCompiled ? this._compiledCommands : this._originalCommands;
      },
      _updateContext$2: function(context, commands) {
        var i;
        for (i = 0; i < commands.length; ++i)
          commands[i].updateContext$1(context);
      }
    },
    GraphicsCommand: {
      "^": "Object;",
      _setGraphics$1: function(graphics) {
        if (this._drawing$_graphics != null && graphics != null)
          throw H.wrapException(P.ArgumentError$("Command is already assigned to graphics."));
        else
          this._drawing$_graphics = graphics;
      }
    },
    GraphicsContext: {
      "^": "Object;"
    },
    JointStyle: {
      "^": "Object;index,_drawing$_name",
      toString$0: function(_) {
        return this._drawing$_name;
      }
    },
    CapsStyle: {
      "^": "Object;index,_drawing$_name",
      toString$0: function(_) {
        return this._drawing$_name;
      }
    },
    _GraphicsCommandMeshColor: {
      "^": "GraphicsCommand;mesh,color,_drawing$_graphics",
      updateContext$1: function(context) {
        if (!!context.$is_GraphicsContextBase)
          context.meshColor$1(this);
      }
    },
    _GraphicsContextBase: {
      "^": "GraphicsContext;",
      beginPath$0: function(_) {
        this._path = new U._GraphicsPath(null, H.setRuntimeTypeInfo([], [U._GraphicsPathSegment]));
      },
      closePath$0: function(_) {
        var t1, t2;
        t1 = this._path;
        t2 = t1._currentSegment;
        if (t2 != null) {
          t2._closed = true;
          t1._currentSegment = null;
        }
      },
      moveTo$2: function(_, x, y) {
        this._path.moveTo$2(0, x, y);
      },
      lineTo$2: function(_, x, y) {
        this._path.lineTo$2(0, x, y);
      },
      bezierCurveTo$6: function(_, controlX1, controlY1, controlX2, controlY2, endX, endY) {
        this._path.bezierCurveTo$6(0, controlX1, controlY1, controlX2, controlY2, endX, endY);
      },
      arc$6: function(_, x, y, radius, startAngle, endAngle, antiClockwise) {
        this._path.arc$6(0, x, y, radius, startAngle, endAngle, false);
      }
    },
    _GraphicsContextBounds: {
      "^": "_GraphicsContextBase;_minX,_minY,_maxX,_maxY,_path",
      get$minX: function() {
        return this._minX;
      },
      get$minY: function() {
        return this._minY;
      },
      get$maxX: function() {
        return this._maxX;
      },
      get$maxY: function() {
        return this._maxY;
      },
      get$bounds: function() {
        var t1, t2, t3, t4;
        t1 = this._minX;
        t2 = this._maxX;
        t3 = t1 < t2 && this._minY < this._maxY;
        t4 = [P.num];
        if (t3) {
          t3 = this._minY;
          return new U.Rectangle0(t1, t3, t2 - t1, this._maxY - t3, t4);
        } else
          return new U.Rectangle0(0, 0, 0, 0, t4);
      },
      fillColor$1: function(color) {
        this._updateBoundsForMesh$1(this._path);
      },
      strokeColor$4: function(color, width, jointStyle, capsStyle) {
        this._updateBoundsForMesh$1(U._GraphicsStroke$(this._path, width, jointStyle, capsStyle));
      },
      meshColor$1: function(command) {
        this._updateBoundsForMesh$1(command.mesh);
      },
      _updateBoundsForMesh$1: function(mesh) {
        var t1, t2, _i, meshSegment;
        for (t1 = mesh.segments, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          meshSegment = t1[_i];
          this._minX = this._minX > meshSegment.get$minX() ? meshSegment.get$minX() : this._minX;
          this._minY = this._minY > meshSegment.get$minY() ? meshSegment.get$minY() : this._minY;
          this._maxX = this._maxX < meshSegment.get$maxX() ? meshSegment.get$maxX() : this._maxX;
          this._maxY = this._maxY < meshSegment.get$maxY() ? meshSegment.get$maxY() : this._maxY;
        }
      }
    },
    _GraphicsContextCanvas: {
      "^": "GraphicsContext;renderState,_drawing$_renderContext,_canvasContext",
      beginPath$0: function(_) {
        this._canvasContext.beginPath();
      },
      closePath$0: function(_) {
        this._canvasContext.closePath();
      },
      moveTo$2: function(_, x, y) {
        this._canvasContext.moveTo(x, y);
      },
      lineTo$2: function(_, x, y) {
        this._canvasContext.lineTo(x, y);
      },
      bezierCurveTo$6: function(_, controlX1, controlY1, controlX2, controlY2, endX, endY) {
        this._canvasContext.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
      },
      arc$6: function(_, x, y, radius, startAngle, endAngle, antiClockwise) {
        var t1 = this._canvasContext;
        t1.toString;
        t1.arc(x, y, radius, startAngle, endAngle, false);
      },
      fillColor$1: function(color) {
        var t1 = this._canvasContext;
        t1.fillStyle = V.color2rgba(color);
        t1.toString;
        t1.fill("nonzero");
      },
      strokeColor$4: function(color, width, jointStyle, capsStyle) {
        var t1, lineJoin, lineCap;
        t1 = this._canvasContext;
        t1.strokeStyle = V.color2rgba(color);
        t1.lineWidth = width;
        lineJoin = jointStyle === C.JointStyle_0 ? "miter" : "round";
        t1.lineJoin = jointStyle === C.JointStyle_2 ? "bevel" : lineJoin;
        lineCap = capsStyle === C.CapsStyle_0 ? "butt" : "round";
        t1.lineCap = capsStyle === C.CapsStyle_2 ? "square" : lineCap;
        t1.stroke();
      },
      _GraphicsContextCanvas$1: function(renderState) {
        var t1, t2;
        t1 = this._drawing$_renderContext;
        t1.setTransform$1(0, renderState._currentContextState.matrix);
        t2 = renderState._currentContextState.alpha;
        t1._activeAlpha = t2;
        t1._renderingContext.globalAlpha = t2;
        this._canvasContext.beginPath();
      },
      static: {
        _GraphicsContextCanvas$: function(renderState) {
          var t1 = H.interceptedTypeCast(renderState._engine$_renderContext, "$isRenderContextCanvas");
          t1 = new U._GraphicsContextCanvas(renderState, t1, t1._renderingContext);
          t1._GraphicsContextCanvas$1(renderState);
          return t1;
        }
      }
    },
    _GraphicsContextCompiler: {
      "^": "_GraphicsContextBase;commands,_path",
      fillColor$1: function(color) {
        this.commands.push(new U._GraphicsCommandMeshColor(U._GraphicsPath$clone(this._path), color, null));
      },
      strokeColor$4: function(color, width, jointStyle, capsStyle) {
        this.commands.push(new U._GraphicsCommandMeshColor(U._GraphicsStroke$(this._path, width, jointStyle, capsStyle), color, null));
      },
      meshColor$1: function(command) {
        this.commands.push(command);
      }
    },
    _GraphicsContextHitTest: {
      "^": "_GraphicsContextBase;_hit,_localX,_localY,_path",
      fillColor$1: function(color) {
        var mesh = this._path;
        this._hit = this._hit || mesh.hitTest$2(this._localX, this._localY);
      },
      strokeColor$4: function(color, width, jointStyle, capsStyle) {
        var mesh = U._GraphicsStroke$(this._path, width, jointStyle, capsStyle);
        this._hit = this._hit || mesh.hitTest$2(this._localX, this._localY);
      },
      meshColor$1: function(command) {
        this._hit = this._hit || command.mesh.hitTest$2(this._localX, this._localY);
      }
    },
    _GraphicsContextRender: {
      "^": "_GraphicsContextBase;renderState,_path",
      fillColor$1: function(color) {
        this._path.fillColor$2(this.renderState, color);
      },
      strokeColor$4: function(color, width, jointStyle, capsStyle) {
        U._GraphicsStroke$(this._path, width, jointStyle, capsStyle).fillColor$2(this.renderState, color);
      },
      meshColor$1: function(command) {
        command.mesh.fillColor$2(this.renderState, command.color);
      }
    },
    _GraphicsMesh: {
      "^": "Object;$ti"
    },
    _GraphicsMeshSegment: {
      "^": "Object;_vertexBuffer<,_indexBuffer<",
      get$vertexCount: function() {
        return this._vertexCount;
      },
      get$indexCount: function() {
        return this._indexCount;
      },
      get$lastVertexX: function() {
        var t1, t2;
        t1 = this._vertexBuffer;
        t2 = this._vertexCount * 2 - 2;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        return t1[t2];
      },
      get$lastVertexY: function() {
        var t1, t2;
        t1 = this._vertexBuffer;
        t2 = this._vertexCount * 2 - 1;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        return t1[t2];
      },
      get$firstVertexX: function() {
        var t1 = this._vertexBuffer;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return t1[0];
      },
      get$firstVertexY: function() {
        var t1 = this._vertexBuffer;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        return t1[1];
      },
      get$minX: function() {
        return this._minX;
      },
      get$minY: function() {
        return this._minY;
      },
      get$maxX: function() {
        return this._maxX;
      },
      get$maxY: function() {
        return this._maxY;
      },
      checkBounds$2: function(x, y) {
        return x >= this._minX && x <= this._maxX && y >= this._minY && y <= this._maxY;
      },
      addVertex$2: ["super$_GraphicsMeshSegment$addVertex", function(x, y) {
        var offset, t1, $length, extend, t2, t3;
        offset = this._vertexCount * 2;
        t1 = this._vertexBuffer;
        $length = t1.length;
        if (offset + 2 > $length) {
          extend = $length < 16 ? 16 : $length;
          if (extend > 256)
            extend = 256;
          t2 = new Float32Array($length + extend);
          this._vertexBuffer = t2;
          C.NativeFloat32List_methods.setAll$2(t2, 0, t1);
        }
        t1 = this._minX;
        this._minX = t1 > x ? x : t1;
        t1 = this._minY;
        this._minY = t1 > y ? y : t1;
        t1 = this._maxX;
        this._maxX = t1 < x ? x : t1;
        t1 = this._maxY;
        this._maxY = t1 < y ? y : t1;
        t1 = this._vertexBuffer;
        t2 = t1.length;
        if (offset >= t2)
          return H.ioore(t1, offset);
        t1[offset] = x;
        t3 = offset + 1;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = y;
        return this._vertexCount++;
      }],
      addIndices$3: function(index1, index2, index3) {
        var offset, t1, $length, extend, t2, t3;
        offset = this._indexCount;
        t1 = this._indexBuffer;
        $length = t1.length;
        if (offset + 3 > $length) {
          extend = $length < 32 ? 32 : $length;
          if (extend > 256)
            extend = 256;
          t2 = new Int16Array($length + extend);
          this._indexBuffer = t2;
          C.NativeInt16List_methods.setAll$2(t2, 0, t1);
        }
        t1 = this._indexBuffer;
        t2 = t1.length;
        if (offset >= t2)
          return H.ioore(t1, offset);
        t1[offset] = index1;
        t3 = offset + 1;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = index2;
        t3 = offset + 2;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = index3;
        this._indexCount += 3;
      },
      fillColor$2: function(renderState, color) {
        var t1, t2, ixList;
        t1 = this._indexBuffer.buffer;
        t2 = this._indexCount;
        t1.toString;
        ixList = H.NativeInt16List_NativeInt16List$view(t1, 0, t2);
        t2 = this._vertexBuffer.buffer;
        t1 = this._vertexCount;
        t2.toString;
        renderState._engine$_renderContext.renderTriangleMesh$4(renderState, ixList, H.NativeFloat32List_NativeFloat32List$view(t2, 0, t1 * 2), color);
      },
      _GraphicsMeshSegment$clone$1: function(mesh) {
        this._vertexCount = mesh.get$vertexCount();
        this._indexCount = mesh.get$indexCount();
        this._minX = mesh.get$minX();
        this._minY = mesh.get$minY();
        this._maxX = mesh.get$maxX();
        this._maxY = mesh.get$maxY();
        C.NativeFloat32List_methods.setRange$3(this._vertexBuffer, 0, this._vertexCount * 2, mesh.get$_vertexBuffer());
        C.NativeInt16List_methods.setRange$3(this._indexBuffer, 0, this._indexCount, mesh.get$_indexBuffer());
      }
    },
    _GraphicsPath: {
      "^": "_GraphicsMesh;_currentSegment,segments",
      moveTo$2: function(_, x, y) {
        var t1 = T.Matrix$fromIdentity();
        t1 = new U._GraphicsPathSegment(null, false, new Float32Array(H._checkLength(16)), new Int16Array(H._checkLength(32)), 0, 0, 17976931348623157e292, 17976931348623157e292, -17976931348623157e292, -17976931348623157e292, t1);
        this._currentSegment = t1;
        t1.addVertex$2(x, y);
        this.segments.push(this._currentSegment);
      },
      lineTo$2: function(_, x, y) {
        var t1 = this._currentSegment;
        if (t1 == null)
          this.moveTo$2(0, x, y);
        else
          t1.addVertex$2(x, y);
      },
      bezierCurveTo$6: function(_, controlX1, controlY1, controlX2, controlY2, endX, endY) {
        var t1, t2, t3, t4, vx, vy, s, t00, b0, b1, b2, b3;
        t1 = this._currentSegment;
        if (t1 == null)
          this.moveTo$2(0, endY, endY);
        else {
          t2 = t1._vertexBuffer;
          t1 = t1._vertexCount * 2;
          t3 = t1 - 2;
          t4 = t2.length;
          if (t3 < 0 || t3 >= t4)
            return H.ioore(t2, t3);
          vx = t2[t3];
          --t1;
          if (t1 < 0 || t1 >= t4)
            return H.ioore(t2, t1);
          vy = t2[t1];
          for (s = 1; s <= 20; ++s) {
            t00 = s / 20;
            t1 = 1 - t00;
            b0 = t1 * t1 * t1;
            b1 = t00 * t1 * t1 * 3;
            t2 = t00 * t00;
            b2 = t2 * t1 * 3;
            b3 = t2 * t00;
            this._currentSegment.addVertex$2(b0 * vx + b1 * controlX1 + b2 * controlX2 + b3 * endX, b0 * vy + b1 * controlY1 + b2 * controlY2 + b3 * endY);
          }
        }
      },
      arc$6: function(_, x, y, radius, startAngle, endAngle, antiClockwise) {
        var start, delta, steps, t1, cosR, sinR, tx, ty, ax, ay, s, bx, by;
        start = C.JSInt_methods.$mod(startAngle, 6.283185307179586);
        delta = C.JSNumber_methods.$mod(endAngle, 6.283185307179586) - start;
        if (endAngle < startAngle) {
          if (delta <= 0)
            delta += 6.283185307179586;
        } else
          delta = endAngle - startAngle >= 6.283185307179586 ? 6.283185307179586 : C.JSDouble_methods.$mod(delta, 6.283185307179586);
        steps = C.JSNumber_methods.ceil$0(Math.abs(60 * delta / 6.283185307179586));
        t1 = delta / steps;
        cosR = Math.cos(t1);
        sinR = Math.sin(t1);
        tx = x - x * cosR + y * sinR;
        ty = y - x * sinR - y * cosR;
        ax = x + Math.cos(start) * radius;
        ay = y + Math.sin(start) * radius;
        this.lineTo$2(0, ax, ay);
        for (s = 1; s <= steps; ++s, ay = by, ax = bx) {
          bx = ax * cosR - ay * sinR + tx;
          by = ax * sinR + ay * cosR + ty;
          this._currentSegment.addVertex$2(bx, by);
        }
      },
      fillColor$2: function(renderState, color) {
        var t1, t2, _i, segment;
        for (t1 = this.segments, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          segment = t1[_i];
          if (segment.get$indexCount() === 0)
            segment.calculateIndices$0();
          segment.fillColor$2(renderState, color);
        }
      },
      hitTest$2: function(x, y) {
        var t1, t2, windingCount, _i, segment;
        for (t1 = this.segments, t2 = t1.length, windingCount = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          segment = t1[_i];
          if (!segment.checkBounds$2(x, y))
            continue;
          if (segment.get$indexCount() === 0)
            segment.calculateIndices$0();
          windingCount += segment.windingCountHitTest$2(x, y);
        }
        return windingCount !== 0;
      },
      _GraphicsPath$clone$1: function(path) {
        var t1, t2, t3, _i, segment, t4, t5, t6;
        for (t1 = path.segments, t2 = t1.length, t3 = this.segments, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          segment = t1[_i];
          if (segment.get$indexCount() === 0)
            segment.calculateIndices$0();
          t4 = T.Matrix$fromIdentity();
          t5 = segment.get$vertexCount();
          t5 = new Float32Array(t5 * 2);
          t6 = segment.get$indexCount();
          t4 = new U._GraphicsPathSegment(null, false, t5, new Int16Array(t6), 0, 0, 17976931348623157e292, 17976931348623157e292, -17976931348623157e292, -17976931348623157e292, t4);
          t4._GraphicsMeshSegment$clone$1(segment);
          t4._clockwise = segment.get$clockwise();
          t4._closed = segment.get$closed(segment);
          t3.push(t4);
        }
      },
      $as_GraphicsMesh: function() {
        return [U._GraphicsPathSegment];
      },
      static: {
        _GraphicsPath$clone: function(path) {
          var t1 = new U._GraphicsPath(null, H.setRuntimeTypeInfo([], [U._GraphicsPathSegment]));
          t1._GraphicsPath$clone$1(path);
          return t1;
        }
      }
    },
    _GraphicsPathSegment: {
      "^": "_GraphicsMeshSegment;_clockwise,_closed,_vertexBuffer,_indexBuffer,_vertexCount,_indexCount,_minX,_minY,_maxX,_maxY,_tmpMatrix",
      get$clockwise: function() {
        var t1 = this._clockwise;
        if (typeof t1 !== "boolean") {
          t1 = this._calculateArea$0() >= 0;
          this._clockwise = t1;
        }
        return t1;
      },
      get$closed: function(_) {
        return this._closed;
      },
      addVertex$2: function(x, y) {
        var buf, ofs, t1, t2;
        buf = this._vertexBuffer;
        ofs = this._vertexCount * 2;
        if (ofs !== 0) {
          t1 = ofs - 2;
          t2 = buf.length;
          if (t1 < 0 || t1 >= t2)
            return H.ioore(buf, t1);
          if (V.similar(buf[t1], x, 0.0001)) {
            t1 = ofs - 1;
            if (t1 < 0 || t1 >= t2)
              return H.ioore(buf, t1);
            t1 = !V.similar(buf[t1], y, 0.0001);
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1) {
          this._indexCount = 0;
          this._clockwise = null;
          return this.super$_GraphicsMeshSegment$addVertex(x, y);
        } else
          return this._vertexCount - 1;
      },
      calculateIndices$0: function() {
        this._calculateIndices$0();
      },
      windingCountHitTest$2: function(x, y) {
        var t1, t2, t3, t4, ax, ay, wn, i, bx, by;
        if (this._minX > x || this._maxX < x)
          return 0;
        if (this._minY > y || this._maxY < y)
          return 0;
        t1 = this._vertexCount;
        if (t1 < 3)
          return 0;
        t2 = this._vertexBuffer;
        t3 = (t1 - 1) * 2;
        t4 = t2.length;
        if (t3 < 0 || t3 >= t4)
          return H.ioore(t2, t3);
        ax = t2[t3];
        ++t3;
        if (t3 >= t4)
          return H.ioore(t2, t3);
        ay = t2[t3];
        for (wn = 0, i = 0; i < t1; ++i, ay = by, ax = bx) {
          t3 = i * 2;
          if (t3 >= t4)
            return H.ioore(t2, t3);
          bx = t2[t3];
          ++t3;
          if (t3 >= t4)
            return H.ioore(t2, t3);
          by = t2[t3];
          if (ay <= y) {
            if (by > y && (bx - ax) * (y - ay) - (x - ax) * (by - ay) > 0)
              ++wn;
          } else if (by <= y && (bx - ax) * (y - ay) - (x - ax) * (by - ay) < 0)
            --wn;
        }
        return wn;
      },
      _calculateIndices$0: function() {
        var buffer, count, available, clockwise, p, t1, t2, index, t3, i0, index0, i1, i2, t4, x1, y1, x2, y2, x3, x31, y31, x21, y21, tmp, earFound, t5, t6, t7, t8, u, v, j, vi, t9, x01, y01;
        this._indexCount = 0;
        buffer = this._vertexBuffer;
        count = this._vertexCount;
        if (count < 3)
          return;
        available = H.setRuntimeTypeInfo([], [P.int]);
        clockwise = this.get$clockwise();
        for (p = 0; p < count; ++p)
          available.push(p);
        for (t1 = buffer.length, t2 = clockwise === true, index = 0; t3 = available.length, t3 > 3;) {
          i0 = available[C.JSInt_methods.$mod(index, t3)];
          index0 = index + 1;
          i1 = available[index0 % t3];
          i2 = available[(index + 2) % t3];
          t4 = i0 * 2;
          if (t4 >= t1)
            return H.ioore(buffer, t4);
          x1 = buffer[t4];
          ++t4;
          if (t4 >= t1)
            return H.ioore(buffer, t4);
          y1 = buffer[t4];
          t4 = i1 * 2;
          if (t4 >= t1)
            return H.ioore(buffer, t4);
          x2 = buffer[t4];
          ++t4;
          if (t4 >= t1)
            return H.ioore(buffer, t4);
          y2 = buffer[t4];
          t4 = i2 * 2;
          if (t4 >= t1)
            return H.ioore(buffer, t4);
          x3 = buffer[t4];
          ++t4;
          if (t4 >= t1)
            return H.ioore(buffer, t4);
          x31 = x3 - x1;
          y31 = buffer[t4] - y1;
          x21 = x2 - x1;
          y21 = y2 - y1;
          tmp = y31 * x21 - x31 * y21;
          earFound = t2 ? tmp >= 0 : tmp <= 0;
          t4 = tmp * x21;
          t5 = tmp * y21;
          t6 = tmp * y31;
          t7 = tmp * x31;
          t8 = tmp * tmp;
          u = 0;
          v = 0;
          j = 0;
          while (true) {
            if (!(j < t3 && earFound))
              break;
            if (j >= t3)
              return H.ioore(available, j);
            vi = available[j];
            if (vi !== i0 && vi !== i1 && vi !== i2) {
              t9 = vi * 2;
              if (t9 >= t1)
                return H.ioore(buffer, t9);
              x01 = buffer[t9] - x1;
              ++t9;
              if (t9 >= t1)
                return H.ioore(buffer, t9);
              y01 = buffer[t9] - y1;
              u = t4 * y01 - t5 * x01;
              if (u >= 0) {
                v = t6 * x01 - t7 * y01;
                if (v >= 0)
                  earFound = u + v < t8 ? false : earFound;
              }
            }
            ++j;
          }
          if (earFound) {
            this.addIndices$3(i0, i1, i2);
            C.JSArray_methods.removeAt$1(available, index0 % available.length);
            index = 0;
          } else {
            if (index > 3 * t3)
              break;
            index = index0;
          }
        }
        if (0 >= t3)
          return H.ioore(available, 0);
        t1 = available[0];
        if (1 >= t3)
          return H.ioore(available, 1);
        t2 = available[1];
        if (2 >= t3)
          return H.ioore(available, 2);
        this.addIndices$3(t1, t2, available[2]);
      },
      _calculateArea$0: function() {
        var buffer, count, t1, t2, x1, y1, value, i, x2, y2;
        buffer = this._vertexBuffer;
        count = this._vertexCount;
        if (count < 3)
          return 0;
        t1 = (count - 1) * 2;
        t2 = buffer.length;
        if (t1 < 0 || t1 >= t2)
          return H.ioore(buffer, t1);
        x1 = buffer[t1];
        ++t1;
        if (t1 >= t2)
          return H.ioore(buffer, t1);
        y1 = buffer[t1];
        for (value = 0, i = 0; i < count; ++i, y1 = y2, x1 = x2) {
          t1 = i * 2;
          if (t1 >= t2)
            return H.ioore(buffer, t1);
          x2 = buffer[t1];
          ++t1;
          if (t1 >= t2)
            return H.ioore(buffer, t1);
          y2 = buffer[t1];
          value += (x1 - x2) * (y1 + y2);
        }
        return value / 2;
      }
    },
    _GraphicsStroke: {
      "^": "_GraphicsMesh;width>,jointStyle,capsStyle,segments",
      fillColor$2: function(renderState, color) {
        var t1, t2, _i;
        for (t1 = this.segments, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].fillColor$2(renderState, color);
      },
      hitTest$2: function(x, y) {
        var t1, t2, _i, segment;
        for (t1 = this.segments, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          segment = t1[_i];
          if (!segment.checkBounds$2(x, y))
            continue;
          if (segment.hitTest$2(x, y))
            return true;
        }
        return false;
      },
      _GraphicsStroke$4: function(path, width, jointStyle, capsStyle) {
        var t1, t2, t3, _i, pathSegment, t4, t5, t6;
        for (t1 = path.segments, t2 = t1.length, t3 = this.segments, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          pathSegment = t1[_i];
          t4 = pathSegment.get$vertexCount();
          t5 = pathSegment.get$vertexCount();
          t6 = T.Matrix$fromIdentity();
          t4 = new Float32Array(t4 * 4);
          t4 = new U._GraphicsStrokeSegment(this, -1, -1, t4, new Int16Array(t5 * 6), 0, 0, 17976931348623157e292, 17976931348623157e292, -17976931348623157e292, -17976931348623157e292, t6);
          t4._calculateStroke$1(pathSegment);
          t3.push(t4);
        }
      },
      $as_GraphicsMesh: function() {
        return [U._GraphicsStrokeSegment];
      },
      static: {
        _GraphicsStroke$: function(path, width, jointStyle, capsStyle) {
          var t1 = new U._GraphicsStroke(width, jointStyle, capsStyle, H.setRuntimeTypeInfo([], [U._GraphicsStrokeSegment]));
          t1._GraphicsStroke$4(path, width, jointStyle, capsStyle);
          return t1;
        }
      }
    },
    _GraphicsStrokeSegment: {
      "^": "_GraphicsMeshSegment;stroke,_jointIndex1,_jointIndex2,_vertexBuffer,_indexBuffer,_vertexCount,_indexCount,_minX,_minY,_maxX,_maxY,_tmpMatrix",
      hitTest$2: function(px, py) {
        var t1, t2, t3, t4, t5, i, o1, t6, o2, o3, x1, x2, x3, y1, y2, y3, ab, bc, ca;
        for (t1 = this._indexCount - 2, t2 = this._vertexBuffer, t3 = t2.length, t4 = this._indexBuffer, t5 = t4.length, i = 0; i < t1; i += 3) {
          if (i >= t5)
            return H.ioore(t4, i);
          o1 = t4[i] * 2;
          t6 = i + 1;
          if (t6 >= t5)
            return H.ioore(t4, t6);
          o2 = t4[t6] * 2;
          t6 = i + 2;
          if (t6 >= t5)
            return H.ioore(t4, t6);
          o3 = t4[t6] * 2;
          if (o1 < 0 || o1 >= t3)
            return H.ioore(t2, o1);
          x1 = t2[o1] - px;
          if (o2 < 0 || o2 >= t3)
            return H.ioore(t2, o2);
          x2 = t2[o2] - px;
          if (o3 < 0 || o3 >= t3)
            return H.ioore(t2, o3);
          x3 = t2[o3] - px;
          if (x1 > 0 && x2 > 0 && x3 > 0)
            continue;
          if (x1 < 0 && x2 < 0 && x3 < 0)
            continue;
          t6 = o1 + 1;
          if (t6 >= t3)
            return H.ioore(t2, t6);
          y1 = t2[t6] - py;
          t6 = o2 + 1;
          if (t6 >= t3)
            return H.ioore(t2, t6);
          y2 = t2[t6] - py;
          t6 = o3 + 1;
          if (t6 >= t3)
            return H.ioore(t2, t6);
          y3 = t2[t6] - py;
          if (y1 > 0 && y2 > 0 && y3 > 0)
            continue;
          if (y1 < 0 && y2 < 0 && y3 < 0)
            continue;
          ab = x1 * y2 - x2 * y1;
          bc = x2 * y3 - x3 * y2;
          ca = x3 * y1 - x1 * y3;
          if (ab >= 0 && bc >= 0 && ca >= 0)
            return true;
          if (ab <= 0 && bc <= 0 && ca <= 0)
            return true;
        }
        return false;
      },
      _calculateStroke$1: function(pathSegment) {
        var t1, width, jointStyle, capsStyle, vertices, $length, $closed, ax, ay, bx, by, t2, t3, t4, t5, t6, t7, v1x, v1y, v1l, n1x, n1y, i, i0, offset, v2x, t8, v2y, vx, vy, v2l, n2x, n2y, t9, t10, t11, i1, i2, it, itAbs, jointStyle0, vmx, vmy, isOverlap, i20, i3, i4, i5, t12, t13, t14, t15, t16, x1, y1, x2, y2;
        t1 = this.stroke;
        width = t1.width;
        jointStyle = t1.jointStyle;
        capsStyle = t1.capsStyle;
        vertices = pathSegment.get$_vertexBuffer();
        $length = pathSegment.get$vertexCount();
        t1 = J.getInterceptor$x(pathSegment);
        $closed = t1.get$closed(pathSegment);
        if (t1.get$closed(pathSegment) === true && $length >= 2) {
          ax = pathSegment.get$firstVertexX();
          ay = pathSegment.get$firstVertexY();
          bx = pathSegment.get$lastVertexX();
          by = pathSegment.get$lastVertexY();
          if (ax === bx && ay === by)
            --$length;
        }
        if ($length <= 1)
          return;
        for (t1 = $length - 1, t2 = vertices.length, t3 = $closed === false, t4 = $closed === true, t5 = jointStyle !== C.JointStyle_0, t6 = capsStyle === C.CapsStyle_1, t7 = capsStyle === C.CapsStyle_2, v1x = 0, v1y = 0, v1l = 0, n1x = 0, n1y = 0, i = -2; i <= $length; i = i0, n1y = n2y, n1x = n2x, v1l = v2l, v1y = v2y, v1x = v2x) {
          i0 = i + 1;
          offset = C.JSInt_methods.$mod(i0, $length) * 2;
          if (offset < 0 || offset >= t2)
            return H.ioore(vertices, offset);
          v2x = vertices[offset];
          t8 = offset + 1;
          if (t8 >= t2)
            return H.ioore(vertices, t8);
          v2y = vertices[t8];
          vx = v2x - v1x;
          vy = v1y - v2y;
          t8 = Math.sqrt(vx * vx + vy * vy);
          if (typeof width !== "number")
            return H.iae(width);
          v2l = t8 / (0.5 * width);
          n2x = vy / v2l;
          n2y = vx / v2l;
          if (i === 0 && t3)
            if (t7) {
              this._jointIndex1 = this.addVertex$2(v1x + n2x - n2y, v1y + n2y + n2x);
              this._jointIndex2 = this.addVertex$2(v1x - n2x - n2y, v1y - n2y + n2x);
            } else {
              t8 = v1x + n2x;
              t9 = v1x - n2x;
              t10 = v1y + n2y;
              t11 = v1y - n2y;
              if (t6) {
                this._jointIndex1 = this.addVertex$2(t8, t10);
                t8 = this.addVertex$2(t9, t11);
                this._jointIndex2 = t8;
                this._addArc$9(v1x, v1y, -n2x, -n2y, n2x, n2y, this._jointIndex1, t8, true);
              } else {
                this._jointIndex1 = this.addVertex$2(t8, t10);
                this._jointIndex2 = this.addVertex$2(t9, t11);
              }
            }
          else if (i === t1 && t3) {
            i1 = this._jointIndex1;
            i2 = this._jointIndex2;
            if (t7) {
              this._jointIndex1 = this.addVertex$2(v1x + n1x + n1y, v1y + n1y - n1x);
              this._jointIndex2 = this.addVertex$2(v1x - n1x + n1y, v1y - n1y - n1x);
            } else {
              t8 = v1y - n1y;
              t9 = v1x + n1x;
              t10 = v1x - n1x;
              t11 = v1y + n1y;
              if (t6) {
                this._jointIndex1 = this.addVertex$2(t9, t11);
                t8 = this.addVertex$2(t10, t8);
                this._jointIndex2 = t8;
                this._addArc$9(v1x, v1y, n1x, n1y, -n1x, -n1y, t8, this._jointIndex1, true);
              } else {
                this._jointIndex1 = this.addVertex$2(t9, t11);
                this._jointIndex2 = this.addVertex$2(t10, t8);
              }
            }
            this.addIndices$3(i1, i2, this._jointIndex1);
            this.addIndices$3(i2, this._jointIndex1, this._jointIndex2);
          } else {
            if (i >= 0)
              t8 = i < $length || t4;
            else
              t8 = false;
            if (t8) {
              it = (n2x * (n1x - n2x) + n2y * (n1y - n2y)) / (n2x * n1y - n2y * n1x);
              itAbs = Math.abs(it);
              if (isNaN(it)) {
                it = 0;
                itAbs = 0;
              }
              jointStyle0 = t5 && itAbs < 0.1 ? C.JointStyle_0 : jointStyle;
              if (jointStyle0 === C.JointStyle_0 && itAbs > 10)
                jointStyle0 = C.JointStyle_2;
              vmx = n1x - it * n1y;
              vmy = n1y + it * n1x;
              isOverlap = itAbs > v1l || itAbs > v2l;
              i2 = this._jointIndex1;
              t8 = it >= 0;
              i1 = t8 ? i2 : this._jointIndex2;
              i20 = t8 ? this._jointIndex2 : i2;
              if (jointStyle0 === C.JointStyle_0) {
                if (!isOverlap) {
                  i3 = this._jointIndex2;
                  i4 = this.addVertex$2(v1x + vmx, v1y + vmy);
                  this._jointIndex1 = i4;
                  i5 = this.addVertex$2(v1x - vmx, v1y - vmy);
                  this._jointIndex2 = i5;
                } else {
                  t9 = v1x + n2x;
                  t10 = v1x - n2x;
                  t11 = v1y + n2y;
                  t12 = v1y - n2y;
                  if (t8) {
                    i3 = this.addVertex$2(v1x + n1x, v1y + n1y);
                    i4 = this.addVertex$2(v1x - vmx, v1y - vmy);
                    i5 = this.addVertex$2(t10, t12);
                    this._jointIndex2 = i5;
                    this._jointIndex1 = this.addVertex$2(t9, t11);
                    this.addIndices$3(i1, i3, i4);
                  } else {
                    i3 = this.addVertex$2(v1x - n1x, v1y - n1y);
                    i4 = this.addVertex$2(v1x + vmx, v1y + vmy);
                    i5 = this.addVertex$2(t9, t11);
                    this._jointIndex1 = i5;
                    this._jointIndex2 = this.addVertex$2(t10, t12);
                    this.addIndices$3(i1, i3, i4);
                  }
                }
                this.addIndices$3(i1, i20, i4);
                this.addIndices$3(i3, i4, i5);
              } else if (jointStyle0 === C.JointStyle_2) {
                t9 = !isOverlap;
                if (t9 && t8) {
                  i3 = this.addVertex$2(v1x + vmx, v1y + vmy);
                  this._jointIndex1 = i3;
                  i4 = this.addVertex$2(v1x - n1x, v1y - n1y);
                  i5 = this.addVertex$2(v1x - n2x, v1y - n2y);
                  this._jointIndex2 = i5;
                } else if (t9) {
                  i3 = this.addVertex$2(v1x - vmx, v1y - vmy);
                  this._jointIndex2 = i3;
                  i4 = this.addVertex$2(v1x + n1x, v1y + n1y);
                  i5 = this.addVertex$2(v1x + n2x, v1y + n2y);
                  this._jointIndex1 = i5;
                } else {
                  t9 = v1y - n1y;
                  t10 = v1x + n1x;
                  t11 = v1y + n2y;
                  t12 = v1y + n1y;
                  t13 = v1x - n2x;
                  t14 = v1x - n1x;
                  t15 = v1y - n2y;
                  t16 = v1x + n2x;
                  if (t8) {
                    i3 = this.addVertex$2(t10, t12);
                    i4 = this.addVertex$2(t14, t9);
                    i5 = this.addVertex$2(t13, t15);
                    this._jointIndex2 = i5;
                    this._jointIndex1 = this.addVertex$2(t16, t11);
                  } else {
                    i3 = this.addVertex$2(t14, t9);
                    i4 = this.addVertex$2(t10, t12);
                    i5 = this.addVertex$2(t16, t11);
                    this._jointIndex1 = i5;
                    this._jointIndex2 = this.addVertex$2(t13, t15);
                  }
                }
                this.addIndices$3(i1, i20, i3);
                this.addIndices$3(i20, i3, i4);
                this.addIndices$3(i3, i4, i5);
              } else if (jointStyle0 === C.JointStyle_1) {
                t9 = !isOverlap;
                if (t9 && t8) {
                  i3 = this.addVertex$2(v1x + vmx, v1y + vmy);
                  this._jointIndex1 = i3;
                  i4 = this.addVertex$2(v1x - n1x, v1y - n1y);
                  this._jointIndex2 = this._addArc$9(v1x, v1y, -n1x, -n1y, -n2x, -n2y, i3, i4, false);
                } else if (t9) {
                  i3 = this.addVertex$2(v1x - vmx, v1y - vmy);
                  this._jointIndex2 = i3;
                  i4 = this.addVertex$2(v1x + n1x, v1y + n1y);
                  this._jointIndex1 = this._addArc$9(v1x, v1y, n1x, n1y, n2x, n2y, i3, i4, true);
                } else {
                  t9 = v1y - n1y;
                  t10 = v1x + n1x;
                  t11 = v1x - n1x;
                  t12 = v1y + n1y;
                  if (t8) {
                    i3 = this.addVertex$2(t10, t12);
                    i4 = this.addVertex$2(t11, t9);
                    this._jointIndex1 = this.addVertex$2(v1x + n2x, v1y + n2y);
                    this._jointIndex2 = this._addArc$9(v1x, v1y, -n1x, -n1y, -n2x, -n2y, i3, i4, false);
                  } else {
                    i3 = this.addVertex$2(t11, t9);
                    i4 = this.addVertex$2(t10, t12);
                    this._jointIndex2 = this.addVertex$2(v1x - n2x, v1y - n2y);
                    this._jointIndex1 = this._addArc$9(v1x, v1y, n1x, n1y, n2x, n2y, i3, i4, true);
                  }
                }
                this.addIndices$3(i1, i20, i3);
                this.addIndices$3(i20, i3, i4);
              }
              if (i2 < 0) {
                t8 = this._vertexBuffer;
                t9 = this._jointIndex1 * 2;
                t10 = t8.length;
                if (t9 < 0 || t9 >= t10)
                  return H.ioore(t8, t9);
                x1 = t8[t9];
                ++t9;
                if (t9 >= t10)
                  return H.ioore(t8, t9);
                y1 = t8[t9];
                t9 = this._jointIndex2 * 2;
                if (t9 < 0 || t9 >= t10)
                  return H.ioore(t8, t9);
                x2 = t8[t9];
                ++t9;
                if (t9 >= t10)
                  return H.ioore(t8, t9);
                y2 = t8[t9];
                this._vertexCount = 0;
                this._indexCount = 0;
                this._jointIndex1 = this.addVertex$2(x1, y1);
                this._jointIndex2 = this.addVertex$2(x2, y2);
              }
            }
          }
        }
      },
      _addArc$9: function(vx, vy, n1x, n1y, n2x, n2y, index1, index2, antiClockwise) {
        var startAngle, endAngle, start, delta, steps, t1, cosR, sinR, tx, ty, ax, ay, index3, s, bx, by, index;
        startAngle = Math.atan2(n1y, n1x);
        endAngle = Math.atan2(n2y, n2x);
        start = C.JSNumber_methods.$mod(startAngle, 6.283185307179586);
        delta = C.JSNumber_methods.$mod(endAngle, 6.283185307179586) - start;
        if (antiClockwise && endAngle > startAngle) {
          if (delta >= 0)
            delta -= 6.283185307179586;
        } else if (antiClockwise)
          delta = C.JSDouble_methods.$mod(delta, 6.283185307179586) - 6.283185307179586;
        else if (endAngle < startAngle) {
          if (delta <= 0)
            delta += 6.283185307179586;
        } else
          delta = C.JSDouble_methods.$mod(delta, 6.283185307179586);
        steps = C.JSNumber_methods.ceil$0(Math.abs(10 * delta / 3.141592653589793));
        t1 = delta / steps;
        cosR = Math.cos(t1);
        sinR = Math.sin(t1);
        tx = vx - vx * cosR + vy * sinR;
        ty = vy - vx * sinR - vy * cosR;
        ax = vx + n1x;
        ay = vy + n1y;
        for (index3 = index2, s = 0; s < steps; ++s, ay = by, ax = bx, index3 = index) {
          bx = ax * cosR - ay * sinR + tx;
          by = ax * sinR + ay * cosR + ty;
          index = this.addVertex$2(bx, by);
          this.addIndices$3(index1, index3, index);
        }
        return index3;
      }
    }
  }], ["stagexl.engine", "package:stagexl/src/engine.dart",, L, {
    "^": "",
    _globalFrameRequest: function() {
      if ($._globalFrameCallbackId === -1) {
        var t1 = window;
        C.Window_methods._ensureRequestAnimationFrame$0(t1);
        $._globalFrameCallbackId = C.Window_methods._requestAnimationFrame$1(t1, W._wrapZone(new L._globalFrameRequest_closure()));
      }
    },
    BlendMode: {
      "^": "Object;srcFactor,dstFactor,compositeOperation"
    },
    RenderBufferIndex: {
      "^": "Object;data,usage,position,count,_contextIdentifier,_engine$_buffer,_renderingContext,_renderStatistics",
      activate$1: function(_, renderContext) {
        var t1, t2;
        t1 = this._contextIdentifier;
        t2 = renderContext._contextIdentifier;
        if (t1 !== t2) {
          this._contextIdentifier = t2;
          this._renderStatistics = renderContext.renderStatistics;
          t1 = renderContext._renderingContext;
          this._renderingContext = t1;
          t1 = t1.createBuffer();
          this._engine$_buffer = t1;
          this._renderingContext.bindBuffer(34963, t1);
          this._renderingContext.bufferData(34963, this.data, this.usage);
        }
        this._renderingContext.bindBuffer(34963, this._engine$_buffer);
      }
    },
    RenderBufferVertex: {
      "^": "Object;data,usage,position,count,_contextIdentifier,_engine$_buffer,_renderingContext,_renderStatistics",
      activate$1: function(_, renderContext) {
        var t1, t2;
        t1 = this._contextIdentifier;
        t2 = renderContext._contextIdentifier;
        if (t1 !== t2) {
          this._contextIdentifier = t2;
          this._renderStatistics = renderContext.renderStatistics;
          t1 = renderContext._renderingContext;
          this._renderingContext = t1;
          t1 = t1.createBuffer();
          this._engine$_buffer = t1;
          this._renderingContext.bindBuffer(34962, t1);
          this._renderingContext.bufferData(34962, this.data, this.usage);
        }
        this._renderingContext.bindBuffer(34962, this._engine$_buffer);
      },
      bindAttribute$4: function(index, size, stride, offset) {
        if (index == null)
          return;
        this._renderingContext.vertexAttribPointer(index, size, 5126, false, stride, offset);
      }
    },
    RenderEngine: {
      "^": "Object;index,_engine$_name",
      toString$0: function(_) {
        return this._engine$_name;
      }
    },
    RenderContextEvent: {
      "^": "Object;"
    },
    RenderContext: {
      "^": "Object;"
    },
    RenderContextCanvas: {
      "^": "RenderContext;_canvasElement,_renderingContext,_identityMatrix,_activeBlendMode,_activeAlpha,renderStatistics,_contextLostEvent,_contextRestoredEvent",
      get$renderEngine: function() {
        return C.RenderEngine_1;
      },
      reset$0: function(_) {
        var t1;
        this.setTransform$1(0, this._identityMatrix);
        this._activeBlendMode = C.BlendMode_bZz;
        t1 = this._renderingContext;
        t1.globalCompositeOperation = "source-over";
        this._activeAlpha = 1;
        t1.globalAlpha = 1;
      },
      clear$1: function(_, color) {
        var t1, alpha, t2, t3;
        this.setTransform$1(0, this._identityMatrix);
        this._activeBlendMode = C.BlendMode_bZz;
        t1 = this._renderingContext;
        t1.globalCompositeOperation = "source-over";
        this._activeAlpha = 1;
        t1.globalAlpha = 1;
        alpha = color >>> 24 & 255;
        if (alpha < 255) {
          t2 = this._canvasElement;
          t3 = J.getInterceptor$x(t2);
          t1.clearRect(0, 0, t3.get$width(t2), t3.get$height(t2));
        }
        if (alpha > 0) {
          t1.fillStyle = V.color2rgba(color);
          t2 = this._canvasElement;
          t3 = J.getInterceptor$x(t2);
          t1.fillRect(0, 0, t3.get$width(t2), t3.get$height(t2));
        }
      },
      flush$0: function(_) {
      },
      beginRenderMask$2: function(renderState, mask) {
        var t1, t2;
        t1 = this._renderingContext;
        t2 = renderState._currentContextState.matrix._data;
        t1.setTransform(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
        t1.beginPath();
        mask.renderMask$1(renderState);
        t1.save();
        t1.clip();
      },
      endRenderMask$2: function(renderState, mask) {
        var t1 = this._renderingContext;
        t1.restore();
        t1.globalAlpha = this._activeAlpha;
        t1.globalCompositeOperation = this._activeBlendMode.compositeOperation;
        J.get$border$x(mask);
      },
      renderTextureQuad$2: [function(renderState, renderTextureQuad) {
        var context, source, rotation, sourceRect, vxList, matrix, alpha, blendMode, t1, t2, t3, t4, t5, t6;
        if (renderTextureQuad.get$hasCustomVertices()) {
          this.renderTextureMesh$4(renderState, renderTextureQuad.get$renderTexture(), renderTextureQuad.get$ixList(), renderTextureQuad.get$vxList());
          return;
        }
        context = this._renderingContext;
        source = renderTextureQuad.get$renderTexture()._engine$_source;
        rotation = renderTextureQuad.get$rotation();
        sourceRect = renderTextureQuad.get$sourceRectangle();
        vxList = renderTextureQuad.get$vxListQuad();
        matrix = renderState.get$globalMatrix();
        alpha = J.get$globalAlpha$x(renderState);
        blendMode = renderState.get$globalBlendMode();
        t1 = this._activeAlpha;
        if (t1 == null ? alpha != null : t1 !== alpha) {
          this._activeAlpha = alpha;
          context.globalAlpha = alpha;
        }
        if (this._activeBlendMode !== blendMode) {
          this._activeBlendMode = blendMode;
          context.globalCompositeOperation = blendMode.compositeOperation;
        }
        if (rotation === 0) {
          t1 = matrix._data;
          context.setTransform(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5]);
          t1 = sourceRect.left;
          t2 = sourceRect.top;
          t3 = sourceRect.width;
          t4 = sourceRect.height;
          t5 = vxList[0];
          t6 = vxList[1];
          context.drawImage(source, t1, t2, t3, t4, t5, t6, vxList[8] - t5, vxList[9] - t6);
        } else if (rotation === 1) {
          t1 = matrix._data;
          context.setTransform(-t1[2], -t1[3], t1[0], t1[1], t1[4], t1[5]);
          context.drawImage(source, sourceRect.left, sourceRect.top, sourceRect.width, sourceRect.height, 0 - vxList[13], vxList[12], vxList[9] - vxList[1], vxList[8] - vxList[0]);
        } else if (rotation === 2) {
          t1 = matrix._data;
          context.setTransform(-t1[0], -t1[1], -t1[2], -t1[3], t1[4], t1[5]);
          t1 = sourceRect.left;
          t2 = sourceRect.top;
          t3 = sourceRect.width;
          t4 = sourceRect.height;
          t5 = vxList[8];
          t6 = vxList[9];
          context.drawImage(source, t1, t2, t3, t4, 0 - t5, 0 - t6, t5 - vxList[0], t6 - vxList[1]);
        } else if (rotation === 3) {
          t1 = matrix._data;
          context.setTransform(t1[2], t1[3], -t1[0], -t1[1], t1[4], t1[5]);
          context.drawImage(source, sourceRect.left, sourceRect.top, sourceRect.width, sourceRect.height, vxList[5], 0 - vxList[4], vxList[9] - vxList[1], vxList[8] - vxList[0]);
        }
      }, "call$2", "get$renderTextureQuad", 4, 0, 15, 9, 5],
      renderTextureMesh$4: function(renderState, renderTexture, ixList, vxList) {
        var context, source, matrix, alpha, blendMode, iw, ih, t1, i, i1, i2, i3, t2, x1, t3, y1, u1, v1, x2, y2, u2, v2, x3, y3, u3, v3, t4, id, t5, t6, ma, mb, mc, md;
        context = this._renderingContext;
        source = renderTexture._engine$_source;
        matrix = renderState.get$globalMatrix();
        alpha = J.get$globalAlpha$x(renderState);
        blendMode = renderState.get$globalBlendMode();
        iw = 1 / renderTexture._engine$_width;
        ih = 1 / renderTexture._engine$_height;
        t1 = this._activeAlpha;
        if (t1 == null ? alpha != null : t1 !== alpha) {
          this._activeAlpha = alpha;
          context.globalAlpha = alpha;
        }
        if (this._activeBlendMode !== blendMode) {
          this._activeBlendMode = blendMode;
          context.globalCompositeOperation = blendMode.compositeOperation;
        }
        t1 = matrix._data;
        context.setTransform(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5]);
        for (t1 = ixList.length - 2, i = 0; i < t1; i += 3) {
          i1 = J.$shl$n(ixList[i], 2);
          i2 = J.$shl$n(ixList[i + 1], 2);
          i3 = J.$shl$n(ixList[i + 2], 2);
          t2 = vxList.length;
          if (i1 >= t2)
            return H.ioore(vxList, i1);
          x1 = vxList[i1];
          t3 = i1 + 1;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          y1 = vxList[t3];
          t3 = i1 + 2;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          u1 = vxList[t3];
          t3 = i1 + 3;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          v1 = vxList[t3];
          if (i2 >= t2)
            return H.ioore(vxList, i2);
          x2 = vxList[i2];
          t3 = i2 + 1;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          y2 = vxList[t3];
          t3 = i2 + 2;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          u2 = vxList[t3];
          t3 = i2 + 3;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          v2 = vxList[t3];
          if (i3 >= t2)
            return H.ioore(vxList, i3);
          x3 = vxList[i3];
          t3 = i3 + 1;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          y3 = vxList[t3];
          t3 = i3 + 2;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          u3 = vxList[t3];
          t3 = i3 + 3;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          v3 = vxList[t3];
          context.save();
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.lineTo(x3, y3);
          context.closePath();
          context.clip();
          x2 = J.$sub$n(x2, x1);
          y2 = J.$sub$n(y2, y1);
          x3 = J.$sub$n(x3, x1);
          y3 = J.$sub$n(y3, y1);
          u2 = J.$sub$n(u2, u1);
          v2 = J.$sub$n(v2, v1);
          u3 = J.$sub$n(u3, u1);
          v3 = J.$sub$n(v3, v1);
          t3 = J.getInterceptor$ns(u2);
          t2 = J.getInterceptor$ns(u3);
          t4 = J.$sub$n(t3.$mul(u2, v3), t2.$mul(u3, v2));
          if (typeof t4 !== "number")
            return H.iae(t4);
          id = 1 / t4;
          t4 = J.getInterceptor$ns(v3);
          t5 = J.getInterceptor$ns(v2);
          t6 = J.$sub$n(t4.$mul(v3, x2), t5.$mul(v2, x3));
          if (typeof t6 !== "number")
            return H.iae(t6);
          ma = id * t6;
          t5 = J.$sub$n(t4.$mul(v3, y2), t5.$mul(v2, y3));
          if (typeof t5 !== "number")
            return H.iae(t5);
          mb = id * t5;
          t5 = J.$sub$n(t3.$mul(u2, x3), t2.$mul(u3, x2));
          if (typeof t5 !== "number")
            return H.iae(t5);
          mc = id * t5;
          t2 = J.$sub$n(t3.$mul(u2, y3), t2.$mul(u3, y2));
          if (typeof t2 !== "number")
            return H.iae(t2);
          md = id * t2;
          if (typeof u1 !== "number")
            return H.iae(u1);
          t2 = J.$sub$n(x1, ma * u1);
          if (typeof v1 !== "number")
            return H.iae(v1);
          context.transform(ma * iw, mb * iw, mc * ih, md * ih, J.$sub$n(t2, mc * v1), J.$sub$n(J.$sub$n(y1, mb * u1), md * v1));
          context.drawImage(source, 0, 0);
          context.restore();
        }
      },
      renderTriangle$8: function(renderState, x1, y1, x2, y2, x3, y3, color) {
        var context, t1, matrix, alpha, blendMode;
        context = this._renderingContext;
        t1 = renderState._currentContextState;
        matrix = t1.matrix;
        alpha = t1.alpha;
        blendMode = t1.blendMode;
        if (this._activeAlpha !== alpha) {
          this._activeAlpha = alpha;
          context.globalAlpha = alpha;
        }
        if (this._activeBlendMode !== blendMode) {
          this._activeBlendMode = blendMode;
          context.globalCompositeOperation = blendMode.compositeOperation;
        }
        t1 = matrix._data;
        context.setTransform(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5]);
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(x3, y3);
        context.closePath();
        context.fillStyle = V.color2rgba(color);
        context.fill("nonzero");
      },
      renderTriangleMesh$4: function(renderState, ixList, vxList, color) {
        var context, t1, matrix, alpha, blendMode, t2, i, i0, i1, i2, x1, t3, y1, x2, y2, x3, y3;
        context = this._renderingContext;
        t1 = renderState._currentContextState;
        matrix = t1.matrix;
        alpha = t1.alpha;
        blendMode = t1.blendMode;
        if (this._activeAlpha !== alpha) {
          this._activeAlpha = alpha;
          context.globalAlpha = alpha;
        }
        if (this._activeBlendMode !== blendMode) {
          this._activeBlendMode = blendMode;
          context.globalCompositeOperation = blendMode.compositeOperation;
        }
        t1 = matrix._data;
        context.setTransform(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5]);
        context.beginPath();
        for (t1 = ixList.length - 2, t2 = vxList.length, i = 0; i < t1; i += 3) {
          i0 = ixList[i] << 1 >>> 0;
          i1 = ixList[i + 1] << 1 >>> 0;
          i2 = ixList[i + 2] << 1 >>> 0;
          if (i0 >= t2)
            return H.ioore(vxList, i0);
          x1 = vxList[i0];
          t3 = i0 + 1;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          y1 = vxList[t3];
          if (i1 >= t2)
            return H.ioore(vxList, i1);
          x2 = vxList[i1];
          t3 = i1 + 1;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          y2 = vxList[t3];
          if (i2 >= t2)
            return H.ioore(vxList, i2);
          x3 = vxList[i2];
          t3 = i2 + 1;
          if (t3 >= t2)
            return H.ioore(vxList, t3);
          y3 = vxList[t3];
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.lineTo(x3, y3);
        }
        context.fillStyle = V.color2rgba(color);
        context.fill("nonzero");
      },
      renderTextureQuadFiltered$3: function(renderState, renderTextureQuad, renderFilters) {
        this.renderTextureQuad$2(renderState, renderTextureQuad);
      },
      renderObjectFiltered$2: function(renderState, renderObject) {
        renderObject.render$1(renderState);
      },
      setTransform$1: function(_, matrix) {
        var t1 = matrix._data;
        this._renderingContext.setTransform(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5]);
      }
    },
    RenderContextWebGL: {
      "^": "RenderContext;_canvasElement,_renderingContext,_projectionMatrix,_maskStates,_activeRenderProgram,_activeRenderFrameBuffer,_activeRenderStencilBuffer,_activeBlendMode,_contextValid,_contextIdentifier,renderProgramSimple,renderProgramTinted,renderProgramTriangle,renderBufferIndex,renderBufferVertex,_activeRenderTextures,_renderFrameBufferPool,_renderPrograms,renderStatistics,_contextLostEvent,_contextRestoredEvent",
      get$renderEngine: function() {
        return C.RenderEngine_0;
      },
      reset$0: function(_) {
        var t1, viewportWidth, viewportHeight;
        t1 = this._canvasElement;
        viewportWidth = t1.width;
        viewportHeight = t1.height;
        this._activeRenderFrameBuffer = null;
        this._renderingContext.bindFramebuffer(36160, null);
        this._renderingContext.viewport(0, 0, viewportWidth, viewportHeight);
        t1 = this._projectionMatrix;
        t1.setIdentity$0();
        if (typeof viewportWidth !== "number")
          return H.iae(viewportWidth);
        if (typeof viewportHeight !== "number")
          return H.iae(viewportHeight);
        t1.scale$3(0, 2 / viewportWidth, -2 / viewportHeight, 1);
        t1.translate$3(0, -1, 1, 0);
        this._activeRenderProgram.set$projectionMatrix(t1);
      },
      clear$1: function(_, color) {
        var rfb, a;
        rfb = this._activeRenderFrameBuffer;
        C.JSArray_methods.set$length(rfb instanceof L.RenderFrameBuffer ? rfb._maskStates : this._maskStates, 0);
        this._updateScissorTest$1(null);
        this._renderingContext.disable(2960);
        a = (color >>> 24 & 255) / 255;
        this._renderingContext.colorMask(true, true, true, true);
        this._renderingContext.clearColor((color >>> 16 & 255) / 255 * a, (color >>> 8 & 255) / 255 * a, (color & 255) / 255 * a, a);
        this._renderingContext.clear(17408);
      },
      flush$0: function(_) {
        J.flush$0$x(this._activeRenderProgram);
      },
      beginRenderMask$2: function(renderState, mask) {
        var matrix, t1, result, last, next, t2, rLeft, t3, rTop, rRight, stencil;
        J.flush$0$x(this._activeRenderProgram);
        if (!!J.getInterceptor(mask).$isScissorRenderMask) {
          renderState.push$3(mask.transformationMatrix, 1, null);
          matrix = renderState._currentContextState.matrix;
          t1 = matrix._data;
          result = V.similar(t1[1], 0, 0.0001) && V.similar(t1[2], 0, 0.0001) ? matrix.transformRectangle$1(mask.rectangle) : null;
          renderState._currentContextState = renderState._currentContextState.previousContextState;
          if (result != null) {
            last = this._getLastScissorValue$0();
            if (last == null)
              next = result;
            else {
              t1 = result.left;
              t2 = last.left;
              rLeft = Math.max(H.checkNum(t1), H.checkNum(t2));
              t2 = result.top;
              t3 = last.top;
              rTop = Math.max(H.checkNum(t2), H.checkNum(t3));
              t1 = J.$add$ns(t1, result.width);
              t3 = J.$add$ns(last.left, last.width);
              rRight = Math.min(H.checkNum(t1), H.checkNum(t3));
              t3 = J.$add$ns(result.top, result.height);
              t1 = J.$add$ns(last.top, last.height);
              next = new U.Rectangle0(rLeft, rTop, rRight - rLeft, Math.min(H.checkNum(t3), H.checkNum(t1)) - rTop, [H.getTypeArgumentByIndex(result, 0)]);
            }
            this._getMaskStates$0().push(new L._ScissorMaskState(next, mask));
            this._updateScissorTest$1(next);
            return;
          }
        }
        stencil = this._getLastStencilValue$0() + 1;
        this._renderingContext.enable(2960);
        this._renderingContext.stencilOp(7680, 7680, 7682);
        this._renderingContext.stencilFunc(514, stencil - 1, 255);
        this._renderingContext.colorMask(false, false, false, false);
        mask.renderMask$1(renderState);
        J.flush$0$x(this._activeRenderProgram);
        this._renderingContext.stencilOp(7680, 7680, 7680);
        this._renderingContext.colorMask(true, true, true, true);
        this._getMaskStates$0().push(new L._StencilMaskState(stencil, mask));
        this._updateStencilTest$1(stencil);
      },
      endRenderMask$2: function(renderState, mask) {
        var t1, maskState;
        J.flush$0$x(this._activeRenderProgram);
        t1 = this._getMaskStates$0();
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        maskState = t1.pop();
        if (!!maskState.$is_ScissorMaskState)
          this._updateScissorTest$1(this._getLastScissorValue$0());
        else if (!!maskState.$is_StencilMaskState) {
          this._renderingContext.enable(2960);
          this._renderingContext.stencilOp(7680, 7680, 7683);
          t1 = maskState.value;
          this._renderingContext.stencilFunc(514, t1, 255);
          this._renderingContext.colorMask(false, false, false, false);
          mask.renderMask$1(renderState);
          J.flush$0$x(this._activeRenderProgram);
          this._renderingContext.stencilOp(7680, 7680, 7680);
          this._renderingContext.colorMask(true, true, true, true);
          this._updateStencilTest$1(t1 - 1);
        }
      },
      renderTextureQuad$2: [function(renderState, renderTextureQuad) {
        var t1 = this.renderProgramSimple;
        this.activateRenderProgram$1(t1);
        this.activateBlendMode$1(renderState.get$globalBlendMode());
        this.activateRenderTexture$1(renderTextureQuad.get$renderTexture());
        t1.renderTextureQuad$2(renderState, renderTextureQuad);
      }, "call$2", "get$renderTextureQuad", 4, 0, 15, 9, 5],
      renderTriangle$8: function(renderState, x1, y1, x2, y2, x3, y3, color) {
        var t1, t2, matrix, alpha, ixData, t3, vxData, t4, ixIndex, t5, vxIndex, vxCount, ma, mb, mc, md, mx, my, colorA, colorR, colorG, colorB, t6;
        t1 = this.renderProgramTriangle;
        this.activateRenderProgram$1(t1);
        this.activateBlendMode$1(renderState._currentContextState.blendMode);
        t2 = renderState._currentContextState;
        matrix = t2.matrix;
        alpha = t2.alpha;
        t2 = t1._renderBufferIndex;
        ixData = t2.data;
        t3 = ixData.length;
        if (t2.position + 3 >= t3)
          t1.flush$0(0);
        t2 = t1._renderBufferVertex;
        vxData = t2.data;
        t4 = vxData.length;
        if (t2.position + 18 >= t4)
          t1.flush$0(0);
        t2 = t1._renderBufferIndex;
        ixIndex = t2.position;
        t5 = t1._renderBufferVertex;
        vxIndex = t5.position;
        vxCount = t5.count;
        if (ixIndex >= t3)
          return H.ioore(ixData, ixIndex);
        ixData[ixIndex] = vxCount;
        t5 = ixIndex + 1;
        if (t5 >= t3)
          return H.ioore(ixData, t5);
        ixData[t5] = vxCount + 1;
        t5 = ixIndex + 2;
        if (t5 >= t3)
          return H.ioore(ixData, t5);
        ixData[t5] = vxCount + 2;
        t2.position = ixIndex + 3;
        t2.count += 3;
        t2 = matrix._data;
        ma = t2[0];
        mb = t2[1];
        mc = t2[2];
        md = t2[3];
        mx = t2[4];
        my = t2[5];
        colorA = 0.00392156862745098 * (color >>> 24 & 255) * alpha;
        colorR = 0.00392156862745098 * (color >>> 16 & 255) * colorA;
        colorG = 0.00392156862745098 * (color >>> 8 & 255) * colorA;
        colorB = 0.00392156862745098 * (color & 255) * colorA;
        t2 = J.getInterceptor$ns(x1);
        t5 = J.getInterceptor$ns(y1);
        t3 = J.$add$ns(J.$add$ns(t2.$mul(x1, ma), t5.$mul(y1, mc)), mx);
        if (vxIndex >= t4)
          return H.ioore(vxData, vxIndex);
        vxData[vxIndex] = t3;
        t3 = vxIndex + 1;
        t5 = J.$add$ns(J.$add$ns(t2.$mul(x1, mb), t5.$mul(y1, md)), my);
        if (t3 >= t4)
          return H.ioore(vxData, t3);
        vxData[t3] = t5;
        t5 = vxIndex + 2;
        if (t5 >= t4)
          return H.ioore(vxData, t5);
        vxData[t5] = colorR;
        t5 = vxIndex + 3;
        if (t5 >= t4)
          return H.ioore(vxData, t5);
        vxData[t5] = colorG;
        t5 = vxIndex + 4;
        if (t5 >= t4)
          return H.ioore(vxData, t5);
        vxData[t5] = colorB;
        t5 = vxIndex + 5;
        if (t5 >= t4)
          return H.ioore(vxData, t5);
        vxData[t5] = colorA;
        t5 = vxIndex + 6;
        t3 = J.getInterceptor$ns(x2);
        t2 = J.getInterceptor$ns(y2);
        t6 = J.$add$ns(J.$add$ns(t3.$mul(x2, ma), t2.$mul(y2, mc)), mx);
        if (t5 >= t4)
          return H.ioore(vxData, t5);
        vxData[t5] = t6;
        t6 = vxIndex + 7;
        t2 = J.$add$ns(J.$add$ns(t3.$mul(x2, mb), t2.$mul(y2, md)), my);
        if (t6 >= t4)
          return H.ioore(vxData, t6);
        vxData[t6] = t2;
        t2 = vxIndex + 8;
        if (t2 >= t4)
          return H.ioore(vxData, t2);
        vxData[t2] = colorR;
        t2 = vxIndex + 9;
        if (t2 >= t4)
          return H.ioore(vxData, t2);
        vxData[t2] = colorG;
        t2 = vxIndex + 10;
        if (t2 >= t4)
          return H.ioore(vxData, t2);
        vxData[t2] = colorB;
        t2 = vxIndex + 11;
        if (t2 >= t4)
          return H.ioore(vxData, t2);
        vxData[t2] = colorA;
        t2 = vxIndex + 12;
        t6 = J.getInterceptor$ns(x3);
        t3 = J.getInterceptor$ns(y3);
        t5 = J.$add$ns(J.$add$ns(t6.$mul(x3, ma), t3.$mul(y3, mc)), mx);
        if (t2 >= t4)
          return H.ioore(vxData, t2);
        vxData[t2] = t5;
        t5 = vxIndex + 13;
        t3 = J.$add$ns(J.$add$ns(t6.$mul(x3, mb), t3.$mul(y3, md)), my);
        if (t5 >= t4)
          return H.ioore(vxData, t5);
        vxData[t5] = t3;
        t3 = vxIndex + 14;
        if (t3 >= t4)
          return H.ioore(vxData, t3);
        vxData[t3] = colorR;
        t3 = vxIndex + 15;
        if (t3 >= t4)
          return H.ioore(vxData, t3);
        vxData[t3] = colorG;
        t3 = vxIndex + 16;
        if (t3 >= t4)
          return H.ioore(vxData, t3);
        vxData[t3] = colorB;
        t3 = vxIndex + 17;
        if (t3 >= t4)
          return H.ioore(vxData, t3);
        vxData[t3] = colorA;
        t1 = t1._renderBufferVertex;
        t1.position += 18;
        t1.count += 3;
      },
      renderTriangleMesh$4: function(renderState, ixList, vxList, color) {
        var t1 = this.renderProgramTriangle;
        this.activateRenderProgram$1(t1);
        this.activateBlendMode$1(renderState._currentContextState.blendMode);
        t1.renderTriangleMesh$4(renderState, ixList, vxList, color);
      },
      renderTextureQuadFiltered$3: function(renderState, renderTextureQuad, renderFilters) {
        var t1, firstFilter;
        t1 = renderFilters.length;
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(renderFilters, 0);
          firstFilter = renderFilters[0];
        } else
          firstFilter = null;
        if (!(t1 === 0))
          if (firstFilter instanceof L.RenderFilter && firstFilter.get$isSimple())
            firstFilter.renderFilter$3(renderState, renderTextureQuad, 0);
          else
            this.renderObjectFiltered$2(renderState, new L._RenderTextureQuadObject(renderTextureQuad, renderFilters, T.Matrix$fromIdentity(), C.BlendMode_bZz, null, null, 1));
      },
      renderObjectFiltered$2: function(renderState, renderObject) {
        var bounds, filters, t1, pixelRatio, boundsLeft, boundsTop, boundsRight, boundsBottom, i, overlap, t2, t3, boundsWidth, boundsHeight, initialRenderFrameBuffer, initialProjectionMatrix, filterRenderState, filterProjectionMatrix, filterRenderFrameBuffer, renderFrameBufferMap, t4, t5, filter, renderPassSources, renderPassTargets, t6, pass, renderPassSource, renderPassTarget, sourceRenderFrameBuffer, sourceRenderTextureQuad, t7;
        bounds = renderObject.get$bounds();
        filters = renderObject.get$filters();
        t1 = renderState._currentContextState.matrix._data;
        pixelRatio = Math.sqrt(Math.abs(t1[0] * t1[3] - t1[1] * t1[2]));
        boundsLeft = J.floor$0$n(bounds.left);
        boundsTop = J.floor$0$n(bounds.top);
        boundsRight = J.ceil$0$n(J.$add$ns(bounds.left, bounds.width));
        boundsBottom = J.ceil$0$n(J.$add$ns(bounds.top, bounds.height));
        for (i = 0; i < filters.length; ++i) {
          overlap = filters[i].get$overlap();
          t1 = overlap.left;
          if (typeof t1 !== "number")
            return H.iae(t1);
          boundsLeft += t1;
          t2 = overlap.top;
          if (typeof t2 !== "number")
            return H.iae(t2);
          boundsTop += t2;
          t3 = overlap.width;
          if (typeof t3 !== "number")
            return H.iae(t3);
          boundsRight += t1 + t3;
          t2 = C.JSNumber_methods.$add(t2, overlap.height);
          if (typeof t2 !== "number")
            return H.iae(t2);
          boundsBottom += t2;
        }
        boundsLeft = C.JSNumber_methods.floor$0(boundsLeft * pixelRatio);
        boundsTop = C.JSNumber_methods.floor$0(boundsTop * pixelRatio);
        boundsWidth = C.JSNumber_methods.ceil$0(boundsRight * pixelRatio) - boundsLeft;
        boundsHeight = C.JSNumber_methods.ceil$0(boundsBottom * pixelRatio) - boundsTop;
        initialRenderFrameBuffer = this._activeRenderFrameBuffer;
        t1 = this._projectionMatrix;
        initialProjectionMatrix = new T.Matrix3D(new Float32Array(H._checkLength(16)));
        initialProjectionMatrix.copyFrom$1(t1);
        filterRenderState = L.RenderState$(this, null, null, null);
        filterProjectionMatrix = new T.Matrix3D(new Float32Array(H._checkLength(16)));
        filterProjectionMatrix.setIdentity$0();
        filterRenderFrameBuffer = this.getRenderFrameBuffer$2(boundsWidth, boundsHeight);
        t2 = P.int;
        renderFrameBufferMap = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t2, L.RenderFrameBuffer]);
        t3 = -boundsLeft;
        t4 = -boundsTop;
        filterProjectionMatrix.translate$3(0, t3, t4, 0);
        filterProjectionMatrix.scale$3(0, 2 / boundsWidth, 2 / boundsHeight, 1);
        filterProjectionMatrix.translate$3(0, -1, -1, 0);
        filterRenderState._currentContextState.matrix.scale$2(0, pixelRatio, pixelRatio);
        renderFrameBufferMap.$indexSet(0, 0, filterRenderFrameBuffer);
        this.activateRenderFrameBuffer$1(filterRenderFrameBuffer);
        this.activateProjectionMatrix$1(filterProjectionMatrix);
        this.activateBlendMode$1(C.BlendMode_bZz);
        this.clear$1(0, 0);
        t5 = filters.length;
        if (!(t5 === 0)) {
          if (0 >= t5)
            return H.ioore(filters, 0);
          if (filters[0].get$isSimple() && !!renderObject.$is_RenderTextureQuadObject) {
            if (0 >= filters.length)
              return H.ioore(filters, 0);
            this.renderTextureQuadFiltered$3(filterRenderState, renderObject.renderTextureQuad, [filters[0]]);
            filters = C.JSArray_methods.sublist$1(filters, 1);
          } else
            renderObject.render$1(filterRenderState);
        }
        for (t2 = [t2], t5 = this._renderFrameBufferPool, i = 0; i < filters.length; ++i) {
          filter = filters[i];
          renderPassSources = filter.get$renderPassSources();
          renderPassTargets = filter.get$renderPassTargets();
          for (t6 = [H.getTypeArgumentByIndex(renderPassSources, 0)], pass = 0; pass < renderPassSources.length;) {
            renderPassSource = renderPassSources[pass];
            if (pass >= renderPassTargets.length)
              return H.ioore(renderPassTargets, pass);
            renderPassTarget = renderPassTargets[pass];
            if (renderFrameBufferMap.containsKey$1(0, renderPassSource)) {
              sourceRenderFrameBuffer = renderFrameBufferMap.$index(0, renderPassSource);
              sourceRenderTextureQuad = L.RenderTextureQuad$(sourceRenderFrameBuffer.get$renderTexture(), new U.Rectangle0(0, 0, boundsWidth, boundsHeight, t2), new U.Rectangle0(t3, t4, boundsWidth, boundsHeight, t2), 0, pixelRatio);
            } else
              throw H.wrapException(new P.StateError("Invalid renderPassSource!"));
            if (i === filters.length - 1 && renderPassTarget === C.JSArray_methods.get$last(renderPassTargets)) {
              this.activateRenderFrameBuffer$1(initialRenderFrameBuffer);
              t1.copyFrom$1(initialProjectionMatrix);
              J.flush$0$x(this._activeRenderProgram);
              this._activeRenderProgram.set$projectionMatrix(t1);
              t7 = renderState._currentContextState.blendMode;
              if (t7 !== this._activeBlendMode) {
                J.flush$0$x(this._activeRenderProgram);
                this._activeBlendMode = t7;
                this._renderingContext.blendFunc(t7.srcFactor, t7.dstFactor);
              }
              filterRenderState = renderState;
              filterRenderFrameBuffer = null;
            } else if (renderFrameBufferMap.containsKey$1(0, renderPassTarget)) {
              filterRenderFrameBuffer = renderFrameBufferMap.$index(0, renderPassTarget);
              this.activateRenderFrameBuffer$1(filterRenderFrameBuffer);
              if (C.BlendMode_bZz !== this._activeBlendMode) {
                J.flush$0$x(this._activeRenderProgram);
                this._activeBlendMode = C.BlendMode_bZz;
                this._renderingContext.blendFunc(1, 771);
              }
            } else {
              filterRenderFrameBuffer = this.getRenderFrameBuffer$2(boundsWidth, boundsHeight);
              renderFrameBufferMap.$indexSet(0, renderPassTarget, filterRenderFrameBuffer);
              this.activateRenderFrameBuffer$1(filterRenderFrameBuffer);
              if (C.BlendMode_bZz !== this._activeBlendMode) {
                J.flush$0$x(this._activeRenderProgram);
                this._activeBlendMode = C.BlendMode_bZz;
                this._renderingContext.blendFunc(1, 771);
              }
              this.clear$1(0, 0);
            }
            filter.renderFilter$3(filterRenderState, sourceRenderTextureQuad, pass);
            ++pass;
            if (new H.SubListIterable(renderPassSources, pass, null, t6).every$1(0, new L.RenderContextWebGL_renderObjectFiltered_closure(renderPassSource))) {
              renderFrameBufferMap.remove$1(0, renderPassSource);
              if (sourceRenderFrameBuffer instanceof L.RenderFrameBuffer) {
                J.flush$0$x(this._activeRenderProgram);
                t5.push(sourceRenderFrameBuffer);
              }
            }
          }
          renderFrameBufferMap.clear$0(0);
          renderFrameBufferMap.$indexSet(0, 0, filterRenderFrameBuffer);
        }
      },
      getRenderProgram$2: function($name, ifAbsent) {
        return this._renderPrograms.putIfAbsent$2(0, $name, ifAbsent);
      },
      getRenderFrameBuffer$2: function(width, height) {
        var t1, t2, renderFrameBuffer, renderTexture, renderStencilBuffer;
        t1 = this._renderFrameBufferPool;
        t2 = t1.length;
        if (t2 === 0) {
          t1 = new L.RenderFrameBuffer(null, null, null, -1, null, null, H.setRuntimeTypeInfo([], [L._MaskState]));
          t2 = new L.RenderTexture(0, 0, null, null, C.RenderTextureFiltering_9729, C.RenderTextureWrapping_33071, C.RenderTextureWrapping_33071, null, -1, false, null, null, -1);
          t2._engine$_width = V.ensureInt(width);
          t2._engine$_height = V.ensureInt(height);
          t1._engine$_renderTexture = t2;
          t2 = new L.RenderStencilBuffer(0, 0, null, -1, null, null);
          t2._engine$_width = V.ensureInt(width);
          t2._engine$_height = V.ensureInt(height);
          t1._renderStencilBuffer = t2;
          return t1;
        } else {
          if (0 >= t2)
            return H.ioore(t1, -1);
          renderFrameBuffer = t1.pop();
          renderTexture = renderFrameBuffer._engine$_renderTexture;
          renderStencilBuffer = renderFrameBuffer._renderStencilBuffer;
          if (renderTexture._engine$_width !== width || renderTexture._engine$_height !== height) {
            this.releaseRenderTexture$1(renderTexture);
            renderTexture.resize$2(0, width, height);
            renderStencilBuffer.resize$2(0, width, height);
          }
          return renderFrameBuffer;
        }
      },
      releaseRenderTexture$1: function(renderTexture) {
        var t1, i, t2;
        for (t1 = this._activeRenderTextures, i = 0; i < 8; ++i) {
          t2 = t1[i];
          if (renderTexture == null ? t2 == null : renderTexture === t2) {
            t1[i] = null;
            this._renderingContext.activeTexture(33984 + i);
            this._renderingContext.bindTexture(3553, null);
          }
        }
      },
      activateRenderFrameBuffer$1: function(renderFrameBuffer) {
        var t1, rfb, viewportWidth, viewportHeight, t2;
        t1 = this._activeRenderFrameBuffer;
        if (renderFrameBuffer == null ? t1 != null : renderFrameBuffer !== t1) {
          t1 = this._activeRenderProgram;
          if (renderFrameBuffer instanceof L.RenderFrameBuffer) {
            J.flush$0$x(t1);
            this._activeRenderFrameBuffer = renderFrameBuffer;
            renderFrameBuffer.activate$1(0, this);
          } else {
            J.flush$0$x(t1);
            this._activeRenderFrameBuffer = null;
            this._renderingContext.bindFramebuffer(36160, null);
          }
          rfb = this._activeRenderFrameBuffer;
          t1 = rfb instanceof L.RenderFrameBuffer;
          viewportWidth = t1 ? rfb._engine$_renderTexture._engine$_width : this._canvasElement.width;
          viewportHeight = t1 ? rfb._engine$_renderTexture._engine$_height : this._canvasElement.height;
          this._renderingContext.viewport(0, 0, viewportWidth, viewportHeight);
          this._updateScissorTest$1(this._getLastScissorValue$0());
          t1 = this._getLastStencilValue$0();
          t2 = this._renderingContext;
          if (t1 === 0)
            t2.disable(2960);
          else {
            t2.enable(2960);
            this._renderingContext.stencilFunc(514, t1, 255);
          }
        }
      },
      activateRenderStencilBuffer$1: function(renderStencilBuffer) {
        var t1 = this._activeRenderStencilBuffer;
        if (renderStencilBuffer == null ? t1 != null : renderStencilBuffer !== t1) {
          J.flush$0$x(this._activeRenderProgram);
          this._activeRenderStencilBuffer = renderStencilBuffer;
          renderStencilBuffer.activate$1(0, this);
        }
      },
      activateRenderProgram$1: function(renderProgram) {
        var t1 = this._activeRenderProgram;
        if (renderProgram == null ? t1 != null : renderProgram !== t1) {
          J.flush$0$x(t1);
          this._activeRenderProgram = renderProgram;
          J.activate$1$x(renderProgram, this);
          this._activeRenderProgram.set$projectionMatrix(this._projectionMatrix);
        }
      },
      activateBlendMode$1: function(blendMode) {
        if (blendMode !== this._activeBlendMode) {
          J.flush$0$x(this._activeRenderProgram);
          this._activeBlendMode = blendMode;
          this._renderingContext.blendFunc(blendMode.srcFactor, blendMode.dstFactor);
        }
      },
      activateRenderTexture$1: function(renderTexture) {
        var t1, t2, t3;
        t1 = this._activeRenderTextures;
        t2 = t1[0];
        if (renderTexture == null ? t2 != null : renderTexture !== t2) {
          J.flush$0$x(this._activeRenderProgram);
          t1[0] = renderTexture;
          t1 = renderTexture._contextIdentifier;
          t2 = this._contextIdentifier;
          if (t1 !== t2) {
            renderTexture._engine$_renderContext = this;
            renderTexture._contextIdentifier = t2;
            t1 = this._renderingContext;
            renderTexture._renderingContext = t1;
            renderTexture._texture = t1.createTexture();
            renderTexture._renderingContext.activeTexture(33984);
            renderTexture._renderingContext.bindTexture(3553, renderTexture._texture);
            t1 = renderTexture._renderingContext.isEnabled(3089) === true;
            if (t1)
              renderTexture._renderingContext.disable(3089);
            t2 = renderTexture._engine$_source;
            if (t2 != null) {
              t3 = renderTexture._renderingContext;
              (t3 && C.RenderingContext_methods).texImage2D$6(t3, 3553, 0, 6408, 6408, 5121, t2);
              renderTexture._textureSourceWorkaround = renderTexture._renderingContext.getError() === 1281;
            } else {
              t2 = renderTexture._renderingContext;
              (t2 && C.RenderingContext_methods).texImage2D$9(t2, 3553, 0, 6408, renderTexture._engine$_width, renderTexture._engine$_height, 0, 6408, 5121, null);
            }
            if (renderTexture._textureSourceWorkaround) {
              t2 = renderTexture._engine$_width;
              t2 = W.CanvasElement_CanvasElement(renderTexture._engine$_height, t2);
              renderTexture._canvas = t2;
              t2.getContext("2d").drawImage(renderTexture._engine$_source, 0, 0);
              t2 = renderTexture._renderingContext;
              (t2 && C.RenderingContext_methods).texImage2D$6(t2, 3553, 0, 6408, 6408, 5121, renderTexture._canvas);
            }
            if (t1)
              renderTexture._renderingContext.enable(3089);
            renderTexture._renderingContext.texParameteri(3553, 10242, renderTexture._wrappingX.value);
            renderTexture._renderingContext.texParameteri(3553, 10243, renderTexture._wrappingY.value);
            renderTexture._renderingContext.texParameteri(3553, 10241, renderTexture._filtering.value);
            renderTexture._renderingContext.texParameteri(3553, 10240, renderTexture._filtering.value);
          } else {
            renderTexture._renderingContext.activeTexture(33984);
            renderTexture._renderingContext.bindTexture(3553, renderTexture._texture);
          }
        }
      },
      activateProjectionMatrix$1: function(matrix) {
        var t1 = this._projectionMatrix;
        t1.copyFrom$1(matrix);
        J.flush$0$x(this._activeRenderProgram);
        this._activeRenderProgram.set$projectionMatrix(t1);
      },
      _getViewportHeight$0: function() {
        var rfb = this._activeRenderFrameBuffer;
        return rfb instanceof L.RenderFrameBuffer ? rfb._engine$_renderTexture._engine$_height : this._canvasElement.height;
      },
      _getMaskStates$0: function() {
        var rfb = this._activeRenderFrameBuffer;
        return rfb instanceof L.RenderFrameBuffer ? rfb._maskStates : this._maskStates;
      },
      _getLastStencilValue$0: function() {
        var maskStates, i, maskState;
        maskStates = this._getMaskStates$0();
        for (i = maskStates.length - 1; i >= 0; --i) {
          maskState = maskStates[i];
          if (!!maskState.$is_StencilMaskState)
            return maskState.value;
        }
        return 0;
      },
      _getLastScissorValue$0: function() {
        var maskStates, i, maskState;
        maskStates = this._getMaskStates$0();
        for (i = maskStates.length - 1; i >= 0; --i) {
          maskState = maskStates[i];
          if (!!maskState.$is_ScissorMaskState)
            return maskState.value;
        }
        return;
      },
      _updateStencilTest$1: function(value) {
        var t1 = this._renderingContext;
        if (value === 0)
          t1.disable(2960);
        else {
          t1.enable(2960);
          this._renderingContext.stencilFunc(514, value, 255);
        }
      },
      _updateScissorTest$1: function(value) {
        var viewportHeight, x1, t1, y1, x2;
        if (value == null)
          this._renderingContext.disable(3089);
        else {
          viewportHeight = this._getViewportHeight$0();
          x1 = J.round$0$n(value.left);
          t1 = J.round$0$n(J.$add$ns(value.top, value.height));
          if (typeof viewportHeight !== "number")
            return viewportHeight.$sub();
          y1 = viewportHeight - t1;
          x2 = J.round$0$n(J.$add$ns(value.left, value.width));
          t1 = J.round$0$n(value.top);
          this._renderingContext.enable(3089);
          this._renderingContext.scissor(x1, y1, V.maxInt(x2 - x1, 0), V.maxInt(viewportHeight - t1 - y1, 0));
        }
      },
      _onContextLost$1: [function(contextEvent) {
        var t1;
        J.preventDefault$0$x(contextEvent);
        this._contextValid = false;
        t1 = this._contextLostEvent;
        if (!t1.get$_mayAddEvent())
          H.throwExpression(t1._addEventError$0());
        t1._sendData$1(new L.RenderContextEvent());
      }, "call$1", "get$_onContextLost", 2, 0, 28],
      _onContextRestored$1: [function(contextEvent) {
        var t1;
        this._contextValid = true;
        t1 = $.RenderContextWebGL__globalContextIdentifier + 1;
        $.RenderContextWebGL__globalContextIdentifier = t1;
        this._contextIdentifier = t1;
        t1 = this._contextRestoredEvent;
        if (!t1.get$_mayAddEvent())
          H.throwExpression(t1._addEventError$0());
        t1._sendData$1(new L.RenderContextEvent());
      }, "call$1", "get$_onContextRestored", 2, 0, 28]
    },
    RenderContextWebGL_renderObjectFiltered_closure: {
      "^": "Closure:0;renderPassSource",
      call$1: function(rps) {
        return !J.$eq$(rps, this.renderPassSource);
      }
    },
    RenderFilter: {
      "^": "Object;",
      get$isSimple: function() {
        var overlap = this.get$overlap();
        return J.$eq$(overlap.width, 0) && J.$eq$(overlap.height, 0) && this._renderPassSources.length === 1;
      }
    },
    RenderFrameBuffer: {
      "^": "Object;_engine$_renderTexture,_renderStencilBuffer,_engine$_renderContext,_contextIdentifier,_framebuffer,_renderingContext,_maskStates",
      get$width: function(_) {
        return this._engine$_renderTexture._engine$_width;
      },
      get$height: function(_) {
        return this._engine$_renderTexture._engine$_height;
      },
      get$renderTexture: function() {
        return this._engine$_renderTexture;
      },
      activate$1: function(_, renderContext) {
        var t1, t2, colorData, stencilData;
        t1 = this._contextIdentifier;
        t2 = renderContext._contextIdentifier;
        if (t1 !== t2) {
          this._engine$_renderContext = renderContext;
          this._contextIdentifier = t2;
          t1 = renderContext._renderingContext;
          this._renderingContext = t1;
          this._framebuffer = t1.createFramebuffer();
          this._engine$_renderContext.activateRenderTexture$1(this._engine$_renderTexture);
          this._engine$_renderContext.activateRenderStencilBuffer$1(this._renderStencilBuffer);
          colorData = this._engine$_renderTexture._texture;
          stencilData = this._renderStencilBuffer._renderbuffer;
          this._renderingContext.bindFramebuffer(36160, this._framebuffer);
          this._renderingContext.framebufferTexture2D(36160, 36064, 3553, colorData, 0);
          this._renderingContext.framebufferRenderbuffer(36160, 33306, 36161, stencilData);
        } else
          this._renderingContext.bindFramebuffer(36160, this._framebuffer);
      }
    },
    _globalFrameRequest_closure: {
      "^": "Closure:64;",
      call$1: [function(frameTime) {
        var currentFrameTime, t1, deltaTime, t2, _i;
        currentFrameTime = J.$div$n(frameTime, 1000);
        t1 = $._globalFrameTime;
        if (typeof t1 !== "number")
          return H.iae(t1);
        deltaTime = currentFrameTime - t1;
        $._globalFrameTime = currentFrameTime;
        $._globalFrameCallbackId = -1;
        L._globalFrameRequest();
        t1 = $.$get$_globalFrameListeners();
        t1.toString;
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        t2 = t1.length;
        _i = 0;
        for (; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].call$1(deltaTime);
      }, null, null, 2, 0, null, 48, "call"]
    },
    RenderLoopBase: {
      "^": "Object;",
      start$0: [function(_) {
        this._running = true;
        L._globalFrameRequest();
        $.$get$_globalFrameListeners().push(this.get$_onGlobalFrame());
      }, "call$0", "get$start", 0, 0, 2],
      _onGlobalFrame$1: [function(deltaTime) {
        if (this._running && J.$ge$n(deltaTime, 0))
          if (typeof deltaTime === "number")
            this.advanceTime$1(deltaTime);
      }, "call$1", "get$_onGlobalFrame", 2, 0, 29, 20]
    },
    _MaskState: {
      "^": "Object;mask>"
    },
    _StencilMaskState: {
      "^": "_MaskState;value>,mask"
    },
    _ScissorMaskState: {
      "^": "_MaskState;value>,mask"
    },
    _RenderTextureQuadObject: {
      "^": "Object;renderTextureQuad<,filters<,transformationMatrix<,blendMode<,cache<,mask>,alpha>",
      get$bounds: function() {
        var t1 = this.renderTextureQuad;
        return new U.Rectangle0(0, 0, t1.get$targetWidth(), t1.get$targetHeight(), [P.num]);
      },
      render$1: function(renderState) {
        renderState._engine$_renderContext.renderTextureQuad$2(renderState, this.renderTextureQuad);
      },
      renderFiltered$1: function(renderState) {
        renderState._engine$_renderContext.renderTextureQuad$2(renderState, this.renderTextureQuad);
      },
      renderTextureQuad$2: function(arg0, arg1) {
        return this.renderTextureQuad.call$2(arg0, arg1);
      }
    },
    RenderProgram: {
      "^": "Object;",
      get$attributes: function(_) {
        return this._attributes;
      },
      set$projectionMatrix: function(matrix) {
        var $location = this._uniforms.$index(0, "uProjectionMatrix");
        this._renderingContext.uniformMatrix4fv($location, false, matrix._matrix_3d$_data);
      },
      activate$1: ["super$RenderProgram$activate", function(_, renderContext) {
        var t1, t2;
        t1 = this._contextIdentifier;
        t2 = renderContext._contextIdentifier;
        if (t1 !== t2) {
          this._contextIdentifier = t2;
          this._renderingContext = renderContext._renderingContext;
          this._renderStatistics = renderContext.renderStatistics;
          t1 = renderContext.renderBufferIndex;
          this._renderBufferIndex = t1;
          this._renderBufferVertex = renderContext.renderBufferVertex;
          t1.activate$1(0, renderContext);
          this._renderBufferVertex.activate$1(0, renderContext);
          t1 = this._createProgram$1(this._renderingContext);
          this._program = t1;
          this._updateAttributes$2(this._renderingContext, t1);
          this._updateUniforms$2(this._renderingContext, this._program);
        }
        this._renderingContext.useProgram(this._program);
      }],
      flush$0: function(_) {
        var t1, t2, t3, update, t4;
        t1 = this._renderBufferIndex;
        t2 = t1.position;
        if (t2 > 0 && this._renderBufferVertex.position > 0) {
          t3 = t1.data.buffer;
          t3.toString;
          update = H.NativeInt16List_NativeInt16List$view(t3, 0, t2);
          t1._renderingContext.bufferSubData(34963, 0, update);
          t3 = t1._renderStatistics;
          t3.indexCount = t3.indexCount + t1.count;
          t1 = this._renderBufferIndex;
          t1.position = 0;
          t1.count = 0;
          t1 = this._renderBufferVertex;
          t3 = t1.data.buffer;
          t4 = t1.position;
          t3.toString;
          update = H.NativeFloat32List_NativeFloat32List$view(t3, 0, t4);
          t1._renderingContext.bufferSubData(34962, 0, update);
          t4 = t1._renderStatistics;
          t4.vertexCount = t4.vertexCount + t1.count;
          t1 = this._renderBufferVertex;
          t1.position = 0;
          t1.count = 0;
          this._renderingContext.drawElements(4, t2, 5123, 0);
          ++this._renderStatistics.drawCount;
        }
      },
      _createProgram$1: function(rc) {
        var program, vShader, fShader;
        program = rc.createProgram();
        vShader = this._createShader$3(rc, this.get$vertexShaderSource(), 35633);
        fShader = this._createShader$3(rc, this.get$fragmentShaderSource(), 35632);
        rc.attachShader(program, vShader);
        rc.attachShader(program, fShader);
        rc.linkProgram(program);
        if (rc.getProgramParameter(program, 35714) === true)
          return program;
        throw H.wrapException(new P.StateError(rc.isContextLost() === true ? "ContextLost" : rc.getProgramInfoLog(program)));
      },
      _createShader$3: function(rc, source, type) {
        var shader = rc.createShader(type);
        rc.shaderSource(shader, source);
        rc.compileShader(shader);
        if (rc.getShaderParameter(shader, 35713) === true)
          return shader;
        throw H.wrapException(new P.StateError(rc.isContextLost() === true ? "ContextLost" : rc.getShaderInfoLog(shader)));
      },
      _updateAttributes$2: function(rc, program) {
        var t1, count, i, activeInfo, $location;
        t1 = this._attributes;
        t1.clear$0(0);
        count = rc.getProgramParameter(program, 35721);
        if (typeof count !== "number")
          return H.iae(count);
        i = 0;
        for (; i < count; ++i) {
          activeInfo = rc.getActiveAttrib(program, i);
          $location = rc.getAttribLocation(program, activeInfo.name);
          rc.enableVertexAttribArray($location);
          t1.$indexSet(0, activeInfo.name, $location);
        }
      },
      _updateUniforms$2: function(rc, program) {
        var t1, count, i, activeInfo, $location;
        t1 = this._uniforms;
        t1.clear$0(0);
        count = rc.getProgramParameter(program, 35718);
        if (typeof count !== "number")
          return H.iae(count);
        i = 0;
        for (; i < count; ++i) {
          activeInfo = rc.getActiveUniform(program, i);
          $location = rc.getUniformLocation(program, activeInfo.name);
          t1.$indexSet(0, activeInfo.name, $location);
        }
      }
    },
    RenderProgramSimple: {
      "^": "RenderProgram;_contextIdentifier,_renderingContext,_program,_attributes,_uniforms,_renderBufferIndex,_renderBufferVertex,_renderStatistics",
      get$vertexShaderSource: function() {
        return "\r\n    uniform mat4 uProjectionMatrix;\r\n    attribute vec2 aVertexPosition;\r\n    attribute vec2 aVertexTextCoord;\r\n    attribute float aVertexAlpha;\r\n    varying vec2 vTextCoord;\r\n    varying float vAlpha;\r\n\r\n    void main() {\r\n      vTextCoord = aVertexTextCoord;\r\n      vAlpha = aVertexAlpha;\r\n      gl_Position = vec4(aVertexPosition, 0.0, 1.0) * uProjectionMatrix;\r\n    }\r\n    ";
      },
      get$fragmentShaderSource: function() {
        return "\r\n    precision mediump float;\r\n    uniform sampler2D uSampler;\r\n    varying vec2 vTextCoord;\r\n    varying float vAlpha;\r\n\r\n    void main() {\r\n      gl_FragColor = texture2D(uSampler, vTextCoord) * vAlpha;\r\n    }\r\n    ";
      },
      activate$1: function(_, renderContext) {
        var t1;
        this.super$RenderProgram$activate(0, renderContext);
        this._renderingContext.uniform1i(this._uniforms.$index(0, "uSampler"), 0);
        t1 = this._attributes;
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexPosition"), 2, 20, 0);
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexTextCoord"), 2, 20, 8);
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexAlpha"), 1, 20, 16);
      },
      renderTextureQuad$2: [function(renderState, renderTextureQuad) {
        var alpha, matrix, vxList, t1, ixData, t2, vxData, t3, ixIndex, t4, vxIndex, vxCount, t5, t6, ma1, t7, ma2, mb1, mb2, mc1, mc2, md1, md2;
        if (renderTextureQuad.get$hasCustomVertices()) {
          this.renderTextureMesh$3(renderState, renderTextureQuad.get$ixList(), renderTextureQuad.get$vxList());
          return;
        }
        alpha = J.get$globalAlpha$x(renderState);
        matrix = renderState.get$globalMatrix();
        vxList = renderTextureQuad.get$vxListQuad();
        t1 = this._renderBufferIndex;
        ixData = t1.data;
        t2 = ixData.length;
        if (t1.position + 6 >= t2)
          this.flush$0(0);
        t1 = this._renderBufferVertex;
        vxData = t1.data;
        t3 = vxData.length;
        if (t1.position + 20 >= t3)
          this.flush$0(0);
        t1 = this._renderBufferIndex;
        ixIndex = t1.position;
        t4 = this._renderBufferVertex;
        vxIndex = t4.position;
        vxCount = t4.count;
        if (ixIndex >= t2)
          return H.ioore(ixData, ixIndex);
        ixData[ixIndex] = vxCount;
        t5 = ixIndex + 1;
        if (t5 >= t2)
          return H.ioore(ixData, t5);
        ixData[t5] = vxCount + 1;
        t5 = ixIndex + 2;
        t6 = vxCount + 2;
        if (t5 >= t2)
          return H.ioore(ixData, t5);
        ixData[t5] = t6;
        t5 = ixIndex + 3;
        if (t5 >= t2)
          return H.ioore(ixData, t5);
        ixData[t5] = vxCount;
        t5 = ixIndex + 4;
        if (t5 >= t2)
          return H.ioore(ixData, t5);
        ixData[t5] = t6;
        t6 = ixIndex + 5;
        if (t6 >= t2)
          return H.ioore(ixData, t6);
        ixData[t6] = vxCount + 3;
        t1.position = ixIndex + 6;
        t1.count += 6;
        t1 = vxList[0];
        t6 = matrix._data;
        t2 = t6[0];
        t5 = t6[4];
        ma1 = t1 * t2 + t5;
        t7 = vxList[8];
        ma2 = t7 * t2 + t5;
        t5 = t6[1];
        t2 = t6[5];
        mb1 = t1 * t5 + t2;
        mb2 = t7 * t5 + t2;
        t2 = vxList[1];
        t5 = t6[2];
        mc1 = t2 * t5;
        t7 = vxList[9];
        mc2 = t7 * t5;
        t6 = t6[3];
        md1 = t2 * t6;
        md2 = t7 * t6;
        if (vxIndex >= t3)
          return H.ioore(vxData, vxIndex);
        vxData[vxIndex] = ma1 + mc1;
        t6 = vxIndex + 1;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = mb1 + md1;
        t6 = vxIndex + 2;
        t7 = vxList[2];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t7;
        t7 = vxIndex + 3;
        t6 = vxList[3];
        if (t7 >= t3)
          return H.ioore(vxData, t7);
        vxData[t7] = t6;
        t6 = vxIndex + 4;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = alpha;
        t6 = vxIndex + 5;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = ma2 + mc1;
        t6 = vxIndex + 6;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = mb2 + md1;
        t6 = vxIndex + 7;
        t7 = vxList[6];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t7;
        t7 = vxIndex + 8;
        t6 = vxList[7];
        if (t7 >= t3)
          return H.ioore(vxData, t7);
        vxData[t7] = t6;
        t6 = vxIndex + 9;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = alpha;
        t6 = vxIndex + 10;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = ma2 + mc2;
        t6 = vxIndex + 11;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = mb2 + md2;
        t6 = vxIndex + 12;
        t7 = vxList[10];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t7;
        t7 = vxIndex + 13;
        t6 = vxList[11];
        if (t7 >= t3)
          return H.ioore(vxData, t7);
        vxData[t7] = t6;
        t6 = vxIndex + 14;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = alpha;
        t6 = vxIndex + 15;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = ma1 + mc2;
        t6 = vxIndex + 16;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = mb1 + md2;
        t6 = vxIndex + 17;
        t7 = vxList[14];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t7;
        t7 = vxIndex + 18;
        t6 = vxList[15];
        if (t7 >= t3)
          return H.ioore(vxData, t7);
        vxData[t7] = t6;
        t6 = vxIndex + 19;
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = alpha;
        t4.position = vxIndex + 20;
        t4.count = vxCount + 4;
      }, "call$2", "get$renderTextureQuad", 4, 0, 15, 9, 5],
      renderTextureMesh$3: function(renderState, ixList, vxList) {
        var alpha, matrix, ixListCount, t1, vxListCount, t2, ixData, t3, vxData, t4, t5, ixIndex, t6, vxIndex, vxCount, i, t7, ma, mb, mc, md, mx, my, o, x, y;
        alpha = J.get$globalAlpha$x(renderState);
        matrix = renderState.get$globalMatrix();
        ixListCount = ixList.length;
        t1 = vxList.length;
        vxListCount = t1 >>> 2;
        t2 = this._renderBufferIndex;
        ixData = t2.data;
        t3 = ixData.length;
        if (t2.position + ixListCount >= t3)
          this.flush$0(0);
        t2 = this._renderBufferVertex;
        vxData = t2.data;
        t4 = vxListCount * 5;
        t5 = vxData.length;
        if (t2.position + t4 >= t5)
          this.flush$0(0);
        t2 = this._renderBufferIndex;
        ixIndex = t2.position;
        t6 = this._renderBufferVertex;
        vxIndex = t6.position;
        vxCount = t6.count;
        for (i = 0; i < ixListCount; ++i) {
          t6 = ixIndex + i;
          t7 = ixList[i];
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (t6 >= t3)
            return H.ioore(ixData, t6);
          ixData[t6] = vxCount + t7;
        }
        t2.position = ixIndex + ixListCount;
        this._renderBufferIndex.count += ixListCount;
        t2 = matrix._data;
        ma = t2[0];
        mb = t2[1];
        mc = t2[2];
        md = t2[3];
        mx = t2[4];
        my = t2[5];
        for (i = 0, o = 0; i < vxListCount; ++i, o += 4) {
          if (o >= t1)
            return H.ioore(vxList, o);
          x = vxList[o];
          t2 = o + 1;
          if (t2 >= t1)
            return H.ioore(vxList, t2);
          y = vxList[t2];
          if (typeof x !== "number")
            return H.iae(x);
          if (typeof y !== "number")
            return H.iae(y);
          if (vxIndex >= t5)
            return H.ioore(vxData, vxIndex);
          vxData[vxIndex] = mx + ma * x + mc * y;
          t2 = vxIndex + 1;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = my + mb * x + md * y;
          t2 = vxIndex + 2;
          t3 = o + 2;
          if (t3 >= t1)
            return H.ioore(vxList, t3);
          t3 = vxList[t3];
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = t3;
          t3 = vxIndex + 3;
          t2 = o + 3;
          if (t2 >= t1)
            return H.ioore(vxList, t2);
          t2 = vxList[t2];
          if (t3 >= t5)
            return H.ioore(vxData, t3);
          vxData[t3] = t2;
          t2 = vxIndex + 4;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = alpha;
          vxIndex += 5;
        }
        t1 = this._renderBufferVertex;
        t1.position += t4;
        t1.count += vxListCount;
      }
    },
    RenderProgramTinted: {
      "^": "RenderProgram;_contextIdentifier,_renderingContext,_program,_attributes,_uniforms,_renderBufferIndex,_renderBufferVertex,_renderStatistics",
      get$vertexShaderSource: function() {
        return "\r\n    uniform mat4 uProjectionMatrix;\r\n    attribute vec2 aVertexPosition;\r\n    attribute vec2 aVertexTextCoord;\r\n    attribute vec4 aVertexColor;\r\n    varying vec2 vTextCoord;\r\n    varying vec4 vColor; \r\n\r\n    void main() {\r\n      vTextCoord = aVertexTextCoord;\r\n      vColor = aVertexColor;\r\n      gl_Position = vec4(aVertexPosition, 0.0, 1.0) * uProjectionMatrix;\r\n    }\r\n    ";
      },
      get$fragmentShaderSource: function() {
        return "\r\n    precision mediump float;\r\n    uniform sampler2D uSampler;\r\n    varying vec2 vTextCoord;\r\n    varying vec4 vColor; \r\n\r\n    void main() {\r\n      gl_FragColor = texture2D(uSampler, vTextCoord) * vColor;\r\n    }\r\n    ";
      },
      activate$1: function(_, renderContext) {
        var t1;
        this.super$RenderProgram$activate(0, renderContext);
        this._renderingContext.uniform1i(this._uniforms.$index(0, "uSampler"), 0);
        t1 = this._attributes;
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexPosition"), 2, 32, 0);
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexTextCoord"), 2, 32, 8);
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexColor"), 4, 32, 16);
      },
      renderTextureQuad$6: [function(renderState, renderTextureQuad, r, g, b, a) {
        var alpha, matrix, vxList, t1, ixData, t2, vxData, t3, ixIndex, t4, vxIndex, vxCount, t5, ma1, t6, ma2, mb1, mb2, mc1, mc2, md1, md2, colorA, colorR, colorG, colorB;
        if (renderTextureQuad.get$hasCustomVertices()) {
          this.renderTextureMesh$7(renderState, renderTextureQuad.get$ixList(), renderTextureQuad.get$vxList(), r, g, b, a);
          return;
        }
        alpha = J.get$globalAlpha$x(renderState);
        matrix = renderState.get$globalMatrix();
        vxList = renderTextureQuad.get$vxListQuad();
        t1 = this._renderBufferIndex;
        ixData = t1.data;
        t2 = ixData.length;
        if (t1.position + 6 >= t2)
          this.flush$0(0);
        t1 = this._renderBufferVertex;
        vxData = t1.data;
        t3 = vxData.length;
        if (t1.position + 32 >= t3)
          this.flush$0(0);
        t1 = this._renderBufferIndex;
        ixIndex = t1.position;
        t4 = this._renderBufferVertex;
        vxIndex = t4.position;
        vxCount = t4.count;
        if (ixIndex >= t2)
          return H.ioore(ixData, ixIndex);
        ixData[ixIndex] = vxCount;
        t4 = ixIndex + 1;
        if (t4 >= t2)
          return H.ioore(ixData, t4);
        ixData[t4] = vxCount + 1;
        t4 = ixIndex + 2;
        t5 = vxCount + 2;
        if (t4 >= t2)
          return H.ioore(ixData, t4);
        ixData[t4] = t5;
        t4 = ixIndex + 3;
        if (t4 >= t2)
          return H.ioore(ixData, t4);
        ixData[t4] = vxCount;
        t4 = ixIndex + 4;
        if (t4 >= t2)
          return H.ioore(ixData, t4);
        ixData[t4] = t5;
        t5 = ixIndex + 5;
        if (t5 >= t2)
          return H.ioore(ixData, t5);
        ixData[t5] = vxCount + 3;
        t1.position = ixIndex + 6;
        t1.count += 6;
        t1 = vxList[0];
        t5 = matrix._data;
        t2 = t5[0];
        t4 = t5[4];
        ma1 = t1 * t2 + t4;
        t6 = vxList[8];
        ma2 = t6 * t2 + t4;
        t4 = t5[1];
        t2 = t5[5];
        mb1 = t1 * t4 + t2;
        mb2 = t6 * t4 + t2;
        t2 = vxList[1];
        t4 = t5[2];
        mc1 = t2 * t4;
        t6 = vxList[9];
        mc2 = t6 * t4;
        t5 = t5[3];
        md1 = t2 * t5;
        md2 = t6 * t5;
        colorA = J.$mul$ns(a, alpha);
        colorR = J.$mul$ns(r, colorA);
        colorG = J.$mul$ns(g, colorA);
        colorB = J.$mul$ns(b, colorA);
        if (vxIndex >= t3)
          return H.ioore(vxData, vxIndex);
        vxData[vxIndex] = ma1 + mc1;
        t5 = vxIndex + 1;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = mb1 + md1;
        t5 = vxIndex + 2;
        t6 = vxList[2];
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = t6;
        t6 = vxIndex + 3;
        t5 = vxList[3];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t5;
        t5 = vxIndex + 4;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorR;
        t5 = vxIndex + 5;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorG;
        t5 = vxIndex + 6;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorB;
        t5 = vxIndex + 7;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorA;
        t5 = vxIndex + 8;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = ma2 + mc1;
        t5 = vxIndex + 9;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = mb2 + md1;
        t5 = vxIndex + 10;
        t6 = vxList[6];
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = t6;
        t6 = vxIndex + 11;
        t5 = vxList[7];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t5;
        t5 = vxIndex + 12;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorR;
        t5 = vxIndex + 13;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorG;
        t5 = vxIndex + 14;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorB;
        t5 = vxIndex + 15;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorA;
        t5 = vxIndex + 16;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = ma2 + mc2;
        t5 = vxIndex + 17;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = mb2 + md2;
        t5 = vxIndex + 18;
        t6 = vxList[10];
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = t6;
        t6 = vxIndex + 19;
        t5 = vxList[11];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t5;
        t5 = vxIndex + 20;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorR;
        t5 = vxIndex + 21;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorG;
        t5 = vxIndex + 22;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorB;
        t5 = vxIndex + 23;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorA;
        t5 = vxIndex + 24;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = ma1 + mc2;
        t5 = vxIndex + 25;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = mb1 + md2;
        t5 = vxIndex + 26;
        t6 = vxList[14];
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = t6;
        t6 = vxIndex + 27;
        t5 = vxList[15];
        if (t6 >= t3)
          return H.ioore(vxData, t6);
        vxData[t6] = t5;
        t5 = vxIndex + 28;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorR;
        t5 = vxIndex + 29;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorG;
        t5 = vxIndex + 30;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorB;
        t5 = vxIndex + 31;
        if (t5 >= t3)
          return H.ioore(vxData, t5);
        vxData[t5] = colorA;
        t5 = this._renderBufferVertex;
        t5.position += 32;
        t5.count += 4;
      }, "call$6", "get$renderTextureQuad", 12, 0, 66, 9, 5, 12, 51, 16, 15],
      renderTextureMesh$7: function(renderState, ixList, vxList, r, g, b, a) {
        var matrix, alpha, ixListCount, t1, vxListCount, t2, ixData, t3, vxData, t4, t5, ixIndex, t6, vxIndex, vxCount, i, t7, ma, mb, mc, md, mx, my, colorA, colorR, colorG, colorB, o, x, y;
        matrix = renderState.get$globalMatrix();
        alpha = J.get$globalAlpha$x(renderState);
        ixListCount = ixList.length;
        t1 = vxList.length;
        vxListCount = t1 >>> 2;
        t2 = this._renderBufferIndex;
        ixData = t2.data;
        t3 = ixData.length;
        if (t2.position + ixListCount >= t3)
          this.flush$0(0);
        t2 = this._renderBufferVertex;
        vxData = t2.data;
        t4 = vxListCount * 8;
        t5 = vxData.length;
        if (t2.position + t4 >= t5)
          this.flush$0(0);
        t2 = this._renderBufferIndex;
        ixIndex = t2.position;
        t6 = this._renderBufferVertex;
        vxIndex = t6.position;
        vxCount = t6.count;
        for (i = 0; i < ixListCount; ++i) {
          t6 = ixIndex + i;
          t7 = ixList[i];
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (t6 >= t3)
            return H.ioore(ixData, t6);
          ixData[t6] = vxCount + t7;
        }
        t2.position = ixIndex + ixListCount;
        this._renderBufferIndex.count += ixListCount;
        t2 = matrix._data;
        ma = t2[0];
        mb = t2[1];
        mc = t2[2];
        md = t2[3];
        mx = t2[4];
        my = t2[5];
        colorA = J.$mul$ns(a, alpha);
        colorR = J.$mul$ns(r, colorA);
        colorG = J.$mul$ns(g, colorA);
        colorB = J.$mul$ns(b, colorA);
        for (i = 0, o = 0; i < vxListCount; ++i, o += 4) {
          if (o >= t1)
            return H.ioore(vxList, o);
          x = vxList[o];
          t2 = o + 1;
          if (t2 >= t1)
            return H.ioore(vxList, t2);
          y = vxList[t2];
          if (typeof x !== "number")
            return H.iae(x);
          if (typeof y !== "number")
            return H.iae(y);
          if (vxIndex >= t5)
            return H.ioore(vxData, vxIndex);
          vxData[vxIndex] = mx + ma * x + mc * y;
          t2 = vxIndex + 1;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = my + mb * x + md * y;
          t2 = vxIndex + 2;
          t3 = o + 2;
          if (t3 >= t1)
            return H.ioore(vxList, t3);
          t3 = vxList[t3];
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = t3;
          t3 = vxIndex + 3;
          t2 = o + 3;
          if (t2 >= t1)
            return H.ioore(vxList, t2);
          t2 = vxList[t2];
          if (t3 >= t5)
            return H.ioore(vxData, t3);
          vxData[t3] = t2;
          t2 = vxIndex + 4;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorR;
          t2 = vxIndex + 5;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorG;
          t2 = vxIndex + 6;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorB;
          t2 = vxIndex + 7;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorA;
          vxIndex += 8;
        }
        t1 = this._renderBufferVertex;
        t1.position += t4;
        t1.count += vxListCount;
      }
    },
    RenderProgramTriangle: {
      "^": "RenderProgram;_contextIdentifier,_renderingContext,_program,_attributes,_uniforms,_renderBufferIndex,_renderBufferVertex,_renderStatistics",
      get$vertexShaderSource: function() {
        return "\r\n    uniform mat4 uProjectionMatrix;\r\n    attribute vec2 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n      vColor = aVertexColor;\r\n      gl_Position = vec4(aVertexPosition, 0.0, 1.0) * uProjectionMatrix;\r\n    }\r\n    ";
      },
      get$fragmentShaderSource: function() {
        return "\r\n    precision mediump float;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n      gl_FragColor = vColor;\r\n    }\r\n    ";
      },
      activate$1: function(_, renderContext) {
        var t1;
        this.super$RenderProgram$activate(0, renderContext);
        t1 = this._attributes;
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexPosition"), 2, 24, 0);
        this._renderBufferVertex.bindAttribute$4(t1.$index(0, "aVertexColor"), 4, 24, 8);
      },
      renderTriangleMesh$4: function(renderState, ixList, vxList, color) {
        var t1, matrix, alpha, ixListCount, vxListCount, t2, ixData, t3, vxData, t4, t5, ixIndex, t6, vxIndex, vxOffset, i, t7, ma, mb, mc, md, mx, my, colorA, colorR, colorG, colorB, o, x, y;
        t1 = renderState._currentContextState;
        matrix = t1.matrix;
        alpha = t1.alpha;
        ixListCount = ixList.length;
        t1 = vxList.length;
        vxListCount = t1 >>> 1;
        t2 = this._renderBufferIndex;
        ixData = t2.data;
        t3 = ixData.length;
        if (t2.position + ixListCount >= t3)
          this.flush$0(0);
        t2 = this._renderBufferVertex;
        vxData = t2.data;
        t4 = vxListCount * 6;
        t5 = vxData.length;
        if (t2.position + t4 >= t5)
          this.flush$0(0);
        t2 = this._renderBufferIndex;
        ixIndex = t2.position;
        t6 = this._renderBufferVertex;
        vxIndex = t6.position;
        vxOffset = t6.count;
        for (i = 0; i < ixListCount; ++i) {
          t6 = ixIndex + i;
          t7 = ixList[i];
          if (t6 >= t3)
            return H.ioore(ixData, t6);
          ixData[t6] = vxOffset + t7;
        }
        t2.position = ixIndex + ixListCount;
        this._renderBufferIndex.count += ixListCount;
        t2 = matrix._data;
        ma = t2[0];
        mb = t2[1];
        mc = t2[2];
        md = t2[3];
        mx = t2[4];
        my = t2[5];
        colorA = 0.00392156862745098 * (color >>> 24 & 255) * alpha;
        colorR = 0.00392156862745098 * (color >>> 16 & 255) * colorA;
        colorG = 0.00392156862745098 * (color >>> 8 & 255) * colorA;
        colorB = 0.00392156862745098 * (color & 255) * colorA;
        for (i = 0, o = 0; i < vxListCount; ++i, o += 2) {
          if (o >= t1)
            return H.ioore(vxList, o);
          x = vxList[o];
          t2 = o + 1;
          if (t2 >= t1)
            return H.ioore(vxList, t2);
          y = vxList[t2];
          if (vxIndex >= t5)
            return H.ioore(vxData, vxIndex);
          vxData[vxIndex] = mx + ma * x + mc * y;
          t2 = vxIndex + 1;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = my + mb * x + md * y;
          t2 = vxIndex + 2;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorR;
          t2 = vxIndex + 3;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorG;
          t2 = vxIndex + 4;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorB;
          t2 = vxIndex + 5;
          if (t2 >= t5)
            return H.ioore(vxData, t2);
          vxData[t2] = colorA;
          vxIndex += 6;
        }
        t1 = this._renderBufferVertex;
        t1.position += t4;
        t1.count += vxListCount;
      }
    },
    _ContextState: {
      "^": "Object;alpha>,blendMode<,matrix,matrix3D,previousContextState,_nextContextState"
    },
    RenderState: {
      "^": "Object;currentTime,deltaTime,_engine$_renderContext,_firstContextState,_currentContextState",
      get$globalMatrix: function() {
        return this._currentContextState.matrix;
      },
      get$globalAlpha: function(_) {
        return this._currentContextState.alpha;
      },
      get$globalBlendMode: function() {
        return this._currentContextState.blendMode;
      },
      reset$3: function(_, matrix, alpha, blendMode) {
        var t1, t2;
        t1 = this._firstContextState;
        this._currentContextState = t1;
        t1 = t1.matrix;
        t1.identity$0();
        t2 = this._currentContextState;
        t2.alpha = 1;
        t2.blendMode = C.BlendMode_bZz;
        t1.copyFrom$1(matrix);
      },
      reset$1: function($receiver, matrix) {
        return this.reset$3($receiver, matrix, null, null);
      },
      flush$0: function(_) {
        this._engine$_renderContext.flush$0(0);
      },
      renderTextureQuad$1: [function(renderTextureQuad) {
        this._engine$_renderContext.renderTextureQuad$2(this, renderTextureQuad);
      }, "call$1", "get$renderTextureQuad", 2, 0, 67, 5],
      renderObject$1: function(renderObject) {
        var matrix, blendMode, t1, alpha, filters, cache, mask, cs1, cs2, t2, maskAfter;
        matrix = renderObject.get$transformationMatrix();
        blendMode = renderObject.get$blendMode();
        t1 = J.getInterceptor$x(renderObject);
        alpha = t1.get$alpha(renderObject);
        filters = renderObject.get$filters();
        cache = renderObject.get$cache();
        mask = t1.get$mask(renderObject);
        cs1 = this._currentContextState;
        cs2 = cs1._nextContextState;
        if (cs2 == null) {
          t1 = T.Matrix$fromIdentity();
          t2 = new T.Matrix3D(new Float32Array(H._checkLength(16)));
          t2.setIdentity$0();
          cs2 = new L._ContextState(1, C.BlendMode_bZz, t1, t2, cs1, null);
          cs1._nextContextState = cs2;
        }
        t1 = mask != null;
        if (t1)
          mask.get$relativeToParent();
        if (t1) {
          mask.get$relativeToParent();
          maskAfter = true;
        } else
          maskAfter = false;
        cs2.matrix.copyFromAndConcat$2(matrix, cs1.matrix);
        cs2.blendMode = blendMode instanceof L.BlendMode ? blendMode : cs1.blendMode;
        cs2.alpha = J.$mul$ns(alpha, cs1.alpha);
        this._currentContextState = cs2;
        if (maskAfter)
          this._engine$_renderContext.beginRenderMask$2(this, mask);
        if (cache != null)
          this._engine$_renderContext.renderTextureQuad$2(this, cache);
        else if (filters.length > 0)
          renderObject.renderFiltered$1(this);
        else
          renderObject.render$1(this);
        if (maskAfter)
          this._engine$_renderContext.endRenderMask$2(this, mask);
        this._currentContextState = cs1;
      },
      push$3: function(matrix, alpha, blendMode) {
        var cs1, cs2, t1, t2;
        cs1 = this._currentContextState;
        cs2 = cs1._nextContextState;
        if (cs2 == null) {
          t1 = T.Matrix$fromIdentity();
          t2 = new T.Matrix3D(new Float32Array(H._checkLength(16)));
          t2.setIdentity$0();
          cs2 = new L._ContextState(1, C.BlendMode_bZz, t1, t2, cs1, null);
          cs1._nextContextState = cs2;
        }
        cs2.matrix.copyFromAndConcat$2(matrix, cs1.matrix);
        cs2.blendMode = blendMode instanceof L.BlendMode ? blendMode : cs1.blendMode;
        cs2.alpha = alpha * cs1.alpha;
        this._currentContextState = cs2;
      },
      RenderState$4: function(renderContext, matrix, alpha, blendMode) {
        var t1 = this._firstContextState;
        this._currentContextState = t1;
        if (matrix instanceof T.Matrix)
          t1.matrix.copyFrom$1(matrix);
        if (typeof alpha === "number")
          t1.alpha = alpha;
      },
      static: {
        RenderState$: function(renderContext, matrix, alpha, blendMode) {
          var t1, t2;
          t1 = T.Matrix$fromIdentity();
          t2 = new T.Matrix3D(new Float32Array(H._checkLength(16)));
          t2.setIdentity$0();
          t2 = new L.RenderState(0, 0, renderContext, new L._ContextState(1, C.BlendMode_bZz, t1, t2, null, null), null);
          t2.RenderState$4(renderContext, matrix, alpha, blendMode);
          return t2;
        }
      }
    },
    RenderStatistics: {
      "^": "Object;drawCount,vertexCount<,indexCount<",
      toString$0: function(_) {
        return "RenderStatistics: " + this.drawCount + " draws, " + this.vertexCount + " verices, " + this.indexCount + " indices";
      }
    },
    RenderStencilBuffer: {
      "^": "Object;_engine$_width,_engine$_height,_engine$_renderContext,_contextIdentifier,_renderingContext,_renderbuffer",
      get$width: function(_) {
        return this._engine$_width;
      },
      get$height: function(_) {
        return this._engine$_height;
      },
      resize$2: function(_, width, height) {
        var t1;
        if (this._engine$_width !== width || this._engine$_height !== height) {
          this._engine$_width = width;
          this._engine$_height = height;
          t1 = this._engine$_renderContext;
          if (t1 == null || this._renderbuffer == null)
            return;
          if (t1._contextIdentifier !== this._contextIdentifier)
            return;
          t1.activateRenderStencilBuffer$1(this);
          this._renderingContext.renderbufferStorage(36161, 34041, this._engine$_width, this._engine$_height);
        }
      },
      activate$1: function(_, renderContext) {
        var t1, t2;
        t1 = this._contextIdentifier;
        t2 = renderContext._contextIdentifier;
        if (t1 !== t2) {
          this._engine$_renderContext = renderContext;
          this._contextIdentifier = t2;
          t1 = renderContext._renderingContext;
          this._renderingContext = t1;
          t1 = t1.createRenderbuffer();
          this._renderbuffer = t1;
          this._renderingContext.bindRenderbuffer(36161, t1);
          this._renderingContext.renderbufferStorage(36161, 34041, this._engine$_width, this._engine$_height);
        } else
          this._renderingContext.bindRenderbuffer(36161, this._renderbuffer);
      }
    },
    RenderTexture: {
      "^": "Object;_engine$_width,_engine$_height,_engine$_source,_canvas,_filtering,_wrappingX,_wrappingY,_engine$_renderContext,_contextIdentifier,_textureSourceWorkaround,_renderingContext,_texture,_videoUpdateTime",
      get$width: function(_) {
        return this._engine$_width;
      },
      get$height: function(_) {
        return this._engine$_height;
      },
      get$quad: function() {
        var t1, t2, t3;
        t1 = this._engine$_width;
        t2 = this._engine$_height;
        t3 = [P.int];
        return L.RenderTextureQuad$(this, new U.Rectangle0(0, 0, t1, t2, t3), new U.Rectangle0(0, 0, t1, t2, t3), 0, 1);
      },
      get$canvas: function(_) {
        var t1, t2;
        t1 = this._engine$_source;
        t2 = J.getInterceptor(t1);
        if (!!t2.$isCanvasElement)
          return t1;
        else if (!!t2.$isImageElement) {
          t2 = this._engine$_width;
          t2 = W.CanvasElement_CanvasElement(this._engine$_height, t2);
          this._engine$_source = t2;
          this._canvas = t2;
          t2.getContext("2d").drawImage(t1, 0, 0, this._engine$_width, this._engine$_height);
          return this._canvas;
        } else
          throw H.wrapException(new P.StateError("RenderTexture is read only."));
      },
      set$filtering: function(filtering) {
        var t1;
        if (this._filtering === filtering)
          return;
        this._filtering = filtering;
        t1 = this._engine$_renderContext;
        if (t1 == null || this._texture == null)
          return;
        if (t1._contextIdentifier !== this._contextIdentifier)
          return;
        t1.activateRenderTexture$1(this);
        this._renderingContext.texParameteri(3553, 10241, this._filtering.value);
        this._renderingContext.texParameteri(3553, 10240, this._filtering.value);
      },
      dispose$0: function() {
        var t1 = this._renderingContext;
        if (t1 != null && this._texture != null)
          t1.deleteTexture(this._texture);
        this._texture = null;
        this._engine$_source = null;
        this._canvas = null;
        this._renderingContext = null;
        this._contextIdentifier = -1;
        t1 = $.$get$_globalFrameListeners();
        (t1 && C.JSArray_methods).remove$1(t1, this.get$_onGlobalFrame());
      },
      resize$2: function(_, width, height) {
        var t1 = this._engine$_source;
        if (!!J.getInterceptor(t1).$isVideoElement)
          throw H.wrapException(new P.StateError("RenderTexture is not resizeable."));
        else if (!(this._engine$_width === width && this._engine$_height === height))
          if (t1 == null) {
            this._engine$_width = width;
            this._engine$_height = height;
            t1 = this._engine$_renderContext;
            if (t1 == null || this._texture == null)
              return;
            if (t1._contextIdentifier !== this._contextIdentifier)
              return;
            t1.activateRenderTexture$1(this);
            t1 = this._renderingContext;
            (t1 && C.RenderingContext_methods).texImage2D$9(t1, 3553, 0, 6408, this._engine$_width, this._engine$_height, 0, 6408, 5121, null);
          } else {
            this._engine$_width = width;
            this._engine$_height = height;
            t1 = W.CanvasElement_CanvasElement(height, width);
            this._engine$_source = t1;
            this._canvas = t1;
          }
      },
      update$0: function(_) {
        var t1, t2;
        t1 = this._engine$_renderContext;
        if (t1 == null || this._texture == null)
          return;
        if (t1._contextIdentifier !== this._contextIdentifier)
          return;
        t1 = this._renderingContext.isEnabled(3089) === true;
        if (t1)
          this._renderingContext.disable(3089);
        if (this._textureSourceWorkaround) {
          t2 = this._canvas;
          t2.toString;
          t2.getContext("2d").drawImage(this._engine$_source, 0, 0);
          this._engine$_renderContext.activateRenderTexture$1(this);
          t2 = this._renderingContext;
          (t2 && C.RenderingContext_methods).texImage2D$6(t2, 3553, 0, 6408, 6408, 5121, this._canvas);
        } else {
          this._engine$_renderContext.activateRenderTexture$1(this);
          t2 = this._renderingContext;
          (t2 && C.RenderingContext_methods).texImage2D$6(t2, 3553, 0, 6408, 6408, 5121, this._engine$_source);
        }
        if (t1)
          this._renderingContext.enable(3089);
      },
      _onGlobalFrame$1: [function(deltaTime) {
        var t1, currentTime;
        t1 = this._engine$_source;
        if (!!J.getInterceptor(t1).$isVideoElement) {
          currentTime = t1.currentTime;
          t1 = this._videoUpdateTime;
          if (t1 == null ? currentTime != null : t1 !== currentTime) {
            this._videoUpdateTime = currentTime;
            this.update$0(0);
          }
        }
      }, "call$1", "get$_onGlobalFrame", 2, 0, 29, 20],
      RenderTexture$fromImageElement$1: function(imageElement) {
        var t1 = J.getInterceptor$x(imageElement);
        this._engine$_width = V.ensureInt(t1.get$width(imageElement));
        this._engine$_height = V.ensureInt(t1.get$height(imageElement));
        this._engine$_source = imageElement;
      },
      RenderTexture$3: function(width, height, fillColor) {
        var t1, context;
        if (width <= 0)
          throw H.wrapException(P.ArgumentError$("width"));
        if (height <= 0)
          throw H.wrapException(P.ArgumentError$("height"));
        this._engine$_width = V.ensureInt(width);
        t1 = V.ensureInt(height);
        this._engine$_height = t1;
        t1 = W.CanvasElement_CanvasElement(t1, this._engine$_width);
        this._canvas = t1;
        this._engine$_source = t1;
        if (fillColor !== 0) {
          context = t1.getContext("2d");
          context.fillStyle = V.color2rgba(fillColor);
          context.fillRect(0, 0, this._engine$_width, this._engine$_height);
        }
      },
      static: {
        RenderTexture$: function(width, height, fillColor) {
          var t1 = new L.RenderTexture(0, 0, null, null, C.RenderTextureFiltering_9729, C.RenderTextureWrapping_33071, C.RenderTextureWrapping_33071, null, -1, false, null, null, -1);
          t1.RenderTexture$3(width, height, fillColor);
          return t1;
        },
        RenderTexture$fromImageElement: function(imageElement) {
          var t1 = new L.RenderTexture(0, 0, null, null, C.RenderTextureFiltering_9729, C.RenderTextureWrapping_33071, C.RenderTextureWrapping_33071, null, -1, false, null, null, -1);
          t1.RenderTexture$fromImageElement$1(imageElement);
          return t1;
        }
      }
    },
    RenderTextureFiltering: {
      "^": "Object;value>"
    },
    RenderTextureQuad: {
      "^": "Object;renderTexture<,sourceRectangle<,offsetRectangle<,rotation<,pixelRatio<,ixListQuad,vxListQuad<,_ixList,_vxList,_hasCustomVertices",
      get$targetWidth: function() {
        return J.$div$n(this.offsetRectangle.width, this.pixelRatio);
      },
      get$targetHeight: function() {
        return J.$div$n(this.offsetRectangle.height, this.pixelRatio);
      },
      get$vxList: function() {
        return this._vxList;
      },
      get$ixList: function() {
        return this._ixList;
      },
      get$hasCustomVertices: function() {
        return this._hasCustomVertices;
      },
      get$drawMatrix: function() {
        var pr, t1, t2, tx, ty;
        pr = this.pixelRatio;
        t1 = this.rotation;
        if (t1 === 0) {
          t1 = this.sourceRectangle;
          t2 = this.offsetRectangle;
          return T.Matrix$(pr, 0, 0, pr, J.$add$ns(t1.left, t2.left), J.$add$ns(t1.top, t2.top));
        } else if (t1 === 1) {
          t1 = this.sourceRectangle;
          t2 = this.offsetRectangle;
          tx = J.$sub$n(J.$add$ns(t1.left, t1.width), t2.top);
          ty = J.$add$ns(t1.top, t2.left);
          if (typeof pr !== "number")
            return H.iae(pr);
          return T.Matrix$(0, pr, 0 - pr, 0, tx, ty);
        } else if (t1 === 2) {
          t1 = this.sourceRectangle;
          t2 = this.offsetRectangle;
          tx = J.$sub$n(J.$add$ns(t1.left, t1.width), t2.left);
          ty = J.$sub$n(J.$add$ns(t1.top, t1.height), t2.top);
          if (typeof pr !== "number")
            return H.iae(pr);
          t2 = 0 - pr;
          return T.Matrix$(t2, 0, 0, t2, tx, ty);
        } else if (t1 === 3) {
          t1 = this.sourceRectangle;
          t2 = this.offsetRectangle;
          tx = J.$add$ns(t1.left, t2.top);
          ty = J.$sub$n(J.$add$ns(t1.top, t1.height), t2.left);
          if (typeof pr !== "number")
            return H.iae(pr);
          return T.Matrix$(0, 0 - pr, pr, 0, tx, ty);
        } else
          throw H.wrapException(new P.Error());
      },
      cut$1: function(rectangle) {
        var t1, rL, rT, t2, t3;
        t1 = this.pixelRatio;
        rL = J.round$0$n(J.$mul$ns(rectangle.left, t1));
        rT = J.round$0$n(J.$mul$ns(rectangle.top, t1));
        t2 = J.round$0$n(J.$mul$ns(J.$add$ns(rectangle.left, rectangle.width), t1)) - rL;
        t1 = J.round$0$n(J.$mul$ns(J.$add$ns(rectangle.top, rectangle.height), t1)) - rT;
        t3 = [P.int];
        return L.RenderTextureQuad_RenderTextureQuad$slice(this, new U.Rectangle0(rL, rT, t2, t1, t3), new U.Rectangle0(0, 0, t2, t1, t3), 0);
      },
      getImageData$0: function(_) {
        var rect, t1;
        rect = this.sourceRectangle;
        t1 = this.renderTexture;
        return P.convertNativeToDart_ImageData(J.get$context2D$x(t1.get$canvas(t1)).getImageData(rect.left, rect.top, rect.width, rect.height));
      },
      putImageData$1: function(_, imageData) {
        var rect, t1, context;
        rect = this.sourceRectangle;
        t1 = this.renderTexture;
        context = J.get$context2D$x(t1.get$canvas(t1));
        (context && C.CanvasRenderingContext2D_methods).putImageData$3(context, imageData, rect.left, rect.top);
      },
      RenderTextureQuad$5: function(renderTexture, sourceRectangle, offsetRectangle, rotation, pixelRatio) {
        var sr, or, rt, pr, t1, t2, t3, t4, t5, t6;
        sr = this.sourceRectangle;
        or = this.offsetRectangle;
        rt = this.renderTexture;
        pr = this.pixelRatio;
        t1 = this.rotation;
        t2 = t1 === 0;
        if (t2 || t1 === 2) {
          t3 = this.vxListQuad;
          t4 = or.left;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = 0 - t4;
          if (typeof pr !== "number")
            return H.iae(pr);
          t5 = t4 / pr;
          t3[12] = t5;
          t3[0] = t5;
          t5 = or.top;
          if (typeof t5 !== "number")
            return H.iae(t5);
          t5 = 0 - t5;
          t6 = t5 / pr;
          t3[5] = t6;
          t3[1] = t6;
          t6 = sr.width;
          if (typeof t6 !== "number")
            return H.iae(t6);
          t4 = (t4 + t6) / pr;
          t3[4] = t4;
          t3[8] = t4;
          t4 = sr.height;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = (t5 + t4) / pr;
          t3[13] = t4;
          t3[9] = t4;
          t4 = t6;
        } else {
          if (t1 === 1 || t1 === 3) {
            t3 = this.vxListQuad;
            t4 = or.left;
            if (typeof t4 !== "number")
              return H.iae(t4);
            t4 = 0 - t4;
            if (typeof pr !== "number")
              return H.iae(pr);
            t5 = t4 / pr;
            t3[12] = t5;
            t3[0] = t5;
            t5 = or.top;
            if (typeof t5 !== "number")
              return H.iae(t5);
            t5 = 0 - t5;
            t6 = t5 / pr;
            t3[5] = t6;
            t3[1] = t6;
            t6 = sr.height;
            if (typeof t6 !== "number")
              return H.iae(t6);
            t6 = (t4 + t6) / pr;
            t3[4] = t6;
            t3[8] = t6;
            t6 = sr.width;
            if (typeof t6 !== "number")
              return H.iae(t6);
            t5 = (t5 + t6) / pr;
            t3[13] = t5;
            t3[9] = t5;
          } else
            throw H.wrapException(new P.Error());
          t4 = t6;
        }
        if (t2) {
          t1 = J.$div$n(sr.left, rt._engine$_width);
          t3[14] = t1;
          t3[2] = t1;
          t1 = J.$div$n(sr.top, rt._engine$_height);
          t3[7] = t1;
          t3[3] = t1;
          t1 = J.$div$n(J.$add$ns(sr.left, sr.width), rt._engine$_width);
          t3[6] = t1;
          t3[10] = t1;
          t1 = J.$div$n(J.$add$ns(sr.top, sr.height), rt._engine$_height);
          t3[15] = t1;
          t3[11] = t1;
        } else if (t1 === 1) {
          t1 = J.$div$n(J.$add$ns(sr.left, t4), rt._engine$_width);
          t3[6] = t1;
          t3[2] = t1;
          t1 = J.$div$n(sr.top, rt._engine$_height);
          t3[15] = t1;
          t3[3] = t1;
          t1 = J.$div$n(sr.left, rt._engine$_width);
          t3[14] = t1;
          t3[10] = t1;
          t1 = J.$div$n(J.$add$ns(sr.top, sr.height), rt._engine$_height);
          t3[7] = t1;
          t3[11] = t1;
        } else if (t1 === 2) {
          t1 = J.$div$n(J.$add$ns(sr.left, t4), rt._engine$_width);
          t3[14] = t1;
          t3[2] = t1;
          t1 = J.$div$n(J.$add$ns(sr.top, sr.height), rt._engine$_height);
          t3[7] = t1;
          t3[3] = t1;
          t1 = J.$div$n(sr.left, rt._engine$_width);
          t3[6] = t1;
          t3[10] = t1;
          t1 = J.$div$n(sr.top, rt._engine$_height);
          t3[15] = t1;
          t3[11] = t1;
        } else if (t1 === 3) {
          t1 = J.$div$n(sr.left, rt._engine$_width);
          t3[6] = t1;
          t3[2] = t1;
          t1 = J.$div$n(J.$add$ns(sr.top, sr.height), rt._engine$_height);
          t3[15] = t1;
          t3[3] = t1;
          t1 = J.$div$n(J.$add$ns(sr.left, sr.width), rt._engine$_width);
          t3[14] = t1;
          t3[10] = t1;
          t1 = J.$div$n(sr.top, rt._engine$_height);
          t3[7] = t1;
          t3[11] = t1;
        } else
          throw H.wrapException(new P.Error());
        t1 = this.ixListQuad;
        t1[0] = 0;
        t1[1] = 1;
        t1[2] = 2;
        t1[3] = 0;
        t1[4] = 2;
        t1[5] = 3;
        this._vxList = t3;
        this._ixList = t1;
        this._hasCustomVertices = false;
      },
      static: {
        RenderTextureQuad$: function(renderTexture, sourceRectangle, offsetRectangle, rotation, pixelRatio) {
          var t1 = new L.RenderTextureQuad(renderTexture, sourceRectangle, offsetRectangle, rotation, pixelRatio, new Int16Array(H._checkLength(6)), new Float32Array(H._checkLength(16)), null, null, false);
          t1.RenderTextureQuad$5(renderTexture, sourceRectangle, offsetRectangle, rotation, pixelRatio);
          return t1;
        },
        RenderTextureQuad_RenderTextureQuad$slice: function(renderTextureQuad, sourceRectangle, offsetRectangle, rotation) {
          var renderTexture, pixelRatio, oldRotation, oldSourceL, oldSourceT, t1, oldSourceR, oldSourceB, oldOffsetL, oldOffsetT, newRotation, newSourceL, newSourceT, newSourceR, newSourceB, newOffsetL, newOffsetT, newOffsetW, newOffsetH, tmpSourceL, t2, tmpSourceT, tmpSourceR, tmpSourceB;
          renderTexture = renderTextureQuad.get$renderTexture();
          pixelRatio = renderTextureQuad.get$pixelRatio();
          oldRotation = renderTextureQuad.get$rotation();
          oldSourceL = renderTextureQuad.get$sourceRectangle().left;
          oldSourceT = renderTextureQuad.get$sourceRectangle().top;
          t1 = renderTextureQuad.get$sourceRectangle();
          oldSourceR = J.$add$ns(t1.left, t1.width);
          t1 = renderTextureQuad.get$sourceRectangle();
          oldSourceB = J.$add$ns(t1.top, t1.height);
          oldOffsetL = renderTextureQuad.get$offsetRectangle().left;
          oldOffsetT = renderTextureQuad.get$offsetRectangle().top;
          newRotation = C.JSNumber_methods.$mod(J.$add$ns(renderTextureQuad.get$rotation(), rotation), 4);
          newSourceL = sourceRectangle.left;
          newSourceT = sourceRectangle.top;
          newSourceR = J.$add$ns(newSourceL, sourceRectangle.width);
          newSourceB = J.$add$ns(sourceRectangle.top, sourceRectangle.height);
          newOffsetL = offsetRectangle.left;
          newOffsetT = offsetRectangle.top;
          newOffsetW = offsetRectangle.width;
          newOffsetH = offsetRectangle.height;
          if (oldRotation === 0) {
            t1 = J.getInterceptor$ns(oldSourceL);
            tmpSourceL = J.$add$ns(t1.$add(oldSourceL, oldOffsetL), newSourceL);
            t2 = J.getInterceptor$ns(oldSourceT);
            tmpSourceT = J.$add$ns(t2.$add(oldSourceT, oldOffsetT), newSourceT);
            tmpSourceR = J.$add$ns(t1.$add(oldSourceL, oldOffsetL), newSourceR);
            tmpSourceB = J.$add$ns(t2.$add(oldSourceT, oldOffsetT), newSourceB);
          } else if (oldRotation === 1) {
            t1 = J.getInterceptor$n(oldSourceR);
            tmpSourceL = J.$sub$n(t1.$sub(oldSourceR, oldOffsetT), newSourceB);
            t2 = J.getInterceptor$ns(oldSourceT);
            tmpSourceT = J.$add$ns(t2.$add(oldSourceT, oldOffsetL), newSourceL);
            tmpSourceR = J.$sub$n(t1.$sub(oldSourceR, oldOffsetT), newSourceT);
            tmpSourceB = J.$add$ns(t2.$add(oldSourceT, oldOffsetL), newSourceR);
          } else if (oldRotation === 2) {
            t1 = J.getInterceptor$n(oldSourceR);
            tmpSourceL = J.$sub$n(t1.$sub(oldSourceR, oldOffsetL), newSourceR);
            t2 = J.getInterceptor$n(oldSourceB);
            tmpSourceT = J.$sub$n(t2.$sub(oldSourceB, oldOffsetT), newSourceB);
            tmpSourceR = J.$sub$n(t1.$sub(oldSourceR, oldOffsetL), newSourceL);
            tmpSourceB = J.$sub$n(t2.$sub(oldSourceB, oldOffsetT), newSourceT);
          } else if (oldRotation === 3) {
            t1 = J.getInterceptor$ns(oldSourceL);
            tmpSourceL = J.$add$ns(t1.$add(oldSourceL, oldOffsetT), newSourceT);
            t2 = J.getInterceptor$n(oldSourceB);
            tmpSourceT = J.$sub$n(t2.$sub(oldSourceB, oldOffsetL), newSourceR);
            tmpSourceR = J.$add$ns(t1.$add(oldSourceL, oldOffsetT), newSourceB);
            tmpSourceB = J.$sub$n(t2.$sub(oldSourceB, oldOffsetL), newSourceL);
          } else {
            tmpSourceL = 0;
            tmpSourceT = 0;
            tmpSourceR = 0;
            tmpSourceB = 0;
          }
          newSourceL = V.clampInt(tmpSourceL, oldSourceL, oldSourceR);
          newSourceT = V.clampInt(tmpSourceT, oldSourceT, oldSourceB);
          newSourceR = V.clampInt(tmpSourceR, oldSourceL, oldSourceR);
          newSourceB = V.clampInt(tmpSourceB, oldSourceT, oldSourceB);
          if (newRotation === 0) {
            newOffsetL = J.$add$ns(newOffsetL, J.$sub$n(tmpSourceL, newSourceL));
            newOffsetT = J.$add$ns(newOffsetT, J.$sub$n(tmpSourceT, newSourceT));
          } else if (newRotation === 1) {
            newOffsetL = J.$add$ns(newOffsetL, J.$sub$n(tmpSourceT, newSourceT));
            newOffsetT = J.$add$ns(newOffsetT, J.$sub$n(newSourceR, tmpSourceR));
          } else if (newRotation === 2) {
            newOffsetL = J.$add$ns(newOffsetL, J.$sub$n(newSourceR, tmpSourceR));
            newOffsetT = J.$add$ns(newOffsetT, J.$sub$n(tmpSourceB, newSourceB));
          } else if (newRotation === 3) {
            newOffsetL = J.$add$ns(newOffsetL, J.$sub$n(newSourceB, tmpSourceB));
            newOffsetT = J.$add$ns(newOffsetT, J.$sub$n(newSourceL, tmpSourceL));
          }
          t1 = [P.int];
          return L.RenderTextureQuad$(renderTexture, new U.Rectangle0(newSourceL, newSourceT, J.$sub$n(newSourceR, newSourceL), J.$sub$n(newSourceB, newSourceT), t1), new U.Rectangle0(newOffsetL, newOffsetT, newOffsetW, newOffsetH, t1), newRotation, pixelRatio);
        }
      }
    },
    RenderTextureWrapping: {
      "^": "Object;value>"
    }
  }], ["stagexl.errors", "package:stagexl/src/errors.dart",, T, {
    "^": "",
    LoadError: {
      "^": "Error;message,error>",
      toString$0: function(_) {
        var result = "LoadError: " + this.message;
        return result;
      }
    }
  }], ["stagexl.events", "package:stagexl/src/events.dart",, R, {
    "^": "",
    _dispatchBroadcastEvent: function(broadcastEvent, subscriptions) {
      var $length, i, subscription, t1;
      $length = subscriptions.length;
      for (i = 0; i < $length; ++i) {
        if (i < 0 || i >= subscriptions.length)
          return H.ioore(subscriptions, i);
        subscription = subscriptions[i];
        if (!subscription._canceled) {
          broadcastEvent._isPropagationStopped = false;
          broadcastEvent._isImmediatePropagationStopped = false;
          t1 = subscription._eventStream.target;
          broadcastEvent._events$_target = t1;
          broadcastEvent._currentTarget = t1;
          broadcastEvent._eventPhase = C.EventPhase_1;
          subscription.eventListener$1(broadcastEvent);
        } else {
          C.JSArray_methods.removeAt$1(subscriptions, i);
          --$length;
          --i;
        }
      }
    },
    BroadcastEvent: {
      "^": "Event;",
      get$captures: function() {
        return false;
      }
    },
    EnterFrameEvent: {
      "^": "BroadcastEvent;passedTime<,_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped"
    },
    ExitFrameEvent: {
      "^": "BroadcastEvent;_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped"
    },
    RenderEvent: {
      "^": "BroadcastEvent;_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped"
    },
    Event: {
      "^": "Object;_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped",
      stopPropagation$0: function(_) {
        this._isPropagationStopped = true;
      },
      stopImmediatePropagation$0: function(_) {
        this._isPropagationStopped = true;
        this._isImmediatePropagationStopped = true;
      },
      get$type: function(_) {
        return this._type;
      },
      get$captures: function() {
        return true;
      },
      get$target: function(_) {
        return this._events$_target;
      },
      get$currentTarget: function(_) {
        return this._currentTarget;
      }
    },
    EventDispatcher: {
      "^": "Object;",
      on$1: function(_, eventType) {
        var eventStreams, eventStream;
        eventStreams = this._eventStreams;
        if (eventStreams == null) {
          eventStreams = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.String, [R.EventStream, R.Event]]);
          this._eventStreams = eventStreams;
        }
        eventStream = eventStreams.$index(0, eventType);
        if (eventStream == null) {
          eventStream = new R.EventStream(this, eventType, new Array(0), 0, [null]);
          eventStreams.$indexSet(0, eventType, eventStream);
        }
        return eventStream;
      },
      hasEventListener$2$useCapture: function(eventType, useCapture) {
        var eventStreams, eventStream;
        eventStreams = this._eventStreams;
        if (eventStreams == null)
          return false;
        eventStream = eventStreams.$index(0, eventType);
        if (eventStream == null)
          return false;
        return useCapture ? eventStream.get$hasCapturingSubscriptions() : eventStream.get$hasBubblingSubscriptions();
      },
      hasEventListener$1: function(eventType) {
        return this.hasEventListener$2$useCapture(eventType, false);
      },
      addEventListener$4$priority$useCapture: function(_, eventType, eventListener, priority, useCapture) {
        return this.on$1(0, eventType)._subscribe$3(eventListener, false, priority);
      },
      addEventListener$2: function($receiver, eventType, eventListener) {
        return this.addEventListener$4$priority$useCapture($receiver, eventType, eventListener, 0, false);
      },
      dispatchEvent$1: function(_, $event) {
        this.dispatchEventRaw$3($event, this, C.EventPhase_1);
      },
      dispatchEventRaw$3: function($event, target, eventPhase) {
        var eventStreams, eventStream;
        $event._isPropagationStopped = false;
        $event._isImmediatePropagationStopped = false;
        eventStreams = this._eventStreams;
        if (eventStreams == null)
          return;
        eventStream = eventStreams.$index(0, $event._type);
        if (eventStream == null)
          return;
        eventStream._dispatchEventInternal$3($event, target, eventPhase);
      }
    },
    EventPhase: {
      "^": "Object;index,_events$_name",
      toString$0: function(_) {
        return this._events$_name;
      }
    },
    EventStream: {
      "^": "Stream;target>,eventType,_subscriptions,_capturingSubscriptionCount,$ti",
      get$hasCapturingSubscriptions: function() {
        return this._capturingSubscriptionCount > 0;
      },
      get$hasBubblingSubscriptions: function() {
        return this._subscriptions.length > this._capturingSubscriptionCount;
      },
      listen$5$cancelOnError$onDone$onError$priority: function(onData, cancelOnError, onDone, onError, priority) {
        return this._subscribe$3(onData, false, priority);
      },
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        return this.listen$5$cancelOnError$onDone$onError$priority(onData, cancelOnError, onDone, onError, 0);
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$5$cancelOnError$onDone$onError$priority(onData, false, onDone, onError, 0);
      },
      listen$1: function(onData) {
        return this.listen$5$cancelOnError$onDone$onError$priority(onData, false, null, null, 0);
      },
      _subscribe$3: function(eventListener, captures, priority) {
        var subscription, oldSubscriptions, t1, newSubscriptions, t2, index, o, n, oldSubscription, n0;
        subscription = new R.EventStreamSubscription(priority, 0, false, false, this, eventListener, this.$ti);
        oldSubscriptions = this._subscriptions;
        t1 = oldSubscriptions.length;
        newSubscriptions = H.setRuntimeTypeInfo(new Array(t1 + 1), [R.EventStreamSubscription]);
        t2 = newSubscriptions.length;
        index = t2 - 1;
        for (o = 0, n = 0; o < t1; ++o, n = n0) {
          oldSubscription = oldSubscriptions[o];
          if (o === n && oldSubscription._priority < priority) {
            n0 = n + 1;
            index = n;
            n = n0;
          }
          n0 = n + 1;
          if (n >= t2)
            return H.ioore(newSubscriptions, n);
          newSubscriptions[n] = oldSubscription;
        }
        if (index < 0 || index >= t2)
          return H.ioore(newSubscriptions, index);
        newSubscriptions[index] = subscription;
        this._subscriptions = newSubscriptions;
        switch (this.eventType) {
          case "enterFrame":
            $.$get$_enterFrameSubscriptions().push(subscription);
            break;
          case "exitFrame":
            $.$get$_exitFrameSubscriptions().push(subscription);
            break;
          case "render":
            $.$get$_renderSubscriptions().push(subscription);
            break;
        }
        return subscription;
      },
      _unsubscribe$2: function(eventListener, captures) {
        var subscriptions, t1, i, subscription, t2;
        subscriptions = this._subscriptions;
        for (t1 = subscriptions.length, i = 0; i < t1; ++i) {
          subscription = subscriptions[i];
          if (J.$eq$(subscription._eventListener, eventListener)) {
            subscription._captures;
            t2 = true;
          } else
            t2 = false;
          if (t2)
            this._cancelSubscription$1(subscription);
        }
      },
      _cancelSubscription$1: function(eventStreamSubscription) {
        var oldSubscriptions, t1, newSubscriptions, t2, o, n, oldSubscription, n0;
        eventStreamSubscription._canceled = true;
        oldSubscriptions = this._subscriptions;
        t1 = oldSubscriptions.length;
        if (t1 === 0)
          return;
        newSubscriptions = H.setRuntimeTypeInfo(new Array(t1 - 1), [R.EventStreamSubscription]);
        for (t2 = newSubscriptions.length, o = 0, n = 0; o < t1; ++o) {
          oldSubscription = oldSubscriptions[o];
          if (oldSubscription == null ? eventStreamSubscription == null : oldSubscription === eventStreamSubscription)
            continue;
          if (n >= t2)
            return;
          n0 = n + 1;
          newSubscriptions[n] = oldSubscription;
          n = n0;
        }
        eventStreamSubscription._captures;
        this._subscriptions = newSubscriptions;
      },
      _dispatchEventInternal$3: function($event, target, eventPhase) {
        var subscriptions, isCapturing, inputEvent, t1, t2, i, subscription, t3;
        subscriptions = this._subscriptions;
        isCapturing = eventPhase === C.EventPhase_0;
        inputEvent = !!$event.$isInputEvent ? $event : null;
        for (t1 = subscriptions.length, t2 = this.target, i = 0; i < t1; ++i) {
          subscription = subscriptions[i];
          if (!subscription._canceled)
            if (subscription._pauseCount <= 0) {
              subscription._captures;
              t3 = isCapturing;
            } else
              t3 = true;
          else
            t3 = true;
          if (t3)
            continue;
          $event._events$_target = target;
          $event._currentTarget = t2;
          $event._eventPhase = eventPhase;
          $.InputEvent_current = inputEvent;
          subscription.eventListener$1($event);
          $.InputEvent_current = null;
          if ($event._isImmediatePropagationStopped)
            return;
        }
      }
    },
    EventStreamSubscription: {
      "^": "StreamSubscription;_priority,_pauseCount,_canceled,_captures,_eventStream,_eventListener,$ti",
      get$isPaused: function() {
        return this._pauseCount > 0;
      },
      get$eventListener: function() {
        return this._eventListener;
      },
      cancel$0: function(_) {
        if (!this._canceled)
          this._eventStream._cancelSubscription$1(this);
        return;
      },
      pause$1: function(_, resumeSignal) {
        ++this._pauseCount;
      },
      pause$0: function($receiver) {
        return this.pause$1($receiver, null);
      },
      resume$0: function(_) {
        var t1 = this._pauseCount;
        if (t1 === 0)
          throw H.wrapException(new P.StateError("Subscription is not paused."));
        this._pauseCount = t1 - 1;
      },
      eventListener$1: function(arg0) {
        return this.get$eventListener().call$1(arg0);
      }
    },
    InputEventMode: {
      "^": "Object;index,_events$_name",
      toString$0: function(_) {
        return this._events$_name;
      }
    },
    InputEvent: {
      "^": "Event;localX<,localY<,stageX<,stageY<,altKey>,ctrlKey>,shiftKey>",
      preventDefault$0: function(_) {
        this._isDefaultPrevented = true;
      }
    },
    KeyboardEvent0: {
      "^": "Event;"
    },
    MouseEvent: {
      "^": "InputEvent;deltaX>,deltaY>,buttonDown<,clickCount,localX,localY,stageX,stageY,altKey,ctrlKey,shiftKey,_isDefaultPrevented,_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped"
    },
    TextEvent0: {
      "^": "Event;"
    },
    TouchEvent: {
      "^": "InputEvent;touchPointID<,isPrimaryTouchPoint<,localX,localY,stageX,stageY,altKey,ctrlKey,shiftKey,_isDefaultPrevented,_type,_bubbles,_eventPhase,_events$_target,_currentTarget,_isPropagationStopped,_isImmediatePropagationStopped"
    }
  }], ["stagexl.filters.drop_shadow", "package:stagexl/src/filters/drop_shadow_filter.dart",, Y, {
    "^": "",
    DropShadowFilter: {
      "^": "BitmapFilter;_distance,_angle,_blurX,_blurY,_quality,_color,knockout,hideObject,_renderPassSources,_renderPassTargets",
      get$overlap: function() {
        var t1, t2, shiftX, shiftY, t3;
        t1 = this._distance;
        t2 = Math.cos(H.checkNum(this._angle));
        if (typeof t1 !== "number")
          return t1.$mul();
        shiftX = C.JSNumber_methods.round$0(t1 * t2);
        t2 = this._distance;
        t1 = Math.sin(H.checkNum(this._angle));
        if (typeof t2 !== "number")
          return t2.$mul();
        shiftY = C.JSNumber_methods.round$0(t2 * t1);
        t1 = [P.int];
        t2 = this._blurX;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = this._blurY;
        if (typeof t3 !== "number")
          return H.iae(t3);
        return new U.Rectangle0(-1, -1, 2, 2, t1).boundingBox$1(0, new U.Rectangle0(shiftX - t2, shiftY - t3, 2 * t2, 2 * t3, t1));
      },
      get$renderPassSources: function() {
        return this._renderPassSources;
      },
      get$renderPassTargets: function() {
        return this._renderPassTargets;
      },
      set$quality: function(value) {
        var t1, t2, i, t3, t4;
        P.RangeError_checkValueInInterval(value, 1, 5, null, null);
        this._quality = value;
        t1 = this._renderPassSources;
        C.JSArray_methods.set$length(t1, 0);
        t2 = this._renderPassTargets;
        C.JSArray_methods.set$length(t2, 0);
        if (typeof value !== "number")
          return H.iae(value);
        i = 0;
        for (; i < value; ++i) {
          t3 = i * 2;
          t1.push(t3);
          t4 = t3 + 1;
          t1.push(t4);
          t2.push(t4);
          t2.push(t3 + 2);
        }
        t1.push(0);
        t2.push(value * 2);
      },
      apply$2: function(bitmapData, rectangle) {
        var renderTextureQuad, sourceImageData, imageData, t1, data, width, height, t2, shiftX, shiftY, pixelRatio, blurX, blurY, alphaChannel, stride, x, y;
        renderTextureQuad = bitmapData.renderTextureQuad;
        sourceImageData = this.hideObject === false || this.knockout === true ? renderTextureQuad.getImageData$0(0) : null;
        imageData = renderTextureQuad.getImageData$0(0);
        t1 = J.getInterceptor$x(imageData);
        data = t1.get$data(imageData);
        width = V.ensureInt(t1.get$width(imageData));
        height = V.ensureInt(t1.get$height(imageData));
        t1 = this._distance;
        t2 = Math.cos(H.checkNum(this._angle));
        if (typeof t1 !== "number")
          return t1.$mul();
        shiftX = C.JSNumber_methods.round$0(t1 * t2);
        t2 = this._distance;
        t1 = Math.sin(H.checkNum(this._angle));
        if (typeof t2 !== "number")
          return t2.$mul();
        shiftY = C.JSNumber_methods.round$0(t2 * t1);
        pixelRatio = renderTextureQuad.pixelRatio;
        t1 = this._blurX;
        if (typeof t1 !== "number")
          return t1.$mul();
        if (typeof pixelRatio !== "number")
          return H.iae(pixelRatio);
        blurX = C.JSNumber_methods.round$0(t1 * pixelRatio);
        t1 = this._blurY;
        if (typeof t1 !== "number")
          return t1.$mul();
        blurY = C.JSNumber_methods.round$0(t1 * pixelRatio);
        alphaChannel = A.BitmapDataChannel_getCanvasIndex(8);
        stride = width * 4;
        L.shiftChannel(data, 3, width, height, shiftX, shiftY);
        for (x = 0; x < width; ++x)
          L.blur(data, x * 4 + alphaChannel, height, stride, blurY);
        for (y = 0; y < height; ++y)
          L.blur(data, y * stride + alphaChannel, width, 4, blurX);
        if (this.knockout === true)
          L.setColorKnockout(data, this._color, J.get$data$x(sourceImageData));
        else {
          t1 = this.hideObject;
          t2 = this._color;
          if (t1 === true)
            L.setColor(data, t2);
          else
            L.setColorBlend(data, t2, J.get$data$x(sourceImageData));
        }
        renderTextureQuad.putImageData$1(0, imageData);
      },
      apply$1: function(bitmapData) {
        return this.apply$2(bitmapData, null);
      },
      renderFilter$3: function(renderState, renderTextureQuad, pass) {
        var renderContext, renderTexture, passCount, passScale, t1, pixelRatio, pixelRatioScale, pixelRatioDistance, renderProgram, t2, t3, t4, t5, t6;
        renderContext = renderState._engine$_renderContext;
        renderTexture = renderTextureQuad.get$renderTexture();
        passCount = this._renderPassSources.length;
        passScale = Math.pow(0.5, pass >>> 1);
        t1 = renderState._currentContextState.matrix._data;
        pixelRatio = Math.sqrt(Math.abs(t1[0] * t1[3] - t1[1] * t1[2]));
        pixelRatioScale = pixelRatio * passScale;
        t1 = this._distance;
        if (typeof t1 !== "number")
          return H.iae(t1);
        pixelRatioDistance = pixelRatio * t1;
        if (pass === passCount - 1) {
          if (this.knockout !== true && this.hideObject !== true)
            renderContext.renderTextureQuad$2(renderState, renderTextureQuad);
        } else {
          renderProgram = renderContext.getRenderProgram$2("$DropShadowFilterProgram", new Y.DropShadowFilter_renderFilter_closure());
          renderContext.activateRenderProgram$1(renderProgram);
          renderContext.activateRenderTexture$1(renderTexture);
          t1 = pass === passCount - 2;
          t2 = this._color;
          if (!t1) {
            if (typeof t2 !== "number")
              return t2.$or();
            t2 = (t2 | 4278190080) >>> 0;
          }
          t1 = t1 ? renderState._currentContextState.alpha : 1;
          t3 = pass === 0;
          t4 = t3 ? pixelRatioDistance * Math.cos(H.checkNum(this._angle)) / renderTexture._engine$_width : 0;
          t3 = t3 ? pixelRatioDistance * Math.sin(H.checkNum(this._angle)) / renderTexture._engine$_height : 0;
          t5 = (pass & 1) === 0;
          if (t5) {
            t6 = this._blurX;
            if (typeof t6 !== "number")
              return H.iae(t6);
            t6 = pixelRatioScale * t6 / renderTexture._engine$_width;
          } else
            t6 = 0;
          if (t5)
            t5 = 0;
          else {
            t5 = this._blurY;
            if (typeof t5 !== "number")
              return H.iae(t5);
            t5 = pixelRatioScale * t5 / renderTexture._engine$_height;
          }
          renderProgram.configure$6(t2, t1, t4, t3, t6, t5);
          renderProgram.renderTextureQuad$2(renderState, renderTextureQuad);
          J.flush$0$x(renderProgram);
        }
      }
    },
    DropShadowFilter_renderFilter_closure: {
      "^": "Closure:1;",
      call$0: function() {
        var t1 = P.String;
        return new Y.DropShadowFilterProgram(-1, null, null, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t1, P.int]), new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t1, P.UniformLocation]), new L.RenderBufferIndex(new Int16Array(H._checkLength(0)), 35048, 0, 0, -1, null, null, null), new L.RenderBufferVertex(new Float32Array(H._checkLength(0)), 35048, 0, 0, -1, null, null, null), new L.RenderStatistics(0, 0, 0));
      }
    },
    DropShadowFilterProgram: {
      "^": "RenderProgramSimple;_contextIdentifier,_renderingContext,_program,_attributes,_uniforms,_renderBufferIndex,_renderBufferVertex,_renderStatistics",
      get$vertexShaderSource: function() {
        return "\r\n    uniform mat4 uProjectionMatrix;\r\n    uniform vec2 uRadius;\r\n    uniform vec2 uShift;\r\n\r\n    attribute vec2 aVertexPosition;\r\n    attribute vec2 aVertexTextCoord;\r\n\r\n    varying vec2 vBlurCoords[7];\r\n\r\n    void main() {\r\n      vec2 texCoord = aVertexTextCoord - uShift;\r\n      vBlurCoords[0] = texCoord - uRadius * 1.2;\r\n      vBlurCoords[1] = texCoord - uRadius * 0.8;\r\n      vBlurCoords[2] = texCoord - uRadius * 0.4;\r\n      vBlurCoords[3] = texCoord;\r\n      vBlurCoords[4] = texCoord + uRadius * 0.4;\r\n      vBlurCoords[5] = texCoord + uRadius * 0.8;\r\n      vBlurCoords[6] = texCoord + uRadius * 1.2;\r\n      gl_Position = vec4(aVertexPosition, 0.0, 1.0) * uProjectionMatrix;\r\n    }\r\n    ";
      },
      get$fragmentShaderSource: function() {
        return "\r\n    precision mediump float;\r\n\r\n    uniform sampler2D uSampler;\r\n    uniform vec4 uColor;\r\n      \r\n    varying vec2 vBlurCoords[7];\r\n\r\n    void main() {\r\n      float alpha = 0.0;\r\n      alpha += texture2D(uSampler, vBlurCoords[0]).a * 0.00443;\r\n      alpha += texture2D(uSampler, vBlurCoords[1]).a * 0.05399;\r\n      alpha += texture2D(uSampler, vBlurCoords[2]).a * 0.24197;\r\n      alpha += texture2D(uSampler, vBlurCoords[3]).a * 0.39894;\r\n      alpha += texture2D(uSampler, vBlurCoords[4]).a * 0.24197;\r\n      alpha += texture2D(uSampler, vBlurCoords[5]).a * 0.05399;\r\n      alpha += texture2D(uSampler, vBlurCoords[6]).a * 0.00443;\r\n      alpha *= uColor.a;\r\n      gl_FragColor = vec4(uColor.rgb * alpha, alpha);\r\n    }\r\n    ";
      },
      configure$6: function(color, alpha, shiftX, shiftY, radiusX, radiusY) {
        var t1;
        if (typeof color !== "number")
          return color.$shr();
        t1 = this._uniforms;
        this._renderingContext.uniform2f(t1.$index(0, "uShift"), shiftX, shiftY);
        this._renderingContext.uniform2f(t1.$index(0, "uRadius"), radiusX, radiusY);
        this._renderingContext.uniform4f(t1.$index(0, "uColor"), (color >>> 16 & 255) / 255, (color >>> 8 & 255) / 255, (color & 255) / 255, (color >>> 24 & 255) / 255 * alpha);
      }
    }
  }], ["stagexl.geom.matrix", "package:stagexl/src/geom/matrix.dart",, T, {
    "^": "",
    Matrix: {
      "^": "Object;_data",
      toString$0: function(_) {
        var t1 = this._data;
        return "Matrix [a=" + H.S(t1[0]) + ", b=" + H.S(t1[1]) + ", c=" + H.S(t1[2]) + ", d=" + H.S(t1[3]) + ", tx=" + H.S(t1[4]) + ", ty=" + H.S(t1[5]) + "]";
      },
      transformPoint$2: function(point, returnPoint) {
        var px, py, t1, t2, t3, t4, t5, t6;
        px = point.get$x(point);
        px.toString;
        py = point.get$y(point);
        py.toString;
        t1 = this._data;
        t2 = t1[0];
        if (typeof px !== "number")
          return px.$mul();
        t3 = t1[2];
        if (typeof py !== "number")
          return py.$mul();
        t4 = t1[4];
        t5 = t1[1];
        t6 = t1[3];
        t1 = t1[5];
        return new U.Point(px * t2 + py * t3 + t4, px * t5 + py * t6 + t1, [P.num]);
      },
      transformPoint$1: function(point) {
        return this.transformPoint$2(point, null);
      },
      transformRectangle$2: function(rectangle, returnRectangle) {
        var rl, rr, rt, rb, t1, t2, t3, t4, t5, x1, t6, t7, t8, t9, y1, x2, y2, x3, y3, x4, y4, left, $top, right, bottom, width, heigth;
        rl = J.toDouble$0$n(rectangle.left);
        rr = J.toDouble$0$n(J.$add$ns(rectangle.left, rectangle.width));
        rt = J.toDouble$0$n(rectangle.top);
        rb = J.toDouble$0$n(J.$add$ns(rectangle.top, rectangle.height));
        t1 = this._data;
        t2 = t1[0];
        t3 = rl * t2;
        t4 = t1[2];
        t5 = rt * t4;
        x1 = t3 + t5;
        t6 = t1[1];
        t7 = rl * t6;
        t8 = t1[3];
        t9 = rt * t8;
        y1 = t7 + t9;
        t2 = rr * t2;
        x2 = t2 + t5;
        t6 = rr * t6;
        y2 = t6 + t9;
        t4 = rb * t4;
        x3 = t2 + t4;
        t8 = rb * t8;
        y3 = t6 + t8;
        x4 = t3 + t4;
        y4 = t7 + t8;
        left = x1 > x2 ? x2 : x1;
        if (left > x3)
          left = x3;
        if (left > x4)
          left = x4;
        $top = y1 > y2 ? y2 : y1;
        if ($top > y3)
          $top = y3;
        if ($top > y4)
          $top = y4;
        right = x1 < x2 ? x2 : x1;
        if (right < x3)
          right = x3;
        if (right < x4)
          right = x4;
        bottom = y1 < y2 ? y2 : y1;
        if (bottom < y3)
          bottom = y3;
        if (bottom < y4)
          bottom = y4;
        width = right - left;
        heigth = bottom - $top;
        if (returnRectangle instanceof U.Rectangle0) {
          t2 = t1[4];
          t1 = t1[5];
          returnRectangle.left = t2 + left;
          returnRectangle.top = t1 + $top;
          returnRectangle.width = width;
          returnRectangle.height = heigth;
          return returnRectangle;
        } else
          return new U.Rectangle0(t1[4] + left, t1[5] + $top, width, heigth, [P.num]);
      },
      transformRectangle$1: function(rectangle) {
        return this.transformRectangle$2(rectangle, null);
      },
      identity$0: function() {
        var t1 = this._data;
        t1[0] = 1;
        t1[1] = 0;
        t1[2] = 0;
        t1[3] = 1;
        t1[4] = 0;
        t1[5] = 0;
      },
      scale$2: function(_, scaleX, scaleY) {
        var t1, t2;
        t1 = this._data;
        t2 = t1[0];
        if (typeof scaleX !== "number")
          return H.iae(scaleX);
        t1[0] = t2 * scaleX;
        t2 = t1[1];
        if (typeof scaleY !== "number")
          return H.iae(scaleY);
        t1[1] = t2 * scaleY;
        t1[2] = t1[2] * scaleX;
        t1[3] = t1[3] * scaleY;
        t1[4] = t1[4] * scaleX;
        t1[5] = t1[5] * scaleY;
      },
      prependTranslation$2: function(translationX, translationY) {
        var t1, t2, t3;
        t1 = this._data;
        t2 = J.getInterceptor$ns(translationX);
        t3 = J.getInterceptor$ns(translationY);
        t1[4] = J.$add$ns(J.$add$ns(t2.$mul(translationX, t1[0]), t3.$mul(translationY, t1[2])), t1[4]);
        t1[5] = J.$add$ns(J.$add$ns(t2.$mul(translationX, t1[1]), t3.$mul(translationY, t1[3])), t1[5]);
      },
      setTo$6: function(a, b, c, d, tx, ty) {
        var t1 = this._data;
        t1[0] = a;
        t1[1] = b;
        t1[2] = c;
        t1[3] = d;
        t1[4] = tx;
        t1[5] = ty;
      },
      copyFrom$1: function(matrix) {
        var t1, t2;
        t1 = this._data;
        t2 = matrix._data;
        t1[0] = t2[0];
        t1[1] = t2[1];
        t1[2] = t2[2];
        t1[3] = t2[3];
        t1[4] = t2[4];
        t1[5] = t2[5];
      },
      copyFromAndConcat$2: function(copyMatrix, concatMatrix) {
        var t1, a1, b1, c1, d1, tx1, ty1, a2, b2, c2, d2, tx2, ty2;
        t1 = copyMatrix._data;
        a1 = t1[0];
        b1 = t1[1];
        c1 = t1[2];
        d1 = t1[3];
        tx1 = t1[4];
        ty1 = t1[5];
        t1 = concatMatrix._data;
        a2 = t1[0];
        b2 = t1[1];
        c2 = t1[2];
        d2 = t1[3];
        tx2 = t1[4];
        ty2 = t1[5];
        t1 = this._data;
        t1[0] = a1 * a2 + b1 * c2;
        t1[1] = a1 * b2 + b1 * d2;
        t1[2] = c1 * a2 + d1 * c2;
        t1[3] = c1 * b2 + d1 * d2;
        t1[4] = tx1 * a2 + ty1 * c2 + tx2;
        t1[5] = tx1 * b2 + ty1 * d2 + ty2;
      },
      Matrix$fromIdentity$0: function() {
        var t1 = this._data;
        t1[0] = 1;
        t1[1] = 0;
        t1[2] = 0;
        t1[3] = 1;
        t1[4] = 0;
        t1[5] = 0;
      },
      Matrix$6: function(a, b, c, d, tx, ty) {
        var t1 = this._data;
        a.toString;
        t1[0] = a;
        b.toString;
        t1[1] = b;
        c.toString;
        t1[2] = c;
        d.toString;
        t1[3] = d;
        t1[4] = J.toDouble$0$n(tx);
        t1[5] = J.toDouble$0$n(ty);
      },
      static: {
        Matrix$: function(a, b, c, d, tx, ty) {
          var t1 = new T.Matrix(new Float32Array(H._checkLength(6)));
          t1.Matrix$6(a, b, c, d, tx, ty);
          return t1;
        },
        Matrix$fromIdentity: function() {
          var t1 = new T.Matrix(new Float32Array(H._checkLength(6)));
          t1.Matrix$fromIdentity$0();
          return t1;
        }
      }
    }
  }], ["stagexl.geom.matrix_3d", "package:stagexl/src/geom/matrix_3d.dart",, T, {
    "^": "",
    Matrix3D: {
      "^": "Object;_matrix_3d$_data",
      setIdentity$0: function() {
        var t1 = this._matrix_3d$_data;
        t1[0] = 1;
        t1[1] = 0;
        t1[2] = 0;
        t1[3] = 0;
        t1[4] = 0;
        t1[5] = 1;
        t1[6] = 0;
        t1[7] = 0;
        t1[8] = 0;
        t1[9] = 0;
        t1[10] = 1;
        t1[11] = 0;
        t1[12] = 0;
        t1[13] = 0;
        t1[14] = 0;
        t1[15] = 1;
      },
      scale$3: function(_, scaleX, scaleY, scaleZ) {
        var t1 = this._matrix_3d$_data;
        t1[0] = t1[0] * scaleX;
        t1[1] = t1[1] * scaleX;
        t1[2] = t1[2] * scaleX;
        t1[3] = t1[3] * scaleX;
        t1[4] = t1[4] * scaleY;
        t1[5] = t1[5] * scaleY;
        t1[6] = t1[6] * scaleY;
        t1[7] = t1[7] * scaleY;
        t1[8] = t1[8] * scaleZ;
        t1[9] = t1[9] * scaleZ;
        t1[10] = t1[10] * scaleZ;
        t1[11] = t1[11] * scaleZ;
      },
      translate$3: function(_, translationX, translationY, translationZ) {
        var t1 = this._matrix_3d$_data;
        t1[3] = t1[3] + translationX;
        t1[7] = t1[7] + translationY;
        t1[11] = t1[11] + translationZ;
      },
      copyFrom$1: function(matrix) {
        var t1, t2;
        t1 = this._matrix_3d$_data;
        t2 = matrix._matrix_3d$_data;
        t1[0] = t2[0];
        t1[1] = t2[1];
        t1[2] = t2[2];
        t1[3] = t2[3];
        t1[4] = t2[4];
        t1[5] = t2[5];
        t1[6] = t2[6];
        t1[7] = t2[7];
        t1[8] = t2[8];
        t1[9] = t2[9];
        t1[10] = t2[10];
        t1[11] = t2[11];
        t1[12] = t2[12];
        t1[13] = t2[13];
        t1[14] = t2[14];
        t1[15] = t2[15];
      }
    }
  }], ["stagexl.geom.point", "package:stagexl/src/geom/point.dart",, U, {
    "^": "",
    Point: {
      "^": "Object;x*,y*,$ti",
      toString$0: function(_) {
        return "Point<" + H.S(new H.TypeImpl(H.runtimeTypeToString(H.getTypeArgumentByIndex(this, 0)), null)) + "> [x=" + H.S(this.x) + ", y=" + H.S(this.y) + "]";
      },
      $eq: function(_, other) {
        var t1;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        return !!t1.$isPoint0 && J.$eq$(this.x, t1.get$x(other)) && J.$eq$(this.y, t1.get$y(other));
      },
      get$hashCode: function(_) {
        var a, b;
        a = J.get$hashCode$(this.x);
        b = J.get$hashCode$(this.y);
        return O.JenkinsHash_finish(O.JenkinsHash_combine(O.JenkinsHash_combine(0, a), b));
      },
      $add: function(_, other) {
        var t1 = J.getInterceptor$x(other);
        return new U.Point(J.$add$ns(this.x, t1.get$x(other)), J.$add$ns(this.y, t1.get$y(other)), this.$ti);
      },
      $sub: function(_, other) {
        var t1 = J.getInterceptor$x(other);
        return new U.Point(J.$sub$n(this.x, t1.get$x(other)), J.$sub$n(this.y, t1.get$y(other)), this.$ti);
      },
      $mul: function(_, factor) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return new U.Point(H.subtypeOfRuntimeTypeCast(J.$mul$ns(this.x, factor), t1), H.subtypeOfRuntimeTypeCast(J.$mul$ns(this.y, factor), t1), this.$ti);
      },
      $isPoint0: 1
    }
  }], ["stagexl.geom.rectangle", "package:stagexl/src/geom/rectangle.dart",, U, {
    "^": "",
    Rectangle0: {
      "^": "Object;left>,top>,width*,height>,$ti",
      toString$0: function(_) {
        return "Rectangle<" + H.S(new H.TypeImpl(H.runtimeTypeToString(H.getTypeArgumentByIndex(this, 0)), null)) + "> [left=" + H.S(this.left) + ", top=" + H.S(this.top) + ", width=" + H.S(this.width) + ", height=" + H.S(this.height) + "]";
      },
      $eq: function(_, other) {
        var t1;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        return !!t1.$isRectangle && J.$eq$(this.left, t1.get$left(other)) && J.$eq$(this.top, t1.get$top(other)) && J.$eq$(this.width, t1.get$width(other)) && J.$eq$(this.height, t1.get$height(other));
      },
      get$hashCode: function(_) {
        var a, b, c, d;
        a = J.get$hashCode$(this.left);
        b = J.get$hashCode$(this.top);
        c = J.get$hashCode$(this.width);
        d = J.get$hashCode$(this.height);
        return O.JenkinsHash_finish(O.JenkinsHash_combine(O.JenkinsHash_combine(O.JenkinsHash_combine(O.JenkinsHash_combine(0, a), b), c), d));
      },
      get$isEmpty: function(_) {
        return J.$le$n(this.width, 0) || J.$le$n(this.height, 0);
      },
      get$right: function(_) {
        return J.$add$ns(this.left, this.width);
      },
      get$bottom: function(_) {
        return J.$add$ns(this.top, this.height);
      },
      contains$2: function(_, px, py) {
        return J.$le$n(this.left, px) && J.$le$n(this.top, py) && J.$gt$n(J.$add$ns(this.left, this.width), px) && J.$gt$n(J.$add$ns(this.top, this.height), py);
      },
      boundingBox$1: function(_, other) {
        var t1, t2, rLeft, t3, rTop, rRight;
        t1 = this.left;
        t2 = other.left;
        rLeft = Math.min(H.checkNum(t1), H.checkNum(t2));
        t2 = this.top;
        t3 = other.top;
        rTop = Math.min(H.checkNum(t2), H.checkNum(t3));
        t1 = J.$add$ns(t1, this.width);
        t3 = J.$add$ns(other.left, other.width);
        rRight = Math.max(H.checkNum(t1), H.checkNum(t3));
        t3 = J.$add$ns(this.top, this.height);
        t1 = J.$add$ns(other.top, other.height);
        return new U.Rectangle0(rLeft, rTop, rRight - rLeft, Math.max(H.checkNum(t3), H.checkNum(t1)) - rTop, this.$ti);
      },
      $isRectangle: 1,
      $asRectangle: null
    }
  }], ["stagexl.internal.environment", "package:stagexl/src/internal/environment.dart",, Q, {
    "^": "",
    _checkTouchEventSupport: function() {
      var t1, exception;
      try {
        t1 = P.Device_isEventTypeSupported("TouchEvent");
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
        return false;
      }
    }
  }], ["stagexl.internal.filter_helpers", "package:stagexl/src/internal/filter_helpers.dart",, L, {
    "^": "",
    clearChannel: function(data, offset, $length) {
      var offsetEnd, i;
      offsetEnd = offset + $length * 4 - 4;
      if (offset < 0)
        throw H.wrapException(P.RangeError$(offset));
      if (offsetEnd >= data.length)
        throw H.wrapException(P.RangeError$(offsetEnd));
      for (i = offset; i <= offsetEnd; i += 4)
        data[i] = 0;
    },
    shiftChannel: function(data, channel, width, height, shiftX, shiftY) {
      var t1, t2, src, dst, t3, t4, y;
      if (channel > 3)
        throw H.wrapException(P.ArgumentError$(null));
      if (shiftX === 0 && shiftY === 0)
        return;
      if (Math.abs(shiftX) >= width || Math.abs(shiftY) >= height) {
        L.clearChannel(data, channel, width * height);
        return;
      }
      t1 = shiftX + width * shiftY;
      t2 = 4 * t1;
      if (t1 < 0) {
        src = channel - t2;
        for (t1 = data.length, dst = channel; src < t1; src += 4, dst += 4) {
          if (src < 0)
            return H.ioore(data, src);
          t2 = data[src];
          if (dst >= t1)
            return H.ioore(data, dst);
          data[dst] = t2;
        }
      } else {
        t1 = data.length;
        t3 = t1 + channel;
        dst = t3 - 4;
        src = t3 - t2;
        for (; src >= 0; src -= 4, dst -= 4) {
          if (src >= t1)
            return H.ioore(data, src);
          t2 = data[src];
          if (dst < 0)
            return H.ioore(data, dst);
          data[dst] = t2;
        }
      }
      for (t1 = shiftX < 0, t2 = shiftX > 0, t3 = height + shiftY, t4 = 0 - shiftX, y = 0; y < height; ++y)
        if (y < shiftY || y >= t3)
          L.clearChannel(data, y * width * 4 + channel, width);
        else if (t2)
          L.clearChannel(data, y * width * 4 + channel, shiftX);
        else if (t1)
          L.clearChannel(data, (y * width + width + shiftX) * 4 + channel, t4);
    },
    blur: function(data, offset, $length, stride, radius) {
      var weight, weightInv, sum, radius2, buffer, t1, t2, offsetDestination, offsetSource, dif, i, t3, value;
      ++radius;
      weight = radius * radius;
      weightInv = C.JSInt_methods.$tdiv(4194304, weight);
      sum = C.JSInt_methods._tdivFast$1(weight, 2);
      radius2 = radius * 2;
      buffer = $.$get$_buffer();
      for (t1 = $length + radius, t2 = data.length, offsetDestination = offset, offsetSource = offsetDestination, dif = 0, i = 0; i < t1; ++i) {
        if (i >= radius) {
          if (offsetDestination < 0 || offsetDestination >= t2)
            return H.ioore(data, offsetDestination);
          data[offsetDestination] = (sum * weightInv | 0) >>> 22;
          offsetDestination += stride;
          t3 = i & 1023;
          dif = i >= radius2 ? dif - (2 * buffer[t3] - buffer[i - radius & 1023]) : dif - 2 * buffer[t3];
        }
        t3 = i + radius & 1023;
        if (i < $length) {
          if (offsetSource < 0 || offsetSource >= t2)
            return H.ioore(data, offsetSource);
          value = data[offsetSource];
          offsetSource += stride;
          buffer[t3] = value;
          dif += value;
          sum += dif;
        } else {
          buffer[t3] = 0;
          sum += dif;
        }
      }
    },
    setColor: function(data, color) {
      var rColor, gColor, bColor, aColor, t1, i, t2;
      if (typeof color !== "number")
        return color.$shr();
      rColor = color >>> 16 & 255;
      gColor = color >>> 8 & 255;
      bColor = color & 255;
      aColor = color >>> 24 & 255;
      if ($.$get$isLittleEndianSystem() === true)
        for (t1 = data.length - 4, i = 0; i <= t1; i += 4) {
          data[i] = rColor;
          data[i + 1] = gColor;
          data[i + 2] = bColor;
          t2 = i + 3;
          data[t2] = (aColor * data[t2] | 0) >>> 8;
        }
      else
        for (t1 = data.length - 4, i = 0; i <= t1; i += 4) {
          data[i] = (aColor * data[i] | 0) >>> 8;
          data[i + 1] = bColor;
          data[i + 2] = gColor;
          data[i + 3] = rColor;
        }
    },
    setColorBlend: function(dstData, color, srcData) {
      var t1, t2, rColor, gColor, bColor, aColor, i, t3, srcA, srcAX, dstAX, outAX, t4;
      t1 = dstData.length;
      t2 = srcData.length;
      if (t1 !== t2)
        return;
      if (typeof color !== "number")
        return color.$shr();
      rColor = color >>> 16 & 255;
      gColor = color >>> 8 & 255;
      bColor = color & 255;
      aColor = color >>> 24 & 255;
      if ($.$get$isLittleEndianSystem() === true)
        for (t1 -= 4, i = 0; i <= t1; i += 4) {
          t3 = i + 3;
          if (t3 >= t2)
            return H.ioore(srcData, t3);
          srcA = srcData[t3];
          srcAX = srcA * 255;
          dstAX = (dstData[t3] * (255 - srcA) * aColor | 0) >>> 8;
          outAX = srcAX + dstAX;
          if (outAX > 0) {
            if (i >= t2)
              return H.ioore(srcData, i);
            dstData[i] = C.JSInt_methods.$tdiv(srcData[i] * srcAX + rColor * dstAX, outAX);
            t4 = i + 1;
            if (t4 >= t2)
              return H.ioore(srcData, t4);
            dstData[t4] = C.JSInt_methods.$tdiv(srcData[t4] * srcAX + gColor * dstAX, outAX);
            t4 = i + 2;
            if (t4 >= t2)
              return H.ioore(srcData, t4);
            dstData[t4] = C.JSInt_methods.$tdiv(srcData[t4] * srcAX + bColor * dstAX, outAX);
            dstData[t3] = C.JSInt_methods._tdivFast$1(outAX, 255);
          } else
            dstData[t3] = 0;
        }
      else
        for (t1 -= 4, i = 0; i <= t1; i += 4) {
          if (i >= t2)
            return H.ioore(srcData, i);
          srcA = srcData[i];
          srcAX = srcA * 255;
          dstAX = (dstData[i] * (255 - srcA) * aColor | 0) >>> 8;
          outAX = srcAX + dstAX;
          if (outAX > 0) {
            dstData[i] = C.JSInt_methods._tdivFast$1(outAX, 255);
            t3 = i + 1;
            if (t3 >= t2)
              return H.ioore(srcData, t3);
            dstData[t3] = C.JSInt_methods.$tdiv(srcData[t3] * srcAX + bColor * dstAX, outAX);
            t3 = i + 2;
            if (t3 >= t2)
              return H.ioore(srcData, t3);
            dstData[t3] = C.JSInt_methods.$tdiv(srcData[t3] * srcAX + gColor * dstAX, outAX);
            t3 = i + 3;
            if (t3 >= t2)
              return H.ioore(srcData, t3);
            dstData[t3] = C.JSInt_methods.$tdiv(srcData[t3] * srcAX + rColor * dstAX, outAX);
          } else
            dstData[i] = 0;
        }
    },
    setColorKnockout: function(dstData, color, srcData) {
      var t1, t2, rColor, gColor, bColor, aColor, i, t3, t4;
      t1 = dstData.length;
      t2 = srcData.length;
      if (t1 !== t2)
        return;
      if (typeof color !== "number")
        return color.$shr();
      rColor = color >>> 16 & 255;
      gColor = color >>> 8 & 255;
      bColor = color & 255;
      aColor = color >>> 24 & 255;
      if ($.$get$isLittleEndianSystem() === true)
        for (t1 -= 4, i = 0; i <= t1; i += 4) {
          dstData[i] = rColor;
          dstData[i + 1] = gColor;
          dstData[i + 2] = bColor;
          t3 = i + 3;
          t4 = dstData[t3];
          if (t3 >= t2)
            return H.ioore(srcData, t3);
          dstData[t3] = ((aColor * t4 * (255 - srcData[t3]) | 0) >>> 0) / 65280 | 0;
        }
      else
        for (t1 -= 4, i = 0; i <= t1; i += 4) {
          t3 = dstData[i];
          if (i >= t2)
            return H.ioore(srcData, i);
          dstData[i] = ((aColor * t3 * (255 - srcData[i]) | 0) >>> 0) / 65280 | 0;
          dstData[i + 1] = bColor;
          dstData[i + 2] = gColor;
          dstData[i + 3] = rColor;
        }
    }
  }], ["stagexl.internal.image_loader", "package:stagexl/src/internal/image_loader.dart",, N, {
    "^": "",
    ImageLoader: {
      "^": "Object;image,_completer,_url,_onLoadSubscription,_onErrorSubscription",
      _onImageLoad$1: [function($event) {
        this._onLoadSubscription.cancel$0(0);
        this._onErrorSubscription.cancel$0(0);
        this._completer.complete$1(0, this.image);
      }, "call$1", "get$_onImageLoad", 2, 0, 14],
      _onImageError$1: [function($event) {
        this._onLoadSubscription.cancel$0(0);
        this._onErrorSubscription.cancel$0(0);
        this._completer.completeError$1(new T.LoadError("Failed to load " + H.S(this.image.src) + ".", null));
      }, "call$1", "get$_onImageError", 2, 0, 14],
      ImageLoader$3: function(url, webpAvailable, corsEnabled) {
        var t1, t2;
        t1 = this.image;
        t2 = W.Event0;
        this._onLoadSubscription = W._EventStreamSubscription$(t1, "load", this.get$_onImageLoad(), false, t2);
        this._onErrorSubscription = W._EventStreamSubscription$(t1, "error", this.get$_onImageError(), false, t2);
        t1.src = this._url;
      },
      static: {
        ImageLoader$: function(url, webpAvailable, corsEnabled) {
          var t1 = W.ImageElement;
          t1 = new N.ImageLoader(W.ImageElement_ImageElement(null, null, null), new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [t1]), [t1]), url, null, null);
          t1.ImageLoader$3(url, false, false);
          return t1;
        }
      }
    }
  }], ["stagexl.internal.jenkins_hash", "package:stagexl/src/internal/jenkins_hash.dart",, O, {
    "^": "",
    JenkinsHash_combine: function(hash, value) {
      if (typeof value !== "number")
        return H.iae(value);
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    JenkinsHash_finish: function(hash) {
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }
  }], ["stagexl.internal.tools", "package:stagexl/src/internal/tools.dart",, V, {
    "^": "",
    color2rgb: function(color) {
      return "rgb(" + (color >>> 16 & 255) + "," + (color >>> 8 & 255) + "," + (color & 255) + ")";
    },
    color2rgba: function(color) {
      return "rgba(" + (color >>> 16 & 255) + "," + (color >>> 8 & 255) + "," + (color & 255) + "," + H.S((color >>> 24 & 255) / 255) + ")";
    },
    minInt: function(a, b) {
      if (a <= b)
        return a;
      else
        return b;
    },
    maxInt: function(a, b) {
      if (a >= b)
        return a;
      else
        return b;
    },
    minNum: function(a, b) {
      if (typeof a !== "number")
        return a.$le();
      if (typeof b !== "number")
        return H.iae(b);
      if (a <= b)
        return a;
      else
        return b;
    },
    clampInt: function(value, lower, upper) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$le(value, lower))
        return lower;
      else if (t1.$ge(value, upper))
        return upper;
      else
        return value;
    },
    ensureBool: function(value) {
      if (typeof value === "boolean")
        return value;
      else
        throw H.wrapException(P.ArgumentError$("The supplied value (" + H.S(value) + ") is not a bool."));
    },
    ensureInt: function(value) {
      if (typeof value === "number" && Math.floor(value) === value)
        return value;
      else
        throw H.wrapException(P.ArgumentError$("The supplied value (" + H.S(value) + ") is not an int."));
    },
    ensureNum: function(value) {
      if (typeof value === "number")
        return value;
      else
        throw H.wrapException(P.ArgumentError$("The supplied value (" + H.S(value) + ") is not a number."));
    },
    ensureString: function(value) {
      return value;
    },
    similar: function(a, b, epsilon) {
      return a - epsilon < b && a + epsilon > b;
    }
  }], ["stagexl.resources", "package:stagexl/src/resources.dart",, O, {
    "^": "",
    ResourceManager: {
      "^": "Object;_resourceMap,_progressEvent",
      load$0: function(_) {
        var $async$goto = 0, $async$completer = P.Completer_Completer$sync(), $async$returnValue, $async$self = this, t1, errors;
        var $async$load$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.get$pendingResources();
                $async$goto = 3;
                return P._asyncAwait(P.Future_wait(new H.MappedListIterable(t1, new O.ResourceManager_load_closure(), [H.getTypeArgumentByIndex(t1, 0), null]), null, false), $async$load$0);
              case 3:
                // returning from await.
                errors = $async$self.get$failedResources().length;
                if (errors > 0)
                  throw H.wrapException(new P.StateError("Failed to load " + errors + " resource(s)."));
                else {
                  $async$returnValue = $async$self;
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStart($async$load$0, $async$completer);
      },
      get$finishedResources: function() {
        var t1, t2;
        t1 = this._resourceMap;
        t1 = t1.get$values(t1);
        t2 = H.getRuntimeTypeArgument(t1, "Iterable", 0);
        return P.List_List$from(new H.WhereIterable(t1, new O.ResourceManager_finishedResources_closure(), [t2]), true, t2);
      },
      get$pendingResources: function() {
        var t1, t2;
        t1 = this._resourceMap;
        t1 = t1.get$values(t1);
        t2 = H.getRuntimeTypeArgument(t1, "Iterable", 0);
        return P.List_List$from(new H.WhereIterable(t1, new O.ResourceManager_pendingResources_closure(), [t2]), true, t2);
      },
      get$failedResources: function() {
        var t1, t2;
        t1 = this._resourceMap;
        t1 = t1.get$values(t1);
        t2 = H.getRuntimeTypeArgument(t1, "Iterable", 0);
        return P.List_List$from(new H.WhereIterable(t1, new O.ResourceManager_failedResources_closure(), [t2]), true, t2);
      },
      addTextFile$2: function($name, url) {
        this._addResource$4("TextFile", $name, url, W.HttpRequest_getString(url, null, null).then$2$onError(new O.ResourceManager_addTextFile_closure(), new O.ResourceManager_addTextFile_closure0()));
      },
      _addResource$4: function(kind, $name, url, loader) {
        var key, resource, t1;
        key = kind + "." + H.S($name);
        resource = O.ResourceManagerResource$(kind, $name, url, loader);
        t1 = this._resourceMap;
        if (t1.containsKey$1(0, key))
          throw H.wrapException(new P.StateError("ResourceManager already contains a resource called '" + H.S($name) + "'"));
        else
          t1.$indexSet(0, key, resource);
        resource._resources$_completer.future.then$1(new O.ResourceManager__addResource_closure(this));
      },
      _getResourceValue$2: function(kind, $name) {
        var resource, t1;
        resource = this._resourceMap.$index(0, kind + "." + $name);
        if (resource == null)
          throw H.wrapException(new P.StateError("Resource '" + $name + "' does not exist."));
        else {
          t1 = J.getInterceptor$x(resource);
          if (t1.get$value(resource) != null)
            return t1.get$value(resource);
          else if (t1.get$error(resource) != null)
            throw H.wrapException(t1.get$error(resource));
          else
            throw H.wrapException(new P.StateError("Resource '" + $name + "' has not finished loading yet."));
        }
      }
    },
    ResourceManager_load_closure: {
      "^": "Closure:0;",
      call$1: [function(r) {
        return J.get$complete$x(r);
      }, null, null, 2, 0, null, 12, "call"]
    },
    ResourceManager_finishedResources_closure: {
      "^": "Closure:0;",
      call$1: function(r) {
        return J.get$value$x(r) != null;
      }
    },
    ResourceManager_pendingResources_closure: {
      "^": "Closure:0;",
      call$1: function(r) {
        var t1 = J.getInterceptor$x(r);
        return t1.get$value(r) == null && t1.get$error(r) == null;
      }
    },
    ResourceManager_failedResources_closure: {
      "^": "Closure:0;",
      call$1: function(r) {
        return J.get$error$x(r) != null;
      }
    },
    ResourceManager_addTextFile_closure: {
      "^": "Closure:0;",
      call$1: [function(text) {
        return text;
      }, null, null, 2, 0, null, 18, "call"]
    },
    ResourceManager_addTextFile_closure0: {
      "^": "Closure:0;",
      call$1: [function(error) {
        throw H.wrapException(new P.StateError("Failed to load text file."));
      }, null, null, 2, 0, null, 2, "call"]
    },
    ResourceManager__addResource_closure: {
      "^": "Closure:0;$this",
      call$1: [function(_) {
        var t1, finished, t2;
        t1 = this.$this;
        finished = t1.get$finishedResources().length;
        t2 = t1._resourceMap;
        t2 = t2.get$length(t2);
        t1 = t1._progressEvent;
        if (!t1.get$_mayAddEvent())
          H.throwExpression(t1._addEventError$0());
        t1._sendData$1(finished / t2);
      }, null, null, 2, 0, null, 4, "call"]
    },
    ResourceManagerResource: {
      "^": "Object;kind,name>,url>,_resources$_value,_resources$_error,_resources$_completer",
      toString$0: function(_) {
        return "ResourceManagerResource [kind=" + this.kind + ", name=" + H.S(this.name) + ", url = " + H.S(this.url) + "]";
      },
      get$value: function(_) {
        return this._resources$_value;
      },
      get$error: function(_) {
        return this._resources$_error;
      },
      get$complete: function(_) {
        return this._resources$_completer.future;
      },
      ResourceManagerResource$4: function(kind, $name, url, loader) {
        loader.then$1(new O.ResourceManagerResource_closure(this)).catchError$1(new O.ResourceManagerResource_closure0(this)).whenComplete$1(new O.ResourceManagerResource_closure1(this));
      },
      complete$1: function($receiver, arg0) {
        return this.get$complete(this).call$1(arg0);
      },
      static: {
        ResourceManagerResource$: function(kind, $name, url, loader) {
          var t1 = new O.ResourceManagerResource(kind, $name, url, null, null, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]));
          t1.ResourceManagerResource$4(kind, $name, url, loader);
          return t1;
        }
      }
    },
    ResourceManagerResource_closure: {
      "^": "Closure:0;$this",
      call$1: [function(resource) {
        this.$this._resources$_value = resource;
      }, null, null, 2, 0, null, 52, "call"]
    },
    ResourceManagerResource_closure0: {
      "^": "Closure:0;$this",
      call$1: [function(error) {
        this.$this._resources$_error = error;
      }, null, null, 2, 0, null, 2, "call"]
    },
    ResourceManagerResource_closure1: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1 = this.$this;
        t1._resources$_completer.complete$1(0, t1);
      }
    },
    TextureAtlas: {
      "^": "Object;frames",
      getBitmapData$1: [function($name) {
        var t1, i, frame;
        for (t1 = this.frames, i = 0; i < t1.length; ++i) {
          frame = t1[i];
          if (J.$eq$(frame.name, $name))
            return frame._bitmapData;
        }
        throw H.wrapException(P.ArgumentError$("TextureAtlasFrame not found: '" + $name + "'"));
      }, "call$1", "get$getBitmapData", 2, 0, 68]
    },
    TextureAtlasFormat: {
      "^": "Object;"
    },
    _TextureAtlasFormatJson: {
      "^": "TextureAtlasFormat;",
      load$1: function(_, loader) {
        var $async$goto = 0, $async$completer = P.Completer_Completer$sync(), $async$returnValue, $async$self = this, json, t1, $frames, meta, image, textureAtlas, renderTextureQuad, t2, frame, fileName, t3, frameMap, $async$temp1;
        var $async$load$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  $async$temp1 = C.JsonCodec_null_null;
                  $async$goto = 3;
                  return P._asyncAwait(W.HttpRequest_getString(loader._sourceUrl, null, null), $async$load$1);
                case 3:
                  // returning from await.
                  json = $async$temp1.decode$1($async$result);
                  t1 = J.getInterceptor$asx(json);
                  $frames = t1.$index(json, "frames");
                  meta = H.interceptedTypeCast(t1.$index(json, "meta"), "$isMap");
                  image = H.stringTypeCast(J.$index$asx(meta, "image"));
                  textureAtlas = new O.TextureAtlas(H.setRuntimeTypeInfo([], [O.TextureAtlasFrame]));
                  $async$goto = 4;
                  return P._asyncAwait(loader.getRenderTextureQuad$1(image), $async$load$1);
                case 4:
                  // returning from await.
                  renderTextureQuad = $async$result;
                  t1 = J.getInterceptor($frames);
                  if (!!t1.$isList)
                    for (t2 = t1.get$iterator($frames); t2.moveNext$0();) {
                      frame = H.interceptedTypeCast(t2.get$current(), "$isMap");
                      fileName = H.stringTypeCast(J.$index$asx(frame, "filename"));
                      t3 = P.RegExp_RegExp("(.+?)(\\.[^.]*$|$)", true, false).firstMatch$1(fileName)._match;
                      if (1 >= t3.length) {
                        $async$returnValue = H.ioore(t3, 1);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      $async$self._createFrame$5(textureAtlas, renderTextureQuad, t3[1], frame, meta);
                    }
                  if (!!t1.$isMap)
                    for (t2 = J.get$iterator$ax(t1.get$keys($frames)); t2.moveNext$0();) {
                      fileName = t2.get$current();
                      frameMap = H.interceptedTypeCast(t1.$index($frames, fileName), "$isMap");
                      t3 = P.RegExp_RegExp("(.+?)(\\.[^.]*$|$)", true, false).firstMatch$1(fileName)._match;
                      if (1 >= t3.length) {
                        $async$returnValue = H.ioore(t3, 1);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      $async$self._createFrame$5(textureAtlas, renderTextureQuad, t3[1], frameMap, meta);
                    }
                  $async$returnValue = textureAtlas;
                  // goto return
                  $async$goto = 1;
                  break;
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
        });
        return P._asyncStart($async$load$1, $async$completer);
      },
      _createFrame$5: function(textureAtlas, renderTextureQuad, frameName, frameMap, metaMap) {
        var t1, rotation, offsetX, offsetY, originalWidth, originalHeight, frameX, frameY, t2, t3, frameWidth, frameHeight, vertices, verticesUV, triangles, width, height, vxList, t4, ixList, t5, i, j, taf, q;
        t1 = J.getInterceptor$asx(frameMap);
        rotation = V.ensureBool(H.boolTypeCast(t1.$index(frameMap, "rotated"))) ? 1 : 0;
        offsetX = V.ensureInt(J.$index$asx(t1.$index(frameMap, "spriteSourceSize"), "x"));
        offsetY = V.ensureInt(J.$index$asx(t1.$index(frameMap, "spriteSourceSize"), "y"));
        originalWidth = V.ensureInt(J.$index$asx(t1.$index(frameMap, "sourceSize"), "w"));
        originalHeight = V.ensureInt(J.$index$asx(t1.$index(frameMap, "sourceSize"), "h"));
        frameX = V.ensureInt(J.$index$asx(t1.$index(frameMap, "frame"), "x"));
        frameY = V.ensureInt(J.$index$asx(t1.$index(frameMap, "frame"), "y"));
        t2 = t1.$index(frameMap, "frame");
        t3 = rotation === 0;
        frameWidth = V.ensureInt(J.$index$asx(t2, t3 ? "w" : "h"));
        t2 = t1.$index(frameMap, "frame");
        frameHeight = V.ensureInt(J.$index$asx(t2, t3 ? "h" : "w"));
        if (t1.containsKey$1(frameMap, "vertices") === true) {
          vertices = H.listTypeCast(t1.$index(frameMap, "vertices"));
          verticesUV = H.listTypeCast(t1.$index(frameMap, "verticesUV"));
          triangles = H.listTypeCast(t1.$index(frameMap, "triangles"));
          t1 = J.getInterceptor$asx(metaMap);
          width = J.toInt$0$n(J.$index$asx(t1.$index(metaMap, "size"), "w"));
          height = J.toInt$0$n(J.$index$asx(t1.$index(metaMap, "size"), "h"));
          t1 = J.getInterceptor$asx(vertices);
          t2 = t1.get$length(vertices) * 4;
          vxList = new Float32Array(t2);
          t3 = J.getInterceptor$asx(triangles);
          t4 = t3.get$length(triangles) * 3;
          ixList = new Int16Array(t4);
          for (t2 -= 4, t5 = J.getInterceptor$asx(verticesUV), i = 0, j = 0; i <= t2; i += 4, ++j) {
            vxList[i] = J.$mul$ns(J.$index$asx(t1.$index(vertices, j), 0), 1);
            vxList[i + 1] = J.$mul$ns(J.$index$asx(t1.$index(vertices, j), 1), 1);
            vxList[i + 2] = J.$div$n(J.$index$asx(t5.$index(verticesUV, j), 0), width);
            vxList[i + 3] = J.$div$n(J.$index$asx(t5.$index(verticesUV, j), 1), height);
          }
          for (t1 = t4 - 3, i = 0, j = 0; i <= t1; i += 3, ++j) {
            ixList[i] = J.$index$asx(t3.$index(triangles, j), 0);
            ixList[i + 1] = J.$index$asx(t3.$index(triangles, j), 1);
            ixList[i + 2] = J.$index$asx(t3.$index(triangles, j), 2);
          }
        } else {
          vxList = null;
          ixList = null;
        }
        taf = new O.TextureAtlasFrame(textureAtlas, renderTextureQuad, frameName, rotation, offsetX, offsetY, originalWidth, originalHeight, frameX, frameY, frameWidth, frameHeight, vxList, ixList, null);
        t1 = [P.int];
        q = L.RenderTextureQuad_RenderTextureQuad$slice(renderTextureQuad, new U.Rectangle0(frameX, frameY, frameWidth, frameHeight, t1), new U.Rectangle0(-offsetX, -offsetY, originalWidth, originalHeight, t1), rotation);
        if (vxList != null && ixList != null) {
          q._vxList = vxList;
          q._ixList = ixList;
          q._hasCustomVertices = true;
        } else {
          q._vxList = q.vxListQuad;
          q._ixList = q.ixListQuad;
          q._hasCustomVertices = false;
        }
        t1 = q.offsetRectangle;
        t2 = q.pixelRatio;
        taf._bitmapData = new A.BitmapData(J.$div$n(t1.width, t2), J.$div$n(t1.height, t2), q);
        textureAtlas.frames.push(taf);
      }
    },
    TextureAtlasFrame: {
      "^": "Object;textureAtlas,textureAtlasQuad,name>,rotation<,offsetX,offsetY,originalWidth,originalHeight,frameX,frameY,frameWidth,frameHeight,vxList<,ixList<,_bitmapData"
    },
    TextureAtlasLoader: {
      "^": "Object;"
    },
    _TextureAtlasLoaderFile: {
      "^": "TextureAtlasLoader;_sourceUrl,_webpAvailable,_corsEnabled,_pixelRatio",
      getRenderTextureQuad$1: function(filename) {
        var $async$goto = 0, $async$completer = P.Completer_Completer$sync(), $async$returnValue, $async$self = this, t1, path, $async$temp1;
        var $async$getRenderTextureQuad$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._sourceUrl;
                t1 = P.RegExp_RegExp("^(.*/)?(?:$|(.+?)(?:(\\.[^.]*$)|$))", true, false).firstMatch$1(t1)._match;
                if (1 >= t1.length) {
                  $async$returnValue = H.ioore(t1, 1);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                path = t1[1];
                $async$temp1 = L;
                $async$goto = 3;
                return P._asyncAwait(N.ImageLoader$(path == null ? filename : H.S(path) + H.S(filename), false, false)._completer.future, $async$getRenderTextureQuad$1);
              case 3:
                // returning from await.
                t1 = $async$temp1.RenderTexture$fromImageElement($async$result).get$quad();
                $async$returnValue = L.RenderTextureQuad$(t1.renderTexture, t1.sourceRectangle, t1.offsetRectangle, t1.rotation, $async$self._pixelRatio);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStart($async$getRenderTextureQuad$1, $async$completer);
      }
    }
  }], ["stagexl.text", "package:stagexl/src/text.dart",, Y, {
    "^": "",
    _getFontStyleMetrics: function(textFormat) {
      var fontStyle = textFormat.get$_cssFontStyle();
      return $.$get$_fontStyleMetrics().putIfAbsent$2(0, fontStyle, new Y._getFontStyleMetrics_closure(textFormat));
    },
    _getFontStyleMetrics_closure: {
      "^": "Closure:1;textFormat",
      call$0: function() {
        return Y._FontStyleMetrics$(this.textFormat);
      }
    },
    _FontStyleMetrics: {
      "^": "Object;ascent<,descent<,height>",
      _FontStyleMetrics$1: function(textFormat) {
        var text, block, div, fontStyle, t1, exception;
        fontStyle = textFormat.get$_cssFontStyle();
        text = W._ElementFactoryProvider_createElement_tag("span", null);
        block = W._ElementFactoryProvider_createElement_tag("div", null);
        div = W._ElementFactoryProvider_createElement_tag("div", null);
        J.set$font$x(J.get$style$x(text), fontStyle);
        J.set$text$x(text, "Hg");
        J.set$display$x(J.get$style$x(block), "inline-block");
        J.set$width$x(J.get$style$x(block), "1px");
        J.set$height$x(J.get$style$x(block), "0px");
        J.append$1$x(div, block);
        J.append$1$x(div, text);
        document.body.appendChild(div);
        try {
          J.set$verticalAlign$x(J.get$style$x(block), "baseline");
          this.ascent = J.get$offsetTop$x(block) - J.get$offsetTop$x(text);
          J.set$verticalAlign$x(J.get$style$x(block), "bottom");
          t1 = J.get$offsetTop$x(block) - J.get$offsetTop$x(text);
          this.height = t1;
          this.descent = t1 - this.ascent;
        } catch (exception) {
          H.unwrapException(exception);
          t1 = textFormat.size;
          this.height = t1;
          this.ascent = C.JSNumber_methods._tdivFast$1(t1 * 7, 8);
          this.descent = C.JSNumber_methods._tdivFast$1(t1 * 2, 8);
        } finally {
          J.remove$0$ax(div);
        }
      },
      static: {
        _FontStyleMetrics$: function(textFormat) {
          var t1 = new Y._FontStyleMetrics(0, 0, 0);
          t1._FontStyleMetrics$1(textFormat);
          return t1;
        }
      }
    },
    TextField: {
      "^": "InteractiveObject;_text$_text,_defaultTextFormat,_autoSize,_text$_type,_caretIndex,_caretLine,_caretTime,_caretX,_caretY,_caretWidth,_caretHeight,_wordWrap,_multiline,_displayAsPassword,_background,_border,_passwordChar,_backgroundColor,_borderColor,_maxChars,_text$_width,_text$_height,_textWidth,_textHeight,_textLineMetrics,_refreshPending,_cacheAsBitmap,_renderTexture,_renderTextureQuad,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      get$renderTexture: function() {
        return this._renderTexture;
      },
      get$text: function(_) {
        return this._text$_text;
      },
      get$type: function(_) {
        return this._text$_type;
      },
      set$width: function(_, value) {
        this._text$_width = J.toDouble$0$n(value);
        this._refreshPending |= 3;
      },
      set$text: function(_, value) {
        this._text$_text = value;
        this._caretIndex = J.get$length$asx(value);
        this._refreshPending |= 3;
      },
      get$x: function(_) {
        this._refreshTextLineMetrics$0();
        return A.DisplayObject.prototype.get$x.call(this, this);
      },
      get$width: function(_) {
        this._refreshTextLineMetrics$0();
        return this._text$_width;
      },
      get$height: function(_) {
        this._refreshTextLineMetrics$0();
        return this._text$_height;
      },
      get$transformationMatrix: function() {
        this._refreshTextLineMetrics$0();
        return A.DisplayObject.prototype.get$transformationMatrix.call(this);
      },
      get$bounds: function() {
        this._refreshTextLineMetrics$0();
        var t1 = this._text$_width;
        this._refreshTextLineMetrics$0();
        return new U.Rectangle0(0, 0, t1, this._text$_height, [P.num]);
      },
      hitTestInput$2: function(localX, localY) {
        var t1 = J.getInterceptor$n(localX);
        if (!t1.$lt(localX, 0)) {
          this._refreshTextLineMetrics$0();
          t1 = t1.$ge(localX, this._text$_width);
        } else
          t1 = true;
        if (t1)
          return;
        t1 = J.getInterceptor$n(localY);
        if (!t1.$lt(localY, 0)) {
          this._refreshTextLineMetrics$0();
          t1 = t1.$ge(localY, this._text$_height);
        } else
          t1 = true;
        if (t1)
          return;
        return this;
      },
      render$1: function(renderState) {
        this._refreshTextLineMetrics$0();
        this._refreshCache$1(renderState._currentContextState.matrix);
        renderState._engine$_renderContext.renderTextureQuad$2(renderState, this._renderTextureQuad);
        this._caretTime = this._caretTime + renderState.deltaTime;
        if (this._text$_type === "input")
          this.get$stage() != null;
      },
      renderFiltered$1: function(renderState) {
        if (this._text$_type === "input")
          this.super$DisplayObject$renderFiltered(renderState);
        else {
          this._refreshTextLineMetrics$0();
          this._refreshCache$1(renderState._currentContextState.matrix);
          renderState._engine$_renderContext.renderTextureQuadFiltered$3(renderState, this._renderTextureQuad, this._filters);
        }
      },
      _refreshTextLineMetrics$0: function() {
        var t1, textFormat, textFormatSize, textFormatStrokeWidth, textFormatLeftMargin, textFormatRightMargin, textFormatTopMargin, textFormatBottomMargin, textFormatIndent, textFormatLeading, textFormatAlign, textFormatVerticalAlign, fontStyle, fontStyleMetrics, fontStyleMetricsAscent, fontStyleMetricsDescent, canvasContext, paragraphLines, paragraphSplit, paragraphs, startIndex, p, paragraph, t2, t3, line, textLineMetrics, indent, offsetX, offsetY, width, t4, autoWidth, autoHeight, availableWidth, heightOffset, textIndex, text, shiftX, t5, shiftY;
        t1 = this._refreshPending;
        if ((t1 & 1) === 0)
          return;
        else
          this._refreshPending = t1 & 254;
        t1 = this._textLineMetrics;
        C.JSArray_methods.set$length(t1, 0);
        textFormat = this._defaultTextFormat;
        textFormatSize = V.ensureNum(textFormat.size);
        textFormatStrokeWidth = V.ensureNum(textFormat.strokeWidth);
        textFormatLeftMargin = V.ensureNum(textFormat.leftMargin);
        textFormatRightMargin = V.ensureNum(textFormat.rightMargin);
        textFormatTopMargin = V.ensureNum(textFormat.topMargin);
        textFormatBottomMargin = V.ensureNum(textFormat.bottomMargin);
        textFormatIndent = V.ensureNum(textFormat.indent);
        textFormatLeading = V.ensureNum(textFormat.leading);
        textFormatAlign = V.ensureString(textFormat.align);
        textFormatVerticalAlign = V.ensureString(textFormat.verticalAlign);
        fontStyle = textFormat.get$_cssFontStyle();
        fontStyleMetrics = Y._getFontStyleMetrics(textFormat);
        fontStyleMetricsAscent = V.ensureNum(fontStyleMetrics.get$ascent());
        fontStyleMetricsDescent = V.ensureNum(fontStyleMetrics.get$descent());
        canvasContext = $.$get$_dummyCanvasContext();
        paragraphLines = H.setRuntimeTypeInfo([], [P.int]);
        paragraphSplit = P.RegExp_RegExp("\\r\\n|\\r|\\n", true, false);
        paragraphs = J.split$1$s(this._text$_text, paragraphSplit);
        canvasContext.font = fontStyle + " ";
        canvasContext.textAlign = "start";
        canvasContext.textBaseline = "alphabetic";
        canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        for (startIndex = 0, p = 0; p < paragraphs.length; ++p) {
          paragraph = paragraphs[p];
          if (typeof paragraph !== "string")
            continue;
          paragraphLines.push(t1.length);
          paragraph = this._passwordEncoder$1(paragraph);
          t1.push(new Y.TextLineMetrics(paragraph, startIndex, 0, 0, 0, 0, 0, 0, 0, 0));
          startIndex += paragraph.length + 1;
        }
        this._textWidth = 0;
        this._textHeight = 0;
        for (t2 = textFormatTopMargin + textFormatSize, t3 = textFormatLeading + textFormatSize + fontStyleMetricsDescent, line = 0; line < t1.length; ++line) {
          textLineMetrics = t1[line];
          indent = C.JSArray_methods.contains$1(paragraphLines, line) ? textFormatIndent : 0;
          offsetX = textFormatLeftMargin + indent;
          offsetY = t2 + line * t3;
          width = canvasContext.measureText(textLineMetrics._text$_text).width;
          width.toString;
          textLineMetrics._text$_x = offsetX;
          textLineMetrics._text$_y = offsetY;
          textLineMetrics._text$_width = width;
          textLineMetrics._text$_height = textFormatSize;
          textLineMetrics._ascent = fontStyleMetricsAscent;
          textLineMetrics._descent = fontStyleMetricsDescent;
          textLineMetrics._leading = textFormatLeading;
          textLineMetrics._indent = indent;
          t4 = this._textWidth;
          if (typeof width !== "number")
            return H.iae(width);
          this._textWidth = Math.max(t4, offsetX + width + textFormatRightMargin);
          this._textHeight = offsetY + fontStyleMetricsDescent + textFormatBottomMargin;
        }
        t2 = textFormatStrokeWidth * 2;
        t3 = this._textWidth + t2;
        this._textWidth = t3;
        this._textHeight += t2;
        autoWidth = C.JSNumber_methods.ceil$0(t3);
        autoHeight = C.JSNumber_methods.ceil$0(this._textHeight);
        t2 = this._text$_width;
        if (t2 !== autoWidth || this._text$_height !== autoHeight)
          switch (this._autoSize) {
            case "left":
              this._text$_width = autoWidth;
              this._text$_height = autoHeight;
              t2 = autoWidth;
              break;
            case "right":
              this.super$DisplayObject$x(0, J.$sub$n(A.DisplayObject.prototype.get$x.call(this, this), autoWidth - this._text$_width));
              this._text$_width = autoWidth;
              this._text$_height = autoHeight;
              t2 = autoWidth;
              break;
            case "center":
              this.super$DisplayObject$x(0, J.$sub$n(A.DisplayObject.prototype.get$x.call(this, this), (autoWidth - this._text$_width) / 2));
              this._text$_width = autoWidth;
              this._text$_height = autoHeight;
              t2 = autoWidth;
              break;
          }
        availableWidth = t2 - textFormatLeftMargin - textFormatRightMargin;
        switch (textFormatVerticalAlign) {
          case "center":
            heightOffset = (this._text$_height - this._textHeight) / 2;
            break;
          case "bottom":
            heightOffset = this._text$_height - this._textHeight - textFormatStrokeWidth;
            break;
          default:
            heightOffset = textFormatStrokeWidth;
        }
        for (line = 0; t2 = t1.length, line < t2; ++line) {
          textLineMetrics = t1[line];
          switch (textFormatAlign) {
            case "center":
            case "justify":
              textLineMetrics._text$_x = textLineMetrics._text$_x + (availableWidth - textLineMetrics._text$_width) / 2;
              break;
            case "right":
            case "end":
              textLineMetrics._text$_x = textLineMetrics._text$_x + (availableWidth - textLineMetrics._text$_width);
              break;
            default:
              textLineMetrics._text$_x += textFormatStrokeWidth;
          }
          textLineMetrics._text$_y += heightOffset;
        }
        if (this._text$_type === "input") {
          for (line = t2 - 1; line >= 0; --line) {
            if (line >= t1.length)
              return H.ioore(t1, line);
            textLineMetrics = t1[line];
            t2 = textLineMetrics._textIndex;
            if (J.$ge$n(this._caretIndex, t2)) {
              textIndex = J.$sub$n(this._caretIndex, t2);
              text = C.JSString_methods.substring$2(textLineMetrics._text$_text, 0, textIndex);
              this._caretLine = line;
              t2 = textLineMetrics._text$_x;
              t3 = canvasContext.measureText(text).width;
              t3.toString;
              if (typeof t3 !== "number")
                return H.iae(t3);
              this._caretX = t2 + t3;
              this._caretY = textLineMetrics._text$_y - fontStyleMetricsAscent * 0.9;
              this._caretWidth = 2;
              this._caretHeight = textFormatSize;
              break;
            }
          }
          for (t2 = this._caretX, t3 = this._text$_width, t4 = t3 * 0.2, shiftX = 0; shiftX + t2 > t3;)
            shiftX -= t4;
          for (; shiftX + t2 < 0;)
            shiftX += t4;
          for (t3 = this._caretY, t4 = this._caretHeight, t5 = this._text$_height, shiftY = 0; shiftY + t3 + t4 > t5;)
            shiftY -= textFormatSize;
          for (; shiftY + t3 < 0;)
            shiftY += textFormatSize;
          this._caretX = t2 + shiftX;
          this._caretY += shiftY;
          for (line = 0; line < t1.length; ++line) {
            textLineMetrics = t1[line];
            textLineMetrics._text$_x += shiftX;
            textLineMetrics._text$_y += shiftY;
          }
        }
      },
      _refreshCache$1: function(globalMatrix) {
        var t1, pixelRatioGlobal, pixelRatioCache, width, height, matrix, context;
        t1 = globalMatrix._data;
        pixelRatioGlobal = Math.sqrt(Math.abs(t1[0] * t1[3] - t1[1] * t1[2]));
        t1 = this._renderTextureQuad;
        pixelRatioCache = t1 == null ? t1 : t1.pixelRatio;
        if (pixelRatioCache == null)
          pixelRatioCache = 0;
        t1 = J.getInterceptor$n(pixelRatioCache);
        if (t1.$lt(pixelRatioCache, pixelRatioGlobal * 0.8))
          this._refreshPending |= 2;
        if (t1.$gt(pixelRatioCache, pixelRatioGlobal * 1.25))
          this._refreshPending |= 2;
        t1 = this._refreshPending;
        if ((t1 & 2) === 0)
          return;
        this._refreshPending = t1 & 253;
        width = C.JSNumber_methods.ceil$0(Math.max(1, this._text$_width * pixelRatioGlobal));
        height = C.JSNumber_methods.ceil$0(Math.max(1, this._text$_height * pixelRatioGlobal));
        t1 = this._renderTexture;
        if (t1 == null) {
          t1 = L.RenderTexture$(width, height, 16777215);
          this._renderTexture = t1;
          t1 = t1.get$quad();
          t1 = L.RenderTextureQuad$(t1.renderTexture, t1.sourceRectangle, t1.offsetRectangle, t1.rotation, pixelRatioGlobal);
          this._renderTextureQuad = t1;
        } else {
          t1.resize$2(0, width, height);
          t1 = this._renderTexture.get$quad();
          t1 = L.RenderTextureQuad$(t1.renderTexture, t1.sourceRectangle, t1.offsetRectangle, t1.rotation, pixelRatioGlobal);
          this._renderTextureQuad = t1;
        }
        matrix = t1.get$drawMatrix();
        t1 = this._renderTexture;
        context = J.get$context2D$x(t1.get$canvas(t1));
        t1 = matrix._data;
        context.setTransform(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5]);
        context.clearRect(0, 0, this._text$_width, this._text$_height);
        this._renderText$1(context);
        this._renderTexture.update$0(0);
      },
      _renderText$1: function(context) {
        var textFormat, t1, lineWidth, i, lm;
        textFormat = this._defaultTextFormat;
        t1 = textFormat.size;
        lineWidth = C.JSDouble_methods.ceil$0(t1 / 20);
        context.save();
        context.beginPath();
        context.rect(0, 0, this._text$_width, this._text$_height);
        context.clip();
        context.font = textFormat.get$_cssFontStyle() + " ";
        context.textAlign = "start";
        context.textBaseline = "alphabetic";
        context.lineCap = "round";
        context.lineJoin = "round";
        t1 = textFormat.strokeWidth;
        if (t1 > 0) {
          context.lineWidth = t1 * 2;
          context.strokeStyle = V.color2rgb(textFormat.strokeColor);
          for (t1 = this._textLineMetrics, i = 0; i < t1.length; ++i) {
            lm = t1[i];
            context.strokeText(lm._text$_text, lm._text$_x, lm._text$_y);
          }
        }
        context.lineWidth = lineWidth;
        context.strokeStyle = V.color2rgb(textFormat.color);
        t1 = V.color2rgb(textFormat.color);
        context.fillStyle = t1;
        for (t1 = this._textLineMetrics, i = 0; i < t1.length; ++i) {
          lm = t1[i];
          context.fillText(lm._text$_text, lm._text$_x, lm._text$_y);
        }
        context.restore();
      },
      _passwordEncoder$1: function(text) {
        return text;
      },
      _text$_onKeyDown$1: [function(keyboardEvent) {
        var text, t1, textLength, textLineMetrics, caretIndex, caretLine, t2, caretIndexNew, tlm, tlmFrom, tlmTo;
        if (this._text$_type === "input") {
          this._refreshTextLineMetrics$0();
          text = this._text$_text;
          t1 = J.getInterceptor$asx(text);
          textLength = t1.get$length(text);
          textLineMetrics = this._textLineMetrics;
          caretIndex = this._caretIndex;
          caretLine = this._caretLine;
          t2 = J.getInterceptor$x(keyboardEvent);
          switch (t2.get$keyCode(keyboardEvent)) {
            case 8:
              t2.preventDefault$0(keyboardEvent);
              t2 = J.getInterceptor$n(caretIndex);
              if (t2.$gt(caretIndex, 0)) {
                this._text$_text = t1.substring$2(text, 0, t2.$sub(caretIndex, 1)) + t1.substring$1(text, caretIndex);
                caretIndexNew = t2.$sub(caretIndex, 1);
              } else
                caretIndexNew = -1;
              break;
            case 35:
              t2.preventDefault$0(keyboardEvent);
              if (caretLine < 0 || caretLine >= textLineMetrics.length)
                return H.ioore(textLineMetrics, caretLine);
              tlm = textLineMetrics[caretLine];
              caretIndexNew = tlm._textIndex + tlm._text$_text.length;
              break;
            case 36:
              t2.preventDefault$0(keyboardEvent);
              if (caretLine < 0 || caretLine >= textLineMetrics.length)
                return H.ioore(textLineMetrics, caretLine);
              caretIndexNew = textLineMetrics[caretLine]._textIndex;
              break;
            case 37:
              t2.preventDefault$0(keyboardEvent);
              t1 = J.getInterceptor$n(caretIndex);
              caretIndexNew = t1.$gt(caretIndex, 0) ? t1.$sub(caretIndex, 1) : -1;
              break;
            case 38:
              t2.preventDefault$0(keyboardEvent);
              if (caretLine > 0 && caretLine < textLineMetrics.length) {
                t1 = textLineMetrics.length;
                if (caretLine < 0 || caretLine >= t1)
                  return H.ioore(textLineMetrics, caretLine);
                tlmFrom = textLineMetrics[caretLine];
                t2 = caretLine - 1;
                if (t2 < 0 || t2 >= t1)
                  return H.ioore(textLineMetrics, t2);
                tlmTo = textLineMetrics[t2];
                caretIndexNew = tlmTo._textIndex + Math.min(J.$sub$n(caretIndex, tlmFrom._textIndex), tlmTo._text$_text.length);
              } else
                caretIndexNew = 0;
              break;
            case 39:
              t2.preventDefault$0(keyboardEvent);
              t1 = J.getInterceptor$n(caretIndex);
              caretIndexNew = t1.$lt(caretIndex, textLength) ? t1.$add(caretIndex, 1) : -1;
              break;
            case 40:
              t2.preventDefault$0(keyboardEvent);
              if (caretLine >= 0 && caretLine < textLineMetrics.length - 1) {
                t1 = textLineMetrics.length;
                if (caretLine < 0 || caretLine >= t1)
                  return H.ioore(textLineMetrics, caretLine);
                tlmFrom = textLineMetrics[caretLine];
                t2 = caretLine + 1;
                if (t2 >= t1)
                  return H.ioore(textLineMetrics, t2);
                tlmTo = textLineMetrics[t2];
                caretIndexNew = tlmTo._textIndex + Math.min(J.$sub$n(caretIndex, tlmFrom._textIndex), tlmTo._text$_text.length);
              } else
                caretIndexNew = textLength;
              break;
            case 46:
              t2.preventDefault$0(keyboardEvent);
              t2 = J.getInterceptor$n(caretIndex);
              if (t2.$lt(caretIndex, textLength)) {
                this._text$_text = t1.substring$2(text, 0, caretIndex) + t1.substring$1(text, t2.$add(caretIndex, 1));
                caretIndexNew = caretIndex;
              } else
                caretIndexNew = -1;
              break;
            default:
              caretIndexNew = -1;
          }
          if (caretIndexNew !== -1) {
            this._caretIndex = caretIndexNew;
            this._caretTime = 0;
            this._refreshPending |= 3;
          }
        }
      }, "call$1", "get$_text$_onKeyDown", 2, 0, 69, 39],
      _onTextInput$1: [function(textEvent) {
        var t1, textLength, caretIndex, newText, t2;
        if (this._text$_type === "input") {
          t1 = J.getInterceptor$x(textEvent);
          t1.preventDefault$0(textEvent);
          textLength = J.get$length$asx(this._text$_text);
          caretIndex = this._caretIndex;
          newText = t1.get$text(textEvent);
          if (J.$eq$(newText, "\r"))
            newText = "\n";
          if (J.$eq$(newText, "\n") && true)
            newText = "";
          t1 = J.getInterceptor(newText);
          if (t1.$eq(newText, ""))
            return;
          t2 = this._maxChars;
          if (t2 !== 0 && J.$ge$n(textLength, t2))
            return;
          this._text$_text = C.JSString_methods.$add(J.substring$2$s(this._text$_text, 0, caretIndex), newText) + J.substring$1$s(this._text$_text, caretIndex);
          this._caretIndex = J.$add$ns(this._caretIndex, t1.get$length(newText));
          this._caretTime = 0;
          this._refreshPending |= 3;
        }
      }, "call$1", "get$_onTextInput", 2, 0, 70, 36],
      _text$_onMouseDown$1: [function(mouseEvent) {
        var mouseX, mouseY, canvasContext, t1, line, textLineMetrics, text, lineX, t2, t3, t4, bestDistance, bestIndex, c, width, distance;
        mouseX = J.toDouble$0$n(mouseEvent.get$localX());
        mouseY = J.toDouble$0$n(mouseEvent.get$localY());
        canvasContext = $.$get$_dummyCanvasContext();
        canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        for (t1 = this._textLineMetrics, line = 0; line < t1.length; ++line) {
          textLineMetrics = t1[line];
          text = textLineMetrics._text$_text;
          lineX = textLineMetrics._text$_x;
          t2 = textLineMetrics._text$_y;
          t3 = textLineMetrics._ascent;
          t4 = textLineMetrics._descent;
          if (t2 - t3 <= mouseY && t2 + t4 >= mouseY) {
            for (t2 = text.length, bestDistance = 1 / 0, bestIndex = 0, c = 0; c <= t2; ++c) {
              width = canvasContext.measureText(C.JSString_methods.substring$2(text, 0, c)).width;
              width.toString;
              if (typeof width !== "number")
                return H.iae(width);
              distance = Math.abs(lineX + width - mouseX);
              if (distance < bestDistance) {
                bestIndex = c;
                bestDistance = distance;
              }
            }
            this._caretIndex = textLineMetrics._textIndex + bestIndex;
            this._caretTime = 0;
            this._refreshPending |= 3;
          }
        }
      }, "call$1", "get$_text$_onMouseDown", 2, 0, 12, 19],
      TextField$2: function(text, textFormat) {
        this.set$text(0, text != null ? text : "");
        this._defaultTextFormat = (textFormat != null ? textFormat : new Y.TextFormat("Arial", 12, 0, 0, 4278190080, null, 400, false, false, false, "left", "top", 0, 0, 0, 0, 0, 0)).clone$0(0);
        this._refreshPending |= 3;
        this.on$1(0, "keyDown").listen$1(this.get$_text$_onKeyDown());
        this.on$1(0, "textInput").listen$1(this.get$_onTextInput());
        this.on$1(0, "mouseDown").listen$1(this.get$_text$_onMouseDown());
      },
      static: {
        TextField$: function(text, textFormat) {
          var t1, t2;
          t1 = H.setRuntimeTypeInfo([], [Y.TextLineMetrics]);
          t2 = $.DisplayObject__nextID;
          $.DisplayObject__nextID = t2 + 1;
          t2 = new Y.TextField("", null, "none", "dynamic", 0, 0, 0, 0, 0, 0, 0, false, false, false, false, false, "\u2022", 16777215, 0, 0, 100, 100, 0, 0, t1, 3, true, null, null, false, true, "auto", true, 0, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
          t2.TextField$2(text, textFormat);
          return t2;
        }
      }
    },
    TextFormat: {
      "^": "Object;font,size,color,strokeWidth,strokeColor,fillGradient,weight,bold,italic,underline,align,verticalAlign,topMargin,bottomMargin,leftMargin,rightMargin,indent@,leading",
      clone$0: function(_) {
        return new Y.TextFormat(this.font, this.size, this.color, this.strokeWidth, this.strokeColor, this.fillGradient, this.weight, false, false, false, this.align, this.verticalAlign, this.topMargin, this.bottomMargin, this.leftMargin, this.rightMargin, this.indent, this.leading);
      },
      get$_cssFontStyle: function() {
        var fontStyle = "" + this.weight + " " + H.S(this.size) + "px " + this.font;
        return fontStyle;
      }
    },
    TextLineMetrics: {
      "^": "Object;_text$_text,_textIndex,_text$_x,_text$_y,_text$_width,_text$_height,_ascent,_descent,_leading,_indent",
      get$x: function(_) {
        return this._text$_x;
      },
      get$y: function(_) {
        return this._text$_y;
      },
      get$width: function(_) {
        return this._text$_width;
      },
      get$height: function(_) {
        return this._text$_height;
      },
      get$ascent: function() {
        return this._ascent;
      },
      get$descent: function() {
        return this._descent;
      },
      get$indent: function() {
        return this._indent;
      }
    }
  }], ["stagexl.ui.mouse", "package:stagexl/src/ui/mouse.dart",, Q, {
    "^": "",
    MouseCursorData: {
      "^": "Object;"
    }
  }], ["score_player_example", "score_player_example.dart",, L, {
    "^": "",
    main: [function() {
      var root, options, config, t1;
      root = L._getRootPath();
      options = new M.PlayerLoaderOptions("stageCanvas", "songUrl", null, "");
      options.defaultSongUrl = "songXmls/testfile.xml";
      options.resourceRoot = root;
      config = new M.PlayerInitConfig(true, false, $.$get$InstrumentUtils_instruments()[0], 70, false, null, null, "", P.LinkedHashMap__makeLiteral(["recorder", "images/atlases/recorder1.json", "controls", "images/atlases/player_controls.json"]));
      config.resourceRoot = root;
      P.print(C.JSString_methods.$add("root: ", root));
      t1 = new M.StandalonePlayerLoader(null, new L.main_closure(config), null, null, null, null, null);
      t1._options = options;
      t1._init$0();
    }, "call$0", "score_player_example__main$closure", 0, 0, 1],
    _getRootPath: function() {
      var paths = J.$index$asx($.$get$context(), "paths");
      if (paths != null && paths.hasProperty$1("resourceRoot"))
        return J.$index$asx(paths, "resourceRoot");
      return "";
    },
    main_closure: {
      "^": "Closure:1;config",
      call$0: [function() {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([], [A.DisplayObject]);
        t2 = $.DisplayObject__nextID;
        $.DisplayObject__nextID = t2 + 1;
        t2 = new L.BasicPlayer(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1, true, true, false, true, "auto", true, 0, t2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, true, false, null, null, H.setRuntimeTypeInfo([], [A.BitmapFilter]), null, "", null, T.Matrix$fromIdentity(), true, null, null);
        t2.init$1(this.config);
        return t2;
      }, null, null, 0, 0, null, "call"]
    },
    BasicPlayer: {
      "^": "AbstractPlayer;_config,_resourceManager,_pbm,_lm,_barPlayControls,controls,_songLoadCompleter,_driver,score,_score_player$_scoreViewer,scoreManager,arranger,instrument,_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      init$1: function(config) {
        config.notationVOffset = 40;
        config.showNoteNames = true;
        this.super$AbstractPlayer$init(config);
      }
    },
    BasicControls: {
      "^": "AbstractControls;_playBtn,_upTempoBtn,_downTempoBtn,_playBtnBmp,_stopBtnBmp,_tempoTF,_tempoPercentage,_unscaledWidth,_micAccessRequested,pm,_graphics,dropTarget,hitArea,_children,_mouseChildren,_tabChildren,doubleClickEnabled,mouseEnabled,mouseCursor,tabEnabled,tabIndex,displayObjectID,_x,_y,_pivotX,_pivotY,_scaleX,_scaleY,_skewX,_skewY,_rotation,_alpha,_display$_visible,_off,_mask,_blendMode,_filters,_cache,_display$_name,_parent,_transformationMatrix,_transformationMatrixRefresh,userData,_eventStreams",
      setMode$1: function(mode) {
        var t1, t2;
        if (mode === 0) {
          this._playBtn.mouseEnabled = false;
          this._upTempoBtn.mouseEnabled = false;
          this._downTempoBtn.mouseEnabled = false;
        } else if (mode === 1) {
          t1 = this._playBtn;
          t1.mouseEnabled = true;
          this._upTempoBtn.mouseEnabled = true;
          this._downTempoBtn.mouseEnabled = true;
          t2 = this._playBtnBmp;
          t1.hitTestState = t2;
          t1.overState = t2;
          t1.downState = t2;
          t1.upState = t2;
        } else if (mode === 2) {
          t1 = this._playBtn;
          t1.mouseEnabled = true;
          this._upTempoBtn.mouseEnabled = false;
          this._downTempoBtn.mouseEnabled = false;
          t2 = this._stopBtnBmp;
          t1.hitTestState = t2;
          t1.overState = t2;
          t1.downState = t2;
          t1.upState = t2;
        }
      },
      _onTempoUpBtnClick$1: [function(e) {
        var t1 = this._tempoPercentage += 10;
        if (t1 > 400)
          this._tempoPercentage = 400;
        this._updateTempoDisplay$0();
      }, "call$1", "get$_onTempoUpBtnClick", 2, 0, 4, 0],
      _onTempoDownBtnClick$1: [function(e) {
        var t1 = this._tempoPercentage -= 10;
        if (t1 < 10)
          this._tempoPercentage = 10;
        this._updateTempoDisplay$0();
      }, "call$1", "get$_onTempoDownBtnClick", 2, 0, 4, 0],
      _updateTempoDisplay$0: function() {
        var t1, t2, t3, t4;
        this._tempoTF.set$text(0, "Tempo: " + this._tempoPercentage + "%");
        t1 = this._upTempoBtn;
        t2 = t1._x;
        t1 = t1.get$boundsTransformed().width;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t3 = this._downTempoBtn._x;
        t4 = this._tempoTF;
        t4._refreshTextLineMetrics$0();
        t4.set$x(0, t3 + (t2 + t1 - t3 - t4._textWidth * 0.5) / 2);
      },
      _onPlayBtnClick$1: [function(e) {
        var t1, t2, t3, t4;
        t1 = this.pm;
        t2 = t1._pbm;
        t3 = t2._playbackDO;
        t4 = t3 != null;
        if (t4 && !t3.playbackFinished) {
          if (t4 && !t3.playbackFinished) {
            t2._pm._driver.stop$0(0);
            t2._finishPlayback$0();
          }
        } else {
          if (!this._micAccessRequested) {
            t1._driver._micManager.initMicAndGetPermission$0().then$1(new L.BasicControls__onPlayBtnClick_closure(this));
            return;
          }
          t2._play$6(false, 0, 0, null, null, C.AssessmentType_3);
        }
      }, "call$1", "get$_onPlayBtnClick", 2, 0, 4, 0]
    },
    BasicControls__onPlayBtnClick_closure: {
      "^": "Closure:0;$this",
      call$1: [function(_) {
        this.$this._micAccessRequested = true;
      }, null, null, 2, 0, null, 4, "call"]
    }
  }, 1]];
  setupProgram(dart, 0);
  // getInterceptor methods
  J.getInterceptor = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSDouble.prototype;
    }
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return J.JSNull.prototype;
    if (typeof receiver == "boolean")
      return J.JSBool.prototype;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$asx = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$ax = function(receiver) {
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$n = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$ns = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$s = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$x = function(receiver) {
    if (receiver == null)
      return receiver;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.set$_data$_height$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$_data$_height(receiver, value);
  };
  J.set$_data$_width$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$_data$_width(receiver, value);
  };
  J.set$display$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$display(receiver, value);
  };
  J.set$font$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$font(receiver, value);
  };
  J.set$height$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$height(receiver, value);
  };
  J.set$location$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$location(receiver, value);
  };
  J.set$next$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$next(receiver, value);
  };
  J.set$style$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$style(receiver, value);
  };
  J.set$text$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$text(receiver, value);
  };
  J.set$verticalAlign$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$verticalAlign(receiver, value);
  };
  J.set$visible$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$visible(receiver, value);
  };
  J.set$width$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$width(receiver, value);
  };
  J.set$x$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$x(receiver, value);
  };
  J.set$y$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$y(receiver, value);
  };
  J.get$attributes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$attributes(receiver);
  };
  J.get$border$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$border(receiver);
  };
  J.get$childNodes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$childNodes(receiver);
  };
  J.get$complete$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$complete(receiver);
  };
  J.get$context2D$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$context2D(receiver);
  };
  J.get$currentTarget$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$currentTarget(receiver);
  };
  J.get$data$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$data(receiver);
  };
  J.get$endTime$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$endTime(receiver);
  };
  J.get$error$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$error(receiver);
  };
  J.get$globalAlpha$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$globalAlpha(receiver);
  };
  J.get$height$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$height(receiver);
  };
  J.get$id$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$id(receiver);
  };
  J.get$inputBuffer$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$inputBuffer(receiver);
  };
  J.get$isEmpty$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
  };
  J.get$iterator$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$iterator(receiver);
  };
  J.get$keys$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$keys(receiver);
  };
  J.get$length$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$length(receiver);
  };
  J.get$measure$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$measure(receiver);
  };
  J.get$name$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$name(receiver);
  };
  J.get$next$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$next(receiver);
  };
  J.get$offsetTop$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$offsetTop(receiver);
  };
  J.get$parent$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$parent(receiver);
  };
  J.get$response$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$response(receiver);
  };
  J.get$responseText$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$responseText(receiver);
  };
  J.get$result$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$result(receiver);
  };
  J.get$startTime$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$startTime(receiver);
  };
  J.get$style$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$style(receiver);
  };
  J.get$tagName$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$tagName(receiver);
  };
  J.get$text$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$text(receiver);
  };
  J.get$time$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$time(receiver);
  };
  J.get$type$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$type(receiver);
  };
  J.get$url$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$url(receiver);
  };
  J.get$value$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$value(receiver);
  };
  J.get$visible$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$visible(receiver);
  };
  J.get$voice$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$voice(receiver);
  };
  J.get$width$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$width(receiver);
  };
  J.get$x$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$x(receiver);
  };
  J.$add$ns = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver + a0;
    return J.getInterceptor$ns(receiver).$add(receiver, a0);
  };
  J.$and$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver & a0) >>> 0;
    return J.getInterceptor$n(receiver).$and(receiver, a0);
  };
  J.$div$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver / a0;
    return J.getInterceptor$n(receiver).$div(receiver, a0);
  };
  J.$ge$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver >= a0;
    return J.getInterceptor$n(receiver).$ge(receiver, a0);
  };
  J.$gt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver > a0;
    return J.getInterceptor$n(receiver).$gt(receiver, a0);
  };
  J.$index$asx = function(receiver, a0) {
    if (typeof a0 === "number")
      if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
        if (a0 >>> 0 === a0 && a0 < receiver.length)
          return receiver[a0];
    return J.getInterceptor$asx(receiver).$index(receiver, a0);
  };
  J.$indexSet$ax = function(receiver, a0, a1) {
    if (typeof a0 === "number")
      if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
        return receiver[a0] = a1;
    return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
  };
  J.$le$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver <= a0;
    return J.getInterceptor$n(receiver).$le(receiver, a0);
  };
  J.$lt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver < a0;
    return J.getInterceptor$n(receiver).$lt(receiver, a0);
  };
  J.$mod$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$mod(receiver, a0);
  };
  J.$mul$ns = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver * a0;
    return J.getInterceptor$ns(receiver).$mul(receiver, a0);
  };
  J.$shl$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$shl(receiver, a0);
  };
  J.$sub$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver - a0;
    return J.getInterceptor$n(receiver).$sub(receiver, a0);
  };
  J.$tdiv$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
  };
  J.$xor$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver ^ a0) >>> 0;
    return J.getInterceptor$n(receiver).$xor(receiver, a0);
  };
  J.__isolate_helper$_add$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).__isolate_helper$_add$1(receiver, a0);
  };
  J._querySelectorAll$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver)._querySelectorAll$1(receiver, a0);
  };
  J.abs$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).abs$0(receiver);
  };
  J.activate$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).activate$1(receiver, a0);
  };
  J.addEventListener$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).addEventListener$2(receiver, a0, a1);
  };
  J.addEventListener$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
  };
  J.allMatches$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).allMatches$1(receiver, a0);
  };
  J.append$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).append$1(receiver, a0);
  };
  J.ceil$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).ceil$0(receiver);
  };
  J.clearColor$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).clearColor$0(receiver);
  };
  J.clearMeasures$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).clearMeasures$0(receiver);
  };
  J.compareTo$1$ns = function(receiver, a0) {
    return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
  };
  J.complete$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).complete$1(receiver, a0);
  };
  J.contains$2$asx = function(receiver, a0, a1) {
    return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
  };
  J.containsKey$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).containsKey$1(receiver, a0);
  };
  J.createGain$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).createGain$0(receiver);
  };
  J.createScriptProcessor$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).createScriptProcessor$3(receiver, a0, a1, a2);
  };
  J.decodeAudioData$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).decodeAudioData$1(receiver, a0);
  };
  J.dispatchEvent$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).dispatchEvent$1(receiver, a0);
  };
  J.elementAt$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
  };
  J.fillRange$3$ax = function(receiver, a0, a1, a2) {
    return J.getInterceptor$ax(receiver).fillRange$3(receiver, a0, a1, a2);
  };
  J.floor$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).floor$0(receiver);
  };
  J.flush$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).flush$0(receiver);
  };
  J.forEach$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
  };
  J.getChannelData$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).getChannelData$1(receiver, a0);
  };
  J.getPropertyValue$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).getPropertyValue$1(receiver, a0);
  };
  J.indexOf$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
  };
  J.map$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).map$1(receiver, a0);
  };
  J.matchAsPrefix$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
  };
  J.parseFromString$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).parseFromString$2(receiver, a0, a1);
  };
  J.preventDefault$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).preventDefault$0(receiver);
  };
  J.querySelector$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).querySelector$1(receiver, a0);
  };
  J.querySelectorAll$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).querySelectorAll$1(receiver, a0);
  };
  J.remove$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).remove$0(receiver);
  };
  J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
  };
  J.replaceRange$3$asx = function(receiver, a0, a1, a2) {
    return J.getInterceptor$asx(receiver).replaceRange$3(receiver, a0, a1, a2);
  };
  J.round$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).round$0(receiver);
  };
  J.send$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).send$1(receiver, a0);
  };
  J.setProperty$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).setProperty$3(receiver, a0, a1, a2);
  };
  J.skip$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
  };
  J.split$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).split$1(receiver, a0);
  };
  J.substring$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).substring$1(receiver, a0);
  };
  J.substring$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
  };
  J.toDouble$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).toDouble$0(receiver);
  };
  J.toInt$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).toInt$0(receiver);
  };
  J.toRadixString$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
  };
  J.trim$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).trim$0(receiver);
  };
  J.update$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).update$2(receiver, a0, a1);
  };
  J.get$hashCode$ = function(receiver) {
    return J.getInterceptor(receiver).get$hashCode(receiver);
  };
  J.$eq$ = function(receiver, a0) {
    if (receiver == null)
      return a0 == null;
    if (typeof receiver != "object")
      return a0 != null && receiver === a0;
    return J.getInterceptor(receiver).$eq(receiver, a0);
  };
  J.noSuchMethod$1$ = function(receiver, a0) {
    return J.getInterceptor(receiver).noSuchMethod$1(receiver, a0);
  };
  J.toString$0$ = function(receiver) {
    return J.getInterceptor(receiver).toString$0(receiver);
  };
  Isolate.makeConstantList = function(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  };
  var $ = Isolate.$isolateProperties;
  C.AudioBufferSourceNode_methods = P.AudioBufferSourceNode.prototype;
  C.CanvasElement_methods = W.CanvasElement.prototype;
  C.CanvasRenderingContext2D_methods = W.CanvasRenderingContext2D.prototype;
  C.HttpRequest_methods = W.HttpRequest.prototype;
  C.Interceptor_methods = J.Interceptor.prototype;
  C.JSArray_methods = J.JSArray.prototype;
  C.JSDouble_methods = J.JSDouble.prototype;
  C.JSInt_methods = J.JSInt.prototype;
  C.JSNull_methods = J.JSNull.prototype;
  C.JSNumber_methods = J.JSNumber.prototype;
  C.JSString_methods = J.JSString.prototype;
  C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
  C.NativeByteBuffer_methods = H.NativeByteBuffer.prototype;
  C.NativeFloat32List_methods = H.NativeFloat32List.prototype;
  C.NativeInt16List_methods = H.NativeInt16List.prototype;
  C.NativeUint8List_methods = H.NativeUint8List.prototype;
  C.Navigator_methods = W.Navigator.prototype;
  C.NodeList_methods = W.NodeList.prototype;
  C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
  C.RenderingContext_methods = P.RenderingContext.prototype;
  C.Touch_methods = W.Touch.prototype;
  C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
  C.Window_methods = W.Window.prototype;
  C.AssessmentType_0 = new F.AssessmentType(0, "AssessmentType.NONE");
  C.AssessmentType_1 = new F.AssessmentType(1, "AssessmentType.RHYTHM_KEYBOARD");
  C.AssessmentType_3 = new F.AssessmentType(3, "AssessmentType.PITCH");
  C.Base64Encoder_false = new P.Base64Encoder(false);
  C.Base64Codec_Base64Encoder_false = new P.Base64Codec(C.Base64Encoder_false);
  C.BlendMode_bZz = new L.BlendMode(1, 771, "source-over");
  C.C_OutOfMemoryError = new P.OutOfMemoryError();
  C.C__DelayedDone = new P._DelayedDone();
  C.C__RootZone = new P._RootZone();
  C.C__TextureAtlasFormatJson = new O._TextureAtlasFormatJson();
  C.CapsStyle_0 = new U.CapsStyle(0, "CapsStyle.NONE");
  C.CapsStyle_1 = new U.CapsStyle(1, "CapsStyle.ROUND");
  C.CapsStyle_2 = new U.CapsStyle(2, "CapsStyle.SQUARE");
  C.Duration_0 = new P.Duration(0);
  C.Duration_500000 = new P.Duration(500000);
  C.EventPhase_0 = new R.EventPhase(0, "EventPhase.CAPTURING_PHASE");
  C.EventPhase_1 = new R.EventPhase(1, "EventPhase.AT_TARGET");
  C.EventPhase_2 = new R.EventPhase(2, "EventPhase.BUBBLING_PHASE");
  C.HitType_0 = new Q.HitType(0, "HitType.RHYTHM_HIT");
  C.HitType_1 = new Q.HitType(1, "HitType.BEAT_HIT");
  C.InputEventMode_0 = new R.InputEventMode(0, "InputEventMode.MouseOnly");
  C.InputEventMode_1 = new R.InputEventMode(1, "InputEventMode.TouchOnly");
  C.InputEventMode_2 = new R.InputEventMode(2, "InputEventMode.MouseAndTouch");
  C.JS_CONST_4IJ = function() {  var toStringFunction = Object.prototype.toString;  function getTag(o) {    var s = toStringFunction.call(o);    return s.substring(8, s.length - 1);  }  function getUnknownTag(object, tag) {    if (/^HTML[A-Z].*Element$/.test(tag)) {      var name = toStringFunction.call(object);      if (name == "[object Object]") return null;      return "HTMLElement";    }  }  function getUnknownTagGenericBrowser(object, tag) {    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";    return getUnknownTag(object, tag);  }  function prototypeForTag(tag) {    if (typeof window == "undefined") return null;    if (typeof window[tag] == "undefined") return null;    var constructor = window[tag];    if (typeof constructor != "function") return null;    return constructor.prototype;  }  function discriminator(tag) { return null; }  var isBrowser = typeof navigator == "object";  return {    getTag: getTag,    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,    prototypeForTag: prototypeForTag,    discriminator: discriminator };};
  C.JS_CONST_AgZ = function(hooks) { return hooks; };
  C.JS_CONST_EKH = function(hooks) {  if (typeof dartExperimentalFixupGetTag != "function") return hooks;  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);};
  C.JS_CONST_EyN = function(hooks) {  var getTag = hooks.getTag;  var prototypeForTag = hooks.prototypeForTag;  function getTagFixed(o) {    var tag = getTag(o);    if (tag == "Document") {      // "Document", so we check for the xmlVersion property, which is the empty      if (!!o.xmlVersion) return "!Document";      return "!HTMLDocument";    }    return tag;  }  function prototypeForTagFixed(tag) {    if (tag == "Document") return null;    return prototypeForTag(tag);  }  hooks.getTag = getTagFixed;  hooks.prototypeForTag = prototypeForTagFixed;};
  C.JS_CONST_LlX = function(hooks) {  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";  if (userAgent.indexOf("Firefox") == -1) return hooks;  var getTag = hooks.getTag;  var quickMap = {    "BeforeUnloadEvent": "Event",    "DataTransfer": "Clipboard",    "GeoGeolocation": "Geolocation",    "Location": "!Location",    "WorkerMessageEvent": "MessageEvent",    "XMLDocument": "!Document"};  function getTagFirefox(o) {    var tag = getTag(o);    return quickMap[tag] || tag;  }  hooks.getTag = getTagFirefox;};
  C.JS_CONST_TSE = function getTagFallback(o) {  var s = Object.prototype.toString.call(o);  return s.substring(8, s.length - 1);};
  C.JS_CONST_c0o = function(hooks) {  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";  if (userAgent.indexOf("Trident/") == -1) return hooks;  var getTag = hooks.getTag;  var quickMap = {    "BeforeUnloadEvent": "Event",    "DataTransfer": "Clipboard",    "HTMLDDElement": "HTMLElement",    "HTMLDTElement": "HTMLElement",    "HTMLPhraseElement": "HTMLElement",    "Position": "Geoposition"  };  function getTagIE(o) {    var tag = getTag(o);    var newTag = quickMap[tag];    if (newTag) return newTag;    if (tag == "Object") {      if (window.DataView && (o instanceof window.DataView)) return "DataView";    }    return tag;  }  function prototypeForTagIE(tag) {    var constructor = window[tag];    if (constructor == null) return null;    return constructor.prototype;  }  hooks.getTag = getTagIE;  hooks.prototypeForTag = prototypeForTagIE;};
  C.JS_CONST_nuk = function(getTagFallback) {  return function(hooks) {    if (typeof navigator != "object") return hooks;    var ua = navigator.userAgent;    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;    if (ua.indexOf("Chrome") >= 0) {      function confirm(p) {        return typeof window == "object" && window[p] && window[p].name == p;      }      if (confirm("Window") && confirm("HTMLElement")) return hooks;    }    hooks.getTag = getTagFallback;  };};
  C.JointStyle_0 = new U.JointStyle(0, "JointStyle.MITER");
  C.JointStyle_1 = new U.JointStyle(1, "JointStyle.ROUND");
  C.JointStyle_2 = new U.JointStyle(2, "JointStyle.BEVEL");
  C.JsonCodec_null_null = new P.JsonCodec(null, null);
  C.JsonDecoder_null = new P.JsonDecoder(null);
  C.List_0 = Isolate.makeConstantList([0]);
  C.List_1 = Isolate.makeConstantList([1]);
  C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.int]);
  C.List_2Bc = Isolate.makeConstantList([8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8]);
  C.List_2Vk = Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]);
  C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
  C.List_JYB = Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]);
  C.List_X3d0 = Isolate.makeConstantList([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
  C.List_X3d = Isolate.makeConstantList([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]);
  C.List_eea = Isolate.makeConstantList([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
  C.List_empty = Isolate.makeConstantList([]);
  C.List_gRj = Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]);
  C.List_i3t = Isolate.makeConstantList([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]);
  C.List_nxB = Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]);
  C.List_qNA = Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]);
  C.List_qQn = Isolate.makeConstantList([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]);
  C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
  C.List_uSC = Isolate.makeConstantList([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  C.List_empty0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.String]);
  C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, P.String]);
  C.List_empty1 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.Symbol0]);
  C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty1, [P.Symbol0, null]);
  C.NoteheadType_0 = new G.NoteheadType(0, "NoteheadType.QUARTER");
  C.NoteheadType_1 = new G.NoteheadType(1, "NoteheadType.HALF");
  C.NoteheadType_2 = new G.NoteheadType(2, "NoteheadType.WHOLE");
  C.RenderEngine_0 = new L.RenderEngine(0, "RenderEngine.WebGL");
  C.RenderEngine_1 = new L.RenderEngine(1, "RenderEngine.Canvas2D");
  C.RenderTextureFiltering_9728 = new L.RenderTextureFiltering(9728);
  C.RenderTextureFiltering_9729 = new L.RenderTextureFiltering(9729);
  C.RenderTextureWrapping_33071 = new L.RenderTextureWrapping(33071);
  C.SimpleButtonState_0 = new A.SimpleButtonState(0, "SimpleButtonState.Up");
  C.SimpleButtonState_1 = new A.SimpleButtonState(1, "SimpleButtonState.Over");
  C.SimpleButtonState_2 = new A.SimpleButtonState(2, "SimpleButtonState.Down");
  C.StageAlign_0 = new A.StageAlign(0, "StageAlign.TOP_LEFT");
  C.StageAlign_1 = new A.StageAlign(1, "StageAlign.TOP");
  C.StageAlign_2 = new A.StageAlign(2, "StageAlign.TOP_RIGHT");
  C.StageAlign_3 = new A.StageAlign(3, "StageAlign.LEFT");
  C.StageAlign_4 = new A.StageAlign(4, "StageAlign.NONE");
  C.StageAlign_5 = new A.StageAlign(5, "StageAlign.RIGHT");
  C.StageAlign_6 = new A.StageAlign(6, "StageAlign.BOTTOM_LEFT");
  C.StageAlign_7 = new A.StageAlign(7, "StageAlign.BOTTOM");
  C.StageAlign_8 = new A.StageAlign(8, "StageAlign.BOTTOM_RIGHT");
  C.StageRenderMode_0 = new A.StageRenderMode(0, "StageRenderMode.AUTO");
  C.StageRenderMode_2 = new A.StageRenderMode(2, "StageRenderMode.ONCE");
  C.StageRenderMode_3 = new A.StageRenderMode(3, "StageRenderMode.STOP");
  C.StageScaleMode_0 = new A.StageScaleMode(0, "StageScaleMode.EXACT_FIT");
  C.StageScaleMode_1 = new A.StageScaleMode(1, "StageScaleMode.NO_BORDER");
  C.StageScaleMode_2 = new A.StageScaleMode(2, "StageScaleMode.NO_SCALE");
  C.StageScaleMode_3 = new A.StageScaleMode(3, "StageScaleMode.SHOW_ALL");
  C.Symbol_call = new H.Symbol("call");
  C.Utf8Codec_false = new P.Utf8Codec(false);
  $.Primitives_mirrorFunctionCacheName = "$cachedFunction";
  $.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
  $.Primitives_timerFrequency = null;
  $.Primitives_timerTicks = null;
  $.Closure_functionCounter = 0;
  $.BoundClosure_selfFieldNameCache = null;
  $.BoundClosure_receiverFieldNameCache = null;
  $.getTagFunction = null;
  $.alternateTagFunction = null;
  $.prototypeForTagFunction = null;
  $.dispatchRecordsForInstanceTags = null;
  $.interceptorsForUncacheableTags = null;
  $.initNativeDispatchFlag = null;
  $._nextCallback = null;
  $._lastCallback = null;
  $._lastPriorityCallback = null;
  $._isInCallbackLoop = false;
  $.Zone__current = C.C__RootZone;
  $.Expando__keyCount = 0;
  $.Stopwatch__frequency = null;
  $.Device__isOpera = null;
  $.Device__isIE = null;
  $.Device__isFirefox = null;
  $.Device__isWebKit = null;
  $.Device__cachedCssPrefix = null;
  $.KeyHitRecognizer__ref = null;
  $.MicManager__ref = null;
  $.AudioManager_context = null;
  $.ScoreViewerViewManager__numScrollDeltaReadings = null;
  $.FingeringDisplay_resourceManager = null;
  $.FingeringDisplay_displays = null;
  $.FingeringDisplay__fingerMode = 0;
  $.FingeringDisplay__fingerings = null;
  $.BitmapMusicRenderer_firstPageVerticalOffset = 50;
  $.SystemRenderer_TC_FLAT_POSITIONS = null;
  $.SystemRenderer_BC_FLAT_POSITIONS = null;
  $.SystemRenderer_TC_SHARP_POSITIONS = null;
  $.SystemRenderer_BC_SHARP_POSITIONS = null;
  $.SystemRenderer_TENOR_FLAT_POSITIONS = null;
  $.SystemRenderer_TENOR_SHARP_POSITIONS = null;
  $.SystemRenderer_ALTO_FLAT_POSITIONS = null;
  $.SystemRenderer_ALTO_SHARP_POSITIONS = null;
  $.VisualSystem__cacheWidthAddition = 0;
  $.MusicTextures_pathPrefix = "";
  $.MusicTextures_wholeRest = null;
  $.MusicTextures_halfRest = null;
  $.MusicTextures_quarterRest = null;
  $.MusicTextures_eighthRest = null;
  $.MusicTextures_sixteenthRest = null;
  $.MusicTextures_thirtySecondRest = null;
  $.MusicTextures_sixtyFourthRest = null;
  $.MusicTextures_wholeNoteHead = null;
  $.MusicTextures_halfNoteHead = null;
  $.MusicTextures_quarterNoteHead = null;
  $.MusicTextures_sharp = null;
  $.MusicTextures_flat = null;
  $.MusicTextures_natural = null;
  $.MusicTextures_doubleSharp = null;
  $.MusicTextures_doubleFlat = null;
  $.MusicTextures_eighthFlagUp = null;
  $.MusicTextures_eighthFlagDown = null;
  $.MusicTextures_sixteenthFlagUp = null;
  $.MusicTextures_sixteenthFlagDown = null;
  $.MusicTextures_thirtySecondFlagUp = null;
  $.MusicTextures_thirtySecondFlagDown = null;
  $.MusicTextures_sixtyFourthFlagUp = null;
  $.MusicTextures_sixtyFourthFlagDown = null;
  $.MusicTextures_trebleClef = null;
  $.MusicTextures_bassClef = null;
  $.MusicTextures_altoClef = null;
  $.MusicTextures_tenorClef = null;
  $.MusicTextures_f = null;
  $.MusicTextures_ff = null;
  $.MusicTextures_fff = null;
  $.MusicTextures_p = null;
  $.MusicTextures_pp = null;
  $.MusicTextures_ppp = null;
  $.MusicTextures_mf = null;
  $.MusicTextures_mp = null;
  $.MusicTextures_augmentationDot = null;
  $.MusicTextures_accent = null;
  $.MusicTextures_staccato = null;
  $.MusicTextures_legato = null;
  $.MusicTextures__texturesCreated = false;
  $.MusicTextures__svgScale = 1;
  $.MusicTextures_onCompleteFunction = null;
  $.SFPlayer__context = null;
  $.DisplayObject__nextID = 0;
  $._TouchPoint__globalTouchPointID = 1;
  $.RenderContextWebGL__globalContextIdentifier = 0;
  $._globalFrameTime = 17976931348623157e292;
  $._globalFrameCallbackId = -1;
  $.InputEvent_current = null;
  $.Mouse__cursorHidden = false;
  $.Mouse__cursorName = "auto";
  $ = null;
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers$[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    $dart_deferred_initializers$[hunkHash]($globals$, $);
    init.deferredInitialized[hunkHash] = true;
  };
  init.deferredLibraryUris = {};
  init.deferredLibraryHashes = {};
  // Empty type-to-interceptor map.
  (function(lazies) {
    for (var i = 0; i < lazies.length;) {
      var fieldName = lazies[i++];
      var getterName = lazies[i++];
      var lazyValue = lazies[i++];
      var staticName = lazies[i++];
      Isolate.$lazy(fieldName, getterName, lazyValue, staticName);
    }
  })(["DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
    return H.getIsolateAffinityTag("_$dart_dartClosure");
  }, "DART_CLOSURE_PROPERTY_NAME", "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
    return H.getIsolateAffinityTag("_$dart_js");
  }, "JS_INTEROP_INTERCEPTOR_TAG", "IsolateNatives_thisScript", "$get$IsolateNatives_thisScript", function() {
    return H.IsolateNatives_computeThisScript();
  }, "IsolateNatives_thisScript", "IsolateNatives_workerIds", "$get$IsolateNatives_workerIds", function() {
    if (typeof WeakMap == "function")
      var t1 = new WeakMap();
    else {
      t1 = $.Expando__keyCount;
      $.Expando__keyCount = t1 + 1;
      t1 = "expando$key$" + t1;
    }
    return new P.Expando(null, t1);
  }, "IsolateNatives_workerIds", "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({
      toString: function() {
        return "$receiver$";
      }
    }));
  }, "TypeErrorDecoder_noSuchMethodPattern", "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
      toString: function() {
        return "$receiver$";
      }
    }));
  }, "TypeErrorDecoder_notClosurePattern", "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
  }, "TypeErrorDecoder_nullCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = '$arguments$';
      try {
        null.$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_nullLiteralCallPattern", "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
  }, "TypeErrorDecoder_undefinedCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = '$arguments$';
      try {
        (void 0).$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_undefinedLiteralCallPattern", "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
  }, "TypeErrorDecoder_nullPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      try {
        null.$method$;
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_nullLiteralPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
  }, "TypeErrorDecoder_undefinedPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      try {
        (void 0).$method$;
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
    return P._AsyncRun__initializeScheduleImmediate();
  }, "_AsyncRun__scheduleImmediateClosure", "Future__nullFuture", "$get$Future__nullFuture", function() {
    return P._Future$value(null, P.Null);
  }, "Future__nullFuture", "_toStringVisiting", "$get$_toStringVisiting", function() {
    return [];
  }, "_toStringVisiting", "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
    return H.NativeInt8List_NativeInt8List$fromList([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2]);
  }, "_Base64Decoder__inverseAlphabet", "_scannerTables", "$get$_scannerTables", function() {
    return P._createTables();
  }, "_scannerTables", "CssStyleDeclaration__propertyCache", "$get$CssStyleDeclaration__propertyCache", function() {
    return {};
  }, "CssStyleDeclaration__propertyCache", "context", "$get$context", function() {
    return P._wrapToDart(self);
  }, "context", "_DART_OBJECT_PROPERTY_NAME", "$get$_DART_OBJECT_PROPERTY_NAME", function() {
    return H.getIsolateAffinityTag("_$dart_dartObject");
  }, "_DART_OBJECT_PROPERTY_NAME", "_dartProxyCtor", "$get$_dartProxyCtor", function() {
    return function DartObject(o) {
      this.o = o;
    };
  }, "_dartProxyCtor", "AssessmentInstrumentUtils_instruments", "$get$AssessmentInstrumentUtils_instruments", function() {
    return [Q.AssessmentInstrumentDO$(3, "Soprano Recorder", 1, 0.05, 1, true, false, 2500, 0.05, null, null, null, 400, null, 2, 1, 10, 50, 6, 60, 9, null, null, 30, null, 0.1, 0.3, 0.45, -12, 50, 256), Q.AssessmentInstrumentDO$(101, "Clap", 2, null, null, null, null, null, null, 5, 1.5, 0, null, 80, null, null, null, null, null, null, null, 0.25, -0.15, null, null, null, null, null, null, null, null), Q.AssessmentInstrumentDO$(102, "Rhythm Voice", 2, null, null, null, null, null, null, 4, 1.5, 0, null, 120, null, null, null, null, null, null, null, 0.25, -0.2, null, null, null, null, null, null, null, null)];
  }, "AssessmentInstrumentUtils_instruments", "PitchUtils_centPitchNames", "$get$PitchUtils_centPitchNames", function() {
    return P.LinkedHashMap__makeLiteral([0, "C", 100, "C", 200, "D", 300, "E", 400, "E", 500, "F", 600, "F", 700, "G", 800, "A", 900, "A", 1000, "B", 1100, "B"]);
  }, "PitchUtils_centPitchNames", "InstrumentUtils_instruments", "$get$InstrumentUtils_instruments", function() {
    return [S.InstrumentDO$(3, "Soprano Recorder", "treble", -12, -2, 2, [[60, 71, 74], [60, 67, 79], [60, 71, 84], [60, 71, 128]], 1, 0), S.InstrumentDO$(4, "Alto Recorder", "treble", -5, -2, 2, [[60, 67, 74], [60, 67, 79], [60, 67, 84], [60, 67, 128]], 1, 0), S.InstrumentDO$(300, "Alto Recorder Untransposed", "treble", 0, -3, 1, [[67, 74, 81], [67, 74, 86], [67, 74, 91], [67, 74, 128]], 1, 2), S.InstrumentDO$(5, "Piccolo", "treble", -12, -3, 1, [[65, 78, 82], [65, 78, 87], [62, 78, 93], [62, 78, 128]], 1, null), S.InstrumentDO$(6, "Flute", "treble", 0, -3, 1, [[65, 77, 82], [63, 77, 87], [60, 77, 93], [60, 77, 128]], 1, null), S.InstrumentDO$(7, "Oboe", "treble", 0, -3, 1, [[65, 74, 79], [60, 74, 84], [58, 74, 91], [58, 74, 128]], 1, null), S.InstrumentDO$(8, "Bassoon", "bass", 0, -3, 1, [[43, 53, 60], [43, 53, 67], [34, 53, 74], [34, 53, 128]], 1, null), S.InstrumentDO$(9, "Clarinet", "treble", 2, -2, 2, [[52, 67, 77], [52, 72, 86], [52, 72, 91], [52, 72, 128]], 1, null), S.InstrumentDO$(10, "Bass Clarinet", "treble", 14, -2, 2, [[52, 67, 77], [52, 70, 86], [52, 70, 91], [52, 70, 128]], 1, null), S.InstrumentDO$(11, "Soprano Sax", "treble", 2, -2, 2, [[62, 72, 79], [58, 72, 84], [58, 72, 90], [58, 72, 128]], 1, null), S.InstrumentDO$(12, "Alto Sax", "treble", 9, -1, 3, [[62, 72, 79], [58, 72, 84], [58, 72, 90], [58, 72, 128]], 1, null), S.InstrumentDO$(13, "Tenor Sax", "treble", 14, -2, 2, [[62, 72, 79], [58, 72, 84], [58, 72, 90], [58, 72, 128]], 1, null), S.InstrumentDO$(14, "Bari Sax", "treble", 21, -1, 3, [[62, 72, 79], [58, 72, 84], [58, 72, 90], [58, 72, 128]], 1, null), S.InstrumentDO$(15, "Trumpet", "treble", 2, -2, 2, [[58, 64, 74], [54, 69, 79], [54, 69, 86], [54, 69, 128]], 1, null), S.InstrumentDO$(16, "Horn in F", "treble", 7, -2, 2, [[55, 64, 74], [53, 67, 79], [53, 67, 84], [48, 67, 128]], 1, null), S.InstrumentDO$(17, "Trombone", "bass", 0, -4, 0, [[44, 53, 60], [40, 53, 65], [40, 53, 72], [40, 53, 128]], 1, null), S.InstrumentDO$(18, "Euphonium TC", "treble", 14, -2, 2, [[58, 64, 74], [54, 69, 79], [54, 69, 86], [54, 69, 128]], 1, null), S.InstrumentDO$(19, "Euphonium BC", "bass", 0, -4, 0, [[44, 50, 60], [40, 55, 65], [40, 55, 72], [40, 55, 128]], 1, null), S.InstrumentDO$(20, "Tuba", "bass", 0, -4, 0, [[32, 38, 48], [28, 43, 53], [28, 43, 60], [28, 43, 128]], 1, null), S.InstrumentDO$(21, "Violin", "treble", 0, -1, 3, [[62, 68, 79], [55, 72, 86], [55, 72, 92], [55, 72, 128]], 1, null), S.InstrumentDO$(22, "Viola", "alto", 0, -1, 3, [[55, 61, 72], [48, 65, 79], [48, 65, 85], [48, 65, 128]], 1, null), S.InstrumentDO$(23, "Cello", "bass", 0, -1, 3, [[43, 49, 60], [36, 53, 67], [36, 53, 73], [36, 53, 128]], 1, null), S.InstrumentDO$(24, "Bass", "bass", 12, -1, 3, [[40, 49, 60], [40, 51, 67], [40, 53, 73], [40, 53, 128]], 1, null), S.InstrumentDO$(25, "Piano", "treble", 0, -2, 2, [[1, 69, 128], [1, 69, 128], [1, 69, 128], [1, 69, 128]], 1, null)];
  }, "InstrumentUtils_instruments", "PitchUtils_pitchNameCentVals", "$get$PitchUtils_pitchNameCentVals", function() {
    return P.LinkedHashMap__makeLiteral(["C", 0, "D", 200, "E", 400, "F", 500, "G", 700, "A", 900, "B", 1100]);
  }, "PitchUtils_pitchNameCentVals", "PitchUtils_centPitchNames0", "$get$PitchUtils_centPitchNames0", function() {
    return P.LinkedHashMap__makeLiteral([0, "C", 100, "C", 200, "D", 300, "E", 400, "E", 500, "F", 600, "F", 700, "G", 800, "A", 900, "A", 1000, "B", 1100, "B"]);
  }, "PitchUtils_centPitchNames0", "ScoreViewerViewManager__wheelDeltas", "$get$ScoreViewerViewManager__wheelDeltas", function() {
    return P.LinkedHashMap__makeEmpty();
  }, "ScoreViewerViewManager__wheelDeltas", "FingeringDisplay_positions", "$get$FingeringDisplay_positions", function() {
    return [4, 46, 81, 116, 167, 202, 237, 272];
  }, "FingeringDisplay_positions", "FingeringDisplay__baroqueFingerings", "$get$FingeringDisplay__baroqueFingerings", function() {
    return [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2], [0, 0, 0, 0, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 2], [0, 0, 0, 2, 2, 2, 2, 2], [0, 0, 2, 0, 0, 2, 0, 2], [0, 0, 2, 2, 2, 2, 2, 2], [0, 2, 0, 2, 2, 2, 2, 2], [2, 0, 0, 2, 2, 2, 2, 2], [2, 2, 0, 2, 2, 2, 2, 2], [2, 2, 0, 0, 0, 0, 0, 2], [3, 0, 0, 0, 0, 0, 2, 2], [3, 0, 0, 0, 0, 2, 0, 2], [3, 0, 0, 0, 2, 0, 2, 2], [3, 0, 0, 0, 2, 2, 2, 2], [3, 0, 0, 2, 0, 2, 2, 2], [3, 0, 0, 2, 2, 2, 2, 2], [3, 0, 0, 2, 0, 0, 0, 2], [3, 0, 0, 2, 0, 0, 2, 2], [3, 0, 2, 2, 0, 0, 2, 2], [3, 0, 3, 0, 0, 3, 0, 0], [3, 0, 2, 0, 0, 2, 0, 2], [3, 2, 0, 0, 2, 0, 0, 2]];
  }, "FingeringDisplay__baroqueFingerings", "FingeringDisplay__germanFingerings", "$get$FingeringDisplay__germanFingerings", function() {
    return [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 2], [0, 0, 0, 2, 2, 2, 2, 2], [0, 0, 2, 0, 0, 2, 2, 2], [0, 0, 2, 2, 2, 2, 2, 2], [0, 2, 0, 2, 2, 2, 2, 2], [2, 0, 0, 2, 2, 2, 2, 2], [2, 2, 0, 2, 2, 2, 2, 2], [2, 2, 0, 0, 0, 0, 0, 2], [3, 0, 0, 0, 0, 0, 2, 2], [3, 0, 0, 0, 0, 2, 2, 2], [3, 0, 0, 0, 2, 0, 2, 0], [3, 0, 0, 0, 2, 2, 2, 2], [3, 0, 0, 0, 2, 0, 0, 0], [3, 0, 0, 2, 2, 2, 2, 2], [3, 0, 0, 2, 0, 0, 0, 2], [3, 0, 0, 2, 0, 0, 2, 2], [3, 0, 2, 2, 0, 0, 2, 2], [3, 0, 3, 0, 0, 3, 0, 0], [3, 0, 2, 0, 0, 2, 0, 2], [3, 2, 0, 0, 2, 0, 0, 2]];
  }, "FingeringDisplay__germanFingerings", "FingeringDisplay__altoUntransposedFingerings", "$get$FingeringDisplay__altoUntransposedFingerings", function() {
    return [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2], [0, 0, 0, 0, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 2], [0, 0, 0, 2, 2, 2, 2, 2], [0, 0, 2, 0, 0, 2, 0, 2], [0, 0, 2, 2, 2, 2, 2, 2], [0, 2, 0, 2, 2, 2, 2, 2], [2, 0, 0, 2, 2, 2, 2, 2], [2, 2, 0, 2, 2, 2, 2, 2], [2, 2, 0, 0, 0, 0, 0, 2], [3, 0, 0, 0, 0, 0, 2, 2], [3, 0, 0, 0, 0, 2, 0, 2], [3, 0, 0, 0, 2, 0, 2, 2], [3, 0, 0, 0, 2, 2, 2, 2], [3, 0, 0, 2, 0, 2, 2, 2], [3, 0, 0, 2, 2, 2, 2, 2], [3, 0, 0, 2, 0, 0, 0, 2], [3, 0, 0, 2, 0, 0, 2, 2], [3, 0, 2, 2, 0, 0, 2, 2], [3, 0, 3, 0, 0, 3, 0, 0], [3, 0, 2, 0, 0, 2, 0, 2], [3, 2, 0, 0, 2, 0, 0, 2]];
  }, "FingeringDisplay__altoUntransposedFingerings", "MusicTextures__coloredNoteheadDOs", "$get$MusicTextures__coloredNoteheadDOs", function() {
    return [];
  }, "MusicTextures__coloredNoteheadDOs", "BitmapData_defaultLoadOptions", "$get$BitmapData_defaultLoadOptions", function() {
    return new A.BitmapDataLoadOptions(true, true, false, 2, false);
  }, "BitmapData_defaultLoadOptions", "_globalFrameListeners", "$get$_globalFrameListeners", function() {
    return [];
  }, "_globalFrameListeners", "_enterFrameSubscriptions", "$get$_enterFrameSubscriptions", function() {
    return [];
  }, "_enterFrameSubscriptions", "_exitFrameSubscriptions", "$get$_exitFrameSubscriptions", function() {
    return [];
  }, "_exitFrameSubscriptions", "_renderSubscriptions", "$get$_renderSubscriptions", function() {
    return [];
  }, "_renderSubscriptions", "devicePixelRatio", "$get$devicePixelRatio", function() {
    var devicePixelRatio = W.window().devicePixelRatio;
    return typeof devicePixelRatio !== "number" ? 1 : devicePixelRatio;
  }, "devicePixelRatio", "isLittleEndianSystem", "$get$isLittleEndianSystem", function() {
    var wordList, t1, byteList;
    wordList = H.NativeInt32List_NativeInt32List(1);
    t1 = wordList.buffer;
    byteList = (t1 && C.NativeByteBuffer_methods).asUint8List$0(t1);
    wordList[0] = 287454020;
    if (0 >= byteList.length)
      return H.ioore(byteList, 0);
    return byteList[0] === 68;
  }, "isLittleEndianSystem", "isTouchEventSupported", "$get$isTouchEventSupported", function() {
    return Q._checkTouchEventSupport();
  }, "isTouchEventSupported", "_buffer", "$get$_buffer", function() {
    return H.NativeInt32List_NativeInt32List(1024);
  }, "_buffer", "_dummyCanvas", "$get$_dummyCanvas", function() {
    return W.CanvasElement_CanvasElement(16, 16);
  }, "_dummyCanvas", "_dummyCanvasContext", "$get$_dummyCanvasContext", function() {
    var t1 = $.$get$_dummyCanvas();
    return (t1 && C.CanvasElement_methods).get$context2D(t1);
  }, "_dummyCanvasContext", "_fontStyleMetrics", "$get$_fontStyleMetrics", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.String, Y._FontStyleMetrics);
  }, "_fontStyleMetrics", "Mouse__cursorDatas", "$get$Mouse__cursorDatas", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.String, Q.MouseCursorData);
  }, "Mouse__cursorDatas", "Mouse__cursorChangedEvent", "$get$Mouse__cursorChangedEvent", function() {
    return P.StreamController_StreamController$broadcast(null, null, false, P.String);
  }, "Mouse__cursorChangedEvent", "Mouse_onCursorChanged", "$get$Mouse_onCursorChanged", function() {
    var t1 = $.$get$Mouse__cursorChangedEvent();
    return t1.get$stream(t1);
  }, "Mouse_onCursorChanged"]);
  Isolate = Isolate.$finishIsolateConstructor(Isolate);
  $ = new Isolate();
  init.metadata = ["e", null, "error", "value", "_", "renderTextureQuad", "stackTrace", "result", "key", "renderState", "data", "o", "r", "x", "invocation", "a", "b", "score", "text", "mouseEvent", "deltaTime", "theStackTrace", "sender", "arg", 0, "each", "isolate", "theError", "xhr", "stream", "dict", "postCreate", "callback", "captureThis", "self", "arguments", "textEvent", "request", "numberOfArguments", "keyboardEvent", "buffer", "object", "jsonString", "closure", "touchEvent", "cursorName", "arg3", "arg4", "frameTime", "arg1", "element", "g", "resource", "message", "arg2"];
  init.types = [{func: 1, args: [,]}, {func: 1}, {func: 1, v: true}, {func: 1, args: [,,]}, {func: 1, v: true, args: [R.InputEvent]}, {func: 1, v: true, args: [M.PlayerEvent]}, {func: 1, args: [W.Element]}, {func: 1, v: true, args: [F.ScoreViewerEvent]}, {func: 1, v: true, args: [{func: 1, v: true}]}, {func: 1, v: true, args: [P.Object], opt: [P.StackTrace]}, {func: 1, ret: P.Future}, {func: 1, v: true, args: [R.Event]}, {func: 1, v: true, args: [R.MouseEvent]}, {func: 1, ret: P.num, args: [P.num]}, {func: 1, v: true, args: [W.Event0]}, {func: 1, v: true, args: [L.RenderState, L.RenderTextureQuad]}, {func: 1, args: [P.String,,]}, {func: 1, args: [P.String]}, {func: 1, args: [, P.StackTrace]}, {func: 1, v: true, opt: [,]}, {func: 1, args: [O.Score]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, v: true, args: [P.Uint8List, P.String, P.int]}, {func: 1, args: [W.HttpRequest]}, {func: 1, ret: P.double, args: [P.int]}, {func: 1, v: true, args: [W.KeyboardEvent]}, {func: 1, v: true, args: [R.EnterFrameEvent]}, {func: 1, v: true, args: [P.String]}, {func: 1, v: true, args: [P.ContextEvent]}, {func: 1, v: true, args: [P.num]}, {func: 1, v: true, opt: [P.int]}, {func: 1, v: true, opt: [P.Object]}, {func: 1, v: true, args: [P.num], opt: [P.num, P.num]}, {func: 1, v: true, opt: [P.num]}, {func: 1, args: [P.Symbol0,,]}, {func: 1, v: true, args: [P.Float32List]}, {func: 1, args: [, P.String]}, {func: 1, args: [P.Object]}, {func: 1, ret: O.NoteGroup, args: [P.num]}, {func: 1, v: true, args: [, P.StackTrace]}, {func: 1, args: [D.VisualNoteGroup, D.VisualNoteGroup]}, {func: 1, v: true, args: [P.String, P.int]}, {func: 1, args: [P.num, P.num]}, {func: 1, v: true, args: [P.String], opt: [,]}, {func: 1, ret: P.int, args: [P.int, P.int]}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, args: [P.int,,]}, {func: 1, v: true, args: [Q.PitchRecEvent]}, {func: 1, v: true, args: [Q.HitEvent]}, {func: 1, args: [,], opt: [,]}, {func: 1, ret: P.Object, opt: [P.Object]}, {func: 1, ret: P.Future, args: [M.PlayerEvent]}, {func: 1, args: [{func: 1, v: true}]}, {func: 1, ret: P.int, args: [, P.int]}, {func: 1, args: [P.AudioBuffer]}, {func: 1, v: true, args: [[P.List, P.AudioBuffer]]}, {func: 1, v: true, args: [P.Timer]}, {func: 1, v: true, args: [R.TouchEvent]}, {func: 1, v: true, args: [W.MouseEvent0]}, {func: 1, v: true, args: [W.WheelEvent]}, {func: 1, v: true, args: [W.TouchEvent0]}, {func: 1, v: true, args: [A.BitmapData]}, {func: 1, ret: P.String}, {func: 1, ret: [P.List, W.RtcStatsReport]}, {func: 1, args: [P.num]}, {func: 1, v: true, args: [P.int, P.int]}, {func: 1, v: true, args: [L.RenderState, L.RenderTextureQuad, P.double, P.double, P.num, P.num]}, {func: 1, v: true, args: [L.RenderTextureQuad]}, {func: 1, ret: A.BitmapData, args: [P.String]}, {func: 1, v: true, args: [R.KeyboardEvent0]}, {func: 1, v: true, args: [R.TextEvent0]}, {func: 1, ret: P.num}, {func: 1, ret: P.Future, args: [P.Object]}, {func: 1, v: true, args: [P.Object]}, {func: 1, ret: P.int, args: [P.Comparable, P.Comparable]}, {func: 1, ret: P.int, args: [P.String]}, {func: 1, ret: P.double, args: [P.String]}, {func: 1, ret: P.String, args: [W.EventTarget]}, {func: 1, ret: P.Object, args: [,]}, {func: 1, v: true, args: [W.ProgressEvent]}];
  function convertToFastObject(properties) {
    function MyClass() {
    }
    MyClass.prototype = properties;
    new MyClass();
    return properties;
  }
  function convertToSlowObject(properties) {
    properties.__MAGIC_SLOW_PROPERTY = 1;
    delete properties.__MAGIC_SLOW_PROPERTY;
    return properties;
  }
  A = convertToFastObject(A);
  B = convertToFastObject(B);
  C = convertToFastObject(C);
  D = convertToFastObject(D);
  E = convertToFastObject(E);
  F = convertToFastObject(F);
  G = convertToFastObject(G);
  H = convertToFastObject(H);
  J = convertToFastObject(J);
  K = convertToFastObject(K);
  L = convertToFastObject(L);
  M = convertToFastObject(M);
  N = convertToFastObject(N);
  O = convertToFastObject(O);
  P = convertToFastObject(P);
  Q = convertToFastObject(Q);
  R = convertToFastObject(R);
  S = convertToFastObject(S);
  T = convertToFastObject(T);
  U = convertToFastObject(U);
  V = convertToFastObject(V);
  W = convertToFastObject(W);
  X = convertToFastObject(X);
  Y = convertToFastObject(Y);
  Z = convertToFastObject(Z);
  function init() {
    Isolate.$isolateProperties = Object.create(null);
    init.allClasses = map();
    init.getTypeFromName = function(name) {
      return init.allClasses[name];
    };
    init.interceptorsByTag = map();
    init.leafTags = map();
    init.finishedClasses = map();
    Isolate.$lazy = function(fieldName, getterName, lazyValue, staticName, prototype) {
      if (!init.lazies)
        init.lazies = Object.create(null);
      init.lazies[fieldName] = getterName;
      prototype = prototype || Isolate.$isolateProperties;
      var sentinelUndefined = {};
      var sentinelInProgress = {};
      prototype[fieldName] = sentinelUndefined;
      prototype[getterName] = function() {
        var result = this[fieldName];
        if (result == sentinelInProgress)
          H.throwCyclicInit(staticName || fieldName);
        try {
          if (result === sentinelUndefined) {
            this[fieldName] = sentinelInProgress;
            try {
              result = this[fieldName] = lazyValue();
            } finally {
              if (result === sentinelUndefined)
                this[fieldName] = null;
            }
          }
          return result;
        } finally {
          this[getterName] = function() {
            return this[fieldName];
          };
        }
      };
    };
    Isolate.$finishIsolateConstructor = function(oldIsolate) {
      var isolateProperties = oldIsolate.$isolateProperties;
      function Isolate() {
        var staticNames = Object.keys(isolateProperties);
        for (var i = 0; i < staticNames.length; i++) {
          var staticName = staticNames[i];
          this[staticName] = isolateProperties[staticName];
        }
        var lazies = init.lazies;
        var lazyInitializers = lazies ? Object.keys(lazies) : [];
        for (var i = 0; i < lazyInitializers.length; i++)
          this[lazies[lazyInitializers[i]]] = null;
        function ForceEfficientMap() {
        }
        ForceEfficientMap.prototype = this;
        new ForceEfficientMap();
        for (var i = 0; i < lazyInitializers.length; i++) {
          var lazyInitName = lazies[lazyInitializers[i]];
          this[lazyInitName] = isolateProperties[lazyInitName];
        }
      }
      Isolate.prototype = oldIsolate.prototype;
      Isolate.prototype.constructor = Isolate;
      Isolate.$isolateProperties = isolateProperties;
      Isolate.makeConstantList = oldIsolate.makeConstantList;
      Isolate.functionThatReturnsNull = oldIsolate.functionThatReturnsNull;
      return Isolate;
    };
  }
  !function() {
    var intern = function(s) {
      var o = {};
      o[s] = 1;
      return Object.keys(convertToFastObject(o))[0];
    };
    init.getIsolateTag = function(name) {
      return intern("___dart_" + name + init.isolateTag);
    };
    var tableProperty = "___dart_isolate_tags_";
    var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
    var rootProperty = "_ZxYxX";
    for (var i = 0;; i++) {
      var property = intern(rootProperty + "_" + i + "_");
      if (!(property in usedProperties)) {
        usedProperties[property] = 1;
        init.isolateTag = property;
        break;
      }
    }
    init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
  }();
  // BEGIN invoke [main].
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(function(a) {
        H.startRootIsolate(L.score_player_example__main$closure(), a);
      }, []);
    else
      (function(a) {
        H.startRootIsolate(L.score_player_example__main$closure(), a);
      })([]);
  });
  // END invoke [main].
})();

//# sourceMappingURL=score_player_example.dart.js.map
